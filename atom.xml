<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sladning</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-06T04:35:52.744Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>刻在生命里的坚强</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JQuery---常用方法</title>
    <link href="http://yoursite.com/2019/04/04/JQuery---%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/04/04/JQuery---基础/</id>
    <published>2019-04-04T09:50:18.000Z</published>
    <updated>2019-04-06T04:35:52.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-简介"><a href="#一-简介" class="headerlink" title="一. 简介"></a>一. 简介</h1><p>JQuery是一个JavaScript工具库（类库），它通过封装原生的JavaScript函数得到一整套定义好的方法</p><blockquote><p>一句话总结类库。 就是 JavaScript 的<strong>工具库</strong>。 原始社会生火方式， 钻木取火。 但是有了火柴就不一样了</p></blockquote><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>jQuery 库是一个 JavaScript 文件，可以使用 HTML 的 <script> 标签引用它</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 两种方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scriptsrc="http:</span>//<span class="attr">libs.baidu.com</span>/<span class="attr">jquery</span>/<span class="attr">2.0.0</span>/<span class="attr">jquery.js</span>"&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="二-jQuery-语法"><a href="#二-jQuery-语法" class="headerlink" title="二. jQuery 语法"></a>二. jQuery 语法</h1><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).action()</span><br></pre></td></tr></table></figure><ul><li>美元符号定义 jQuery</li><li>选择符（selector）“查询”和“查找” HTML 元素</li><li>jQuery 的 action() 执行对元素的操作</li></ul><h2 id="文档就绪函数"><a href="#文档就绪函数" class="headerlink" title="文档就绪函数"></a>文档就绪函数</h2><p>这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码。</p><p>如果在文档没有完全加载之前就运行函数，操作可能失败。下面是两个具体的例子：</p><ul><li>试图隐藏一个不存在的元素</li><li>获得未完全加载的图像的大小</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="JQuery-选择器"><a href="#JQuery-选择器" class="headerlink" title="JQuery 选择器"></a>JQuery 选择器</h2><table><thead><tr><th>选择器</th><th>CSS模式</th><th>jQuery模式</th><th>描述</th></tr></thead><tbody><tr><td>标签名</td><td>div{}</td><td>$(‘div’)</td><td>获取<strong>所有</strong>div标签的DOM元素</td></tr><tr><td>ID</td><td>#box{}</td><td>$(‘#box’)</td><td>获取<strong>一个</strong>ID为box的DOM对象</td></tr><tr><td>class(类名)</td><td>.box{}</td><td>$(‘.box’)</td><td>获取<strong>所有</strong>class名为box的DOM对象</td></tr></tbody></table><h1 id="JQuery-HTML"><a href="#JQuery-HTML" class="headerlink" title="JQuery HTML"></a>JQuery HTML</h1><h2 id="1-获取与设置-没有看回调"><a href="#1-获取与设置-没有看回调" class="headerlink" title="1.  获取与设置(没有看回调)"></a>1.  获取与设置(没有看回调)</h2><h3 id="1-获得与设置-内容"><a href="#1-获得与设置-内容" class="headerlink" title="1) 获得与设置 内容"></a>1) 获得与设置 内容</h3><p>三个简单实用的用于 DOM 操作的 jQuery 方法：</p><ul><li>text() - 设置或返回所选元素的文本内容</li><li>html() - 设置或返回所选元素的内容（包括 HTML 标记）</li><li>val() - 设置或返回表单字段的值</li></ul><p>下面的例子演示如何通过 jQuery text() 和 html() 方法来获得内容：</p><h4 id="获取实例"><a href="#获取实例" class="headerlink" title="获取实例"></a>获取实例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#btn1"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Text: "</span> + $(<span class="string">"#test"</span>).text());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#btn2"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"HTML: "</span> + $(<span class="string">"#test"</span>).html());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#btn3"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"Value: "</span> + $(<span class="string">"#test"</span>).val());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="设置实例"><a href="#设置实例" class="headerlink" title="设置实例"></a>设置实例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#btn1"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#test1"</span>).text(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">"#btn2"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#test2"</span>).html(<span class="string">"&lt;b&gt;Hello world!&lt;/b&gt;"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">"#btn3"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#test3"</span>).val(<span class="string">"Dolly Duck"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-获取与设置属性"><a href="#2-获取与设置属性" class="headerlink" title="2) 获取与设置属性"></a>2) 获取与设置属性</h3><p> <code>attr()</code> 用于获取与设置属性值</p><h4 id="获取实例-1"><a href="#获取实例-1" class="headerlink" title="获取实例"></a>获取实例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert($(<span class="string">"#w3s"</span>).attr(<span class="string">"href"</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="设置实例-1"><a href="#设置实例-1" class="headerlink" title="设置实例"></a>设置实例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#w3s"</span>).attr(<span class="string">"href"</span>,<span class="string">"http://www.w3school.com.cn/jquery"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置多个属性</span></span><br><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">"#w3s"</span>).attr(&#123;</span><br><span class="line">    <span class="string">"href"</span> : <span class="string">"http://www.w3school.com.cn/jquery"</span>,</span><br><span class="line">    <span class="string">"title"</span> : <span class="string">"W3School jQuery Tutorial"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/shenjp/p/6411345.html">JQuery简介</a>    </p><p>​    <a href="http://www.w3school.com.cn/jquery/jquery_dom_get.asp">W3school</a></p></script></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-简介&quot;&gt;&lt;a href=&quot;#一-简介&quot; class=&quot;headerlink&quot; title=&quot;一. 简介&quot;&gt;&lt;/a&gt;一. 简介&lt;/h1&gt;&lt;p&gt;JQuery是一个JavaScript工具库（类库），它通过封装原生的JavaScript函数得到一整套定义好的方法&lt;/
      
    
    </summary>
    
      <category term="JQuery" scheme="http://yoursite.com/categories/JQuery/"/>
    
    
      <category term="JQuery" scheme="http://yoursite.com/tags/JQuery/"/>
    
  </entry>
  
  <entry>
    <title>Java常用类---Collections</title>
    <link href="http://yoursite.com/2019/04/04/Java%E5%B8%B8%E7%94%A8%E7%B1%BB---Collections/"/>
    <id>http://yoursite.com/2019/04/04/Java常用类---Collections/</id>
    <published>2019-04-04T08:53:27.000Z</published>
    <updated>2019-04-04T08:57:52.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概念"><a href="#一-概念" class="headerlink" title="一. 概念"></a>一. 概念</h1><p>​    Collections是一个工具类，sort是其中的静态方法，是用来对List类型进行排序的</p><a id="more"></a><h1 id="二-使用"><a href="#二-使用" class="headerlink" title="二. 使用"></a>二. 使用</h1><h4 id="两种用法"><a href="#两种用法" class="headerlink" title="两种用法"></a>两种用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用法一</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">    list.sort(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法二</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    list.sort(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/yw0219/p/7222108.html" target="_blank" rel="noopener">java基础——Collections.sort的两种用法</a>    </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-概念&quot;&gt;&lt;a href=&quot;#一-概念&quot; class=&quot;headerlink&quot; title=&quot;一. 概念&quot;&gt;&lt;/a&gt;一. 概念&lt;/h1&gt;&lt;p&gt;​    Collections是一个工具类，sort是其中的静态方法，是用来对List类型进行排序的&lt;/p&gt;
    
    </summary>
    
      <category term="java常用类" scheme="http://yoursite.com/categories/java%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java常用类" scheme="http://yoursite.com/tags/java%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>CSS---常用</title>
    <link href="http://yoursite.com/2019/04/04/CSS---%E5%B8%B8%E7%94%A8/"/>
    <id>http://yoursite.com/2019/04/04/CSS---常用/</id>
    <published>2019-04-04T03:23:51.000Z</published>
    <updated>2019-04-04T08:57:22.543Z</updated>
    
    <content type="html"><![CDATA[<p> <strong><code>!important</code></strong></p><p><strong>提高</strong>指定样式规则的应用优先权（<strong>优先级</strong>）</p><p>语法格式 <strong>{ cssRule !important }</strong> , 即写在定义的最后面，</p><p>例如：<code>p {color:red !important;}</code></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;strong&gt;&lt;code&gt;!important&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提高&lt;/strong&gt;指定样式规则的应用优先权（&lt;strong&gt;优先级&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;语法格式 &lt;strong&gt;{ cssRule !important }&lt;/strong&gt; , 即写在定义的最后面，&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;p {color:red !important;}&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/CSS/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS---框模型</title>
    <link href="http://yoursite.com/2019/04/04/CSS---%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/04/04/CSS---模型/</id>
    <published>2019-04-04T02:23:51.000Z</published>
    <updated>2019-04-04T08:57:26.519Z</updated>
    
    <content type="html"><![CDATA[<h3 id="术语翻译"><a href="#术语翻译" class="headerlink" title="术语翻译"></a>术语翻译</h3><ul><li>element : 元素。</li><li>padding : 内边距，也有资料将其翻译为填充。</li><li>border : 边框。</li><li>margin : 外边距，也有资料将其翻译为空白或空白边</li></ul><a id="more"></a><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="http://www.w3school.com.cn/css/css_boxmodel.asp" target="_blank" rel="noopener">CSS 框模型概述</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;术语翻译&quot;&gt;&lt;a href=&quot;#术语翻译&quot; class=&quot;headerlink&quot; title=&quot;术语翻译&quot;&gt;&lt;/a&gt;术语翻译&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;element : 元素。&lt;/li&gt;
&lt;li&gt;padding : 内边距，也有资料将其翻译为填充。&lt;/li&gt;
&lt;li&gt;border : 边框。&lt;/li&gt;
&lt;li&gt;margin : 外边距，也有资料将其翻译为空白或空白边&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/CSS/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS---基础</title>
    <link href="http://yoursite.com/2019/04/04/CSS---%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/04/04/CSS---基础/</id>
    <published>2019-04-04T01:23:51.000Z</published>
    <updated>2019-04-04T08:56:44.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-CSS-简介"><a href="#一-CSS-简介" class="headerlink" title="一. CSS 简介"></a>一. CSS 简介</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ul><li><p>CSS : 层叠样式表 (简称样式表 <strong>Cascading Style Sheets</strong>)</p></li><li><p>样式定义 <strong>如何显示</strong> HTML 元素</p></li><li><p>外部样式表通常存储在 <strong>CSS 文件</strong> 中</p></li></ul><p>CSS 用于布局与美化网页, 是一种标记语言,因此不需要编译,可以直接由浏览器执行(属于浏览器<a href="https://www.baidu.com/s?wd=%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">解释型语言</a>).</p><p>CSS 文件是一个文本文件,它包含了一些CSS标记,CSS文件必须使用 <code>.css</code> 为文件名后缀. CSS是大小写不敏感的,CSS与css是一样的.</p><a id="more"></a><h2 id="1-2-使用CSS的优势："><a href="#1-2-使用CSS的优势：" class="headerlink" title="1.2 使用CSS的优势："></a>1.2 使用CSS的优势：</h2><ul><li>内容与表现分离,有了CSS,网页的内容(XHMTL)与表现就可以分开了.</li><li>表现的统一,可以使网页的表现非常统一,并且容易修改.</li><li>CSS可以支持多种设备,比如手机,PDA,打印机,电视机,游戏机等.</li><li>使用CSS可以减少网页的代码量,增加网页的浏览速度,减少硬盘容量.</li></ul><h1 id="二-CSS基础语法"><a href="#二-CSS基础语法" class="headerlink" title="二. CSS基础语法"></a>二. CSS基础语法</h1><p>CSS 规则由两个主要的部分构成：<strong>选择器，以及一条或多条声明</strong>, 每条声明由<strong>一个属性和一个值组成</strong></p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 格式 */</span></span><br><span class="line"><span class="selector-tag">selector</span> &#123;</span><br><span class="line">    <span class="attribute">property</span>: value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 实例 */</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:red; <span class="comment">/* 声明 */</span></span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">14px</span>;<span class="comment">/* 声明 */</span></span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">"sans serif"</span>;  <span class="comment">/* 如果值为若干单词，则要给值加引号 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 选择器:h1</span></span><br><span class="line"><span class="comment"> * 属性:color,font-size</span></span><br><span class="line"><span class="comment"> * 值:red,14px</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="三-高级语法"><a href="#三-高级语法" class="headerlink" title="三. 高级语法"></a>三. 高级语法</h1><h5 id="对选择器进行分组，这样，被分组的选择器就可以分享相同的声明。用逗号将需要分组的选择器分开"><a href="#对选择器进行分组，这样，被分组的选择器就可以分享相同的声明。用逗号将需要分组的选择器分开" class="headerlink" title="对选择器进行分组，这样，被分组的选择器就可以分享相同的声明。用逗号将需要分组的选择器分开"></a>对选择器进行分组，这样，被分组的选择器就可以分享相同的声明。用逗号将需要分组的选择器分开</h5><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 所有的标题元素都是绿色的 */</span></span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="四-派生选择器"><a href="#四-派生选择器" class="headerlink" title="四. 派生选择器"></a>四. 派生选择器</h1><p><strong>通过依据元素在其位置的上下文关系来定义样式，你可以使标记更加简洁</strong></p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 列表中的 strong 元素变为斜体字 */</span></span><br><span class="line"><span class="selector-tag">li</span> <span class="selector-tag">strong</span> &#123;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="五-id-选择器"><a href="#五-id-选择器" class="headerlink" title="五. id 选择器"></a>五. id 选择器</h1><ul><li><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。</p></li><li><p>id 选择器<strong>以 “#” 来定义</strong></p></li><li>id 属性只能在每个 HTML 文档中出现一次</li></ul><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><h5 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"red"</span>&gt;</span>这个段落是红色。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"green"</span>&gt;</span>这个段落是绿色。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#red</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-id">#green</span> &#123;<span class="attribute">color</span>:green;&#125;</span><br></pre></td></tr></table></figure><h3 id="id-选择器和派生选择器"><a href="#id-选择器和派生选择器" class="headerlink" title="id 选择器和派生选择器"></a>id 选择器和派生选择器</h3><p><strong>在现代布局中，id 选择器常常用于建立派生选择器。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#sidebar</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line"><span class="attribute">font-style</span>: italic;</span><br><span class="line"><span class="attribute">text-align</span>: right;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="number">0.5em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六-类选择器"><a href="#六-类选择器" class="headerlink" title="六. 类选择器"></a>六. 类选择器</h1><ul><li>选择器以一个点号显示</li><li>类名的<strong>第一个字符不能使用数字</strong>！它无法在 Mozilla 或 Firefox 中起作用</li></ul><h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><h5 id="HTML-1"><a href="#HTML-1" class="headerlink" title="HTML"></a>HTML</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- h1 和 p 元素都有 center 类。这意味着两者都将遵守 ".center" 选择器中的规则 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">This heading will be center-aligned</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">This paragraph will also be center-aligned.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="CSS-1"><a href="#CSS-1" class="headerlink" title="CSS"></a>CSS</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span> &#123;<span class="attribute">text-align</span>: center&#125;</span><br></pre></td></tr></table></figure><h1 id="七-属性选择器"><a href="#七-属性选择器" class="headerlink" title="七. 属性选择器"></a>七. 属性选择器</h1><p>为拥有指定属性的 HTML 元素设置样式</p><h4 id="实例-为带有-title-属性的所有元素设置样式"><a href="#实例-为带有-title-属性的所有元素设置样式" class="headerlink" title="实例: 为带有 title 属性的所有元素设置样式"></a>实例: 为带有 title 属性的所有元素设置样式</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">            <span class="selector-attr">[title]</span> &#123; <span class="attribute">color</span>:red;&#125;</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>可以应用样式：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">title</span>=<span class="string">"Hello world"</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">title</span>=<span class="string">"W3School"</span> <span class="attr">href</span>=<span class="string">"http://w3school.com.cn"</span>&gt;</span>W3School<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>无法应用样式：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://w3school.com.cn"</span>&gt;</span>W3School<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="八-混合使用"><a href="#八-混合使用" class="headerlink" title="八. 混合使用"></a>八. 混合使用</h1><h4 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* class="top" 的nav 下面的&lt;span&gt;和&lt;a&gt;标签被选中 */</span></span><br><span class="line"><span class="selector-tag">nav</span><span class="selector-class">.top</span> <span class="selector-tag">span</span>, <span class="selector-tag">nav</span><span class="selector-class">.top</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">10px</span> <span class="number">0px</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="九-创建"><a href="#九-创建" class="headerlink" title="九. 创建"></a>九. 创建</h1><h3 id="9-1-外部样式表"><a href="#9-1-外部样式表" class="headerlink" title="9.1 外部样式表"></a>9.1 外部样式表</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">head</span>&gt;</span><br><span class="line">&lt;link rel="stylesheet" type="text/css" href="mystyle.css" /&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><h3 id="9-2-内部样式表"><a href="#9-2-内部样式表" class="headerlink" title="9.2 内部样式表"></a>9.2 内部样式表</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">hr</span> &#123;<span class="attribute">color</span>: sienna;&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>: <span class="number">20px</span>;&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">body</span> &#123;<span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"images/back40.gif"</span>);&#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9-3-内联样式"><a href="#9-3-内联样式" class="headerlink" title="9.3 内联样式"></a>9.3 内联样式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: sienna; margin-left: 20px"</span>&gt;</span></span><br><span class="line">    This is a paragraph</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://zhidao.baidu.com/question/551423213.html?qbl=relate_question_0&amp;word=css%CA%C7%D7%F6%CA%B2%C3%B4%B5%C4" target="_blank" rel="noopener">CSS是干什么用的，学来有什么用？</a></p><p>​    <a href="http://www.w3school.com.cn/css/css_jianjie.asp" target="_blank" rel="noopener">W3school CSS</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-CSS-简介&quot;&gt;&lt;a href=&quot;#一-CSS-简介&quot; class=&quot;headerlink&quot; title=&quot;一. CSS 简介&quot;&gt;&lt;/a&gt;一. CSS 简介&lt;/h1&gt;&lt;h2 id=&quot;1-1-概述&quot;&gt;&lt;a href=&quot;#1-1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.1 概述&quot;&gt;&lt;/a&gt;1.1 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CSS : 层叠样式表 (简称样式表 &lt;strong&gt;Cascading Style Sheets&lt;/strong&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;样式定义 &lt;strong&gt;如何显示&lt;/strong&gt; HTML 元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;外部样式表通常存储在 &lt;strong&gt;CSS 文件&lt;/strong&gt; 中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CSS 用于布局与美化网页, 是一种标记语言,因此不需要编译,可以直接由浏览器执行(属于浏览器&lt;a href=&quot;https://www.baidu.com/s?wd=%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80&amp;amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;amp;rsv_dl=gh_pc_zhidao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;解释型语言&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;CSS 文件是一个文本文件,它包含了一些CSS标记,CSS文件必须使用 &lt;code&gt;.css&lt;/code&gt; 为文件名后缀. CSS是大小写不敏感的,CSS与css是一样的.&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/CSS/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---Cookie</title>
    <link href="http://yoursite.com/2019/03/27/JavaWeb---Cookie/"/>
    <id>http://yoursite.com/2019/03/27/JavaWeb---Cookie/</id>
    <published>2019-03-27T14:29:27.000Z</published>
    <updated>2019-04-04T11:25:19.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-会话的概念"><a href="#一-会话的概念" class="headerlink" title="一. 会话的概念"></a>一. 会话的概念</h1><ul><li><strong>会话</strong> : (简单理解)用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器<strong>，整个过程称之为一个会话</strong>。</li><li><strong>有状态会话</strong> : 一个同学来过教室，下次再来教室，我们会知道这个同学曾经来过，这称之为有状态会话。</li></ul><a id="more"></a><h2 id="二、会话过程中要解决的一些问题？"><a href="#二、会话过程中要解决的一些问题？" class="headerlink" title="二、会话过程中要解决的一些问题？"></a>二、会话过程中要解决的一些问题？</h2><p>　　每个用户在使用浏览器与服务器进行会话的过程中，不可避免各自会产生一些数据，程序要想办法为每个用户保存这些数据。</p><h2 id="三、保存会话数据的两种技术"><a href="#三、保存会话数据的两种技术" class="headerlink" title="三、保存会话数据的两种技术"></a>三、保存会话数据的两种技术</h2><h3 id="3-1、Cookie"><a href="#3-1、Cookie" class="headerlink" title="3.1、Cookie"></a>3.1、Cookie</h3><p>　　Cookie是客户端技术，程序把每个用户的数据以cookie的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去。这样，web资源处理的就是用户各自的数据了。</p><h3 id="3-2、Session"><a href="#3-2、Session" class="headerlink" title="3.2、Session"></a>3.2、Session</h3><p>　　Session是服务器端技术，利用这个技术，服务器在运行时可以为每一个用户的浏览器创建一个其独享的session对象，由于session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的session中，当用户再去访问服务器中的其它web资源时，其它web资源再从用户各自的session中取出数据为用户服务。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-会话的概念&quot;&gt;&lt;a href=&quot;#一-会话的概念&quot; class=&quot;headerlink&quot; title=&quot;一. 会话的概念&quot;&gt;&lt;/a&gt;一. 会话的概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;会话&lt;/strong&gt; : (简单理解)用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器&lt;strong&gt;，整个过程称之为一个会话&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有状态会话&lt;/strong&gt; : 一个同学来过教室，下次再来教室，我们会知道这个同学曾经来过，这称之为有状态会话。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---JSP的九个内置对象</title>
    <link href="http://yoursite.com/2019/03/27/JavaWeb---JSP%E7%9A%84%E4%B9%9D%E4%B8%AA%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/03/27/JavaWeb---JSP的九个内置对象/</id>
    <published>2019-03-27T14:29:27.000Z</published>
    <updated>2019-03-28T01:07:48.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-JSP运行原理"><a href="#一-JSP运行原理" class="headerlink" title="一. JSP运行原理"></a>一. JSP运行原理</h1><p>　　每个JSP 页面在第一次被访问时，WEB容器都会把请求交给JSP引擎（即一个Java程序）去处理。JSP引擎先将JSP翻译成一个 <code>_jspServlet</code>(实质上也是一个 servlet ) ，然后按照servlet的调用方式进行调用。<br>　　由于 JSP 第一次访问时会翻译成 servlet ，所以第一次访问通常会比较慢，但第二次访问，JSP引擎如果发现JSP没有变化，就不再翻译，而是直接调用，所以程序的执行效率不会受到影响。<br>　　JSP 引擎在调用 JSP 对应的 <code>_jspServlet</code> 时，会<strong>传递或创建9个与web开发相关的对象</strong>供 <code>_jspServlet</code> 使用。JSP技术的设计者为便于开发人员在编写JSP页面时获得这些web对象的引用，特意定义了9个相应的变量，开发人员在JSP页面中通过这些变量就可以快速获得这9大对象的引用。</p><a id="more"></a><h1 id="二-认识九个内置对象"><a href="#二-认识九个内置对象" class="headerlink" title="二. 认识九个内置对象"></a>二. 认识九个内置对象</h1><table><thead><tr><th style="text-align:center">NO.</th><th style="text-align:left">内置对象</th><th>类型</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><strong>pageContext</strong></td><td><strong>javax.servlet.jsp.PageContext</strong></td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><strong>request</strong></td><td><strong>javax.servlet.http.HttpServletRequest</strong></td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><strong>response</strong></td><td><strong>javax.servlet.http.HttpServletResponse</strong></td></tr><tr><td style="text-align:center">4</td><td style="text-align:left"><strong>session</strong></td><td><strong>javax.servlet.http.HttpSession</strong></td></tr><tr><td style="text-align:center">5</td><td style="text-align:left"><strong>application</strong></td><td><strong>javax.servlet.ServletContext</strong></td></tr><tr><td style="text-align:center">6</td><td style="text-align:left"><strong>config</strong></td><td><strong>javax.servlet.ServletConfig</strong></td></tr><tr><td style="text-align:center">7</td><td style="text-align:left">out</td><td>javax.servlet.jsp.JspWriter</td></tr><tr><td style="text-align:center">8</td><td style="text-align:left">page</td><td>java.lang.Object</td></tr><tr><td style="text-align:center">9</td><td style="text-align:left">exception</td><td>java.lang.Throwable</td></tr></tbody></table><blockquote><p>request，response，session，application，config这些对象在前面都已经作了详细的介绍，这里重点介绍一下剩下的pageContext对象，out对象，page对象</p></blockquote><p><strong>内置对象（又叫隐式对象）:不需要预先声明就可以在脚本代码和表达式中随意使用</strong></p><h1 id="三-page对象"><a href="#三-page对象" class="headerlink" title="三. page对象"></a>三. page对象</h1><p>　　page 对象表示当前一个 JSP 页面，可以理解为一个对象本身，即：把一个JSP当作一个对象来看待。</p><p>​    page对象在开发中几乎不用，了解一下即可</p><h1 id="四-out对象"><a href="#四-out对象" class="headerlink" title="四. out对象"></a>四. out对象</h1><p>　　<strong>out对象用于向客户端发送文本数据。</strong><br>out对象是通过调用 pageContext 对象的 getOut 方法返回的, 其作用和用法与<code>ServletResponse.getWriter</code> 方法返回的 PrintWriter 对象非常相似。<br>　　JSP页面中的out对象的类型为 JspWriter，JspWriter 相当于一种带缓存功能的 PrintWriter，设置 JSP 页面的page指令的buffer属性可以调整它的缓存大小，甚至关闭它的缓存。<br>　　只有向out对象中写入了内容，且满足如下任何一个条件时，out对象才去调用ServletResponse.getWriter方法，并通过该方法返回的PrintWriter对象将out对象的缓冲区中的内容真正写入到Servlet引擎提供的缓冲区中：</p><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ul><li>设置page指令的buffer属性关闭了out对象的缓存功能</li><li>out对象的缓冲区已满</li><li>整个JSP页面结束</li></ul><h1 id="五-pageContext对象"><a href="#五-pageContext对象" class="headerlink" title="五. pageContext对象"></a>五. pageContext对象</h1><p>　　pageContext对象是 JSP 技术中最重要的一个对象，它<strong>代表 JSP 页面的运行环境</strong>，这个对象不仅封装了对其它8大隐式对象的引用，它<strong>自身还是一个域对象(容器)，可以用来保存数据</strong>。并且，这个对象还封装了web开发中经常涉及到的一些常用操作，例如引入和跳转其它资源、检索其它域对象中的属性等。  </p><h3 id="5-1-获得其他对象方法"><a href="#5-1-获得其他对象方法" class="headerlink" title="5.1 获得其他对象方法"></a>5.1 获得其他对象方法</h3><table><thead><tr><th style="text-align:right">方法</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:right"><strong><code>getException()</code></strong></td><td>返回exception隐式对象</td></tr><tr><td style="text-align:right"><strong><code>getPage()</code></strong></td><td>返回page隐式对象</td></tr><tr><td style="text-align:right"><strong><code>getRequest()</code></strong></td><td>返回request隐式对象</td></tr><tr><td style="text-align:right"><strong><code>getResponse()</code></strong></td><td>返回response隐式对象</td></tr><tr><td style="text-align:right"><strong><code>getServletConfig()</code></strong></td><td>返回config隐式对象</td></tr><tr><td style="text-align:right"><strong><code>getServletContext()</code></strong></td><td>返回application隐式对象</td></tr><tr><td style="text-align:right"><strong><code>getSession()</code></strong></td><td>返回session隐式对象</td></tr><tr><td style="text-align:right"><strong><code>getOut()</code></strong></td><td>返回out隐式对象</td></tr></tbody></table><h2 id="5-2-pageContext封装其它8大内置对象的意义"><a href="#5-2-pageContext封装其它8大内置对象的意义" class="headerlink" title="5.2 pageContext封装其它8大内置对象的意义"></a>5.2 pageContext封装其它8大内置对象的意义</h2><p>　　如果在编程过程中，把pageContext对象传递给一个普通java对象，那么这个java对象将可以获取8大隐式对象，此时这个java对象就可以和浏览器交互了，此时这个java对象就成为了一个动态web资源了，这就是pageContext封装其它8大内置对象的意义，<strong>把pageContext传递给谁，谁就能成为一个动态web资源</strong></p><h5 id="那么什么情况下需要把pageContext传递给另外一个java类呢，什么情况下需要使用这种技术呢"><a href="#那么什么情况下需要把pageContext传递给另外一个java类呢，什么情况下需要使用这种技术呢" class="headerlink" title="那么什么情况下需要把pageContext传递给另外一个java类呢，什么情况下需要使用这种技术呢?"></a>那么什么情况下需要把pageContext传递给另外一个java类呢，什么情况下需要使用这种技术呢?</h5><blockquote><p>​    在比较正规的开发中，jsp页面是不允许出现java代码的，如果jsp页面出现了 java 代码，那么就应该想办法把 java 代码移除掉，我们可以<strong>开发一个自定义标签来移除 jsp 页面上的 java 代码</strong>，首先围绕自定义标签写一个java类，jsp引擎在执行自定义标签的时候就会调用围绕自定义标签写的那个 java 类，在调用 java 类的时候就会把 pageContext 对象传递给这个java类，由于pageContext对象封装了对其它8大隐式对象的引用，因此在这个java类中就可以使用jsp页面中的8大隐式对象(request，response，config，application，exception，Session，page，out)了，pageContext对象在jsp自定义标签开发中特别重要。</p></blockquote><h2 id="5-3-pageContext作为域对象"><a href="#5-3-pageContext作为域对象" class="headerlink" title="5.3 pageContext作为域对象"></a>5.3 pageContext作为域对象</h2><p>　　pageContext对象可以作为容器来使用，因此可以将一些数据存储在pageContext对象中。</p><h3 id="1-常用方法"><a href="#1-常用方法" class="headerlink" title="1) 常用方法"></a>1) 常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, Object value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">findAttribute</span><span class="params">(String name)</span></span></span><br></pre></td></tr></table></figure><p><strong>findAttribute()</strong> : 用来<strong>查找各个域中的属性的</strong></p><p>　　当要查找某个属性时，findAttribute方法按照查找顺序 <strong>“page→request→session→application”</strong> 在这四个对象中去查找，只要找到了就返回属性值，如果四个对象都没有找到要查找的属性，则返回一个null。</p><h5 id="范例：使用pageContext的findAttribute方法查找属性值"><a href="#范例：使用pageContext的findAttribute方法查找属性值" class="headerlink" title="范例：使用pageContext的findAttribute方法查找属性值"></a>范例：使用pageContext的findAttribute方法查找属性值</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> contentType=<span class="string">"text/html;charset=UTF-8"</span>%&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;pageContext的findAttribute方法查找属性值&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    pageContext.setAttribute(<span class="string">"name1"</span>, <span class="string">"孤傲苍狼"</span>);</span><br><span class="line">    request.setAttribute(<span class="string">"name2"</span>, <span class="string">"白虎神皇"</span>);</span><br><span class="line">    session.setAttribute(<span class="string">"name3"</span>, <span class="string">"玄天邪帝"</span>);</span><br><span class="line">    application.setAttribute(<span class="string">"name4"</span>, <span class="string">"灭世魔尊"</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">// 使用pageContext的findAttribute方法查找属性，由于取得的值为Object类型，因此必须使用String强制向下转型，转换成String类型</span></span><br><span class="line">    <span class="comment">// 查找name1属性，按照顺序"page→request→session→application"在这四个对象中去查找</span></span><br><span class="line">    String refName1 = (String)pageContext.findAttribute(<span class="string">"name1"</span>);</span><br><span class="line">    String refName2 = (String)pageContext.findAttribute(<span class="string">"name2"</span>);</span><br><span class="line">    String refName3 = (String)pageContext.findAttribute(<span class="string">"name3"</span>);</span><br><span class="line">    String refName4 = (String)pageContext.findAttribute(<span class="string">"name4"</span>);</span><br><span class="line">    String refName5 = (String)pageContext.findAttribute(<span class="string">"name5"</span>); <span class="comment">// 查找一个不存在的属性</span></span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;pageContext.findAttribute方法查找到的属性值：&lt;/h1&gt;</span><br><span class="line">&lt;h3&gt;pageContext对象的name1属性：$&#123;name1&#125;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;request对象的name2属性：$&#123;name2&#125;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;session对象的name3属性：$&#123;name3&#125;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;application对象的name4属性：$&#123;name4&#125;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;不存在的name5属性：$&#123;name5&#125;&lt;/h3&gt;</span><br></pre></td></tr></table></figure><h3 id="2-pageContext对象中封装了访问其它域的方法"><a href="#2-pageContext对象中封装了访问其它域的方法" class="headerlink" title="2) pageContext对象中封装了访问其它域的方法"></a>2) pageContext对象中封装了访问其它域的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String name, <span class="keyword">int</span> scope)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, Object value, <span class="keyword">int</span> scope)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String name, <span class="keyword">int</span> scope)</span></span></span><br></pre></td></tr></table></figure><p>代表各个域的常量</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PageContext.APPLICATION_SCOPE</span><br><span class="line">PageContext.SESSION_SCOPE</span><br><span class="line">PageContext.REQUEST_SCOPE</span><br><span class="line">PageContext.PAGE_SCOPE</span><br></pre></td></tr></table></figure><h5 id="范例：pageContext访问其它域"><a href="#范例：pageContext访问其它域" class="headerlink" title="范例：pageContext访问其它域"></a>范例：pageContext访问其它域</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    <span class="comment">// 此时相当于往session对象中存放了一个name属性，</span></span><br><span class="line"><span class="comment">// 等价于 session.setAttribute("name","孤傲苍狼");</span></span><br><span class="line">    pageContext.setAttribute(<span class="string">"name"</span>,<span class="string">"孤傲苍狼"</span>,PageContext.SESSION_SCOPE);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line"><span class="comment">// 两种取出来的方式</span></span><br><span class="line">    <span class="comment">// 取得session对象的属性，使用pageContext对象获取</span></span><br><span class="line">    String refName1 = (String)pageContext.getAttribute(<span class="string">"name"</span>,PageContext.SESSION_SCOPE);  </span><br><span class="line">    <span class="comment">// 由于取得的值为Object类型，因此必须使用String强制向下转型，转换成String类型</span></span><br><span class="line">     String refName2 = (String)session.getAttribute(<span class="string">"name"</span>);  </span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h2 id="5-4-PageContext-引入和跳转到其他资源"><a href="#5-4-PageContext-引入和跳转到其他资源" class="headerlink" title="5.4 PageContext 引入和跳转到其他资源"></a>5.4 PageContext 引入和跳转到其他资源</h2><p>　　PageContext类中定义了<strong>一个forward方法</strong>(用来跳转页面)和两个include方法(用来引入页面)来分别简化和替代RequestDispatcher.forward方法和include方法。<br>　　方法接收的资源如果以“/”开头， “/”代表当前web应用。</p><p><strong>范例：使用pageContext的forward方法跳转到其他页面</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    <span class="comment">// 使用pageContext的forward方法跳转到 pageContextDemo05.jsp 页面，/代表了当前的web应用</span></span><br><span class="line">    pageContext.forward(<span class="string">"/pageContextDemo05.jsp"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 pageContext.forward(relativeUrlPath)替代 RequestDispatcher.forward(relativeUrlPath)</span></span><br><span class="line">    <span class="comment">// 使用 RequestDispatcher 的 forward 方法实现的跳转方式</span></span><br><span class="line"> pageContext.getRequest().getRequestDispatcher(<span class="string">"/pageContextDemo05.jsp"</span>).forward(request, response);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pageContext.forward(<span class="string">"/pageContextDemo05.jsp"</span>);</span><br></pre></td></tr></table></figure><p>​    这种写法是用来简化和替代  <code>pageContext.getRequest().getRequestDispatcher(&quot;/pageContextDemo05.jsp&quot;).forward(request,response);</code>这种写法的。在实际开发中，使用pageContext.forward(relativeUrlPath)方法跳转页面用得不多，主要是因为要在Jsp页面中嵌套java代码，所以这种做法简单了解一下即可</p><p>​    在开发中，要想从一个Jsp页面采用服务器端跳转的方式跳转到另一个Jsp页面，那么一般会使用 <code>&lt;jsp:forward&gt;</code> 标签，<code>&lt;jsp:forward&gt;</code> 标签用于把请求转发给另外一个资源。</p><h5 id="范例：使用pageContext的include方法引入资源"><a href="#范例：使用pageContext的include方法引入资源" class="headerlink" title="范例：使用pageContext的include方法引入资源"></a>范例：使用pageContext的include方法引入资源</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;使用pageContext的include方法引入资源&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;%-- 使用jsp:include标签引入资源, &lt;jsp:include page=<span class="string">"/jspfragments/head.jsp"</span>/&gt; --%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    pageContext.include(<span class="string">"/jspfragments/head.jsp"</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;hr/&gt;</span><br></pre></td></tr></table></figure><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3779872.html" target="_blank" rel="noopener">JavaWeb学习总结(十七)——JSP中的九个内置对象</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-JSP运行原理&quot;&gt;&lt;a href=&quot;#一-JSP运行原理&quot; class=&quot;headerlink&quot; title=&quot;一. JSP运行原理&quot;&gt;&lt;/a&gt;一. JSP运行原理&lt;/h1&gt;&lt;p&gt;　　每个JSP 页面在第一次被访问时，WEB容器都会把请求交给JSP引擎（即一个Java程序）去处理。JSP引擎先将JSP翻译成一个 &lt;code&gt;_jspServlet&lt;/code&gt;(实质上也是一个 servlet ) ，然后按照servlet的调用方式进行调用。&lt;br&gt;　　由于 JSP 第一次访问时会翻译成 servlet ，所以第一次访问通常会比较慢，但第二次访问，JSP引擎如果发现JSP没有变化，就不再翻译，而是直接调用，所以程序的执行效率不会受到影响。&lt;br&gt;　　JSP 引擎在调用 JSP 对应的 &lt;code&gt;_jspServlet&lt;/code&gt; 时，会&lt;strong&gt;传递或创建9个与web开发相关的对象&lt;/strong&gt;供 &lt;code&gt;_jspServlet&lt;/code&gt; 使用。JSP技术的设计者为便于开发人员在编写JSP页面时获得这些web对象的引用，特意定义了9个相应的变量，开发人员在JSP页面中通过这些变量就可以快速获得这9大对象的引用。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Java常用类---图片处理ImageIO类</title>
    <link href="http://yoursite.com/2019/03/27/Java%E5%B8%B8%E7%94%A8%E7%B1%BB---%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86ImageIO%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/03/27/Java常用类---图片处理ImageIO类/</id>
    <published>2019-03-27T13:35:51.000Z</published>
    <updated>2019-03-29T02:25:12.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-获取图片"><a href="#一-获取图片" class="headerlink" title="一. 获取图片"></a>一. 获取图片</h1><h3 id="1-从本地文本读取图片"><a href="#1-从本地文本读取图片" class="headerlink" title="1) 从本地文本读取图片"></a>1) 从本地文本读取图片</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File sourceimage = <span class="keyword">new</span> File(<span class="string">"c:\mypic.jpg"</span>);</span><br><span class="line">Image image = ImageIO.read(sourceimage);</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-从网络上获取图片"><a href="#2-从网络上获取图片" class="headerlink" title="2) 从网络上获取图片"></a>2) 从网络上获取图片</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.mkyong.com/image/mypic.jpg"</span>);</span><br><span class="line">Image image = ImageIO.read(url);</span><br></pre></td></tr></table></figure><h3 id="3-使用ImageIO读取图片实例"><a href="#3-使用ImageIO读取图片实例" class="headerlink" title="3) 使用ImageIO读取图片实例"></a>3) 使用ImageIO读取图片实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadImage</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Image image = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从网络上获取图片</span></span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"https://sladning.github.io/images/Audrey_Hepburn.jpg"</span>);</span><br><span class="line">image = ImageIO.read(url);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 将图片输出到 JLabel 上</span></span><br><span class="line">JFrame frame = <span class="keyword">new</span> JFrame();</span><br><span class="line">frame.setSize(<span class="number">900</span>, <span class="number">900</span>);</span><br><span class="line">JLabel label = <span class="keyword">new</span> JLabel(<span class="keyword">new</span> ImageIcon(image));</span><br><span class="line">frame.add(label);</span><br><span class="line">frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果打印出来图片</span></span><br></pre></td></tr></table></figure><h1 id="二-写入图片"><a href="#二-写入图片" class="headerlink" title="二. 写入图片"></a>二. 写入图片</h1><h3 id="1-从网络上读取图片写入本地文件中"><a href="#1-从网络上读取图片写入本地文件中" class="headerlink" title="1) 从网络上读取图片写入本地文件中"></a>1) 从网络上读取图片写入本地文件中</h3><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteImage</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">BufferedImage image = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从网络上获取图片</span></span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"https://sladning.github.io/images/Audrey_Hepburn.jpg"</span>);</span><br><span class="line">image = ImageIO.read(url);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行图片的写入</span></span><br><span class="line">ImageIO.write(image, <span class="string">"jpg"</span>, <span class="keyword">new</span> File(<span class="string">"G:\\aaa.jpg"</span>)); <span class="comment">// .jpg文件占空间最小</span></span><br><span class="line">ImageIO.write(image, <span class="string">"gif"</span>, <span class="keyword">new</span> File(<span class="string">"G:\\bbb.gif"</span>));</span><br><span class="line">ImageIO.write(image, <span class="string">"png"</span>, <span class="keyword">new</span> File(<span class="string">"G:\\ccc.png"</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"成功写入G盘"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-从本地文件中读取图片和写入图片"><a href="#2-从本地文件中读取图片和写入图片" class="headerlink" title="2) 从本地文件中读取图片和写入图片"></a>2) 从本地文件中读取图片和写入图片</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLocalImage</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加载图片</span></span><br><span class="line">BufferedImage originalImage = ImageIO.read(<span class="keyword">new</span> File(<span class="string">"G:\\aaa.jpg"</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 写入图片</span></span><br><span class="line">ImageIO.write(originalImage, <span class="string">"jpg"</span>, <span class="keyword">new</span> File(<span class="string">"G:\\abc.jpg"</span>));</span><br><span class="line">System.out.println(<span class="string">"成功写入!!"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://blog.csdn.net/weixin_36279318/article/details/77446605" target="_blank" rel="noopener">ImageIO类的使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-获取图片&quot;&gt;&lt;a href=&quot;#一-获取图片&quot; class=&quot;headerlink&quot; title=&quot;一. 获取图片&quot;&gt;&lt;/a&gt;一. 获取图片&lt;/h1&gt;&lt;h3 id=&quot;1-从本地文本读取图片&quot;&gt;&lt;a href=&quot;#1-从本地文本读取图片&quot; class=&quot;headerlink&quot; title=&quot;1) 从本地文本读取图片&quot;&gt;&lt;/a&gt;1) 从本地文本读取图片&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;File sourceimage = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;string&quot;&gt;&quot;c:\mypic.jpg&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Image image = ImageIO.read(sourceimage);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="java常用类" scheme="http://yoursite.com/categories/java%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java常用类" scheme="http://yoursite.com/tags/java%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---数组</title>
    <link href="http://yoursite.com/2019/03/27/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2019/03/27/Java基础知识---数组/</id>
    <published>2019-03-27T10:01:27.000Z</published>
    <updated>2019-03-28T00:56:03.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一．数组的基本概念"><a href="#一．数组的基本概念" class="headerlink" title="一．数组的基本概念"></a>一．数组的基本概念</h1><ul><li>数组可以看成是<strong>多个相同类型数据组合</strong>，对这些数据的统一管理。</li><li><strong>数组变量属于引用类型</strong>，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。</li><li>数组的元素可以是任何数据类型，<strong>包括基本类型和引用类型</strong>。</li><li>C 和 C++ 中的数组都可以分配在栈上面，而JAVA中的数组是只能分配在<strong>堆</strong>上面的，因为JAVA中的数组是引用类型</li></ul><a id="more"></a><h1 id="二．一维数组"><a href="#二．一维数组" class="headerlink" title="二．一维数组"></a>二．一维数组</h1><h3 id="一维数组的声明"><a href="#一维数组的声明" class="headerlink" title="一维数组的声明"></a>一维数组的声明</h3><h4 id="方式有两种"><a href="#方式有两种" class="headerlink" title="方式有两种"></a>方式有两种</h4><ul><li>格式一：数组元素类型  数组名[ ];  </li><li>格式二：数组元素类型[ ] 数组名;</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[ ];   </span><br><span class="line"><span class="keyword">int</span>[ ] a2;</span><br><span class="line"></span><br><span class="line">String[ ] s1;  </span><br><span class="line">String s1[ ];</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>JAVA语言中声明数组时<strong>不能指定其长度</strong>(数组中的元素个数)</p><blockquote><p>如：<code>int a[5];</code> 这样声明一维数组是非法的</p></blockquote><h1 id="三．数组的模型"><a href="#三．数组的模型" class="headerlink" title="三．数组的模型"></a>三．数组的模型</h1><ul><li>一维数组：一维数组就是一行，一行小格。</li><li>二维数组：二维数组就是一行加一列组成的一个平面分成的小格，有行有列。</li><li>三维数组：三维数组就是一个立方体。</li><li>人类对最多认识到三维空间。</li></ul><h1 id="四-数组对象的创建"><a href="#四-数组对象的创建" class="headerlink" title="四. 数组对象的创建"></a>四. 数组对象的创建</h1><p>JAVA中使用关键字<strong>new</strong>创建数组对象</p><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组名 = new 数组元素的类型[数组元素的个数]</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="comment">// 进行声明,在栈内存中创建变量s</span></span><br><span class="line">        <span class="keyword">int</span>[] s;</span><br><span class="line">        <span class="comment">// 进行数组的创建</span></span><br><span class="line">        <span class="comment">// 在堆内存中创建int[5](一组相邻的内存),s指向对象</span></span><br><span class="line">        s = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            s[i] = i*i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五-元素为引用数据类型的数组"><a href="#五-元素为引用数据类型的数组" class="headerlink" title="五. 元素为引用数据类型的数组"></a>五. 元素为引用数据类型的数组</h1><h5 id="注意：元素为引用数据类型的数组中的每一个元素都需要实例化"><a href="#注意：元素为引用数据类型的数组中的每一个元素都需要实例化" class="headerlink" title="注意：元素为引用数据类型的数组中的每一个元素都需要实例化"></a>注意：元素为引用数据类型的数组中的每一个元素都需要实例化</h5><h5 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> year; <span class="keyword">int</span> moth; <span class="keyword">int</span> day;</span><br><span class="line">    Date(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d)&#123;</span><br><span class="line">        year = y;</span><br><span class="line">        month = m;</span><br><span class="line">        day = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Date[] days;</span><br><span class="line">        days = <span class="keyword">new</span> Date[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            day[i] = <span class="keyword">new</span> Date(<span class="number">2004</span>+i, <span class="number">4</span>, i+<span class="number">1</span>);</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六-数组的初始化"><a href="#六-数组的初始化" class="headerlink" title="六. 数组的初始化"></a>六. 数组的初始化</h1><h4 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[ ])</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1.动态初始化,数组定义与为数组元素分配空间和赋值的操作分开进行。</span></span><br><span class="line">        <span class="keyword">int</span> a[ ];  <span class="comment">// 定义数组，即声明一个int类型的数组a[ ]</span></span><br><span class="line">        a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];  <span class="comment">// 给数组元素分配内存空间。</span></span><br><span class="line">        a[<span class="number">0</span>]=<span class="number">3</span>; a[<span class="number">1</span>]=<span class="number">9</span>; a[<span class="number">2</span>]=<span class="number">8</span>;  <span class="comment">// 给数组元素赋值。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.静态初始化,在定义数组的同时就为数组元素分配空间并赋值。</span></span><br><span class="line">        <span class="keyword">int</span> a[ ] = &#123; <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;   <span class="comment">// 在定义数组的同时给数组分配空间并赋值。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.默认初始化,数组是引用类型，它的元素相当于类的成员变量，因此给数组分配内存空间后，每个元素也被按照成员变量的规则被隐式初始化</span></span><br><span class="line">        <span class="keyword">int</span> a[ ] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];      </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七-数组元素的引用"><a href="#七-数组元素的引用" class="headerlink" title="七. 数组元素的引用"></a>七. 数组元素的引用</h1><p>定义并用运算符<strong>new为之分配内存空间后</strong>，才可以引用数组中的每个元素</p><p>数组元素的引用方式为：<strong>arrayName[index]</strong> (index为数组元素下标，可以是整型常量或整型表达式)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">3</span>], b[i], c[<span class="number">6</span>*i]</span><br></pre></td></tr></table></figure><blockquote><p>数组元素下标从0开始；长度为n的数组的合法下标取值范围为 <strong>0～n—1</strong></p><p>每个数组都有一个属性length指明它的长度，例如：<strong>a.length</strong> 的值为数组a的长度(元素个数)</p></blockquote><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3623759.html" target="_blank" rel="noopener">java基础学习总结——数组</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一．数组的基本概念&quot;&gt;&lt;a href=&quot;#一．数组的基本概念&quot; class=&quot;headerlink&quot; title=&quot;一．数组的基本概念&quot;&gt;&lt;/a&gt;一．数组的基本概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;数组可以看成是&lt;strong&gt;多个相同类型数据组合&lt;/strong&gt;，对这些数据的统一管理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数组变量属于引用类型&lt;/strong&gt;，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。&lt;/li&gt;
&lt;li&gt;数组的元素可以是任何数据类型，&lt;strong&gt;包括基本类型和引用类型&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;C 和 C++ 中的数组都可以分配在栈上面，而JAVA中的数组是只能分配在&lt;strong&gt;堆&lt;/strong&gt;上面的，因为JAVA中的数组是引用类型&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---泛型(2)</title>
    <link href="http://yoursite.com/2019/03/27/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%B3%9B%E5%9E%8B(2)/"/>
    <id>http://yoursite.com/2019/03/27/Java基础知识---泛型(2)/</id>
    <published>2019-03-27T01:35:51.000Z</published>
    <updated>2019-03-29T02:24:27.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-泛型的基本概念"><a href="#一-泛型的基本概念" class="headerlink" title="一. 泛型的基本概念"></a>一. 泛型的基本概念</h1><p><strong>泛型的定义</strong> : 泛型是JDK 1.5的一项新特性，它的本质是参数化类型（Parameterized Type）的应用，也就是说所操作的数据类型被指定为一个参数，在用到的时候在指定具体的类型。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。</p><a id="more"></a><h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><p>在JDK1.5之前，Java泛型程序设计是用继承来实现的。因为Object类是所用类的基类，所以只需要维持一个Object类型的引用即可。就比如A<strong>rrayList只维护一个Object引用的数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK1.5之前的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;......&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span></span>&#123;......&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两个问题："><a href="#两个问题：" class="headerlink" title="两个问题："></a>两个问题：</h4><ol><li><p>没有错误检查，可以向数组列表中添加类的对象</p></li><li><p>在取元素的时候，需要进行强制类型转换</p></li></ol><h4 id="很容易发生错误，比如"><a href="#很容易发生错误，比如" class="headerlink" title="很容易发生错误，比如"></a>很容易发生错误，比如</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**jdk1.5之前的写法，容易出问题*/</span></span><br><span class="line">ArrayList arrayList1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">arrayList1.add(<span class="number">1</span>);</span><br><span class="line">arrayList1.add(<span class="number">1L</span>);</span><br><span class="line">arrayList1.add(<span class="string">"asa"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为不知道取出来的值的类型，类型转换的时候容易出错</span></span><br><span class="line"><span class="keyword">int</span> i = (Integer) arrayList1.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在JDK1.5之后，加入了泛型来解决类似的问题。</p><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** jdk1.5之后加入泛型*/</span></span><br><span class="line"><span class="comment">// 限定数组列表中的类型</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList2=<span class="keyword">new</span> ArrayList&lt;String&gt;();  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为限定了类型，所以不能添加整形</span></span><br><span class="line"><span class="comment">// arrayList2.add(1); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能添加字符串</span></span><br><span class="line">arrayList2.add(<span class="string">"asa"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为知道取出来的值的类型，所以不需要进行强制类型转换</span></span><br><span class="line">String str=arrayList2.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h1 id="二-基本术语"><a href="#二-基本术语" class="headerlink" title="二. 基本术语"></a>二. 基本术语</h1><p>以 <code>ArrayList&lt;E&gt;</code> 和 <code>ArrayList&lt;Integer&gt;</code> 做简要介绍：</p><table><thead><tr><th>元素</th><th>名称</th></tr></thead><tbody><tr><td><strong><code>ArrayList&lt;E&gt;</code></strong></td><td>泛型类型</td></tr><tr><td><strong><code>ArrayList&lt;E&gt;</code> 中的 <code>E</code> </strong></td><td>类型变量或者类型参数</td></tr><tr><td><strong><code>ArrayList&lt;Integer&gt;</code></strong></td><td>参数化的类型</td></tr><tr><td><strong><code>ArrayList&lt;Integer&gt;</code> 中的 <code>integer</code></strong></td><td>类型参数的实例或者实际类型参数</td></tr><tr><td><strong><code>ArrayList&lt;Integer&gt;</code> 中的 <code>&lt;Integer&gt;</code></strong></td><td><code>typeof   Integer</code></td></tr><tr><td><strong><code>ArrayList</code></strong></td><td>原始类型</td></tr></tbody></table><h1 id="三-泛型的使用"><a href="#三-泛型的使用" class="headerlink" title="三. 泛型的使用"></a>三. 泛型的使用</h1><p>泛型的参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。</p><h3 id="1-泛型类的定义和使用"><a href="#1-泛型类的定义和使用" class="headerlink" title="1) 泛型类的定义和使用"></a>1) 泛型类的定义和使用</h3><p>一个泛型类（generic class）就是具有一个或多个类型变量的类。定义一个泛型类十分简单，只需要在类名后面加上&lt;&gt;，再在里面加上类型参数</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T value)</span> </span>&#123; <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.value=value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="comment">// get</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123; <span class="comment">// set</span></span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        </span><br><span class="line">Pair&lt;String&gt; pair = <span class="keyword">new</span> Pair&lt;String&gt;(Hello<span class="string">");</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">String str = pair.getValue();</span></span><br><span class="line"><span class="string">System.out.println(str);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Pair&lt;Integer&gt; ii = new Pair&lt;Integer&gt;(2);</span></span><br><span class="line"><span class="string">System.out.println(ii.getValue());</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// 输出结果:</span></span><br><span class="line"><span class="string">// 变量类型为字符串时: Hello</span></span><br><span class="line"><span class="string">// 变量类型为整形时: 2</span></span><br></pre></td></tr></table></figure><p>Pair类引入了一个类型变量T，用尖括号&lt;&gt;括起来，并放在类名的后面。泛型类可以有多个类型变量。例如，可以定义Pair类，其中第一个域和第二个域使用不同的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt;</span>&#123;......&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong> : 类型变量使用大写形式，且比较短，这是很常见的。在Java库中，使用变量E表示集合的元素类型，K和V分别表示关键字与值的类型。（需要时还可以用临近的字母U和S）表示“任意类型”</p><h3 id="2-泛型接口的定义和使用"><a href="#2-泛型接口的定义和使用" class="headerlink" title="2) 泛型接口的定义和使用"></a>2) 泛型接口的定义和使用</h3><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Show</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowTest01</span> <span class="keyword">implements</span> <span class="title">Show</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String str, Date date)</span> </span>&#123;</span><br><span class="line">System.out.println(str + <span class="string">", 现在的时间为"</span> + date);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowTest02</span> <span class="keyword">implements</span> <span class="title">Show</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 不同类型的参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"a+b的值为:"</span> + (a + b));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description:对两组不同的参数的对象进行输出测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testImplements</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">ShowTest01 showTest01 = <span class="keyword">new</span> ShowTest01();</span><br><span class="line">showTest01.show(<span class="string">"Hello"</span>, <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">ShowTest02 showTest02 = <span class="keyword">new</span> ShowTest02();</span><br><span class="line">showTest02.show(<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="comment">// Hello, 现在的时间为Wed Mar 27 21:02:59 CST 2019</span></span><br><span class="line"><span class="comment">// a+b的值为:15</span></span><br></pre></td></tr></table></figure><h3 id="3-泛型方法的定义和使用"><a href="#3-泛型方法的定义和使用" class="headerlink" title="3) 泛型方法的定义和使用"></a>3) 泛型方法的定义和使用</h3><p>泛型类在多个方法签名间实施类型约束。</p><p>在 <code>List&lt;V&gt;</code> 中，类型参数 V 出现在 get()、add()、contains() 等方法的签名中。当创建一个 Map&lt;K, V&gt; 类型的变量时，您就在方法之间宣称一个类型约束。您传递给 add() 的值将与 get() 返回的值的类型相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        String str=get(<span class="string">"Hello"</span>, <span class="string">"World"</span>);</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> aa = get(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(aa);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt; <span class="function">T <span class="title">get</span><span class="params">(T t, U u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h1 id="三、泛型变量的类型限定"><a href="#三、泛型变量的类型限定" class="headerlink" title="三、泛型变量的类型限定"></a>三、泛型变量的类型限定</h1><p>略</p><hr><h5 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h5><p>​    <a href="https://blog.csdn.net/LonelyRoamer/article/details/7864531" target="_blank" rel="noopener">java泛型（一）、泛型的基本介绍和使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-泛型的基本概念&quot;&gt;&lt;a href=&quot;#一-泛型的基本概念&quot; class=&quot;headerlink&quot; title=&quot;一. 泛型的基本概念&quot;&gt;&lt;/a&gt;一. 泛型的基本概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;泛型的定义&lt;/strong&gt; : 泛型是JDK 1.5的一项新特性，它的本质是参数化类型（Parameterized Type）的应用，也就是说所操作的数据类型被指定为一个参数，在用到的时候在指定具体的类型。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。&lt;/p&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机知识---绝对路径与相对路径</title>
    <link href="http://yoursite.com/2019/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86---%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2019/03/26/计算机知识---绝对路径与相对路径/</id>
    <published>2019-03-26T14:57:55.000Z</published>
    <updated>2019-03-29T01:08:55.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-基本概念"><a href="#一-基本概念" class="headerlink" title="一. 基本概念"></a>一. 基本概念</h1><ol><li><strong>相对路径</strong> : 顾名思义，相对路径就是<strong>相对于当前文件的路径</strong>。网页中一般表示路径使用这个方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"/admin/add"</span></span><br></pre></td></tr></table></figure><ol><li><p><strong>绝对路径</strong> : 绝对路径就是你的<strong>主页上的文件或目录在硬盘上真正的路径</strong>。</p><ul><li><strong>硬盘上</strong> : 你的Perl 程序是存放在 c:/apache/cgi-bin 下的，那么 c:/apache/cgi-bin就是cgi-bin目录的绝对路径</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:/apache/cgi-bin</span><br></pre></td></tr></table></figure><ul><li><strong>网络中</strong> : 以http开头的链接都是绝对路径，绝对路径就是<strong>你的主页上的文件或目录在硬盘上真正的路径</strong>，绝对路径一般在CGI程序的路径配置中经常用到，而在制作网页中实际很少用到。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//www.baidu.com/</span></span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><h1 id="二、相对路径使用的特殊符号"><a href="#二、相对路径使用的特殊符号" class="headerlink" title="二、相对路径使用的特殊符号"></a>二、相对路径使用的特殊符号</h1><h4 id="相对路径使用的特殊符号"><a href="#相对路径使用的特殊符号" class="headerlink" title="相对路径使用的特殊符号"></a>相对路径使用的特殊符号</h4><ul><li><p><strong><code>./</code></strong>：代表目前所在的目录</p></li><li><p><strong><code>../</code></strong> : 代表上一层目录</p></li><li><p><strong><code>/</code></strong> : 代表根目录</p></li></ul><p>根目录下有Site1和Image/Image.jpg，Site1下有Page1.html文件和Site2文件夹。Site2下有Page2.html和Page2Image.jpg图片文件。</p><p>1、文件在当前目录</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Page2.html访问Page2Image.jpg</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">”./Page2Image.jpg”</span>&gt;</span>或者<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">”Page2Image.jpg”</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h1 id="三-绝对路径与相对路径的比较"><a href="#三-绝对路径与相对路径的比较" class="headerlink" title="三. 绝对路径与相对路径的比较"></a>三. 绝对路径与相对路径的比较</h1><h3 id="3-1-绝对路径的优点"><a href="#3-1-绝对路径的优点" class="headerlink" title="3.1 绝对路径的优点"></a>3.1 绝对路径的优点</h3><pre><code>A、如果有人抄袭你的网站内容，里面的链接还会指向你的网站，有些抄袭的人比较懒，根本不会去改内容。其实也不局限于被抄袭，如果有人将你的网页保存到本地电脑中，里面的链接、图片、css、以及js仍然会连接到你的网站。B、如果网页位置改变，里面的链接还是指向正确的URL。</code></pre><h3 id="3-2-绝对路径的缺点"><a href="#3-2-绝对路径的缺点" class="headerlink" title="3.2 绝对路径的缺点"></a>3.2 绝对路径的缺点</h3><pre><code>A、在编码编写时不方便使用绝对路径，因为链接应该指向真正的域名而不是开发站点。</code></pre><blockquote><p> 相对路径的优缺点和绝对路径几乎相反。</p></blockquote><h3 id="3-3-相对路径的优点："><a href="#3-3-相对路径的优点：" class="headerlink" title="3.3 相对路径的优点："></a>3.3 相对路径的优点：</h3><pre><code>A、容易移动内容，可以整个目录移动。B、测试方法比较灵活，本机测试时比较方便。</code></pre><h3 id="3-4-相对路径的缺点："><a href="#3-4-相对路径的缺点：" class="headerlink" title="3.4 相对路径的缺点："></a>3.4 相对路径的缺点：</h3><pre><code>A、部分内容页面换了位置时，链接容易失效。B、容易被人大面积采集抄袭。</code></pre><blockquote><p>相对路径和绝对路径在系统文件中与在网络中类似，文件的路径符号是斜线﻿“/”，而网络路径却是和它相反的反斜线“/”</p></blockquote><h1 id="四-路径分割符"><a href="#四-路径分割符" class="headerlink" title="四. 路径分割符"></a>四. 路径分割符</h1><h4 id="在目录中的分隔符"><a href="#在目录中的分隔符" class="headerlink" title="在目录中的分隔符"></a>在目录中的分隔符</h4><ul><li><p>在Windows中分隔符为 <strong><code>\</code></strong></p></li><li><p>在Unix/Linux中分隔符为 <strong><code>/</code></strong></p></li><li>浏览器地址栏网址使用 <strong><code>/</code></strong></li></ul><blockquote><p>有时我们会看到这样的路径写法，<code>&quot;C:\\Windows\\System&quot;</code>，也就是用两个反斜杠来分隔路径</p><p>这种写法在网络应用或编程中经 常看到，事实上，上面这个路径可以用 <code>&quot;C:/Windows/System&quot;</code> 来代替，不会出错。但是如果写成了 <code>&quot;C:\Windows\System&quot;</code> ， 那就可能会出现各种奇怪的错误了</p></blockquote><p>在 Java程序中 反斜杠 <code>\</code> 与不同的字符会组成不同的转义字符,如 <code>\n</code> 代表换行,</p><p>在字符串中要表示字符 <code>\</code> , 需要写成 <code>\\</code></p><p>​    字符串解析不仅仅局限于C编译器，Java编译器、一些配置文件的解析、Web服务器等等，都会遇到对字符串进行解析的这个问题，由于传统的 Windows采用的是单个反斜杠的路径分隔形式，导致在对文件路径进行解析的时候可能发生不必要的错误，所以就出现了用双反斜杠”\\”分隔路径的形式。 <strong>不管解析引擎是否将反斜杠解析成转义字符，最终在内存中得到的都是”\”</strong>，结果也就不会出问题了。</p><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://blog.csdn.net/jzdzhiyun/article/details/5282512" target="_blank" rel="noopener">关于绝对路径和相对路径</a></p><p>​    <a href="https://www.jianshu.com/p/cf0c6764e5d4" target="_blank" rel="noopener">编程中常见的斜杠（”/“和”\”）问题</a></p><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-基本概念&quot;&gt;&lt;a href=&quot;#一-基本概念&quot; class=&quot;headerlink&quot; title=&quot;一. 基本概念&quot;&gt;&lt;/a&gt;一. 基本概念&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;相对路径&lt;/strong&gt; : 顾名思义，相对路径就是&lt;strong&gt;相对于当前文件的路径&lt;/strong&gt;。网页中一般表示路径使用这个方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;/admin/add&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;绝对路径&lt;/strong&gt; : 绝对路径就是你的&lt;strong&gt;主页上的文件或目录在硬盘上真正的路径&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;硬盘上&lt;/strong&gt; : 你的Perl 程序是存放在 c:/apache/cgi-bin 下的，那么 c:/apache/cgi-bin就是cgi-bin目录的绝对路径&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;c:/apache/cgi-bin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;网络中&lt;/strong&gt; : 以http开头的链接都是绝对路径，绝对路径就是&lt;strong&gt;你的主页上的文件或目录在硬盘上真正的路径&lt;/strong&gt;，绝对路径一般在CGI程序的路径配置中经常用到，而在制作网页中实际很少用到。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;https:&lt;span class=&quot;comment&quot;&gt;//www.baidu.com/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="计算机知识" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="计算机知识" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---File</title>
    <link href="http://yoursite.com/2019/03/26/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---File/"/>
    <id>http://yoursite.com/2019/03/26/Java基础知识---File/</id>
    <published>2019-03-26T14:38:55.000Z</published>
    <updated>2019-03-27T02:13:56.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-初识-File"><a href="#一-初识-File" class="headerlink" title="一. 初识 File"></a>一. 初识 File</h1><h2 id="1-1-File类说明"><a href="#1-1-File类说明" class="headerlink" title="1.1 File类说明"></a>1.1 <strong>File类说明</strong></h2><p>​    存储在变量,数组和对象中的数据是暂时的,<strong>当程序终止时他们就会丢失</strong>.</p><p>​    为了能够永久的保存程序中创建的数据,需要将他们存储到硬盘或光盘的文件中.这些文件可以移动,传送,亦可以被其他程序使用.由于数据存储在文件中,所以我们<strong>需要学习一个和文件有密切关系的类,叫做File类</strong>,将要掌握获取文件的属性以及删除和重命名文件.最终如何向文件中写入数据和从文件中读取数据.</p><p>那么File类关心的是在磁盘上文件的存储.</p><a id="more"></a><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li><p><strong>File类描述的是一个文件或文件夹。（文件夹也可以称为目录）</strong></p></li><li><p>该类的出现是<strong>对文件系统的中的文件以及文件夹进行对象的封装</strong>。可以<strong>通过对象的思想来操作文件以及文件夹</strong>。</p></li><li><p>可以用面向对象的处理问题，通过该对象的方法，可以得到文件或文件夹的信息方便了对文件与文件夹的属性信息进行操作。</p></li><li><p>文件包含很多的信息:如文件名、创建修改时间、大小、可读可写属性等。</p></li></ul><h2 id="1-2-体验File类"><a href="#1-2-体验File类" class="headerlink" title="1.2 体验File类"></a>1.2 <strong>体验File类</strong></h2><p>检验指定路径下是否存在指定的目录或者文件.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检验指定路径下是否存在指定的目录或者文件.</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\a.txt"</span>);</span><br><span class="line">System.out.println(file.exists());</span><br><span class="line"></span><br><span class="line"><span class="comment">// File对象是否是目录</span></span><br><span class="line">System.out.println(file.isDirectory());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象是否是文件</span></span><br><span class="line">System.out.println(file.isFile());</span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><ul><li><p>File对象也可以表示不存在的文件。其实代表了一个抽象路径</p></li><li><p>构建一个File类的实例并不会在机器上创建一个文件.不管文件是否存在都可以创建任意文件名的File实例,可以调用File实例的exists方法判断文件或目录是否存在</p></li></ul><h2 id="1-3-创建File类"><a href="#1-3-创建File类" class="headerlink" title="1.3 创建File类"></a>1.3 创建File类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过将给定路径来创建一个新File实例。</span></span><br><span class="line"><span class="keyword">new</span> File(String pathname);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据parent路径名字符串和child路径名创建一个新File实例。</span></span><br><span class="line"><span class="comment">// parent是指上级目录的路径，完整的路径为parent+child.</span></span><br><span class="line"><span class="keyword">new</span> File(String parent, String child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据parent抽象路径名和child路径名创建一个新File实例。</span></span><br><span class="line"><span class="comment">// parent是指上级目录的路径，完整的路径为parent.getPath()+child.</span></span><br><span class="line"><span class="keyword">new</span> File(File parent, String child);</span><br></pre></td></tr></table></figure><blockquote><p>如果指定的路径不存在（没有这个文件或是文件夹），不会抛异常，这时file.exists()返回false</p></blockquote><p>新建File对象File file=new File();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// file01 是一个文件对象</span></span><br><span class="line">    String path01 = <span class="string">"c:/a.txt"</span>;</span><br><span class="line">    File file01 = <span class="keyword">new</span> File(path);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// file02 是一个文件夹</span></span><br><span class="line">    String path02 = <span class="string">"c:/test"</span>;</span><br><span class="line">    File file02 = <span class="keyword">new</span> File(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li><p>创建File对象需要导包, import java.io.File</p></li><li><p>File对象没有无参数构造.创建对象需要传参.</p><blockquote><p>根据API文档提示,传入一个文件的字符串路径. <code>String path=&quot;c:/a.txt&quot;;</code> (a.txt 文件在c盘下已经存在)</p></blockquote></li><li><p>File类的对象，既可以代表文件<strong>也可以代表文件夹</strong></p></li></ol><h1 id="二-路径"><a href="#二-路径" class="headerlink" title="二. 路径"></a>二. 路径</h1><p>​    路径就是文件或文件夹所在的位置。 </p><h2 id="2-1-绝对路径与相对路径："><a href="#2-1-绝对路径与相对路径：" class="headerlink" title="2.1 绝对路径与相对路径："></a>2.1 <strong>绝对路径与相对路径：</strong></h2><ul><li><p>对于UNIX平台，绝对路径名的前缀是”/“。相对路径名没有前缀。</p></li><li><p>对于Windows平台，绝对路径名的前缀由驱动器号和一个”:”组成，例”c:\…”。相对路径没有盘符前缀。</p></li></ul><p><strong>一般在使用时，建议用绝对路径，因为相对路径容易出问题，不好确定到底在什么地方</strong></p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFile</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 绝对路径</span></span><br><span class="line">        File f1 = <span class="keyword">new</span> File(<span class="string">"d:/LOLFolder"</span>);</span><br><span class="line">        System.out.println(<span class="string">"f1的绝对路径："</span> + f1.getAbsolutePath());</span><br><span class="line">        <span class="comment">// 相对路径,相对于工作目录，如果在eclipse中，就是项目目录</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"LOL.exe"</span>);</span><br><span class="line">        System.out.println(<span class="string">"f2的绝对路径："</span> + f2.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-路径分割符"><a href="#2-2-路径分割符" class="headerlink" title="2.2 路径分割符"></a>2.2 路径分割符</h2><h4 id="上下级文件夹之间使用分隔符分开"><a href="#上下级文件夹之间使用分隔符分开" class="headerlink" title="上下级文件夹之间使用分隔符分开"></a>上下级文件夹之间使用分隔符分开</h4><ul><li>在Windows中分隔符为 <strong><code>\</code></strong></li><li>在Unix/Linux中分隔符为 <strong><code>/</code></strong></li></ul><h4 id="跨平台的目录分隔符"><a href="#跨平台的目录分隔符" class="headerlink" title="跨平台的目录分隔符"></a>跨平台的目录分隔符</h4><p>​    更专业的做法是使用File.separatorChar，这个值就会根据系统得到的相应的分割符。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> File(<span class="string">"c:"</span> + File.separatorChar + <span class="string">"a.txt"</span>);</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> : 如果是使用”\”，则需要<strong>进行转义</strong>，写为”\“才可以，如果是两个”\”，则写为”\\“</p></blockquote><h1 id="三-操作文件的相关方法"><a href="#三-操作文件的相关方法" class="headerlink" title="三. 操作文件的相关方法"></a>三. 操作文件的相关方法</h1><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1) 创建"></a>1) 创建</h3><table><thead><tr><th>序号</th><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>14</td><td><strong>public boolean createNewFile() throws IOException</strong></td><td>在指定位置创建一个空文件，成功就返回true，如果已存在就不创建然后返回false</td></tr><tr><td>21</td><td><strong>public boolean mkdir()</strong></td><td>在指定位置创建目录，这只会创建最后一级目录，如果上级目录不存在就抛异常</td></tr><tr><td>22</td><td><strong>public boolean mkdirs()</strong></td><td>在指定位置创建目录，这会创建路径中所有不存在的目录</td></tr><tr><td>23</td><td><strong>public boolean renameTo(File dest)</strong></td><td>重新命名此抽象路径名表示的文件</td></tr></tbody></table><h3 id="2-获取"><a href="#2-获取" class="headerlink" title="2)获取"></a>2)获取</h3><h5 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h5><table><thead><tr><th style="text-align:center">序号</th><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td><strong>public String getName()</strong></td><td>返回由此抽象路径名<strong>表示的文件或目录的名称</strong>。</td></tr><tr><td style="text-align:center">2</td><td><strong>public String getParent()</strong></td><td>返回此抽象路径名的<strong>父路径名的路径名字符串</strong></td></tr><tr><td style="text-align:center">3</td><td><strong>public File getParentFile()</strong></td><td>返回此抽象路径名的<strong>父路径名的抽象路径名</strong></td></tr><tr><td style="text-align:center">4</td><td><strong>public String getPath()</strong></td><td>将此抽象路径名转换为一个<strong>路径名字符串</strong></td></tr><tr><td style="text-align:center">6</td><td><strong>public String getAbsolutePath()</strong></td><td>返回抽象路径名的<strong>绝对路径名字符串</strong></td></tr><tr><td style="text-align:center">12</td><td><strong>public long lastModified()</strong></td><td>返回此抽象路径名表示的文件最后一次被修改的时间</td></tr><tr><td style="text-align:center">13</td><td><strong>public long length()</strong></td><td>返回由此抽象路径名表示的文件的长度</td></tr></tbody></table><h5 id="文件夹相关"><a href="#文件夹相关" class="headerlink" title="文件夹相关"></a>文件夹相关</h5><table><thead><tr><th>序号</th><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="3-判断"><a href="#3-判断" class="headerlink" title="3) 判断"></a>3) 判断</h3><table><thead><tr><th style="text-align:center">序号</th><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">5</td><td><strong>public boolean isAbsolute()</strong></td><td>测试此抽象路径名<strong>是否为绝对路径名</strong></td></tr><tr><td style="text-align:center">7</td><td><strong>public boolean canRead()</strong></td><td>测试应用程序是否可以读取此抽象路径名表示的文件</td></tr><tr><td style="text-align:center">9</td><td><strong>public boolean exists()</strong></td><td>测试此抽象路径名表示的文件或目录是否存在</td></tr><tr><td style="text-align:center">10</td><td><strong>public boolean isDirectory()</strong></td><td>测试此抽象路径名表示的文件是否是一个目录</td></tr><tr><td style="text-align:center">11</td><td><strong>public boolean isFile()</strong></td><td>测试此抽象路径名表示的文件是否是一个标准文件</td></tr><tr><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center"></td><td></td></tr></tbody></table><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://blog.csdn.net/jdliyao/article/details/79777895" target="_blank" rel="noopener">java File类</a></p><p>​    <a href="https://www.cnblogs.com/qi-dian/p/6132694.html" target="_blank" rel="noopener">Java 关于File使用</a></p><p>​    <a href="http://www.runoob.com/java/java-file.html" target="_blank" rel="noopener">Java File类</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-初识-File&quot;&gt;&lt;a href=&quot;#一-初识-File&quot; class=&quot;headerlink&quot; title=&quot;一. 初识 File&quot;&gt;&lt;/a&gt;一. 初识 File&lt;/h1&gt;&lt;h2 id=&quot;1-1-File类说明&quot;&gt;&lt;a href=&quot;#1-1-File类说明&quot; class=&quot;headerlink&quot; title=&quot;1.1 File类说明&quot;&gt;&lt;/a&gt;1.1 &lt;strong&gt;File类说明&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;​    存储在变量,数组和对象中的数据是暂时的,&lt;strong&gt;当程序终止时他们就会丢失&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;​    为了能够永久的保存程序中创建的数据,需要将他们存储到硬盘或光盘的文件中.这些文件可以移动,传送,亦可以被其他程序使用.由于数据存储在文件中,所以我们&lt;strong&gt;需要学习一个和文件有密切关系的类,叫做File类&lt;/strong&gt;,将要掌握获取文件的属性以及删除和重命名文件.最终如何向文件中写入数据和从文件中读取数据.&lt;/p&gt;
&lt;p&gt;那么File类关心的是在磁盘上文件的存储.&lt;/p&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---Iterator迭代器</title>
    <link href="http://yoursite.com/2019/03/26/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://yoursite.com/2019/03/26/Java基础知识---Iterator迭代器/</id>
    <published>2019-03-26T13:38:55.000Z</published>
    <updated>2019-03-27T09:19:27.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-迭代器概述"><a href="#一-迭代器概述" class="headerlink" title="一. 迭代器概述"></a>一. 迭代器概述</h1><h3 id="1-1-迭代器模式"><a href="#1-1-迭代器模式" class="headerlink" title="1.1 迭代器模式"></a>1.1 迭代器模式</h3><p>​    提供一种方法对一个容器对象中的各个元素进行访问，而又不暴露该对象容器的内部细节</p><a id="more"></a><h3 id="1-2-什么是迭代器？"><a href="#1-2-什么是迭代器？" class="headerlink" title="1.2 什么是迭代器？"></a>1.2 什么是迭代器？</h3><p>　　Java集合框架的集合类，我们有时候称之为<strong>容器</strong>。容器的种类有很多种，比如ArrayList、LinkedList、HashSet…，每种容器都有自己的特点，每种容器都有自己特有的数据结构。</p><p>　　因为容器的内部结构不同，<strong>很多时候可能不知道该怎样去遍历一个容器中的元素</strong>。所以<strong>为了使对容器内元素的操作更为简单，Java引入了迭代器模式！</strong></p><h1 id="二-java-util-Iterator"><a href="#二-java-util-Iterator" class="headerlink" title="二. java.util.Iterator"></a>二. java.util.Iterator</h1><p>　　在Java中Iterator为<strong>一个接口</strong>，它只提供了迭代的基本规则。</p><p>​    在JDK中它是这样定义的：对Collection进行迭代的迭代器。迭代器取代了Java Collection Framework中的Enumeration。</p><p>迭代器与枚举有两点不同:</p><ol><li><p>迭代器在迭代期间可以从集合中移除元素。</p></li><li><p>方法名得到了改进，Enumeration的方法名称都比较长。</p></li></ol><h4 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三个方法解释"><a href="#三个方法解释" class="headerlink" title="三个方法解释"></a>三个方法解释</h4><ul><li><strong><code>hasNext()</code></strong> : 如判断是否存在下一个对象元素.有仍有元素可以迭代,则返回true</li><li><strong><code>next()</code></strong> : 返回迭代的下一个元素</li><li><strong><code>remove()</code></strong> : 从迭代器指向 collenction 中移除元素</li></ul><h1 id="三-java-util-Iterable"><a href="#三-java-util-Iterable" class="headerlink" title="三.  java.util.Iterable"></a>三.  java.util.Iterable</h1><p>　　Java中还提供了一个Iterable接口，Iterable接口实现后的功能是 “”返回“ 一个迭代器，我们常用的实现了该接口的子接口有:Collection<e>、List<e>、Set<e>等。该接口的iterator()方法返回一个标准的Iterator实现。实现Iterable接口允许对象成为Foreach语句的目标。就可以通过foreach语句来遍历你的底层序列。</e></e></e></p><p>　　Iterable接口包含一个能产生Iterator对象的方法，并且Iterable被foreach用来在序列中移动。因此<strong>如果创建了实现Iterable接口的类，都可以将它用于foreach中</strong>。</p><h4 id="接口定义-1"><a href="#接口定义-1" class="headerlink" title="接口定义"></a>接口定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Package java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-使用迭代器遍历集合"><a href="#四-使用迭代器遍历集合" class="headerlink" title="四. 使用迭代器遍历集合"></a>四. 使用迭代器遍历集合</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"abc"</span>);</span><br><span class="line">    list.add(<span class="string">"edf"</span>);</span><br><span class="line">    list.add(<span class="string">"ghi"</span>);</span><br><span class="line">    <span class="comment">// 方式一, 不常用</span></span><br><span class="line">    <span class="keyword">for</span>(Iterator&lt;String&gt; iterator = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式二, 常用</span></span><br><span class="line">    Iterator&lt;Person&gt; iterator = array.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext() ) &#123;</span><br><span class="line">        System.out.println(iterator.next().getName()); <span class="comment">//输出的是wang，而不是tom</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用forEach遍历</span></span><br><span class="line">    <span class="keyword">for</span>(String string : List) &#123;</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用-foreach-遍历集合的优势在于代码更加的简洁，更不容易出错，不用关心下标的起始值和终止值。"><a href="#使用-foreach-遍历集合的优势在于代码更加的简洁，更不容易出错，不用关心下标的起始值和终止值。" class="headerlink" title="使用 foreach 遍历集合的优势在于代码更加的简洁，更不容易出错，不用关心下标的起始值和终止值。"></a>使用 foreach 遍历集合的优势在于代码更加的简洁，更不容易出错，不用关心下标的起始值和终止值。</h5><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/zyuze/p/7726582.html" target="_blank" rel="noopener">深入理解Java中的迭代器</a></p><p>​    <a href="https://www.cnblogs.com/xujian2014/p/5846128.html" target="_blank" rel="noopener">Java集合Iterator迭代器的实现</a></p><p>​    <a href="https://blog.csdn.net/Jae_Wang/article/details/80526216" target="_blank" rel="noopener">Java迭代器(iterator详解以及和for循环的区别)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-迭代器概述&quot;&gt;&lt;a href=&quot;#一-迭代器概述&quot; class=&quot;headerlink&quot; title=&quot;一. 迭代器概述&quot;&gt;&lt;/a&gt;一. 迭代器概述&lt;/h1&gt;&lt;h3 id=&quot;1-1-迭代器模式&quot;&gt;&lt;a href=&quot;#1-1-迭代器模式&quot; class=&quot;headerlink&quot; title=&quot;1.1 迭代器模式&quot;&gt;&lt;/a&gt;1.1 迭代器模式&lt;/h3&gt;&lt;p&gt;​    提供一种方法对一个容器对象中的各个元素进行访问，而又不暴露该对象容器的内部细节&lt;/p&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---文件上传与下载</title>
    <link href="http://yoursite.com/2019/03/26/JavaWeb---%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/03/26/JavaWeb---文件上传与下载/</id>
    <published>2019-03-26T13:38:55.000Z</published>
    <updated>2019-03-31T02:08:54.701Z</updated>
    
    <content type="html"><![CDATA[<p>​    在web应用系统开发中，文件上传和下载功能是非常常用的功能，</p><p>​    对于文件上传，浏览器在上传的过程中是<strong>将文件以流的形式提交到服务器端</strong>的，如果直接使用Servlet获取上传文件的输入流然后再解析里面的请求参数是比较麻烦</p><p>​    一般选择采用apache的开源工具common-fileupload这个文件上传组件</p><a id="more"></a><h1 id="一-开发环境搭建"><a href="#一-开发环境搭建" class="headerlink" title="一. 开发环境搭建"></a>一. 开发环境搭建</h1><p>创建一个 <code>FileUploadAndDownLoad</code> 项目，加入Apache的 <code>commons-fileupload</code> 文件上传组件的相关Jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commons-io-1.4.jar</span><br><span class="line">commons-fileupload-1.2.2.jar</span><br></pre></td></tr></table></figure><h1 id="二-实现文件上传"><a href="#二-实现文件上传" class="headerlink" title="二. 实现文件上传"></a>二. 实现文件上传</h1><h2 id="2-1-文件上传页面和消息提示页面"><a href="#2-1-文件上传页面和消息提示页面" class="headerlink" title="2.1 文件上传页面和消息提示页面"></a>2.1 文件上传页面和消息提示页面</h2><p>upload.jsp 页面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/servlet/UploadHandleServlet"</span> enctype=<span class="string">"multipart/form-data"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    上传用户：&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span>&gt;&lt;br/&gt;</span><br><span class="line">    上传文件<span class="number">1</span>：&lt;input type=<span class="string">"file"</span> name=<span class="string">"file1"</span>&gt;&lt;br/&gt;</span><br><span class="line">    上传文件<span class="number">2</span>：&lt;input type=<span class="string">"file"</span> name=<span class="string">"file2"</span>&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ol><li>form 的 method <strong>必须是 post 的</strong>，get不能上传文件。 还需要加上 <code>enctype=&quot;multipart/form-data&quot;</code> 表示提交的数据是二进制文件</li><li>需要提供 <code>type=&quot;file&quot;</code> 的字段进行上传</li></ol><h2 id="2-2-处理文件上传的Servlet"><a href="#2-2-处理文件上传的Servlet" class="headerlink" title="2.2 处理文件上传的Servlet"></a>2.2 处理文件上传的Servlet</h2><p><code>UploadHandleServlet</code> 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadHandleServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 得到上传文件的保存目录，将上传的文件存放于WEB-INF目录下，不允许外界直接访问，保证上传文件的安全</span></span><br><span class="line">        String savePath = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">"/WEB-INF/upload"</span>);</span><br><span class="line">        File file = <span class="keyword">new</span> File(savePath);</span><br><span class="line">        <span class="comment">// 判断上传文件的保存目录是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (!file.exists() &amp;&amp; !file.isDirectory()) &#123;</span><br><span class="line">            System.out.println(savePath + <span class="string">"目录不存在，需要创建"</span>);</span><br><span class="line">            <span class="comment">// 创建目录</span></span><br><span class="line">            file.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 消息提示</span></span><br><span class="line">        String message = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 使用Apache文件上传组件处理文件上传步骤：</span></span><br><span class="line">            <span class="comment">// 1、创建一个DiskFileItemFactory工厂</span></span><br><span class="line">            DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">            <span class="comment">// 2、创建一个文件上传解析器</span></span><br><span class="line">            ServletFileUpload upload = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line">            <span class="comment">// 解决上传文件名的中文乱码</span></span><br><span class="line">            upload.setHeaderEncoding(<span class="string">"UTF-8"</span>); </span><br><span class="line">            <span class="comment">// 3、判断提交上来的数据是否是上传表单的数据</span></span><br><span class="line">            <span class="keyword">if</span>(!ServletFileUpload.isMultipartContent(request))&#123;</span><br><span class="line">                <span class="comment">// 按照传统方式获取数据</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4、使用ServletFileUpload解析器解析上传数据，解析结果返回的是一个List&lt;FileItem&gt;集合，每一个FileItem对应一个Form表单的输入项</span></span><br><span class="line">            List&lt;FileItem&gt; list = upload.parseRequest(request);</span><br><span class="line">            <span class="keyword">for</span>(FileItem item : list)&#123;</span><br><span class="line">                <span class="comment">// 如果fileitem中封装的是普通输入项的数据</span></span><br><span class="line">                <span class="keyword">if</span>(item.isFormField())&#123;</span><br><span class="line">                    String name = item.getFieldName();</span><br><span class="line">                    <span class="comment">// 解决普通输入项的数据的中文乱码问题</span></span><br><span class="line">                    String value = item.getString(<span class="string">"UTF-8"</span>);</span><br><span class="line">                    <span class="comment">// value = new String(value.getBytes("iso8859-1"),"UTF-8");</span></span><br><span class="line">                    System.out.println(name + <span class="string">"="</span> + value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果fileitem中封装的是上传文件</span></span><br><span class="line">                    <span class="comment">// 得到上传的文件名称，</span></span><br><span class="line">                    String filename = item.getName();</span><br><span class="line">                    System.out.println(filename);</span><br><span class="line">                    <span class="keyword">if</span>(filename==<span class="keyword">null</span> || filename.trim().equals(<span class="string">""</span>))&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                    <span class="comment">// 注意：不同的浏览器提交的文件名是不一样的，有些浏览器提交上来的文件名是带有路径的，如：  c:\a\b\1.txt，而有些只是单纯的文件名，如：1.txt</span></span><br><span class="line">                    <span class="comment">// 处理获取到的上传文件的文件名的路径部分，只保留文件名部分</span></span><br><span class="line">                    filename = filename.substring(filename.lastIndexOf(<span class="string">"\\"</span>)+<span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 获取item中的上传文件的输入流</span></span><br><span class="line">                    InputStream in = item.getInputStream();</span><br><span class="line">                    <span class="comment">// 创建一个文件输出流</span></span><br><span class="line">                    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(savePath + <span class="string">"\\"</span> + filename);</span><br><span class="line">                    <span class="comment">//创建一个缓冲区</span></span><br><span class="line">                    <span class="keyword">byte</span> buffer[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                    <span class="comment">//判断输入流中的数据是否已经读完的标识</span></span><br><span class="line">                    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//循环将输入流读入到缓冲区当中，(len=in.read(buffer))&gt;0就表示in里面还有数据</span></span><br><span class="line">                    <span class="keyword">while</span>((len=in.read(buffer))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">//使用FileOutputStream输出流将缓冲区的数据写入到指定的目录(savePath + "\\" + filename)当中</span></span><br><span class="line">                        out.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//关闭输入流</span></span><br><span class="line">                    in.close();</span><br><span class="line">                    <span class="comment">//关闭输出流</span></span><br><span class="line">                    out.close();</span><br><span class="line">                    <span class="comment">//删除处理文件上传时生成的临时文件</span></span><br><span class="line">                    item.delete();</span><br><span class="line">                    message = <span class="string">"文件上传成功！"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            message= <span class="string">"文件上传失败！"</span>;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(<span class="string">"message"</span>,message);</span><br><span class="line">        request.getRequestDispatcher(<span class="string">"/message.jsp"</span>).forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/4200090.html" target="_blank" rel="noopener">JavaWeb学习总结(五十)——文件上传和下载</a></p><p>​    <a href="https://blog.csdn.net/alan_liuyue/article/details/72782207" target="_blank" rel="noopener">Java文件上传功能代码 —— 普遍适用</a></p><p>​    <a href="https://www.cnblogs.com/ygj0930/p/6073505.html" target="_blank" rel="noopener">JavaWeb开发之网站实现文件上传功能</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    在web应用系统开发中，文件上传和下载功能是非常常用的功能，&lt;/p&gt;
&lt;p&gt;​    对于文件上传，浏览器在上传的过程中是&lt;strong&gt;将文件以流的形式提交到服务器端&lt;/strong&gt;的，如果直接使用Servlet获取上传文件的输入流然后再解析里面的请求参数是比较麻烦&lt;/p&gt;
&lt;p&gt;​    一般选择采用apache的开源工具common-fileupload这个文件上传组件&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---Session</title>
    <link href="http://yoursite.com/2019/03/26/JavaWeb---Session/"/>
    <id>http://yoursite.com/2019/03/26/JavaWeb---Session/</id>
    <published>2019-03-26T13:38:55.000Z</published>
    <updated>2019-04-04T11:30:34.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-Session-概述"><a href="#一-Session-概述" class="headerlink" title="一. Session 概述"></a>一. Session 概述</h1><h2 id="1-1-简单介绍"><a href="#1-1-简单介绍" class="headerlink" title="1.1 简单介绍"></a>1.1 简单介绍</h2><p>　　在WEB开发中，服务器可以为每个用户浏览器创建<strong>一个会话对象（session对象）</strong>，注意：<strong>一个浏览器</strong>独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，<strong>当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务</strong>。</p><h2 id="2-2-Session和Cookie的主要区别"><a href="#2-2-Session和Cookie的主要区别" class="headerlink" title="2.2 Session和Cookie的主要区别"></a>2.2 Session和Cookie的主要区别</h2><ul><li>Cookie数据存储在客户端的浏览器内存中或本地缓存文件中，Session数据存储在服务器端的内存中。</li><li>Cookie数据存储安全性较低，Session数据存储安全性较高。</li><li>Session数据存储在服务器端内存中，访问增多时，降低服务器端性能。而Cookie则不会对服务器端性能造成影响。</li><li>单个Cookie存储的数据最大是4KB，一个网站只能存储20个Cookie。Session则没有这个问题。</li><li>Session在关闭浏览器时失效，而持久Cookie则可以存储更长有效时间。</li><li>Session对象由服务器创建，开发人员可以调用request对象的getSession方法得到session对象。</li></ul><h1 id="二-Session入门"><a href="#二-Session入门" class="headerlink" title="二. Session入门"></a>二. <strong>Session入门</strong></h1><h2 id="2-1-Session常用API"><a href="#2-1-Session常用API" class="headerlink" title="2.1 Session常用API"></a>2.1 <strong>Session常用API</strong></h2><ul><li><strong><code>request.getSession()</code></strong> : 获得HttpSession对象</li><li><strong><code>session.setAttribute(String name, Object value)</code></strong> : 设置数据</li><li><strong><code>session.getAttribute(String name)</code></strong> : 获取共享数据</li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br><span class="line">session.setAttribute(<span class="string">"name"</span>, <span class="string">"longestory"</span>);</span><br><span class="line">String name = (String)session.getAttribute(<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure><h2 id="2-2-Servlet三大域对象"><a href="#2-2-Servlet三大域对象" class="headerlink" title="2.2 Servlet三大域对象"></a>2.2 Servlet三大域对象</h2><p>现在掌握了 <code>HttpSession</code> 对象的基本使用方法，到目前为止，Servlet的 <strong>三大域对象</strong> 都已经掌握。</p><ul><li><strong><code>HttpServletRequest</code></strong> : 一个请求创建一个request对象，所以在<strong>同一个请求中可以共享request</strong>，例如一个请求从 <code>AServlet</code> <strong>转发</strong>到 <code>BServlet</code>，那么 <code>AServlet</code> 和 <code>BServlet</code> 可以<strong>共享request域中的数据</strong></li><li><strong><code>ServletContext</code></strong> : 一个应用只创建一个 <code>ServletContext</code> 对象，所以在 <code>ServletContext</code> 中的数据可以<strong>在整个应用中共享</strong>，只要不启动服务器，那么 <code>ServletContext</code> 中的数据就可以共享</li><li><strong><code>HttpSession</code></strong> :  一个会话创建一个对象，<strong>同一会话</strong>中的多个请求中可以共享session中的数据。</li></ul><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3855702.html" target="_blank" rel="noopener">JavaWeb学习总结(十二)——Session</a></p><p>​    <a href="https://www.cnblogs.com/aaron911/p/7889353.html" target="_blank" rel="noopener">JavaWeb Session</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-Session-概述&quot;&gt;&lt;a href=&quot;#一-Session-概述&quot; class=&quot;headerlink&quot; title=&quot;一. Session 概述&quot;&gt;&lt;/a&gt;一. Session 概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-简单介绍&quot;&gt;&lt;a href=&quot;#1-1
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript---函数</title>
    <link href="http://yoursite.com/2019/03/26/JavaScript---%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/03/26/JavaScript---函数/</id>
    <published>2019-03-26T00:51:18.000Z</published>
    <updated>2019-03-27T09:20:34.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-定义"><a href="#一-定义" class="headerlink" title="一. 定义"></a>一. 定义</h1><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>function</td><td>关键字</td></tr><tr><td>print</td><td>函数名称</td></tr><tr><td>(message)</td><td>参数列表,参数为message</td></tr><tr><td>{</td><td>函数开始</td></tr><tr><td></td><td>返回结果</td></tr><tr><td>}</td><td>函数结束</td></tr></tbody></table><a id="more"></a><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"这一句话是由一个自定义函数打印"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> message + <span class="string">"!!!!"</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 光有函数的定义，还不够，它不会自动执行,需要调用--&gt;</span><br><span class="line">print();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-定义&quot;&gt;&lt;a href=&quot;#一-定义&quot; class=&quot;headerlink&quot; title=&quot;一. 定义&quot;&gt;&lt;/a&gt;一. 定义&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;function&lt;/td&gt;
&lt;td&gt;关键字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;print&lt;/td&gt;
&lt;td&gt;函数名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(message)&lt;/td&gt;
&lt;td&gt;参数列表,参数为message&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;{&lt;/td&gt;
&lt;td&gt;函数开始&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;返回结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;}&lt;/td&gt;
&lt;td&gt;函数结束&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---流</title>
    <link href="http://yoursite.com/2019/03/25/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%B5%81/"/>
    <id>http://yoursite.com/2019/03/25/Java基础知识---流/</id>
    <published>2019-03-25T12:53:27.000Z</published>
    <updated>2019-03-31T02:55:29.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-流式输入-输出原理"><a href="#一-流式输入-输出原理" class="headerlink" title="一. 流式输入/输出原理"></a>一. 流式输入/输出原理</h1><h3 id="1-流是用来-读写-数据的"><a href="#1-流是用来-读写-数据的" class="headerlink" title="1) 流是用来==读写==数据的"></a>1) 流是用来==读写==数据的</h3><p>​    Java有一个类叫File，它封装的是文件的文件名，<strong>只是内存里面的一个对象</strong>，真正的文件是在硬盘上的一块空间，在这个文件里面存放着各种各样的数据.</p><a id="more"></a><h3 id="2-如何读文件里面的数据？"><a href="#2-如何读文件里面的数据？" class="headerlink" title="2) 如何读文件里面的数据？"></a>2) 如何读文件里面的数据？</h3><p>​    <strong>通过流的方式来读</strong></p><p>​    咱们要想从程序读数据，对于计算机来说，无论读什么类型的数据都是以010101101010这样的形式读取的。可以把<strong>文件想象成一个桶</strong>，文件里面的数据就相当于是这个桶里面的水</p><blockquote><h5 id="怎么从这个桶里面取水-怎么从这个文件读取数据"><a href="#怎么从这个桶里面取水-怎么从这个文件读取数据" class="headerlink" title="怎么从这个桶里面取水 (怎么从这个文件读取数据)"></a>怎么从这个桶里面取水 (怎么从这个文件读取数据)</h5><p> <strong>取水办法</strong> : 用一根管道插到桶上面，然后在管道的另一边打开水龙头，桶里面的水就开始哗啦哗啦地从水龙头里流出来了，桶里面的水是通过这根管道流出来的，<strong>因此这根管道就叫流</strong></p></blockquote><ol><li><p>JAVA里面的 <strong>流式输入/输出</strong> 跟水流的原理一模一样，当你要从文件读取数据的时候，一根管道插到文件里面去，然后文件里面的数据就顺着管道流出来，这时你在管道的另一头就可以读取到从文件流出来的各种各样的数据了。当你要往文件写入数据时，也是通过一根管道，让要写入的数据通过这根管道哗啦哗啦地流进文件里面去。</p></li><li><p>除了从文件去取数据以外，还可以<strong>通过网络</strong>，比如用一根管道把我和你的机子连接起来，我说一句话，通过这个管道流进你的机子里面，你马上就可以看得到，而你说一句话，通过这根管道流到我的机子里面，我也马上就可以看到。</p></li><li><p>有的时候，一根管道不够用，比方说这根管道流过来的水有一些杂质，我们就可以在这个根管道的外面再包一层管道，把杂质给过滤掉。从程序的角度来讲，从计算机读取到的原始数据肯定都是010101这种形式的，一个字节一个字节地往外读，当你这样读的时候你觉得这样的方法不合适，没关系，你再在<strong>这根管道的外面再包一层比较强大的管道</strong>，这个管道可以<strong>把010101帮你转换成字符串</strong>。这样你使用程序读取数据时读到的就不再是010101这种形式的数据了，而是一些可以看得懂的字符串了。</p></li></ol><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><table><thead><tr><th style="text-align:center">原始</th><th>类比成</th></tr></thead><tbody><tr><td style="text-align:center">文件</td><td>一个桶</td></tr><tr><td style="text-align:center">文件中的数据</td><td>桶中的水</td></tr><tr><td style="text-align:center">Java 流式输入/输出</td><td>接水的管道</td></tr><tr><td style="text-align:center">更强大的管道</td><td>过滤杂质</td></tr></tbody></table><h1 id="二-输入输出流分类"><a href="#二-输入输出流分类" class="headerlink" title="二. 输入输出流分类"></a>二. 输入输出流分类</h1><p>io包里面定义了所有的流，所以一说流指的就是 <strong>io 包</strong> 里面的</p><p>用一根管道一端<strong>插进文件里程序里面，然后开始读数据</strong>，那么这是输入还是输出呢？</p><ul><li>在文件的角度上，这叫输出</li><li>在程序的角度上，这叫输入</li></ul><h4 id="以后说输入流和输出流都是站在-程序-的角度上来说"><a href="#以后说输入流和输出流都是站在-程序-的角度上来说" class="headerlink" title="以后说输入流和输出流都是站在==程序==的角度上来说"></a>以后说输入流和输出流都是站在==程序==的角度上来说</h4><table><thead><tr><th></th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td><strong>输入流</strong></td><td><code>InputStream</code></td><td><code>Reader</code></td></tr><tr><td><strong>输出流</strong></td><td><code>OutputStream</code></td><td><code>Writer</code></td></tr></tbody></table><p>​    这4个类都是抽象类，可以把这4个类想象成4根不同的管道，一端接着你的程序，另一端接着数据源，你可以通过输出管道从数据源里面往外读数据，也可以通过输入管道网数据源里面输入数据，总之通过这4根管道可以让数据流进来和流出去. <strong>所有类型位于 java.io 内部都分别继承这4种抽象流类型</strong></p><h4 id="从不同的角度进行分类"><a href="#从不同的角度进行分类" class="headerlink" title="从不同的角度进行分类"></a>从不同的角度进行分类</h4><ul><li><p>按<strong>数据流的方向不同</strong>，可以分为输入流和输出流</p></li><li><p>按<strong>处理数据单位不同</strong>可以分为字节流和字符流</p><ul><li><strong>字符流</strong> : 一个字符, 一个字符的往外读数据，一个字符是两个字节</li></ul><ul><li><strong>字节流</strong> : 一个字节, 一个字节的往外读数据, 一个字节是八位</li></ul></li><li><p>按<strong>功能不同</strong>可以分为节点流和处理流</p></li></ul><h1 id="三-节点流和处理流"><a href="#三-节点流和处理流" class="headerlink" title="三. 节点流和处理流"></a>三. 节点流和处理流</h1><h2 id="3-1-节点流类型"><a href="#3-1-节点流类型" class="headerlink" title="3.1 节点流类型"></a>3.1 节点流类型</h2><table><thead><tr><th style="text-align:right">类型</th><th style="text-align:center">字符流</th><th style="text-align:center">字节流</th></tr></thead><tbody><tr><td style="text-align:right">File(文件)</td><td style="text-align:center">FileReader / FileWriter</td><td style="text-align:center">FileInputStream / FileOutputStream</td></tr><tr><td style="text-align:right">Memory Array</td><td style="text-align:center">CharArrayReader / CharArrayWriter</td><td style="text-align:center">ByteArrayInputStream / ByteArrayOutputStream</td></tr><tr><td style="text-align:right">Memory String</td><td style="text-align:center">StringReader / StringWriter</td><td style="text-align:center">—</td></tr><tr><td style="text-align:right">Pipe(管道)</td><td style="text-align:center">PipedReader / PipedWriter</td><td style="text-align:center">PipedInputStream / PipedOutputStream</td></tr></tbody></table><p>可以从一个特定的数据源 (节点) 读写数据 (如: 文件, 内存) </p><p>就像一根管道直接插到数据源上面，直接读数据源里面的数据，或者是直接往数据源里面写入数据。，这根管道就叫做节点流</p><p>典型的节点流是文件流：</p><ul><li>文件的字节输入流（FileInputStream），文件的字节输出流（FileOutputStream）</li><li>文件的字符输入流（FileReader），文件的字符输出流（FileWriter）</li></ul><h2 id="3-2-处理流类型"><a href="#3-2-处理流类型" class="headerlink" title="3.2 处理流类型"></a>3.2 处理流类型</h2><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p>处理流是包在别的流上面的流，相当于是包到别的管道上面的管道 (通过对数据的处理为程序提供更为强大的读写功能)</p><blockquote><p>为什么需要处理流呢？</p><p>这就跟水流里面有杂质，你要过滤它，你可以再套一层管道过滤这些杂质一样。</p></blockquote><h1 id="四-InputStream-输入流"><a href="#四-InputStream-输入流" class="headerlink" title="四. InputStream(输入流)"></a>四. InputStream(输入流)</h1><p>继承自 <code>inputStream</code> 的流都是用于向程序中<strong>输入数据且数据的单位为字节</strong></p><p>凡是以 <code>inputStream</code> 结尾的管道，都是<strong>以字节的形式</strong>向我们的程序输入数据</p><h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取一个字节并以整数的形式返回 (ASCII 0~255)</span></span><br><span class="line"><span class="comment">// 如果返回 -1 已到输入流的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 读取一个字节，并存到一个数组 buffer</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回实际读取的字节数，如果读取前已到输入流的末尾返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] buffer)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 跳过n个字节不读，返回实际跳过的字节数</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>read() 的方法是一个字节，一个字节的往外读，每读取一个字节就处理一个字节. </li><li>read(byte[] buffer) 方法读取数据时先把读取到的数据填满这个 byte[] 的buffer (buffer是内存里面一块缓冲区), 然后再处理数组里面的数据</li></ul><blockquote><p>这就跟我们取水一样，先用一个桶去接，等桶接满后再处理桶里面的水，如果是每读取一个字节就处理一个字，这样读取也太累了</p></blockquote><h1 id="五-OutputStream-输出流"><a href="#五-OutputStream-输出流" class="headerlink" title="五. OutputStream(输出流)"></a>五. OutputStream(输出流)</h1><p>继承自<code>outputStream</code> 的流是用于程序中输入数据, 且数据的单位为字节(8 bit)</p><h4 id="基本方法-1"><a href="#基本方法-1" class="headerlink" title="基本方法"></a>基本方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将输出流中写入一个字节的数据，该字节数据为参数b的低8位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 将一个字节类型的数据中的数据写入输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] buffer)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 将一个字节类型的数组中的从指定位置(off)开始</span></span></span><br><span class="line"><span class="function"><span class="comment">// len 个字节写入到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 将输出流中缓冲区的数据全部写出到目的地</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><h1 id="六-Reader流"><a href="#六-Reader流" class="headerlink" title="六. Reader流"></a>六. Reader流</h1><p>一个字符也就是两个字节，使用 Reader 流读取数据时都是两个字节，两个字节的往外读</p><blockquote><p>为什么还要有这种两个字节的读取方式呢？</p><p>因为有些字符是占两个字节的，如我们中文字符在Java里面就是占两个字节的，如果采用一个字节一个字节往外读的方式，那么读出来的就是半个汉子，这样Java是没有办法正确显示中文字符的所有必要存在这种留一个字符，一个字符的往外读，</p></blockquote><p>和 <code>inputStream</code> 一模一样，唯一的区别就是在于<strong>读的数据单位不同</strong></p><h4 id="基本方法-2"><a href="#基本方法-2" class="headerlink" title="基本方法"></a>基本方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取一个字节并以整数的形式返回(0~255)</span></span><br><span class="line"><span class="comment">// 如果返回 -1 已到输入流的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 读取一个字节，并存到一个数组 buffer</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回实际读取的字节数，如果读取前已到输入流的末尾返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 读取length个字符并存储到一个数组buffer</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从length位置开始,返回实际读取的字符数,如果读取前已到输入流的末尾返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 跳过n个字节不读，返回实际跳过的字节数</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><h1 id="七-Writer流"><a href="#七-Writer流" class="headerlink" title="七. Writer流"></a>七. Writer流</h1><p>继承自writer的流都是用于程序中输出数据, 且数据的单位为字符(16 bit)</p><h4 id="基本方法-3"><a href="#基本方法-3" class="headerlink" title="基本方法"></a>基本方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将输出流中写入一个字节的数据，该字节数据为参数b的低 16 位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 将一个字符类型的数据中的数据写入输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] buffer)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 将一个字符类型的数组中的从指定位置(offset)开始</span></span></span><br><span class="line"><span class="function"><span class="comment">// len 个字节写入到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 将输出流中缓冲区的数据全部写出到目的地</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><h1 id="八-节点流讲解"><a href="#八-节点流讲解" class="headerlink" title="八. 节点流讲解"></a>八. 节点流讲解</h1><p>　　以File(文件)这个类型作为讲解节点流的典型代表</p><h4 id="范例：使用-FileInputStream-流来读取文件的内容"><a href="#范例：使用-FileInputStream-流来读取文件的内容" class="headerlink" title="范例：使用 FileInputStream 流来读取文件的内容"></a>范例：使用 <code>FileInputStream</code> 流来读取文件的内容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileInputStream</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用变量b来装调用read()方法时返回的整数</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用FileInputStream流来读取有中文的内容时，读出来的是乱码</span></span><br><span class="line">        FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//使用FileReader流来读取内容时，中英文都可以正确显示</span></span><br><span class="line">        <span class="comment">// FileReader in = null;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> FileInputStream(<span class="string">"G:\\test.txt"</span>);</span><br><span class="line">            <span class="comment">// in = new FileReader("G:/test.txt");</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"系统找不到指定文件！"</span>);</span><br><span class="line">            System.exit(-<span class="number">1</span>); <span class="comment">// 系统非正常退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用变量num来记录读取到的字符数</span></span><br><span class="line">        <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用read()方法时会抛异常，所以需要捕获异常</span></span><br><span class="line">            <span class="comment">// 循环结束的条件就是返回一个值-1，表示此时已经读取到文件的末尾了</span></span><br><span class="line">            <span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果没有使用“(char)b”进行转换，那么直接打印出来的b就是数字，而不是英文和中文了</span></span><br><span class="line">                <span class="comment">// System.out.print(b+"  ");</span></span><br><span class="line">                <span class="comment">// “char(b)”把使用数字表示的汉字和英文字母转换成字符输入</span></span><br><span class="line">                System.out.print((<span class="keyword">char</span>) b);</span><br><span class="line">                </span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 关闭输入流</span></span><br><span class="line">            in.close();</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">"总共读取了"</span> + num + <span class="string">"个字节的文件"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">            System.out.println(<span class="string">"文件读取错误！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="comment">// 104  101  108  108  111  32  119  111  114  108  100  32  33  33</span></span><br><span class="line"><span class="comment">// hello world !!</span></span><br><span class="line"><span class="comment">// 总共读取了14个字节的文件</span></span><br></pre></td></tr></table></figure><h4 id="范例：使用-FileOutputStream-流往一个文件里面写入数据"><a href="#范例：使用-FileOutputStream-流往一个文件里面写入数据" class="headerlink" title="范例：使用 FileOutputStream 流往一个文件里面写入数据"></a>范例：使用 <code>FileOutputStream</code> 流往一个文件里面写入数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\Java\\MyEclipse 10\\Workspaces\\AnnotationTest\\src\\cn\\galc\\test\\MyMouseAdapter.java"</span>);</span><br><span class="line">            out = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:/java/TestFileOutputStream1.java"</span>);</span><br><span class="line">            <span class="comment">// 指明要写入数据的文件，如果指定的路径中不存在TestFileOutputStream1.java这样的文件，则系统会自动创建一个</span></span><br><span class="line">            <span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(b);</span><br><span class="line">                <span class="comment">// 调用write(int c)方法把读取到的字符全部写入到指定文件中去</span></span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"文件读取失败"</span>);</span><br><span class="line">            System.exit(-<span class="number">1</span>);<span class="comment">// 非正常退出</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">            System.out.println(<span class="string">"文件复制失败！"</span>);</span><br><span class="line">            System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out</span><br><span class="line">                .println(<span class="string">"TestFileInputStream.java文件里面的内容已经成功复制到文件TestFileOutStream1.java里面"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> <code>FileInputStream</code> 和 <code>FileOutputStream</code> 这两个流都是字节流，都是以一个字节为单位进行输入和输出的.所以对于占用2个字节存储空间的字符来说读取出来时就会<strong>显示成乱码</strong></p></blockquote><h4 id="范例：使用FileWriter（字符流）向指定文件中写入数据"><a href="#范例：使用FileWriter（字符流）向指定文件中写入数据" class="headerlink" title="范例：使用FileWriter（字符流）向指定文件中写入数据"></a>范例：使用FileWriter（字符流）向指定文件中写入数据</h4><p>有点问题,回头在补充</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="九-处理流讲解"><a href="#九-处理流讲解" class="headerlink" title="九. 处理流讲解"></a>九. 处理流讲解</h1><h3 id="9-1-第一种处理流——缓冲流-Buffering"><a href="#9-1-第一种处理流——缓冲流-Buffering" class="headerlink" title="9.1 第一种处理流——缓冲流(Buffering)"></a>9.1 第一种处理流——缓冲流(Buffering)</h3><p>缓冲流就要<strong>嵌套在相应的节点流上</strong>，对读写的数据提供了缓冲的功能，提高了读写的效率，同时增加了一些新的方法</p><p>J2SDK 提供了四种缓冲流，其常用的构造方法为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BufferReader(Reader in)</span><br><span class="line">BufferReader(Reader in, <span class="keyword">int</span> sz)  <span class="comment">// sz 为自定义缓存区的大小</span></span><br><span class="line">BufferReader(Writer out)</span><br><span class="line">BufferReader(Writer out, <span class="keyword">int</span> sz)</span><br><span class="line">BufferReader(InputStream in)</span><br><span class="line">BufferReader(InputStream in, <span class="keyword">int</span> size)</span><br><span class="line">BufferReader(OutputStream out)</span><br><span class="line">BufferReader(OutputStream out, <span class="keyword">int</span> size)</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><p>缓冲输入流支持其父类的Mark和reset方法</p></li><li><p>BufferedReader 提供流 readLine 方法用于读取一行字符串(以\r或\n分隔)</p></li><li><p>BufferedWriter提供了newLine用于写入一个行分隔符</p></li><li><p>对于输出的缓冲流写出的数据会先在内存中缓存, 使用 flush 方法将会使内存中的数据立刻写出</p></li></ul><p>​        带有缓冲区的，<strong>缓冲区(Buffer)就是内存里面的一小块区域</strong>，读写数据时都是先把数据放到这块缓冲区域里面，<strong>减少 <code>io</code> 对硬盘的访问次数，保护我们的硬盘</strong>。</p><p>​    可以把缓冲区想象成一个小桶，把要读写的数据想象成水，每次读取数据或者是写入数据之前，都是先把数据装到这个桶里面，装满了以后再做处理。这就是所谓的缓冲。先把数据放置到缓冲区上，等到缓冲区满了以后，再一次把缓冲区里面的数据写入到硬盘上或者读取出来，这样可以有效地减少对硬盘的访问次数，有利于保护我们的硬盘</p><h4 id="缓冲流读取"><a href="#缓冲流读取" class="headerlink" title="缓冲流读取"></a>缓冲流读取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBufferStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">"D:/java/TestFileInputStream.java"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 在FileInputStream节点流的外面套接一层处理流BufferedInputStream</span></span><br><span class="line">            BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) bis.read());</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) bis.read());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 在第100个字符处做一个标记</span></span><br><span class="line">            bis.mark(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span> &amp;&amp; (c = bis.read()) != -<span class="number">1</span>; i++) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) c);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="comment">// 重新回到原来标记的地方</span></span><br><span class="line">            bis.reset();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span> &amp;&amp; (c = bis.read()) != -<span class="number">1</span>; i++) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) c);</span><br><span class="line">            &#125;</span><br><span class="line">            bis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓冲流写入"><a href="#缓冲流写入" class="headerlink" title="缓冲流写入"></a>缓冲流写入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBufferStream1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 往文件 dat2.txt 写入数据的时候,直接从节点流FilterWriter写入觉得不好写，</span></span><br><span class="line"><span class="comment">             * 因此在节点流外部包了一层处理流 BufferedWriter，</span></span><br><span class="line"><span class="comment">             * 这样写入数据时是先通过处理流把数据写入到缓冲区(Buffer)里面，</span></span><br><span class="line"><span class="comment">             * 再通过节点流写入到文件 dat2.txt</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"G:\\dat.txt"</span>));</span><br><span class="line"><span class="comment">// 在节点流FileWriter的外面再套一层处理流BufferedWriter</span></span><br><span class="line">String s = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Math.random() 将会生成一系列介于0～1之间的随机数。</span></span><br><span class="line"><span class="comment">// static String valueOf(double d)</span></span><br><span class="line"><span class="comment">// 这个valueOf()方法的作用就是把一个double类型的数转换成字符串</span></span><br><span class="line">s = String.valueOf(Math.random());</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 *读出来的文件的内容是装在了s这个字符串变量里面了，</span></span><br><span class="line"><span class="comment">                 * 也就是存放在内存里面名字为s的那块区域里面，</span></span><br><span class="line"><span class="comment">                 * 即读取到的文件内容是纯处在内存里面的</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line"></span><br><span class="line">bw.write(s);<span class="comment">// 把随机数字符串写入到指定文件中</span></span><br><span class="line">bw.newLine();<span class="comment">// 调用newLine()方法使得每写入一个随机数就换行显示</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用flush()方法清空缓冲区</span></span><br><span class="line">bw.flush();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 读取这个文件里面的数据是通过节点流直接读取数据，是一个字符一个字符的读取，</span></span><br><span class="line"><span class="comment">             * 这样读取的效率太慢了，因此在节点流 FileReader 外部包了一层处理流 BufferedReader,</span></span><br><span class="line"><span class="comment">             * 先要把读取的数据通过 BufferedReader 处理流存放到内存的缓冲区里面，</span></span><br><span class="line"><span class="comment">             * 然后再使用方法 flush() 把缓冲区里面的数据立刻写出来，</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"G:\\dat.txt"</span>));</span><br><span class="line"><span class="comment">// 在节点流FileReader的外面再套一层处理流BufferedReader</span></span><br><span class="line"><span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 使用BufferedReader处理流里面提供String readLine()方法读取文件中的数据时是一行一行读取的</span></span><br><span class="line"><span class="comment">// 循环结束的条件就是使用readLine()方法读取数据返回的字符串为空值后则表示已经读取到文件的末尾了。</span></span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">bw.close();</span><br><span class="line">br.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    程序的输入指的是把从文件读取到的内容存储到为程序分配的内存区域里面去。</p><h2 id="9-2-转换流"><a href="#9-2-转换流" class="headerlink" title="9.2 转换流"></a>9.2 转换流</h2><ul><li><p><code>InputStreamReader</code>和 <code>OutputStreamWriter</code>用于字节数据到字符数据之间的转换</p></li><li><p><code>InputStreamReader</code> 需要和 <code>InputStream</code> “套接”</p></li><li><p><code>OutStreamWriter</code> 需要和 <code>OutputStream</code> “套接”</p><blockquote><p><code>InputStream isr = InputStreamReader(System.in, &quot;ISO8859_1&quot;)</code></p></blockquote></li></ul><p>转换流非常的有用，它可以把<strong>一个字节流转换成一个字符流</strong></p><p>转换流有两种，</p><ol><li><code>InputStreamReader</code> : 把 <code>InputStream</code> 转换成 Reader</li><li><code>OutputStreamWriter</code> : 把 <code>OutputStream</code> 转换成 Writer, 而且还可以写入字符串</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTransform1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用了转换流之后就可以字符串的形式写入文件里面，</span></span><br><span class="line">            <span class="comment">// 提高了写入的速度，也减少了对硬盘的访问次数</span></span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"G:\\char.txt"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把字符串写入到指定的文件中去</span></span><br><span class="line">osw.write(<span class="string">"My name is 小明."</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用getEncoding()方法取得当前系统的默认字符编码</span></span><br><span class="line">System.out.println(osw.getEncoding());</span><br><span class="line">osw.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里如果不写true，那么前面的数据将会被后面写入的数据给替换掉，</span></span><br><span class="line">            <span class="comment">// 如果写了true,那么后面写出的数据就会跟在前面写入的数据后面不会替换掉前面写入的数据</span></span><br><span class="line"><span class="comment">// 在调用构造方法时指定了字符的编码</span></span><br><span class="line">osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"G:\\char.txt"</span>, <span class="keyword">true</span>), <span class="string">"ISO8859_1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次向指定的文件写入字符串，新写入的字符串加入到原来字符串的后面</span></span><br><span class="line">osw.write(<span class="string">"My name is 小明."</span>);</span><br><span class="line">System.out.println(osw.getEncoding());</span><br><span class="line">osw.close();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// char.txt 里面的内容</span></span><br><span class="line"><span class="comment">// My name is 小明.My name is ??.</span></span><br></pre></td></tr></table></figure><h4 id="范例2-接受键盘输入的数据"><a href="#范例2-接受键盘输入的数据" class="headerlink" title="范例2(接受键盘输入的数据)"></a>范例2(接受键盘输入的数据)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTransform2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// System.in这里的in是一个标准的输入流，用来接收从键盘输入的数据</span></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line"></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">String s = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用readLine()方法把读取到的一行字符串保存到字符串变量s中去</span></span><br><span class="line">s = br.readLine();</span><br><span class="line"><span class="keyword">while</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(s.toUpperCase());</span><br><span class="line"><span class="comment">// 在循环体内继续接收从键盘的输入</span></span><br><span class="line">s = br.readLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要输入exit循环就结束，就会退出</span></span><br><span class="line"><span class="keyword">if</span> (s.equalsIgnoreCase(<span class="string">"exit"</span>)) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-数据流"><a href="#9-3-数据流" class="headerlink" title="9.3 数据流"></a>9.3 数据流</h3><h3 id="9-4-打印流—Print"><a href="#9-4-打印流—Print" class="headerlink" title="9.4 打印流—Print"></a>9.4 打印流—Print</h3><h3 id="9-5-对象流—Object"><a href="#9-5-对象流—Object" class="headerlink" title="9.5 对象流—Object"></a>9.5 对象流—Object</h3><h1 id="十-IO流总结"><a href="#十-IO流总结" class="headerlink" title="十. IO流总结"></a>十. IO流总结</h1><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3634409.html" target="_blank" rel="noopener">java基础学习总结——流</a></p><p>​    <a href="https://www.cnblogs.com/fysola/p/6123947.html" target="_blank" rel="noopener">JAVA基础知识之IO——Java IO体系及常用类</a></p><p>​    <a href="https://www.cnblogs.com/biehongli/p/6074713.html" target="_blank" rel="noopener">Java中IO流，输入输出流概述与总结</a></p><p>​    <a href="https://blog.csdn.net/yczz/article/details/38761237" target="_blank" rel="noopener">Java IO最详解</a></p><p>​    <a href="https://blog.csdn.net/hguisu/article/details/7418161" target="_blank" rel="noopener">Java输入输出流</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-流式输入-输出原理&quot;&gt;&lt;a href=&quot;#一-流式输入-输出原理&quot; class=&quot;headerlink&quot; title=&quot;一. 流式输入/输出原理&quot;&gt;&lt;/a&gt;一. 流式输入/输出原理&lt;/h1&gt;&lt;h3 id=&quot;1-流是用来-读写-数据的&quot;&gt;&lt;a href=&quot;#1-流是用来-读写-数据的&quot; class=&quot;headerlink&quot; title=&quot;1) 流是用来==读写==数据的&quot;&gt;&lt;/a&gt;1) 流是用来==读写==数据的&lt;/h3&gt;&lt;p&gt;​    Java有一个类叫File，它封装的是文件的文件名，&lt;strong&gt;只是内存里面的一个对象&lt;/strong&gt;，真正的文件是在硬盘上的一块空间，在这个文件里面存放着各种各样的数据.&lt;/p&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>HTML---input属性</title>
    <link href="http://yoursite.com/2019/03/25/HTML---input%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2019/03/25/HTML---input属性/</id>
    <published>2019-03-25T12:51:18.000Z</published>
    <updated>2019-04-04T02:18:19.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-input-属性"><a href="#一-input-属性" class="headerlink" title="一. input 属性"></a>一. input 属性</h1><ul><li><strong>name</strong> : 元素的名称；这个不需要多解释了，也就是name的取值代表为当前input元素起个名字</li><li><strong>width</strong> : 当 input type=”image”时，通过width属性控制元素的宽度；</li><li><p><strong>height</strong> : 当 input type=”image”时，通过width属性控制元素的高度；</p></li><li><p><strong>type</strong> : 该属性是input标签里唯一的必须输入的属性，默认为type = “text”</p></li></ul><a id="more"></a><ul><li><p><strong>size</strong> : 元素的宽度；很多人都知道在HTML中，常见的宽度是用 width 表示的，而在input中 width 属性只使用与 <code>type=&quot;image&quot;</code> 时使用，input元素的宽度需要通过size属性来设定，size的值为 <strong>数字</strong></p></li><li><p><strong>step</strong> : 和max min类似，作用是提供一个可以上下点的按钮，比如当前数字是1，你设置了step = “5”，点一下上的按钮，就变成6了。</p></li><li><strong>placeholder</strong> : 一般是用来提示用户输入的，当用户真的输入了文字之后，会被输入的文字覆盖。</li><li><strong>readonly</strong> : 顾名思义，该属性会让表单空控件不可编辑。这里的不可编辑不是禁用，只是不能编辑文本而已，比如像单选框radio，复选框checkbox这种，本来就是不可编辑的，所以这个属性对它们来说毫无意义</li><li><strong>disabled</strong> : 该属性会禁用一个表单元素。这里是禁用，完全禁用掉除了 <code>&lt;output&gt;</code> 之外的所有表单元素</li><li><strong>maxlength</strong> : 该属性用于限制用户输入的最大字数限制。</li><li><strong>autocomplete</strong> : 顾名思义，自动完成，用户输入一部分，后面的自动补全。需要浏览器保存用户输入的内容，以便下一次自动补全。</li><li><strong>autofocus</strong> : 该属性指的是表示这个表单控件在页面载入的时候自动获得焦点。</li></ul><h1 id="二-input中的type属性"><a href="#二-input中的type属性" class="headerlink" title="二. input中的type属性"></a>二. input中的type属性</h1><p><strong><code>&lt;input type=&quot;text&quot;&gt;</code></strong> : 如果一个input没有type属性，那么它会是默认type=”text”。允许输入文本<br><strong><code>&lt;input type=&quot;password&quot;&gt;</code></strong>  : 用户输入的文字将会变成 <strong>*</strong> ,传给后台会是用户输入的文本。<br><strong><code>&lt;input type=&quot;checkbox&quot;&gt;</code></strong> : 复选框，默认是小方格，可以选择多个。<br><strong><code>&lt;input type=&quot;radio&quot;&gt;</code></strong> : 单选框，默认是小圆圈，只能选择一个。</p><p><strong><code>&lt;input type=&quot;submit&quot;&gt;</code></strong>：提交按钮，当点击此按钮时，提交本表单的数据。<br><strong><code>&lt;input type=&quot;file&quot;&gt;</code></strong>：用于从本地硬盘中上传文件并提交</p><blockquote><h5 id="input的file类型的accept属性的值"><a href="#input的file类型的accept属性的值" class="headerlink" title="input的file类型的accept属性的值"></a>input的file类型的accept属性的值</h5><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>audio/*</td><td>接受所有的声音文件。</td></tr><tr><td>video/*</td><td>接受所有的视频文件。</td></tr><tr><td>image/*</td><td>接受所有的图像文件。</td></tr><tr><td><em>MIME_type</em></td><td>一个有效的 MIME 类型，不带参数</td></tr></tbody></table></blockquote><p><strong><code>&lt;input type=&quot;hidden&quot;&gt;</code></strong> : 隐藏域在页面上不显示，用来存储与传递表单的值，当用户提交表单时，隐藏域的内容会一起提交给处理程序<br><strong><code>&lt;input type=&quot;image&quot;&gt;</code></strong> :  图像按钮, 该属性接受所有<img>，将会像submit一样提交图片，如果想上传图片，照片，不妨使用这个属性。<br><strong><code>&lt;input type=&quot;reset&quot;&gt;</code></strong> ：重置按钮，点了这个按钮，表单的数据全部重置，也就是清空的意思<br><strong><code>&lt;input type=&quot;button&quot;&gt;</code></strong> ：表单按钮，和单纯的<button>元素相比，没有<code>&lt;button&gt;</code>使用CSS方便，所以如果你不是想用这个按钮去重置（reset）或者提交（submit），并且为了和传统的表单风格相比配的话，建议你都使用</button><button>而不是 </button><input type="button"></p><p>以上的都是HTML5以前都有的属性，下面是新增的（跟键盘有关的都是要配合手机端使用才有效果）：</p><p><strong><code></code></strong> <input type="email">：该属性外观上和文本栏相似，用于指定一个电子邮箱地址。在web端没有什么差别，但是在手机端就不一样了，输入键盘会自动的变成有@ 数字 A-Z .等，与输入邮箱有关的字符，用户体验直线上升，有木有？<br><strong><code></code></strong> <input type="url">：外观功能和 <input type="email">类似，用于指定一个web地址。在手机端上会自动转换成有类似于.com \等方便用户输入web地址的键盘。<br><strong><code></code></strong> <input type="tel">：用于指定输入的是电话号码。键盘就会变成输入电话号码的键盘。当然，也可以自己定义一些格式什么的，比如023-1235····之类的，需要与pattern属性连用。<br><strong><code></code></strong> <input type="number">：用于指定输入的是数字，键盘为输入数字的键盘。<br><strong><code></code></strong> <input type="range">：变成一个滑动条，不同的客户端显示出默认的样式是不一样的。用户可以左右滑动。webkit中可以使用CSS：input[type=range]{=webkit-appearance:slider-vertical}让滑动条竖起来。<br><strong><code></code></strong> <input type="search">：提供一个搜索栏。如果有文本输入的话，很多浏览器会在最右边提供一个清空搜索栏的小叉，点了就清空该搜索栏。</p><p><input type="color">：在浏览器支持的情况下，提供一个拾色器，虽然功能没有PS里面的那么强大，不过感觉和window自带的图画功能里面的拾色器差不多。</p><p><input type="date">：顾名思义，日期选择器，可以用来选择年月日。</p><p><input type="datetime">：该属性提供两个栏，一个年月日，一个用于时分秒。时区被设置成了UTC。</p><p><input type="datetime-local">：和 <input type="datetime">几乎完全一样，只是不是UTC时间。</p><p><input type="month">：只包括了年，月的时间选择器。</p><p><input type="time">：只包括了时分秒的时间选择器，而且是24小时制。</p><p><input type="week">：该属性是输入多少年的多少周，你可以选择日期，但是返回的是XXXX年XX周。</p><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://blog.csdn.net/chao430/article/details/64904798" target="_blank" rel="noopener">input标签 各属性解释</a></p><p>​    <a href="https://blog.csdn.net/playboyanta123/article/details/77084810" target="_blank" rel="noopener">html5的input类型和所有属性详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-input-属性&quot;&gt;&lt;a href=&quot;#一-input-属性&quot; class=&quot;headerlink&quot; title=&quot;一. input 属性&quot;&gt;&lt;/a&gt;一. input 属性&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;name&lt;/strong&gt; : 元素的名称；这个不需要多解释了，也就是name的取值代表为当前input元素起个名字&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;width&lt;/strong&gt; : 当 input type=”image”时，通过width属性控制元素的宽度；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;height&lt;/strong&gt; : 当 input type=”image”时，通过width属性控制元素的高度；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;type&lt;/strong&gt; : 该属性是input标签里唯一的必须输入的属性，默认为type = “text”&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="HTML" scheme="http://yoursite.com/categories/HTML/"/>
    
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Java常用类---基本类型之间的转换</title>
    <link href="http://yoursite.com/2019/03/25/Java%E5%B8%B8%E7%94%A8%E7%B1%BB---%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2019/03/25/Java常用类---基本类型之间的转换/</id>
    <published>2019-03-25T03:26:27.000Z</published>
    <updated>2019-03-25T06:23:28.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-装箱与拆箱"><a href="#一-装箱与拆箱" class="headerlink" title="一. 装箱与拆箱"></a>一. 装箱与拆箱</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>​    虽然 Java 语言是典型的面向对象编程语言，但其中的八种基本数据类型并不支持面向对象编程，<strong>基本类型的数据不具备“对象”的特性——不携带属性、没有方法可调用</strong>。 沿用它们只是为了迎合人类根深蒂固的习惯，并的确能简单、有效地进行常规数据处理。</p><a id="more"></a><p>这种借助于<strong>非面向对象技术的做法有时也会带来不便</strong>，比如引用类型数据均继承了 Object 类的特性，要转换为 String 类型（经常有这种需要）时只要简单调用 Object  类中定义的 <code>toString()</code></p><p> 即可，而基本数据类型转换为 String 类型则要麻烦得多。为解决此类问题  ，Java为每种基本数据类型分别设计了对应的类，称之为包装类(Wrapper Classes)</p><h2 id="1-2-基本数据类型及对应的包装类"><a href="#1-2-基本数据类型及对应的包装类" class="headerlink" title="1.2 基本数据类型及对应的包装类"></a>1.2 基本数据类型及对应的包装类</h2><table><thead><tr><th style="text-align:center">基本数据类型</th><th style="text-align:left">对应的包装类</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:left">Byte</td></tr><tr><td style="text-align:center">short</td><td style="text-align:left">Short</td></tr><tr><td style="text-align:center">int</td><td style="text-align:left">Integer</td></tr><tr><td style="text-align:center">long</td><td style="text-align:left">Long</td></tr><tr><td style="text-align:center">char</td><td style="text-align:left">Character</td></tr><tr><td style="text-align:center">float</td><td style="text-align:left">Float</td></tr><tr><td style="text-align:center">double</td><td style="text-align:left">Double</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:left">Boolean</td></tr></tbody></table><p>每个包装类的对象可以封装一个相应的基本类型的数据，并提供了其它一些有用的方法。包装类对象一经创建，<strong>其内容（所封装的基本类型数据值）不可改变</strong>。</p><h4 id="基本类型和对应的包装类可以相互装换"><a href="#基本类型和对应的包装类可以相互装换" class="headerlink" title="基本类型和对应的包装类可以相互装换"></a>基本类型和对应的包装类可以相互装换</h4><ul><li>由基本类型向对应的包装类转换称为<strong>装箱</strong>，例如把 int 包装成 Integer 类的对象；</li><li>包装类向对应的基本类型转换称为<strong>拆箱</strong>，例如把 Integer 类的对象重新简化为 int</li></ul><h2 id="1-3-自动拆箱和装箱"><a href="#1-3-自动拆箱和装箱" class="headerlink" title="1.3 自动拆箱和装箱"></a>1.3 自动拆箱和装箱</h2><p>在进行基本数据类型和对应的包装类转换时，系统将自动进行，这将大大方便程序员的代码书写。</p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main www.120xh.cn (String[] args) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">500</span>;</span><br><span class="line">        Integer obj = m; <span class="comment">// 自动装箱</span></span><br><span class="line">        <span class="keyword">int</span> n = obj; <span class="comment">// 自动拆箱</span></span><br><span class="line">        System.out.println(<span class="string">"n = "</span> + n);</span><br><span class="line">        Integer obj1 = <span class="number">500</span>;</span><br><span class="line">        System.out.println(<span class="string">"obj 等价于 obj1？"</span> + obj.equals(obj1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// n = 500</span></span><br><span class="line"><span class="comment">// obj 等价于 obj1？true</span></span><br></pre></td></tr></table></figure><h1 id="二-基本类型之间的转换"><a href="#二-基本类型之间的转换" class="headerlink" title="二. 基本类型之间的转换"></a>二. 基本类型之间的转换</h1><h2 id="1-将字符串转化为整型"><a href="#1-将字符串转化为整型" class="headerlink" title="1. 将字符串转化为整型"></a>1. 将字符串转化为整型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = Integer.parseInt(String str);</span><br><span class="line"><span class="keyword">int</span> i = Integer.valueOf(String str).intValue();</span><br></pre></td></tr></table></figure><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ol><li><p><code>Integer.parseInt</code> 和 <code>Integer.valueOf</code> 不同，前者生成的是整型，而后者是一个对象，所以要通过intValue()来获得对象的值；</p></li><li><p>字串转成 Double, Float, Long 的方法大同小异</p></li></ol><h2 id="2-整型转化为字符串"><a href="#2-整型转化为字符串" class="headerlink" title="2. 整型转化为字符串"></a>2. 整型转化为字符串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = String.valueOf(<span class="keyword">int</span> i);</span><br><span class="line">String str = Integer.toString(<span class="keyword">int</span> i);</span><br><span class="line">String str = “” + i ;</span><br></pre></td></tr></table></figure><p> <strong>注意</strong> : Double, Float, Long 的方法大同小异.</p><h2 id="3-Long-转化为-date"><a href="#3-Long-转化为-date" class="headerlink" title="3. Long 转化为 date"></a>3. Long 转化为 date</h2><p> SimpleDateFormat sf = new SimpleDateFormat(“yyyy/MM/dd HH:mm:ss”);</p><p> //tieml,timef是long,前面转化过来的</p><p> Date date = new Date(timel - timef);</p><p> String time = sf.parse(date);</p><p> <strong>1、float型转换为double型：</strong></p><p> float f1=100.00f;</p><p> Float F1=new Float(f1);</p><p> //F1.doubleValue()为Float类的返回double值型的方法</p><p> double d1=F1.doubleValue();</p><p> <strong>2、double型转换为int型：</strong></p><p> double d1=100.00;</p><p> Double D1=new Double(d1);</p><p> int i1=D1.intValue();</p><p> <strong>3、int型转换为double型：</strong></p><p> int i1=200;</p><p> double d1=i1;</p><p> (2). 字符串与其它数据类型的转换</p><p> 4、字符串与其它类型间的转换：</p><p> ⑴其它类型向字符串的转换</p><p> ①调用类的串转换方法:X.toString();</p><p> ②自动转换:X+“”;</p><p> ③使用String的方法:String.valueOf(X);</p><p> ⑵字符串作为值,向其它类型的转换</p><p> ①先转换成相应的封装器实例,再调用对应的方法转换成其它类型</p><p> 例如，字符中“32.1”转换double型的值的格式为:new Float(“32.1”).doubleValue()。</p><p> 也可以用:Double.valueOf(“32.1”).doubleValue()</p><p> ②静态parseXXX方法</p><p> String s = “1”;</p><p> byte b = Byte.parseByte( s );</p><p> short t = Short.parseShort( s );</p><p> int i = Integer.parseInt( s );</p><p> long l = Long.parseLong( s );</p><p> Float f = Float.parseFloat( s );</p><p> Double d = Double.parseDouble( s );</p><p> ③Character的getNumericValue(char ch)方法</p><p> 返回指定的 Unicode 字符表示的 <code>int</code> 值。</p><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://blog.csdn.net/qq_36850813/article/details/79769400" target="_blank" rel="noopener">java的常见类型转换</a></p><p>​    <a href="https://blog.csdn.net/ching_zhi/article/details/53673989" target="_blank" rel="noopener">JAVA数据类型转换大全</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-装箱与拆箱&quot;&gt;&lt;a href=&quot;#一-装箱与拆箱&quot; class=&quot;headerlink&quot; title=&quot;一. 装箱与拆箱&quot;&gt;&lt;/a&gt;一. 装箱与拆箱&lt;/h1&gt;&lt;h2 id=&quot;1-1-概述&quot;&gt;&lt;a href=&quot;#1-1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.1 概述&quot;&gt;&lt;/a&gt;1.1 概述&lt;/h2&gt;&lt;p&gt;​    虽然 Java 语言是典型的面向对象编程语言，但其中的八种基本数据类型并不支持面向对象编程，&lt;strong&gt;基本类型的数据不具备“对象”的特性——不携带属性、没有方法可调用&lt;/strong&gt;。 沿用它们只是为了迎合人类根深蒂固的习惯，并的确能简单、有效地进行常规数据处理。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java常用类" scheme="http://yoursite.com/tags/java%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---XML详解(1)</title>
    <link href="http://yoursite.com/2019/03/25/JavaWeb---XML%E8%AF%A6%E8%A7%A3(1)/"/>
    <id>http://yoursite.com/2019/03/25/JavaWeb---XML详解(1)/</id>
    <published>2019-03-25T00:26:27.000Z</published>
    <updated>2019-03-25T01:06:08.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-XML-概念"><a href="#一-XML-概念" class="headerlink" title="一. XML 概念"></a>一. XML 概念</h1><h2 id="1-1-什么是-XML"><a href="#1-1-什么是-XML" class="headerlink" title="1.1 什么是 XML ?"></a>1.1 什么是 XML ?</h2><p>​    XML是指可扩展标记语言(eXtensible Markup Language)，它是一种<strong>标记语言</strong>，很类似HTML。它被设计的宗旨是<strong>传输数据，而非显示数据</strong>。</p><p><strong>XML标签没有被预定义，需要用户自行定义标签。</strong> XML技术是W3C组织(World Wide Web Consortium万维网联盟)发布的，目前遵循的是W3C组织于2000年发布的XML1.0规范。 </p><a id="more"></a><h2 id="1-2-XML技术用于解决什么问题？"><a href="#1-2-XML技术用于解决什么问题？" class="headerlink" title="1.2 XML技术用于解决什么问题？"></a>1.2 XML技术用于解决什么问题？</h2><ol><li><p>XML语言出现的根本目的在于 <strong>描述树状图等关系的数据</strong></p></li><li><p>XML是一种<strong>通用的数据交换格式</strong></p></li><li><p><strong>在XML语言中，它允许用户自定义标签。</strong>一个标签用于描述一段数据；一个标签可分为开始标签和结束标签，在起始标签之间，又可以使用其它标签描述其它数据，以此来实现数据关系的描述。</p></li><li><p>XML中的数据<strong>必须通过软件程序来解析执行或显示</strong>，如IE；这样的解析程序称之为<em>Parser</em>(解析器)。</p></li></ol><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">中国</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">北京</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">海淀</span>&gt;</span><span class="tag">&lt;/<span class="name">海淀</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">丰台</span>&gt;</span><span class="tag">&lt;/<span class="name">丰台</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">北京</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">山东</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">济南</span>&gt;</span><span class="tag">&lt;/<span class="name">济南</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">青岛</span>&gt;</span><span class="tag">&lt;/<span class="name">青岛</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">山东</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">湖北</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">武汉</span>&gt;</span><span class="tag">&lt;/<span class="name">武汉</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">荆州</span>&gt;</span><span class="tag">&lt;/<span class="name">荆州</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">湖北</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">中国</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-3-XML常见应用："><a href="#1-3-XML常见应用：" class="headerlink" title="1.3 XML常见应用："></a>1.3 XML常见应用：</h2><p>XML技术除用于<strong>保存有关系的数据</strong>之外，它还经常用作<strong>软件配置文件</strong>，以描述程序模块之间的关系。(如后面将要学习到的Struts、Spring和Hibernate都是基于XML作为配置文件的)</p><p>在一个软件系统中，通过 XML 配置文件可以提高系统的灵活性。即程序的行为是通过XML文件来配置的，而不是硬编码。</p><p>数据交换：不同语言之间用来交换数据</p><p>小型数据库：用来当数据库存储数据</p><h1 id="二-XML-语法"><a href="#二-XML-语法" class="headerlink" title="二. XML 语法"></a>二. XML 语法</h1><p>一个XML文件分为如下几部分内容：</p><p>　　文档声明 元素 属性 注释 CDATA区 、特殊字符 处理指令（PI:Processing Instruction）</p><h2 id="1-1-文档声明"><a href="#1-1-文档声明" class="headerlink" title="1.1 文档声明"></a>1.1 文档声明</h2><p>​    在编写XML文档时，需要先使用文档声明来声明XML文档。且必须出现在文档的第一行。并且<strong>必须指定</strong></p><h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 最简单的语法: --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=“1.0”?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用encoding属性说明文档所使用的字符编码。保存在磁盘上的文件编码要与声明的编码一致 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=“1.0” encoding=“GB2312”?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用standalone属性说明文档是否独立，即是否依赖其他文档, yes不用引入外部的文件，no需要引入。（不常用） --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=“1.0” standalone=“yes”?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-2-元素"><a href="#1-2-元素" class="headerlink" title="1.2 元素"></a>1.2 元素</h2><h3 id="1-标签"><a href="#1-标签" class="headerlink" title="1) 标签"></a>1) 标签</h3><p>XML元素指XML文件中出现的标签。</p><ol><li><p>一个标签分为起始和结束标签(不能省略)。一个标签有如下几种书写形式：</p><ul><li><p>包含标签主体：<code>&lt;mytag&gt;some content&lt;/mytag&gt;</code></p></li><li><p>不含标签主体：<code>&lt;mytag/&gt;</code></p></li></ul></li><li><p>一个标签中可以嵌套若干子标签，但所有标签必须合理的嵌套，不允许有交叉嵌套。</p><p><code>&lt;mytag1&gt;&lt;mytag2&gt;&lt;/mytag1&gt;&lt;/mytag2&gt; WRONG！</code></p></li><li><p>一个XML文档必须有且仅有一个根标签，其他标签都是这个根标签的子标签或孙标签。</p></li></ol><h3 id="2-标签的空格、换行"><a href="#2-标签的空格、换行" class="headerlink" title="2) 标签的空格、换行"></a>2) 标签的空格、换行</h3><p>对于XML标签中出现的所有空格和换行，XML解析程序都会当作标签内容进行处理。例如：下面两段内容的意义是不一样的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">网址</span>&gt;</span>www.baidu.com<span class="tag">&lt;/<span class="name">网址</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第二个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">网址</span>&gt;</span></span><br><span class="line">    www.baidu.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">网址</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于在XML中，<strong>空格和换行都作为原始内容被处理</strong>，所以，在编写XML文件时，使用换行和缩进等方式来让原文件中的内容清晰可读的“良好”书写习惯可能要被迫改变</p><h3 id="3-命名规范"><a href="#3-命名规范" class="headerlink" title="3) 命名规范"></a>3) 命名规范</h3><p>一个XML元素可以包含字母、数字以及其它一些可见字符，但必须遵守下面的一些规范：</p><ol><li>区分大小写，例如，<p>和</p><p>是两个不同的标记。</p></li><li>不能以数字或“-” (中划线)开头。</li><li>不能以xml(或XML、或Xml 等)开头。</li><li>不能包含空格。</li><li>名称中间不能包含冒号（:）。</li></ol><h3 id="4-属性"><a href="#4-属性" class="headerlink" title="4) 属性"></a>4) 属性</h3><p>一个元素可以有多个属性，每个属性都有它自己的名称和取值</p><p>例如: <code>&lt;mytag name=“value” …/&gt;</code></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><p>属性值一定要用引号(单引号或双引号)引起来。</p></li><li><p>属性名称的命名规范与元素的命名规范相同</p></li><li><p>元素中的属性是不允许重复的</p></li><li><p>在XML技术中，标签属性所代表的信息也可以被改成用子元素的形式来描述，例如：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mytag</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">firstName</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lastName</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mytag</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-注释"><a href="#5-注释" class="headerlink" title="5) 注释"></a>5) 注释</h3><p>XML中的注释语法为：<code>&lt;!--这是注释--&gt;</code></p><p>注意：</p><ul><li><p>XML声明之前不能有注释</p></li><li><p>注释不能嵌套</p></li></ul><h3 id="6-转义字符"><a href="#6-转义字符" class="headerlink" title="6) 转义字符"></a>6) 转义字符</h3><table><thead><tr><th style="text-align:center">特殊字符</th><th style="text-align:center">代替字符</th></tr></thead><tbody><tr><td style="text-align:center">&amp;</td><td style="text-align:center"><code>&amp;amp;</code></td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center"><code>&amp;lt;</code></td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center"><code>&amp;gt;</code></td></tr><tr><td style="text-align:center">“</td><td style="text-align:center"><code>&amp;quot;</code></td></tr><tr><td style="text-align:center">‘</td><td style="text-align:center"><code>apos;</code></td></tr></tbody></table><h5 id="实体必须以符号”-amp-”开头，以符号”-”结尾"><a href="#实体必须以符号”-amp-”开头，以符号”-”结尾" class="headerlink" title="实体必须以符号”&amp;”开头，以符号”;”结尾"></a>实体必须以符号”&amp;”开头，以符号”;”结尾</h5><blockquote><p>只有”&lt;” 字符和”&amp;”字符对于XML来说是严格禁止使用的。剩下的都是合法的，为了减少出错，使用实体是一个好习惯。 </p></blockquote><h3 id="7-CDATA区"><a href="#7-CDATA区" class="headerlink" title="7) CDATA区"></a>7) CDATA区</h3><p>CDATA是Character Data的缩写</p><p><strong>作用 :</strong> 把标签当做普通文本内容；</p><p><strong>语法 :</strong> <code>&lt;![CDATA[内容]]&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;![CDATA[</span><br><span class="line">　　&lt;itcast&gt;www.itcast.cn&lt;/itcast&gt;</span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;itcast&gt;www.itcast.cn&lt;/itcast&gt;</code> 被当做普通文本而不是标签</p><h3 id="8-处理指令"><a href="#8-处理指令" class="headerlink" title="8) 处理指令"></a>8) 处理指令</h3><p>处理指令，简称 PI (Processing Instruction)。</p><p><strong>作用 :</strong> 用来指挥软件如何解析XML文档。</p><p><strong>语法 :</strong> 必须以“&lt;?”作为开头，以“?&gt;”作为结尾。 常用处理指令：</p><p>常用处理指令：　　</p><ol><li><p>XML声明：</p><p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312”?&gt;</code></p></li><li><p>xml-stylesheet指令： 作用：指示XML文档所使用的CSS样式XSL。</p><p><code>&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;some.css”?&gt;</code></p></li></ol><blockquote><h5 id="注：对中文命名的标签元素不起作用"><a href="#注：对中文命名的标签元素不起作用" class="headerlink" title="注：对中文命名的标签元素不起作用"></a>注：对中文命名的标签元素不起作用</h5></blockquote><h2 id="XML语法规则总结"><a href="#XML语法规则总结" class="headerlink" title="XML语法规则总结"></a>XML语法规则总结</h2><p>　　所有 XML 元素都须有关闭标签</p><p>　　XML 标签对大小写敏感 XML</p><p>　　必须正确地嵌套顺序</p><p>　　XML 文档必须有根元素(只有一个)</p><p>　　XML 的属性值须加引号</p><p>　　特殊字符必须转义 — CDATA</p><p>　　XML 中的空格、回车换行会解析时被保留</p><h2 id="三-XML-约束"><a href="#三-XML-约束" class="headerlink" title="三. XML 约束"></a>三. XML 约束</h2><p>略</p><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/McCa/p/5938736.html" target="_blank" rel="noopener">JavaWeb之XML详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-XML-概念&quot;&gt;&lt;a href=&quot;#一-XML-概念&quot; class=&quot;headerlink&quot; title=&quot;一. XML 概念&quot;&gt;&lt;/a&gt;一. XML 概念&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是-XML&quot;&gt;&lt;a href=&quot;#1-1-什么是-XML&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是 XML ?&quot;&gt;&lt;/a&gt;1.1 什么是 XML ?&lt;/h2&gt;&lt;p&gt;​    XML是指可扩展标记语言(eXtensible Markup Language)，它是一种&lt;strong&gt;标记语言&lt;/strong&gt;，很类似HTML。它被设计的宗旨是&lt;strong&gt;传输数据，而非显示数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XML标签没有被预定义，需要用户自行定义标签。&lt;/strong&gt; XML技术是W3C组织(World Wide Web Consortium万维网联盟)发布的，目前遵循的是W3C组织于2000年发布的XML1.0规范。 &lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
      <category term="XML" scheme="http://yoursite.com/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---XML详解(1)</title>
    <link href="http://yoursite.com/2019/03/25/JavaWeb---XML%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/03/25/JavaWeb---XML详解/</id>
    <published>2019-03-25T00:26:27.000Z</published>
    <updated>2019-03-25T02:52:50.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-XML-概念"><a href="#一-XML-概念" class="headerlink" title="一. XML 概念"></a>一. XML 概念</h1><h2 id="1-1-什么是-XML"><a href="#1-1-什么是-XML" class="headerlink" title="1.1 什么是 XML ?"></a>1.1 什么是 XML ?</h2><p>​    XML是指可扩展标记语言(eXtensible Markup Language)，它是一种<strong>标记语言</strong>，很类似HTML。它被设计的宗旨是<strong>传输数据，而非显示数据</strong>。</p><p><strong>XML标签没有被预定义，需要用户自行定义标签。</strong> XML技术是W3C组织(World Wide Web Consortium万维网联盟)发布的，目前遵循的是W3C组织于2000年发布的XML1.0规范。 </p><a id="more"></a><h2 id="1-2-XML技术用于解决什么问题？"><a href="#1-2-XML技术用于解决什么问题？" class="headerlink" title="1.2 XML技术用于解决什么问题？"></a>1.2 XML技术用于解决什么问题？</h2><ol><li><p>XML语言出现的根本目的在于 <strong>描述树状图等关系的数据</strong></p></li><li><p>XML是一种<strong>通用的数据交换格式</strong></p></li><li><p><strong>在XML语言中，它允许用户自定义标签。</strong>一个标签用于描述一段数据；一个标签可分为开始标签和结束标签，在起始标签之间，又可以使用其它标签描述其它数据，以此来实现数据关系的描述。</p></li><li><p>XML中的数据<strong>必须通过软件程序来解析执行或显示</strong>，如IE；这样的解析程序称之为<em>Parser</em>(解析器)。</p></li></ol><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">中国</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">北京</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">海淀</span>&gt;</span><span class="tag">&lt;/<span class="name">海淀</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">丰台</span>&gt;</span><span class="tag">&lt;/<span class="name">丰台</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">北京</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">山东</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">济南</span>&gt;</span><span class="tag">&lt;/<span class="name">济南</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">青岛</span>&gt;</span><span class="tag">&lt;/<span class="name">青岛</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">山东</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">湖北</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">武汉</span>&gt;</span><span class="tag">&lt;/<span class="name">武汉</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">荆州</span>&gt;</span><span class="tag">&lt;/<span class="name">荆州</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">湖北</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">中国</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-3-XML常见应用："><a href="#1-3-XML常见应用：" class="headerlink" title="1.3 XML常见应用："></a>1.3 XML常见应用：</h2><p>XML技术除用于<strong>保存有关系的数据</strong>之外，它还经常用作<strong>软件配置文件</strong>，以描述程序模块之间的关系。(如后面将要学习到的Struts、Spring和Hibernate都是基于XML作为配置文件的)</p><p>在一个软件系统中，通过 XML 配置文件可以提高系统的灵活性。即程序的行为是通过XML文件来配置的，而不是硬编码。</p><p>数据交换：不同语言之间用来交换数据</p><p>小型数据库：用来当数据库存储数据</p><h1 id="二-XML-语法"><a href="#二-XML-语法" class="headerlink" title="二. XML 语法"></a>二. XML 语法</h1><p>一个XML文件分为如下几部分内容：</p><p>　　文档声明 元素 属性 注释 CDATA区 、特殊字符 处理指令（PI:Processing Instruction）</p><h2 id="1-1-文档声明"><a href="#1-1-文档声明" class="headerlink" title="1.1 文档声明"></a>1.1 文档声明</h2><p>​    在编写XML文档时，需要先使用文档声明来声明XML文档。且必须出现在文档的第一行。并且<strong>必须指定</strong></p><h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 最简单的语法: --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=“1.0”?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用encoding属性说明文档所使用的字符编码。保存在磁盘上的文件编码要与声明的编码一致 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=“1.0” encoding=“GB2312”?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用standalone属性说明文档是否独立，即是否依赖其他文档, yes不用引入外部的文件，no需要引入。（不常用） --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=“1.0” standalone=“yes”?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-2-元素"><a href="#1-2-元素" class="headerlink" title="1.2 元素"></a>1.2 元素</h2><h3 id="1-标签"><a href="#1-标签" class="headerlink" title="1) 标签"></a>1) 标签</h3><p>XML元素指XML文件中出现的标签。</p><ol><li><p>一个标签分为起始和结束标签(不能省略)。一个标签有如下几种书写形式：</p><ul><li><p>包含标签主体：<code>&lt;mytag&gt;some content&lt;/mytag&gt;</code></p></li><li><p>不含标签主体：<code>&lt;mytag/&gt;</code></p></li></ul></li><li><p>一个标签中可以嵌套若干子标签，但所有标签必须合理的嵌套，不允许有交叉嵌套。</p><p><code>&lt;mytag1&gt;&lt;mytag2&gt;&lt;/mytag1&gt;&lt;/mytag2&gt; WRONG！</code></p></li><li><p>一个XML文档必须有且仅有一个根标签，其他标签都是这个根标签的子标签或孙标签。</p></li></ol><h3 id="2-标签的空格、换行"><a href="#2-标签的空格、换行" class="headerlink" title="2) 标签的空格、换行"></a>2) 标签的空格、换行</h3><p>对于XML标签中出现的所有空格和换行，XML解析程序都会当作标签内容进行处理。例如：下面两段内容的意义是不一样的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">网址</span>&gt;</span>www.baidu.com<span class="tag">&lt;/<span class="name">网址</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第二个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">网址</span>&gt;</span></span><br><span class="line">    www.baidu.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">网址</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于在XML中，<strong>空格和换行都作为原始内容被处理</strong>，所以，在编写XML文件时，使用换行和缩进等方式来让原文件中的内容清晰可读的“良好”书写习惯可能要被迫改变</p><h3 id="3-命名规范"><a href="#3-命名规范" class="headerlink" title="3) 命名规范"></a>3) 命名规范</h3><p>一个XML元素可以包含字母、数字以及其它一些可见字符，但必须遵守下面的一些规范：</p><ol><li>区分大小写，例如，<p>和</p><p>是两个不同的标记。</p></li><li>不能以数字或“-” (中划线)开头。</li><li>不能以xml(或XML、或Xml 等)开头。</li><li>不能包含空格。</li><li>名称中间不能包含冒号（:）。</li></ol><h3 id="4-属性"><a href="#4-属性" class="headerlink" title="4) 属性"></a>4) 属性</h3><p>一个元素可以有多个属性，每个属性都有它自己的名称和取值</p><p>例如: <code>&lt;mytag name=“value” …/&gt;</code></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><p>属性值一定要用引号(单引号或双引号)引起来。</p></li><li><p>属性名称的命名规范与元素的命名规范相同</p></li><li><p>元素中的属性是不允许重复的</p></li><li><p>在XML技术中，标签属性所代表的信息也可以被改成用子元素的形式来描述，例如：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mytag</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">firstName</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lastName</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mytag</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-注释"><a href="#5-注释" class="headerlink" title="5) 注释"></a>5) 注释</h3><p>XML中的注释语法为：<code>&lt;!--这是注释--&gt;</code></p><p>注意：</p><ul><li><p>XML声明之前不能有注释</p></li><li><p>注释不能嵌套</p></li></ul><h3 id="6-转义字符"><a href="#6-转义字符" class="headerlink" title="6) 转义字符"></a>6) 转义字符</h3><table><thead><tr><th style="text-align:center">特殊字符</th><th style="text-align:center">代替字符</th></tr></thead><tbody><tr><td style="text-align:center">&amp;</td><td style="text-align:center"><code>&amp;amp;</code></td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center"><code>&amp;lt;</code></td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center"><code>&amp;gt;</code></td></tr><tr><td style="text-align:center">“</td><td style="text-align:center"><code>&amp;quot;</code></td></tr><tr><td style="text-align:center">‘</td><td style="text-align:center"><code>apos;</code></td></tr></tbody></table><h5 id="实体必须以符号”-amp-”开头，以符号”-”结尾"><a href="#实体必须以符号”-amp-”开头，以符号”-”结尾" class="headerlink" title="实体必须以符号”&amp;”开头，以符号”;”结尾"></a>实体必须以符号”&amp;”开头，以符号”;”结尾</h5><blockquote><p>只有”&lt;” 字符和”&amp;”字符对于XML来说是严格禁止使用的。剩下的都是合法的，为了减少出错，使用实体是一个好习惯。 </p></blockquote><h3 id="7-CDATA区"><a href="#7-CDATA区" class="headerlink" title="7) CDATA区"></a>7) CDATA区</h3><p>CDATA是Character Data的缩写</p><p><strong>作用 :</strong> 把标签当做普通文本内容；</p><p><strong>语法 :</strong> <code>&lt;![CDATA[内容]]&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;![CDATA[</span><br><span class="line">　　&lt;itcast&gt;www.itcast.cn&lt;/itcast&gt;</span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;itcast&gt;www.itcast.cn&lt;/itcast&gt;</code> 被当做普通文本而不是标签</p><h3 id="8-处理指令"><a href="#8-处理指令" class="headerlink" title="8) 处理指令"></a>8) 处理指令</h3><p>处理指令，简称 PI (Processing Instruction)。</p><p><strong>作用 :</strong> 用来指挥软件如何解析XML文档。</p><p><strong>语法 :</strong> 必须以“&lt;?”作为开头，以“?&gt;”作为结尾。 常用处理指令：</p><p>常用处理指令：　　</p><ol><li><p>XML声明：</p><p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312”?&gt;</code></p></li><li><p>xml-stylesheet指令： 作用：指示XML文档所使用的CSS样式XSL。</p><p><code>&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;some.css”?&gt;</code></p></li></ol><blockquote><h5 id="注：对中文命名的标签元素不起作用"><a href="#注：对中文命名的标签元素不起作用" class="headerlink" title="注：对中文命名的标签元素不起作用"></a>注：对中文命名的标签元素不起作用</h5></blockquote><h2 id="XML语法规则总结"><a href="#XML语法规则总结" class="headerlink" title="XML语法规则总结"></a>XML语法规则总结</h2><p>　　所有 XML 元素都须有关闭标签</p><p>　　XML 标签对大小写敏感 XML</p><p>　　必须正确地嵌套顺序</p><p>　　XML 文档必须有根元素(只有一个)</p><p>　　XML 的属性值须加引号</p><p>　　特殊字符必须转义 — CDATA</p><p>　　XML 中的空格、回车换行会解析时被保留</p><h2 id="三-XML-约束"><a href="#三-XML-约束" class="headerlink" title="三. XML 约束"></a>三. XML 约束</h2><p>略</p><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/McCa/p/5938736.html" target="_blank" rel="noopener">JavaWeb之XML详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-XML-概念&quot;&gt;&lt;a href=&quot;#一-XML-概念&quot; class=&quot;headerlink&quot; title=&quot;一. XML 概念&quot;&gt;&lt;/a&gt;一. XML 概念&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是-XML&quot;&gt;&lt;a href=&quot;#1-1-什么是-XML&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是 XML ?&quot;&gt;&lt;/a&gt;1.1 什么是 XML ?&lt;/h2&gt;&lt;p&gt;​    XML是指可扩展标记语言(eXtensible Markup Language)，它是一种&lt;strong&gt;标记语言&lt;/strong&gt;，很类似HTML。它被设计的宗旨是&lt;strong&gt;传输数据，而非显示数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XML标签没有被预定义，需要用户自行定义标签。&lt;/strong&gt; XML技术是W3C组织(World Wide Web Consortium万维网联盟)发布的，目前遵循的是W3C组织于2000年发布的XML1.0规范。 &lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
      <category term="XML" scheme="http://yoursite.com/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---XML详解(2)</title>
    <link href="http://yoursite.com/2019/03/25/JavaWeb---XML%E8%AF%A6%E8%A7%A3(2)/"/>
    <id>http://yoursite.com/2019/03/25/JavaWeb---XML详解(2)/</id>
    <published>2019-03-25T00:26:27.000Z</published>
    <updated>2019-03-25T02:54:51.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-web-xml-的加载过程"><a href="#一-web-xml-的加载过程" class="headerlink" title="一. web.xml 的加载过程"></a>一. web.xml 的加载过程</h1><p>​    当启动一个WEB项目时，<strong>容器</strong>包括 (JBoss、Tomcat等) <strong>首先会读取项目web.xml配置文件里的配置</strong>，当这一步骤没有出错并且完成之后，项目才能正常地被启动起来</p><a id="more"></a><ol><li>启动WEB项目的时候，容器首先会去它的配置文件web.xml读取两个节点 :  <code>&lt;listener&gt;&lt;/listener&gt;</code> 和 <code>&lt;context-param&gt;&lt;/context-param&gt;</code></li><li>紧接着，容器创建一个<strong>ServletContext（Application）</strong>，这个WEB项目所有部分都将共享这个上下文。</li><li>容器以 <code>&lt;context-param&gt;&lt;/context-param&gt;</code> 的 name 作为键，value 作为值，将其转化为键值对，存入ServletContext</li><li>容器创建 <code>&lt;listener&gt;&lt;/listener&gt;</code> 中的类实例，根据配置的class类路径<listener-class>来创建监听，在监听中会有contextInitialized(ServletContextEvent args)初始化方法，启动Web应用时，系统调用Listener的该方法，在这个方法中获得：ServletContext application = ServletContextEvent.getServletContext(); context-param的值 = application.getInitParameter(“context-param的键”); 得到这个context-param的值之后，你就可以做一些操作了。</listener-class></li><li>举例：你可能想在项目启动之前就打开数据库，那么这里就可以在<context-param>中设置数据库的连接方式（驱动、url、user、password），在监听类中初始化数据库的连接。这个监听是自己写的一个类，除了初始化方法，它还有销毁方法，用于关闭应用前释放资源。比如:说数据库连接的关闭，此时，调用contextDestroyed(ServletContextEvent args)，关闭Web应用时，系统调用Listener的该方法。</context-param></li><li>接着，容器会读取<filter></filter>，根据指定的类路径来实例化过滤器。</li><li>以上都是在WEB项目还没有完全启动起来的时候就已经完成了的工作。如果系统中有Servlet，则Servlet是在第一次发起请求的时候被实例化的，而且一般不会被容器销毁，它可以服务于多个用户的请求。所以，Servlet的初始化都要比上面提到的那几个要迟。</li><li>总的来说，web.xml的加载顺序是:<context-param>-&gt;<listener>-&gt;<filter>-&gt;<servlet>。其中，如果web.xml中出现了相同的元素，则按照在配置文件中出现的先后顺序来加载。</servlet></filter></listener></context-param></li><li>对于某类元素而言，与它们出现的顺序是有关的。以<filter>为例，web.xml中当然可以定义多个<filter>，与<filter>相关的一个元素是<filter-mapping>，注意，对于拥有相同<filter-name>的<filter>和<filter-mapping>元素而言，<filter-mapping>必须出现在<filter>之后，否则当解析到<filter-mapping>时，它所对应的<filter-name>还未定义。web容器启动初始化每个<filter>时，按照<filter>出现的顺序来初始化的，当请求资源匹配多个<filter-mapping>时，<filter>拦截资源是按照<filter-mapping>元素出现的顺序来依次调用doFilter()方法的。<servlet>同<filter>类似，此处不再赘述。</filter></servlet></filter-mapping></filter></filter-mapping></filter></filter></filter-name></filter-mapping></filter></filter-mapping></filter-mapping></filter></filter-name></filter-mapping></filter></filter></filter></li></ol><h1 id="二-web-xml标签详解"><a href="#二-web-xml标签详解" class="headerlink" title="二. web.xml标签详解"></a>二. web.xml标签详解</h1><h2 id="2-1-XML文档有效性检查"><a href="#2-1-XML文档有效性检查" class="headerlink" title="2.1 XML文档有效性检查"></a>2.1 XML文档有效性检查</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE web-app PUBLIC"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN""http://java.sun.com/dtd/web-app_2_3.dtd" &gt;</span></span><br></pre></td></tr></table></figure><p>这段代码指定文件类型定义（DTD），可以通过它检查XML文档的有效性。下面显示的&lt;!DOCTYPE&gt;元素有几个特性，这些特性告诉我们关于DTD的信息： </p><ul><li>web-app定义该文档（部署描述符，不是DTD文件）的根元素 </li><li>PUBLIC意味着DTD文件可以被公开使用 </li><li>-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN”意味着DTD由Sun Microsystems, Inc.维护。该信息也表示它描述的文档类型是DTD Web Application 2.3，而且DTD是用英文书写的。 </li><li>URL “<code>http://java.sun.com/dtd/web-app_2_3.dtd</code>” 表示D文件的位置。</li></ul><h2 id="2-2-lt-web-app-gt-lt-web-app-gt"><a href="#2-2-lt-web-app-gt-lt-web-app-gt" class="headerlink" title="2.2 &lt;web-app&gt;&lt;/web-app&gt;"></a>2.2 <code>&lt;web-app&gt;&lt;/web-app&gt;</code></h2><p>部署描述符的根元素是 <code>&lt;web-app&gt;</code> ，DTD文件规定 <code>&lt;web-app&gt;</code> 元素的子元素的语法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">web-app</span> (<span class="attr">icon</span>?, <span class="attr">display-name</span>?, <span class="attr">description</span>?,<span class="attr">distributable</span>?, <span class="attr">context-param</span>*, <span class="attr">filter</span>*, <span class="attr">filter-mapping</span>*,<span class="attr">listener</span>*, <span class="attr">servlet</span>*, <span class="attr">servlet-mapping</span>*, <span class="attr">session-config</span>?,<span class="attr">mime-mapping</span>*, <span class="attr">welcome-file-list</span>?,<span class="attr">error-page</span>*, <span class="attr">taglib</span>*, <span class="attr">resource-env-ref</span>*, <span class="attr">resource-ref</span>*,<span class="attr">security-constraint</span>*, <span class="attr">login-config</span>?, <span class="attr">security-role</span>*,<span class="attr">env-entry</span>*,<span class="attr">ejb-ref</span>*, <span class="attr">ejb-local-ref</span>*)&gt;</span></span><br></pre></td></tr></table></figure><p>正如您所看到的，这个元素含有23个子元素，而且子元素都是可选的。问号（?）表示子元素是可选的，而且只能出现一次。星号（*）表示子元素可在部署描述符中出现零次或多次。有些子元素还可以有它们自己的子元素。web.xml文件中<web-app>元素声明的是下面每个子元素的声明。下面讲述部署描述符中可能包含的所有子元素。</web-app></p><p>注意：在Servlet 2.3中，子元素必须按照DTD文件语法描述中指定的顺序出现。比如：如果部署描述符中的<web-app>元素有<servlet>和<servlet-mapping>两个子元素，则<servlet>子元素必须出现在<servlet-mapping>子元素之前。在Servlet2.4中，顺序并不重要。</servlet-mapping></servlet></servlet-mapping></servlet></web-app></p><h2 id="3-lt-display-name-gt-lt-display-name-gt"><a href="#3-lt-display-name-gt-lt-display-name-gt" class="headerlink" title="3. &lt;display-name&gt;&lt;/display-name&gt;"></a>3. <code>&lt;display-name&gt;&lt;/display-name&gt;</code></h2><p><code>&lt;display-name&gt;test-hwp-web-application&lt;/display-name&gt;</code> 定义了web应用的名称，可以在 <code>&lt;http://localhost:8080/manager/html&gt;</code> 中显示</p><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://blog.csdn.net/believejava/article/details/43229361" target="_blank" rel="noopener">Web.xml详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-web-xml-的加载过程&quot;&gt;&lt;a href=&quot;#一-web-xml-的加载过程&quot; class=&quot;headerlink&quot; title=&quot;一. web.xml 的加载过程&quot;&gt;&lt;/a&gt;一. web.xml 的加载过程&lt;/h1&gt;&lt;p&gt;​    当启动一个WEB项目时，&lt;strong&gt;容器&lt;/strong&gt;包括 (JBoss、Tomcat等) &lt;strong&gt;首先会读取项目web.xml配置文件里的配置&lt;/strong&gt;，当这一步骤没有出错并且完成之后，项目才能正常地被启动起来&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
      <category term="XML" scheme="http://yoursite.com/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>街舞---popping</title>
    <link href="http://yoursite.com/2019/03/24/%E8%A1%97%E8%88%9E---popping/"/>
    <id>http://yoursite.com/2019/03/24/街舞---popping/</id>
    <published>2019-03-24T12:41:51.000Z</published>
    <updated>2019-03-28T15:04:33.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-popping由来"><a href="#一-popping由来" class="headerlink" title="一. popping由来"></a>一. popping由来</h1><p>​    比较为大众所知的是一个名叫 <strong>Boogaloo Sam</strong> 的人，在看到电视节目 Soul Train 上 locker 的表演后激发出来的，然后他在1977年建立了一个舞团, 叫做 The Electric boogaloos(EB舞团)<br><a id="more"></a></p><h2 id="1-1-EB舞团的成员"><a href="#1-1-EB舞团的成员" class="headerlink" title="1.1 EB舞团的成员"></a>1.1 EB舞团的成员</h2><table><thead><tr><th><strong>Popin Pete</strong></th><th><strong>Robot Dane</strong></th><th><strong>Boogaloo Sam</strong></th></tr></thead><tbody><tr><td><strong>Puppet Boozer</strong></td><td><strong>Creeping Sidney</strong></td><td><strong>Scarecrow Scalley</strong></td></tr><tr><td><strong>Skeeter Rabbit(中期加入)</strong></td><td><strong>Sugar Pop(后期加入)</strong></td><td><strong>Mr.Wigles(后期加入)</strong></td></tr></tbody></table><p>有趣的是即使在同一个舞团内,每个人对于popping的想法却都有差异</p><h4 id="Boogaloo-Sam"><a href="#Boogaloo-Sam" class="headerlink" title="Boogaloo Sam"></a>Boogaloo Sam</h4><p>popping 只是他的Boogaloo style里头14种style的其中一种，然后每一种都是由他自己受到启发，想出来的</p><blockquote><h4 id="14-种Style"><a href="#14-种Style" class="headerlink" title="14 种Style"></a>14 种Style</h4><table><thead><tr><th><strong>1. popping</strong></th><th><strong>8. Master Flex</strong></th></tr></thead><tbody><tr><td><strong>2. Secrecrow</strong></td><td><strong>9. Creeping</strong></td></tr><tr><td><strong>3. Puppet</strong></td><td><strong>10. Toy Man</strong></td></tr><tr><td><strong>4. Ticking</strong></td><td><strong>11. Backslide</strong></td></tr><tr><td><strong>5. Tidal Wave</strong></td><td><strong>12. Moon walk</strong></td></tr><tr><td><strong>6. Old Man</strong></td><td><strong>13. Romeo Twist</strong></td></tr><tr><td><strong>7. Twist O/ Neck O Flex</strong></td><td><strong>14. Egyptian Twisst</strong></td></tr></tbody></table></blockquote><h4 id="Pete"><a href="#Pete" class="headerlink" title="Pete"></a>Pete</h4><p>popping就是把肌肉瞬间收缩(pop), 对应到音乐之中，对他来说算是一种技术.就是一种 style , popping 就是dance + pop</p><h4 id="作者观点"><a href="#作者观点" class="headerlink" title="作者观点"></a>作者观点</h4><p>同意大多数其他团员的观点,毕竟像 tuttin 或者是 moon walk 等舞步早在 Sam 之前就已经存在，更重要的是在之后的 popping 发展中，已经不再只是14种舞步了(Tickin Deck/Twist O Flex Don/ Tickin Will)</p><h2 id="1-2-popping命名的由来"><a href="#1-2-popping命名的由来" class="headerlink" title="1.2 popping命名的由来"></a>1.2 popping命名的由来</h2><p>Sam在跳舞的时候每震(摇动)一次肌肉肌肉就说一次pop，所以popping这个名称就是这样来的(没有争议)</p><h2 id="1-3-G-Style"><a href="#1-3-G-Style" class="headerlink" title="1.3 G Style"></a>1.3 G Style</h2><p>舞者: greenteck(加拿大)、 babybang和spazm（挪威 ）、cocopops（很像是瑞典）、 poppin ten 、 gstyle australia, :john gt kite madoka</p><p>G Style:这个派别的出现，它并不是一种popping中的舞风，基本上它只是一个类似组织的派别，唯一比较能够确定的是G Style的舞者，喜欢用大量的waving 和 animation 等等比较细微控制的舞步，但也不是用animation和waving比较多的，就是G style 舞者，Slick dogg 算是创始人，而且他早在声称popping早在Sam之前就已经有了(认为Sam跳的不是popping),不能算是Boogaloo Sam 所发明的. 这也变成著名的 G Style 跟 Boogaloo style决赛斗争，其实原本他们是关系不错的，只是不知道为什么就突然吵起来</p><h1 id="二-popping的种类"><a href="#二-popping的种类" class="headerlink" title="二. popping的种类"></a>二. popping的种类</h1><p>现在来讲讲发展到近时所拥有的舞步种类</p><h2 id="2-1-pop-hit-震动"><a href="#2-1-pop-hit-震动" class="headerlink" title="2.1 pop/hit(震动)"></a>2.1 pop/hit(震动)</h2><h3 id="1-Fresno"><a href="#1-Fresno" class="headerlink" title="1) Fresno"></a>1) Fresno</h3><p>​    重心右移，右手平抬强震,重心左移,左手平抬强震，这是我们常常看见的 popping 基础</p><h3 id="2-Sac-Walk-空军踏步"><a href="#2-Sac-Walk-空军踏步" class="headerlink" title="2) Sac Walk(空军踏步)"></a>2) Sac Walk(空军踏步)</h3><p>​    左脚上前半步, 右脚后退半步，二步于一个拍子间同时完成,</p><h3 id="3-lift"><a href="#3-lift" class="headerlink" title="3) lift"></a>3) lift</h3><p>​    类似爬楼梯的动作，左右手呈90度一朝上朝下，然后重复</p><h2 id="2-2-wave-电流"><a href="#2-2-wave-电流" class="headerlink" title="2.2 wave 电流"></a>2.2 wave 电流</h2><h3 id="1-snake"><a href="#1-snake" class="headerlink" title="1) snake"></a>1) snake</h3><p>​    用胸部做转动 roll 的动作，若双手放置于前方，像蛇一般</p><h3 id="2-king-snake-snake的强化版"><a href="#2-king-snake-snake的强化版" class="headerlink" title="2) king snake (snake的强化版)"></a>2) king snake (snake的强化版)</h3><h3 id="3-October-章鱼"><a href="#3-October-章鱼" class="headerlink" title="3)October(章鱼)"></a>3)October(章鱼)</h3><p>​    从手开始带到全身的电流</p><h2 id="2-3-Slide-滑步"><a href="#2-3-Slide-滑步" class="headerlink" title="2.3 Slide 滑步"></a>2.3 Slide 滑步</h2><h3 id="1-向后滑"><a href="#1-向后滑" class="headerlink" title="1) 向后滑"></a>1) 向后滑</h3><h3 id="2-向侧边滑"><a href="#2-向侧边滑" class="headerlink" title="2) 向侧边滑"></a>2) 向侧边滑</h3><h3 id="3-原地滑"><a href="#3-原地滑" class="headerlink" title="3) 原地滑"></a>3) 原地滑</h3><h3 id="4-转圈圈的滑行方式-加上膝盖的滑行变成膝盖的滑步"><a href="#4-转圈圈的滑行方式-加上膝盖的滑行变成膝盖的滑步" class="headerlink" title="4) 转圈圈的滑行方式(加上膝盖的滑行变成膝盖的滑步)"></a>4) 转圈圈的滑行方式(加上膝盖的滑行变成膝盖的滑步)</h3><h2 id="2-4-Boogaloo-style"><a href="#2-4-Boogaloo-style" class="headerlink" title="2.4 Boogaloo style"></a>2.4 Boogaloo style</h2><p>基本上是以身体各个点为轴心作圆的风格，Roll在其中是很重要的元素</p><h3 id="1-boogaloo"><a href="#1-boogaloo" class="headerlink" title="1) boogaloo"></a>1) boogaloo</h3><p>​    下半身左右脚互换，上身不动，身体有牵引的感觉</p><h3 id="2-work-out"><a href="#2-work-out" class="headerlink" title="2) work out"></a>2) work out</h3><p>​    大步朝前迈出,记得 的是画圆的轨迹，然后身体在跟着扭过去</p><h3 id="3-Boogaloo-Walk-Out"><a href="#3-Boogaloo-Walk-Out" class="headerlink" title="3) Boogaloo Walk Out"></a>3) Boogaloo Walk Out</h3><p>跟 work out 差不多, 多了身体的 wave 和连带动作</p><h3 id="4-Filmore"><a href="#4-Filmore" class="headerlink" title="4) Filmore"></a>4) Filmore</h3><p>做交通指挥一般的动作,</p><h3 id="5-Neck-O-Flex"><a href="#5-Neck-O-Flex" class="headerlink" title="5) Neck-O-Flex"></a>5) Neck-O-Flex</h3><p>​    头转向一侧,固定,转动身体，给人感觉脑袋没动，身体动</p><h3 id="6-Twist-O-Flex"><a href="#6-Twist-O-Flex" class="headerlink" title="6) Twist-O-Flex"></a>6) Twist-O-Flex</h3><p>头,身体,脚,分开转动,</p><h3 id="7-master-O-Flex"><a href="#7-master-O-Flex" class="headerlink" title="7) master-O-Flex"></a>7) master-O-Flex</h3><p>​    和 Twist-O-Flex 差不多，不过脚步往后跨了一个步,类似work out 的步法</p><h3 id="8-Flex-Walk"><a href="#8-Flex-Walk" class="headerlink" title="8) Flex Walk"></a>8) Flex Walk</h3><p>​    手成架构姿势,左右横摆,往前走</p><h3 id="9-Botom-First"><a href="#9-Botom-First" class="headerlink" title="9) Botom First"></a>9) Botom First</h3><p>​    手脚抬成90度，类似lift, 然后脚后转, 有点像是被人从肚子往后推了一下</p><h3 id="10-Botom-Boogaloo-First"><a href="#10-Botom-Boogaloo-First" class="headerlink" title="10) Botom Boogaloo First"></a>10) Botom Boogaloo First</h3><p>​    跟 bottom first 差不多，但是往后跨了一步,类似walk out 的步法</p><h3 id="11-Egyption-Twist-埃及步"><a href="#11-Egyption-Twist-埃及步" class="headerlink" title="11) Egyption Twist 埃及步"></a>11) Egyption Twist 埃及步</h3><p>​    双脚并拢，微屈膝盖，45度侧移脚掌,反复，头一定要看反方向，</p><h3 id="12-Romeo-Twist"><a href="#12-Romeo-Twist" class="headerlink" title="12) Romeo Twist"></a>12) Romeo Twist</h3><p>​    造成内八字外八字状，侧向移动，又名 toe&amp;heel walk, 脚尖脚跟移动的步伐</p><h3 id="13-crazy-legs-疯狂的腿"><a href="#13-crazy-legs-疯狂的腿" class="headerlink" title="13) crazy legs(疯狂的腿)"></a>13) crazy legs(疯狂的腿)</h3><p>​    脚步的左右roll，让人眼花缭乱,</p><h3 id="14-roll"><a href="#14-roll" class="headerlink" title="14) roll"></a>14) roll</h3><p>popping 舞种里不可缺少的重要基本功之一，也是不同风格的舞种里都会运用到的一种元素</p><p>身体的<strong>脖子，胸,胯,肩以及腿部</strong>的转动，最后结合一起转动的</p><h2 id="2-5-style-风格"><a href="#2-5-style-风格" class="headerlink" title="2.5 style 风格"></a>2.5 style 风格</h2><h3 id="1-robot机器人"><a href="#1-robot机器人" class="headerlink" title="1) robot机器人"></a>1) robot机器人</h3><h3 id="2-Toy-Man-玩具人"><a href="#2-Toy-Man-玩具人" class="headerlink" title="2)Toy Man 玩具人"></a>2)Toy Man 玩具人</h3><h3 id="3-Puppet-木偶"><a href="#3-Puppet-木偶" class="headerlink" title="3) Puppet 木偶"></a>3) Puppet 木偶</h3><h3 id="4-Scarecrow-稻草人"><a href="#4-Scarecrow-稻草人" class="headerlink" title="4) Scarecrow 稻草人"></a>4) Scarecrow 稻草人</h3><h4 id="5-Spider-Man-蜘蛛人"><a href="#5-Spider-Man-蜘蛛人" class="headerlink" title="5) Spider Man 蜘蛛人"></a>5) Spider Man 蜘蛛人</h4><p>​    手像蜘蛛一样在身上各个部位爬行的动作</p><h3 id="6-KingTut-Tutting-埃及手"><a href="#6-KingTut-Tutting-埃及手" class="headerlink" title="6) KingTut/Tutting 埃及手"></a>6) KingTut/Tutting 埃及手</h3><p>​    手腕, 手肘, 手背, 各成90度</p><h3 id="7-Strutting-阔步"><a href="#7-Strutting-阔步" class="headerlink" title="7) Strutting 阔步"></a>7) Strutting 阔步</h3><p>​    一格一格的动作，头部要上下左右分格看，</p><h3 id="8-Strobing-快门"><a href="#8-Strobing-快门" class="headerlink" title="8) Strobing 快门"></a>8) Strobing 快门</h3><p>​    像照相时不断闪光所出现的间断的动作</p><h3 id="9-Ticking-连震"><a href="#9-Ticking-连震" class="headerlink" title="9) Ticking 连震"></a>9) Ticking 连震</h3><h3 id="10-Strobing-pop"><a href="#10-Strobing-pop" class="headerlink" title="10) Strobing + pop"></a>10) Strobing + pop</h3><h3 id="11-AirPose-滞空"><a href="#11-AirPose-滞空" class="headerlink" title="11) AirPose 滞空"></a>11) AirPose 滞空</h3><p>​    加上感觉像在月球上一样，动作被吸的一张一合</p><h3 id="12-Shadow-Box"><a href="#12-Shadow-Box" class="headerlink" title="12) Shadow Box"></a>12) Shadow Box</h3><p>​    Skeeter Rabbit 的独创分割，这个用语言很难表达</p><h3 id="13-Senthapeed"><a href="#13-Senthapeed" class="headerlink" title="13) Senthapeed"></a>13) Senthapeed</h3><p>​    一整套的连续动作，身体每一个部分都像是被手带过去的</p><h2 id="2-6-Body-Contral-身体控制"><a href="#2-6-Body-Contral-身体控制" class="headerlink" title="2.6 Body Contral 身体控制"></a>2.6 Body Contral 身体控制</h2><h3 id="1-animation-动画"><a href="#1-animation-动画" class="headerlink" title="1) animation(动画)"></a>1) animation(动画)</h3><p>​    像早期的电影一般, 帧数不足24帧时快速分格动作</p><h3 id="2-Slow-Move-慢动作"><a href="#2-Slow-Move-慢动作" class="headerlink" title="2) Slow Move 慢动作"></a>2) Slow Move 慢动作</h3><p>​    做之前先加速，然后突然变慢</p><h3 id="3-Isolation"><a href="#3-Isolation" class="headerlink" title="3) Isolation"></a>3) Isolation</h3><p>​    身体各个部位关节肢体能够独立运动，而不会牵连其他部分</p><h1 id="三-著名Popper"><a href="#三-著名Popper" class="headerlink" title="三. 著名Popper"></a>三. 著名Popper</h1><p>很多舞者钻研单一舞步的Popper练到极致会变得相当不像人类所能做的动作</p><h2 id="3-1-EB元老"><a href="#3-1-EB元老" class="headerlink" title="3.1 EB元老"></a>3.1 EB元老</h2><h2 id="3-2-杨文昊"><a href="#3-2-杨文昊" class="headerlink" title="3.2 杨文昊"></a>3.2 杨文昊</h2><p>属于偏向使用大量 waving 和 animation 的舞者</p><h2 id="3-3-田一德"><a href="#3-3-田一德" class="headerlink" title="3.3 田一德"></a>3.3 田一德</h2><p>基本上是以 Boogaloo style 为主</p><h2 id="3-4-Nonstop"><a href="#3-4-Nonstop" class="headerlink" title="3.4 Nonstop"></a>3.4 Nonstop</h2><p>本命Marquese scott, 把waving,slow motion, animation, tutting 做到极致. 加上他那瘦弱的身形，竟然能做出一些匪夷所思的失去平衡感的动作，他的特色是跳 dubstep 这种音乐，而且会使用快速地连震</p><p>dubstep 在 popping中 算是一个很爱被使用的音乐类型, </p><h2 id="3-5-Popping-John"><a href="#3-5-Popping-John" class="headerlink" title="3.5 Popping John"></a>3.5 Popping John</h2><p>常与Nonstop上镜头的舞者,比较常用的 waving 还有 robot 去表现，</p><h2 id="3-6-Greenteck"><a href="#3-6-Greenteck" class="headerlink" title="3.6 Greenteck"></a>3.6 Greenteck</h2><p>使用了许多 waving 还有 crazy legs在他的舞蹈中</p><h2 id="3-7-Salah"><a href="#3-7-Salah" class="headerlink" title="3.7 Salah"></a>3.7 Salah</h2><p>虽然他是一位Popper，但是他会很多popping之外的舞风，拥有很多独门绝活，甚至在battle的时候会使出魔术把戏，而他又有强烈的表演风格，跳舞的时候即使在白头也像是在演戏，会有很多的表情动作，所以有人会认为他是actor,不是dancer , 但他也是 battle 上的常胜军</p><h2 id="3-8-Jaja"><a href="#3-8-Jaja" class="headerlink" title="3.8 Jaja"></a>3.8 Jaja</h2><p>最著名的就是它在Robot还有Puppet的舞步，超强的控制力搭配时不时的加入krump的元素.也在&lt;舞力全开&gt;中担任女机器人的角色</p><h2 id="3-9-Madd-Chadd"><a href="#3-9-Madd-Chadd" class="headerlink" title="3.9 Madd Chadd"></a>3.9 Madd Chadd</h2><p>与其说他是proper不如说它已经是完整的机器人</p><h2 id="3-10-Dytto"><a href="#3-10-Dytto" class="headerlink" title="3.10 Dytto"></a>3.10 Dytto</h2><p>一位有奇怪技能的nvpopper, 经常使用她的头发到舞步当中，再搭配上特有的tutting,</p><h2 id="3-11-Fik-Shun"><a href="#3-11-Fik-Shun" class="headerlink" title="3.11 Fik Shun"></a>3.11 Fik Shun</h2><p>特色除了waving之外,还会再加上一些非 popping 的动作，配上他很喜欢的脚尖站立，搭配他的幽默表情是他的一大卖点. 他跟 Les twins 一样，是受火影忍者荼毒很深的舞者，甚至跳舞的时候还使用螺旋丸当舞步</p><h1 id="四-著名的舞团"><a href="#四-著名的舞团" class="headerlink" title="四. 著名的舞团"></a>四. 著名的舞团</h1><h2 id="4-1-Elektro-Botz-三人团体"><a href="#4-1-Elektro-Botz-三人团体" class="headerlink" title="4.1 Elektro Botz (三人团体)"></a>4.1 Elektro Botz (三人团体)</h2><h2 id="4-2-Robot-boys-曾与-popping-John"><a href="#4-2-Robot-boys-曾与-popping-John" class="headerlink" title="4.2 Robot boys (曾与 popping John)"></a>4.2 Robot boys (曾与 popping John)</h2><p>都是很喜欢用很多机械音效的音乐去呈现他们的robot style的舞团，他们在对音乐都可以对得到很细微的程度</p><h2 id="4-3-Roreotics"><a href="#4-3-Roreotics" class="headerlink" title="4.3 Roreotics"></a>4.3 Roreotics</h2><p>很有趣的舞团，曾在ABDC上获得冠军，也由于ABDC给了许多考验，使他们晋升为带有很多其他风格的popping舞团，他们的 animation 和 Strobing 加上他们常使用的速度差是他们的特色，搭配一定要带个墨镜跟不知道为什么让你好像很有特色的发型，是他们舞团的卖点</p><p>4.4 World Fame Us</p><p>虽然是较新的韩国舞团，但成员全部都是battle 的常胜军, popping J, Boogaloo Kin, hozin, hoan, Jaygee 个人风格跟战力都是无可挑剔的, 看他们的排舞有种很纯正的popping的感觉，没有混什么其他的舞风在里头，几乎是是纯popping，卖点大概是每个人的粉丝都很多吧，毕竟每个都是 battle 届赫赫有名的人物</p><h5 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h5><p>​    <a href="https://www.bilibili.com/video/av22797517" target="_blank" rel="noopener">【这！就是街舞】特輯六Popping震爆眼珠的田一德與視覺震撼的楊文昊</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-popping由来&quot;&gt;&lt;a href=&quot;#一-popping由来&quot; class=&quot;headerlink&quot; title=&quot;一. popping由来&quot;&gt;&lt;/a&gt;一. popping由来&lt;/h1&gt;&lt;p&gt;​    比较为大众所知的是一个名叫 &lt;strong&gt;Boogaloo Sam&lt;/strong&gt; 的人，在看到电视节目 Soul Train 上 locker 的表演后激发出来的，然后他在1977年建立了一个舞团, 叫做 The Electric boogaloos(EB舞团)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="街舞" scheme="http://yoursite.com/categories/%E8%A1%97%E8%88%9E/"/>
    
    
      <category term="街舞" scheme="http://yoursite.com/tags/%E8%A1%97%E8%88%9E/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---泛型</title>
    <link href="http://yoursite.com/2019/03/22/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/22/Java基础知识---泛型/</id>
    <published>2019-03-22T01:35:51.000Z</published>
    <updated>2019-03-22T02:10:42.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h1><p>泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。</p><p>什么是泛型？为什么要使用泛型？</p><a id="more"></a><blockquote><p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p></blockquote><h3 id="一个被举了无数次的例子"><a href="#一个被举了无数次的例子" class="headerlink" title="一个被举了无数次的例子"></a>一个被举了无数次的例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.add(<span class="string">"aaaa"</span>);</span><br><span class="line">arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">    String item = (String)arrayList.get(i);</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"item = "</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问，程序的运行结果会以崩溃结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br></pre></td></tr></table></figure><p>ArrayList 可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时<strong>都以String的方式使用，因此程序崩溃了</strong>。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。</p><p>我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// arrayList.add(100); 在编译阶段，编译器就会报错</span></span><br></pre></td></tr></table></figure><p>Java中的泛型，<strong>只在编译阶段有效</strong>。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，<strong>泛型信息不会进入到运行时阶段</strong>。</p><h1 id="二-泛型的使用"><a href="#二-泛型的使用" class="headerlink" title="二. 泛型的使用"></a>二. 泛型的使用</h1><p>泛型有三种使用方式，分别为：<strong>泛型类、泛型接口、泛型方法</strong></p><h2 id="2-1-泛型类"><a href="#2-1-泛型类" class="headerlink" title="2.1 泛型类"></a>2.1 泛型类</h2><h5 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Hero&gt; heros = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line">        <span class="comment">// 简写, 后面可以只用 &lt;&gt;</span></span><br><span class="line">        ArrayList&lt;Hero&gt; heros2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 只有作为Hero的子类可以放进去     </span></span><br><span class="line">        heros.add(<span class="keyword">new</span> APHero());</span><br><span class="line">        heros.add(<span class="keyword">new</span> ADHero());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 和 Hero无关的类型Item还是放不进去</span></span><br><span class="line">        <span class="comment">// heros.add(new Item());       </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-通配符"><a href="#三-通配符" class="headerlink" title="三. 通配符"></a>三. 通配符</h1><h2 id="3-1-extends"><a href="#3-1-extends" class="headerlink" title="3.1 ? extends"></a>3.1 <code>? extends</code></h2><p><code>ArrayList heroList&lt;? extends Hero&gt;</code>表示这是<strong>一个Hero泛型或者其子类泛型</strong></p><ul><li><p>heroList 的泛型可能是Hero</p></li><li><p>heroList 的泛型可能是APHero</p></li><li><p>heroList 的泛型可能是ADHero</p></li></ul><p>所以 可以确凿的是，<strong>从heroList取出来的对象，一定是可以转型成Hero的</strong></p><p>但是，<strong>不能往里面放东西</strong>，因为</p><ul><li>放APHero就不满足<adhero></adhero></li><li>放ADHero又不满足<aphero>                       </aphero></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">        ArrayList&lt;APHero&gt; apHeroList = <span class="keyword">new</span> ArrayList&lt;APHero&gt;();</span><br><span class="line">        apHeroList.add(<span class="keyword">new</span> APHero());</span><br><span class="line">         </span><br><span class="line">        ArrayList&lt;? extends Hero&gt; heroList = apHeroList;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//可以确凿的是，从heroList取出来的对象，一定是可以转型成Hero的   </span></span><br><span class="line">        Hero h= heroList.get(<span class="number">0</span>);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 但是，不能往里面放东西</span></span><br><span class="line">        heroList.add(<span class="keyword">new</span> ADHero()); <span class="comment">// 编译错误，因为heroList的泛型 有可能是APHero       </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-super"><a href="#3-2-super" class="headerlink" title="3.2 ? super"></a>3.2 <code>? super</code></h2><p><code>ArrayList heroList&lt;? super Hero&gt;</code> 表示这是一个Hero泛型或者其父类泛型</p><ul><li>heroList的泛型可能是Hero</li><li>heroList的泛型可能是Object</li></ul><p>可以往里面插入Hero以及Hero的子类<br>但是取出来有风险，因为不确定取出来是Hero还是Object                       </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">        ArrayList&lt;? <span class="keyword">super</span> Hero&gt; heroList = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 所以就可以插入Hero</span></span><br><span class="line">        heroList.add(<span class="keyword">new</span> Hero());</span><br><span class="line">        <span class="comment">// 也可以插入Hero的子类</span></span><br><span class="line">        heroList.add(<span class="keyword">new</span> APHero());</span><br><span class="line">        heroList.add(<span class="keyword">new</span> ADHero());</span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 但是，不能从里面取数据出来,因为其泛型可能是Object,而Object是强转Hero会失败</span></span><br><span class="line">        Hero h= heroList.get(<span class="number">0</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3"><a href="#3-3" class="headerlink" title="3.3 ?"></a>3.3 <code>?</code></h2><p>泛型通配符? 代表任意泛型,这个容器什么泛型都有可能</p><ul><li>所以只能以Object的形式取出来</li><li>并且不能往里面放对象，因为不知道到底是一个什么泛型的容器             </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;APHero&gt; apHeroList = <span class="keyword">new</span> ArrayList&lt;APHero&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// ?泛型通配符，表示任意泛型</span></span><br><span class="line">        ArrayList&lt;?&gt; generalList = apHeroList;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// ?的缺陷1： 既然?代表任意泛型，那么换句话说，你就不知道这个容器里面是什么类型</span></span><br><span class="line">        <span class="comment">// 所以只能以Object的形式取出来</span></span><br><span class="line">        Object o = generalList.get(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// ?的缺陷2： 既然?代表任意泛型，那么既有可能是Hero,也有可能是Item</span></span><br><span class="line">        <span class="comment">// 所以，放哪种对象进去，都有风险，结果就什么什么类型的对象，都不能放进去</span></span><br><span class="line">        generalList.add(<span class="keyword">new</span> Item()); <span class="comment">//编译错误 因为?代表任意泛型，很有可能不是Item</span></span><br><span class="line">        generalList.add(<span class="keyword">new</span> Hero()); <span class="comment">//编译错误 因为?代表任意泛型，很有可能不是Hero</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h3><ul><li>如果希望只取出，不插入，就使用? extends Hero</li><li>如果希望只插入，不取出，就使用? super Hero</li><li>如果希望，又能插入，又能取出，就不要用通配符？</li></ul><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://blog.csdn.net/s10461/article/details/53941091" target="_blank" rel="noopener">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a></p><p>​    <a href="http://how2j.cn/module/58.html" target="_blank" rel="noopener">泛型</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一. 概述&quot;&gt;&lt;/a&gt;一. 概述&lt;/h1&gt;&lt;p&gt;泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。&lt;/p&gt;
&lt;p&gt;什么是泛型？为什么要使用泛型？&lt;/p&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---集合框架</title>
    <link href="http://yoursite.com/2019/03/22/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2019/03/22/Java基础知识---集合框架/</id>
    <published>2019-03-22T01:10:51.000Z</published>
    <updated>2019-03-22T01:22:42.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-集合框架图"><a href="#一-集合框架图" class="headerlink" title="一. 集合框架图"></a>一. 集合框架图</h1><p><img src="https://images2015.cnblogs.com/blog/249993/201611/249993-20161122113410534-705560500.jpg" alt="简化图"></p><p>​    所有集合类都位于<strong>java.util包</strong>下。Java的集合类主要由<strong>两个接口派生而出：Collection和Map</strong>，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。</p><a id="more"></a><ol><li><strong>Collection</strong> : 接口，是高度抽象出来的集合(一组允许重复的对象)，<strong>它包含了集合的基本操作和属性</strong>。Collection包含了<strong>List和Set</strong>两大分支</li><li><strong>List</strong> : 接口, 继承 Collection, 有序集合, <strong>允许重复</strong>，每一个元素都有它的索引, 访问集合中的元素可以根据元素的索引来访问。</li><li><strong>Set</strong> : 接口, 继承 Collection, 无序集合，集合中的元素<strong>不可以重复</strong>, 访问集合中的元素只能根据元素本身来访问</li><li><strong>Map</strong> : 接口是<strong>键－值对象(Key-value对形式)</strong> , 访问时只能根据每项元素的key来访问其value，与Collection接口没有什么关系。</li><li>Set、List和Map可以看做集合的三大类</li><li>Iterator。它是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。ListIterator是专门为遍历List而存在的。</li><li>Enumeration，它是JDK 1.0引入的抽象类。作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。在上面的框图中，Enumeration只能在Hashtable, Vector, Stack中使用。</li><li>Arrays和Collections。它们是操作数组、集合的两个工具类。</li></ol><h1 id="二-Collection接口"><a href="#二-Collection接口" class="headerlink" title="二. Collection接口"></a>二. Collection接口</h1><p>​    Collection接口是处理对象集合的 <strong>根接口</strong> ，其中定义了很多对元素进行操作的方法。Collection接口有两个主要的子接口<strong>List</strong>和<strong>Set</strong></p><blockquote><p> 注意<strong>Map不是Collection的子接口，这个要牢记</strong>。</p></blockquote><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>add() : 添加一个元素到集合中</li><li>addAll() : 将指定集合中的所有元素添加到集合中</li><li>contains() : 检测集合中是否包含指定的元素</li><li>toArray() : 返回一个表示集合的数组。</li></ul><p>另外，Collection中有一个iterator()函数，它的作用是返回一个Iterator接口。通常，我们通过Iterator迭代器来遍历集合。ListIterator是List接口所特有的，在List接口中，通过ListIterator()返回一个ListIterator对象。</p><h2 id="2-1-List-接口"><a href="#2-1-List-接口" class="headerlink" title="2.1 List 接口"></a>2.1 List 接口</h2><p>​    List接口继承于Collection接口，它可以定义一个<strong>允许重复</strong>的<strong>有序集合</strong>。因为List中的元素是有序的，所以我们可以通过使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。</p><p>​    List接口为Collection直接接口。List所代表的是<strong>有序的Collection</strong>，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中<strong>每个元素的插入位置进行精确地控制</strong>，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>​      ArrayList是一个<strong>动态数组</strong>，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。</p><p>​      size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add  操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n)  时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）. </p><p><strong>ArrayList擅长于随机访问。同时ArrayList是非同步的。</strong></p><h3 id="2-Set接口"><a href="#2-Set接口" class="headerlink" title="2. Set接口"></a>2. Set接口</h3><p>​     Set是一种<strong>不包括重复元素的Collection</strong>。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许null的存在但是<strong>仅有一个</strong>。由于Set接口的特殊性，<strong>所有传入Set集合中的元素都必须不同</strong>，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。Set接口有三个具体实现类，分别是散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet。</p><p>​     Set是一种不包含重复的元素的Collection，无序，即任意的两个元素e1和e2都有<strong>e1.equals(e2)=false</strong>，Set最多有一个null元素。需要注意的是:虽然Set中元素没有顺序，但是元素在set中的位置是由该元素的HashCode决定的，其具体位置其实是固定的。</p><p>​     此外需要说明一点，在set接口中的不重复是有特殊要求的。<br>​      举一个例子:对象A和对象B，本来是不同的两个对象，正常情况下它们是能够放入到Set里面的，但是如果对象A和B的都重写了hashcode和equals方法，并且重写后的hashcode和equals方法是相同的话。那么A和B是不能同时放入到Set集合中去的，也就是Set集合中的去重和hashcode与equals方法直接相关。 </p><h2 id="三-Map接口"><a href="#三-Map接口" class="headerlink" title="三. Map接口"></a>三. Map接口</h2><p>​     Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。</p><p>​    <a href="https://blog.csdn.net/guomutian911/article/details/45771621" target="_blank" rel="noopener">遍历Map</a></p><p><strong>1.HashMap</strong></p><p>​      以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[]   table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。</p><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="http://www.runoob.com/java/java-collections.html" target="_blank" rel="noopener">Java 集合框架</a></p><p>​    <a href="https://www.cnblogs.com/xiaoxi/p/6089984.html" target="_blank" rel="noopener">java集合框架综述</a></p><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-集合框架图&quot;&gt;&lt;a href=&quot;#一-集合框架图&quot; class=&quot;headerlink&quot; title=&quot;一. 集合框架图&quot;&gt;&lt;/a&gt;一. 集合框架图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/249993/201611/249993-20161122113410534-705560500.jpg&quot; alt=&quot;简化图&quot;&gt;&lt;/p&gt;
&lt;p&gt;​    所有集合类都位于&lt;strong&gt;java.util包&lt;/strong&gt;下。Java的集合类主要由&lt;strong&gt;两个接口派生而出：Collection和Map&lt;/strong&gt;，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。&lt;/p&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---Servlet跳转</title>
    <link href="http://yoursite.com/2019/03/21/JavaWeb---Servlet%E8%B7%B3%E8%BD%AC/"/>
    <id>http://yoursite.com/2019/03/21/JavaWeb---Servlet跳转/</id>
    <published>2019-03-21T14:29:27.000Z</published>
    <updated>2019-03-29T01:04:07.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-Servlet-跳转"><a href="#一-Servlet-跳转" class="headerlink" title="一. Servlet 跳转"></a>一. Servlet 跳转</h1><h3 id="1-1-redirect-方式-客户端跳转"><a href="#1-1-redirect-方式-客户端跳转" class="headerlink" title="1.1 redirect 方式 (客户端跳转)"></a>1.1 redirect 方式 (客户端跳转)</h3><p>​    发送一个请求给服务器端资源，这个服务器资源会首先给客户端一个响应，客户端再根据这个响应当中所包含的地址，再次向服务器端发送一个请求，也就是说<strong>客户端跳转是两次请求，两次响应</strong>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">"/index.jsp"</span>);</span><br></pre></td></tr></table></figure><ul><li><p>页面的路径是<strong>相对路径</strong> , sendRedirect可以将页面跳转到<strong>任何页面，不一定局限于本web应用中</strong></p></li><li><p>跳转后 <strong>浏览器地址栏变化</strong></p></li><li>称之为<strong>请求重定向/302</strong></li></ul><a id="more"></a><h3 id="1-2-forward方式-服务器端跳转"><a href="#1-2-forward方式-服务器端跳转" class="headerlink" title="1.2 forward方式 (服务器端跳转)"></a>1.2 forward方式 (服务器端跳转)</h3><p>​    由客户端发送一个请求，请求一个服务器资源 (如JSP和Servlet) ，这个资源又将请求转到另一个服务器资源，然后再给客户端发送一个响应，也就是说<strong>服务器端跳转是客户端发送一次请求，服务器端给出一次响应</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestDispatcher dispatcher = request.getRequestDispatcher(<span class="string">"/index.jsp"</span>); </span><br><span class="line">dispatcher.forward(request, response); </span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">"/index.jsp"</span>).forward(request, response);</span><br></pre></td></tr></table></figure><ul><li><p>页面的路径是 <strong>相对路径</strong> , forward方式 <strong>只能跳转到本web应用中的页面上</strong></p></li><li><p>跳转后浏览器地址栏 <strong>不会变化</strong></p></li><li><strong>请求转发/307</strong> 称为</li></ul><h1 id="二-两者之间的区别"><a href="#二-两者之间的区别" class="headerlink" title="二. 两者之间的区别"></a>二. 两者之间的区别</h1><table><thead><tr><th>方面</th><th>redirect 方式 (response , 客户端跳转)</th><th>forward方式 (request , 服务器端跳转)</th></tr></thead><tbody><tr><td>浏览器地址</td><td>会变化 (在地址栏中显示的是最后一次请求地址)</td><td>会不变化 (在地址栏中显示的事第一次页面地址)</td></tr><tr><td>当前资源</td><td></td><td></td></tr><tr><td>指定目标资源的URL</td><td>“”代表的是应用服务器根目录，即<code>http://localhost:8080/</code></td><td>代表的是应用程序根目录,即<code>http://localhost:8080/项目名/</code></td></tr><tr><td></td><td>可以向站外跳转</td><td>只能站内跳转</td></tr><tr><td>是否可以获取到请求中的属性和参数</td><td>不可以</td><td>可以</td></tr></tbody></table><p>注意：<br>    1、客户端跳转“/”代表服务器路径webapps，即服务器根路径，服务器端跳转“/”代表站点根路径，即应用程序根路径；</p><p>​    2、尽量使用response.sendRedirect(“fail.jsp”)而不去使用forward，因为当服务器崩溃了，那么sendRedirect则就会起很大的好处了</p><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://blog.csdn.net/chao2016/article/details/50663427" target="_blank" rel="noopener">java学习心得——servlet的两种跳转方式</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-Servlet-跳转&quot;&gt;&lt;a href=&quot;#一-Servlet-跳转&quot; class=&quot;headerlink&quot; title=&quot;一. Servlet 跳转&quot;&gt;&lt;/a&gt;一. Servlet 跳转&lt;/h1&gt;&lt;h3 id=&quot;1-1-redirect-方式-客户端跳转&quot;&gt;&lt;a href=&quot;#1-1-redirect-方式-客户端跳转&quot; class=&quot;headerlink&quot; title=&quot;1.1 redirect 方式 (客户端跳转)&quot;&gt;&lt;/a&gt;1.1 redirect 方式 (客户端跳转)&lt;/h3&gt;&lt;p&gt;​    发送一个请求给服务器端资源，这个服务器资源会首先给客户端一个响应，客户端再根据这个响应当中所包含的地址，再次向服务器端发送一个请求，也就是说&lt;strong&gt;客户端跳转是两次请求，两次响应&lt;/strong&gt;；&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;response.sendRedirect(&lt;span class=&quot;string&quot;&gt;&quot;/index.jsp&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;页面的路径是&lt;strong&gt;相对路径&lt;/strong&gt; , sendRedirect可以将页面跳转到&lt;strong&gt;任何页面，不一定局限于本web应用中&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;跳转后 &lt;strong&gt;浏览器地址栏变化&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;称之为&lt;strong&gt;请求重定向/302&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---项目中的绝对路径与相对路径</title>
    <link href="http://yoursite.com/2019/03/21/JavaWeb---%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2019/03/21/JavaWeb---项目中的绝对路径与相对路径/</id>
    <published>2019-03-21T14:29:27.000Z</published>
    <updated>2019-03-29T02:15:33.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-与路径相关的操作"><a href="#一-与路径相关的操作" class="headerlink" title="一. 与路径相关的操作"></a>一. 与路径相关的操作</h1><ul><li><p>超链接</p></li><li><p>表单</p></li><li><p>转发</p></li><li><p>包含</p></li><li><p>重定向</p></li><li><p><code>&lt;url-pattern&gt;</code></p></li><li><p>ServletContext获取资源</p></li><li><p>Class获取资源</p></li><li><p>ClassLoader获取资源</p></li></ul><a id="more"></a><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>强烈建议使用 <strong><code>/</code></strong> 开头的路径</li><li><p><strong>超链接、表单、重定向</strong> : 以 <strong><code>/</code></strong> 开头的的路径相对于主机根目录 <code>http://localhost:8080/</code></p><p><strong>转发、包含、<code>&lt;url-pattern&gt;</code></strong>：以 <strong><code>/</code></strong> 开头的的路径相对项目根目录 <code>http://localhost:8080/项目名称/</code></p></li><li><p><strong>不带 <code>/</code> 的相对路径</strong>，是相对于<strong>访问到当前文件的路径，而不是当前文件所在的目录</strong>。</p></li></ul><h1 id="2-客户端路径"><a href="#2-客户端路径" class="headerlink" title="2　客户端路径"></a>2　客户端路径</h1><p><strong>超链接、表单、重定向</strong>都是客户端路径，客户端路径可以分为三种方式：</p><ul><li><p>绝对路径；</p></li><li><p>以“/”开头的相对路径；</p></li><li><p>不以“/”开头的相对路径；</p></li></ul><h4 id="范例-1-超链接-标签"><a href="#范例-1-超链接-标签" class="headerlink" title="范例 1 超链接, 标签"></a>范例 1 超链接, 标签</h4><p><code>http://localhost:8080/hello1/pages/a.html</code> 中的<strong>超链接</strong> (表单同理) 要访问 <code>http://localhost:8080/hello2/index.html</code>  中的 index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 链接1 : 使用绝对路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://localhost:8080/hello2/index.html"</span>&gt;</span>链接1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 链接2：以“/”开头, 最终访问的页面为http://localhost:8080/hello2/index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/hello2/index.html"</span>&gt;</span>链接2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 链接3：不以“/”开头，最终访问的路径为：http://localhost:8080/hello1/pages/index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index.html"</span>&gt;</span>链接3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="范例-2-重定向"><a href="#范例-2-重定向" class="headerlink" title="范例 2 重定向"></a>范例 2 重定向</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">publicclass AServlet extends HttpServlet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 以“/”开头，所以相对当前主机，即 http://localhost:8080/hello2/index.html</span></span><br><span class="line">        response.sendRedirect(<span class="string">"/hello2/index.html"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 假设访问 AServlet 的路径为：http://localhost:8080/hello/servlet/AServlet</span></span><br><span class="line">        <span class="comment">// 不以“/”开头，所以相对当前路径，即http://localhost:8080/hello/servlet/index.html</span></span><br><span class="line">        response.sendRedirect(<span class="string">"index.html"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-建议使用"><a href="#2-1-建议使用" class="headerlink" title="2.1　建议使用 /"></a>2.1　建议使用 <code>/</code></h2><p>​    强烈建议使用“/”开头的路径，这说明在页面中的超链接和表单都要以“/”开头，后面是当前应用的名称，再是访问路径</p><p>其中/hello是当前应用名称，这也说明如果将来修改了应用名称，那么页面中的所有路径也要修改，这一问题的处理方案是使用 <strong><code>request.getContextPath()</code></strong> 来获取应用名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(request.getContextPath() +<span class="string">"/BServlet"</span>);</span><br></pre></td></tr></table></figure><p>  <strong>详情见</strong> <a href="https://sladning.github.io/2019/03/08/JavaWeb---HttpServletResponse%E5%AF%B9%E8%B1%A1/" target="_blank" rel="noopener">JavaWeb—HttpResponse对象</a></p><h1 id="三-服务端路径"><a href="#三-服务端路径" class="headerlink" title="三. 服务端路径"></a>三. 服务端路径</h1><p>请求转发(forward), 请求包含 是服务器端路径, 服务器端路径<strong>必须是相对路径</strong>，不能是绝对路径, 但相对路径有两种形式：</p><ul><li><p>以“/”开头；</p></li><li><p>不以“/”开头</p></li></ul><blockquote><p>服务器端路径与客户端路径的区别是：</p><p><strong>客户端路径</strong>以“/”开头：相对当前主机；</p><p><strong>服务器端路径</strong>以“/”开头：相对当前应用；</p><p>理解: 因为客户端是浏览器访问, 而服务端本来就是在项目中,自然默认是这个项目,所以是相对于当前应用,而客户端访问时不知道是哪个项目,所以客户端是相对于主机</p></blockquote><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设访问AServlet的路径为：http://localhost:8080/hello/servlet/AServlet</span></span><br><span class="line">        <span class="comment">// 以“/”开头，所以相对当前应用，即http://localhost:8080/hello/BServlet</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">"/BServlet"</span>).forward(request, response);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 假设访问AServlet的路径为：http://localhost:8080/hello/servlet/AServlet</span></span><br><span class="line"><span class="comment">// 不以“/”开头，所以相对当前应用，即http://localhost:8080/hello/servlet/BServlet</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">"BServlet"</span>).forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://blog.csdn.net/qq_29028175/article/details/53559738" target="_blank" rel="noopener">WEB项目的相对路径与绝对路径</a>    </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-与路径相关的操作&quot;&gt;&lt;a href=&quot;#一-与路径相关的操作&quot; class=&quot;headerlink&quot; title=&quot;一. 与路径相关的操作&quot;&gt;&lt;/a&gt;一. 与路径相关的操作&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;超链接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;表单&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;转发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;包含&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重定向&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;url-pattern&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ServletContext获取资源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Class获取资源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ClassLoader获取资源&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---final关键字</title>
    <link href="http://yoursite.com/2019/03/21/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/03/21/Java基础知识---final关键字/</id>
    <published>2019-03-21T13:18:27.000Z</published>
    <updated>2019-03-27T09:23:21.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-修饰类"><a href="#1-修饰类" class="headerlink" title="1. 修饰类"></a>1. 修饰类</h2><ul><li><p>当用final修饰一个类时，表明这个类<strong>不能被继承</strong>。</p></li><li><p>如果一个类你永远不会让他被继承，就可以用final进行修饰。</p></li><li><p>final类中的成员变量可以根据需要设为final，但是要注意 <strong>final类中的所有成员方法都会被隐式地指定为final方法</strong></p></li></ul><blockquote><p> 在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类</p></blockquote><a id="more"></a><h5 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认为 final 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-修饰方法"><a href="#2-修饰方法" class="headerlink" title="2. 修饰方法"></a>2. 修饰方法</h2><p>使用 final 方法的原因有两个</p><ol><li>把方法锁定，以防任何继承类修改它的含义；</li><li>效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。</li></ol><blockquote><p>如果只有在想 <strong>明确禁止</strong> 该方法在子类中被覆盖的情况下才将方法设置为final的。即父类的final方法是不能被子类所覆盖的，也就是说<strong>子类是不能够存在和父类一模一样的方法</strong> </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为private修饰，子类中不能继承到此方法，因此，子类中的getName方法是重新定义的、</span></span><br><span class="line"><span class="comment">     * 属于子类本身的方法，编译正常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 因为pblic修饰，子类可以继承到此方法，导致重写了父类的final方法，编译出错</span></span><br><span class="line"><span class="comment">    public final void getName() &#123;    </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-修饰变量"><a href="#3-修饰变量" class="headerlink" title="3. 修饰变量"></a>3. 修饰变量</h2><p>final成员变量表示常量，只能被赋值一次，赋值后值不再改变。</p><ul><li><p>当final修饰一个基本数据类型时，表示该基本数据类型的值一旦<strong>在初始化后便不能发生变化</strong>；</p></li><li><p>如果final修饰一个引用类型时，则在对其初始化之后便<strong>不能再让其指向其他对象了</strong>，但该引用所指向的<strong>对象的内容是可以发生变化的</strong>。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。</p></li></ul><h3 id="初始化方式"><a href="#初始化方式" class="headerlink" title="初始化方式"></a>初始化方式</h3><p>final修饰一个成员变量（属性），必须要显示初始化。这里有两种初始化方式</p><ol><li>在变量声明的时候初始化；</li><li>1在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。</li></ol><blockquote><p> 当函数的参数类型声明为final时，说明该参数是只读型的。即你可以读取使用该参数，但是无法改变该参数的值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i = <span class="number">1</span>; <span class="comment">// 报错</span></span><br><span class="line">        <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        obj = <span class="keyword">new</span> Object(); <span class="comment">// 报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二、深入理解final关键字</strong></p><p>在了解了final关键字的基本用法之后，这一节我们来看一下final关键字容易混淆的地方。</p><p>类的final变量和普通变量有什么区别？</p><h4 id="2、被final修饰的引用变量指向的对象内容可变吗？"><a href="#2、被final修饰的引用变量指向的对象内容可变吗？" class="headerlink" title="2、被final修饰的引用变量指向的对象内容可变吗？"></a>2、被final修饰的引用变量指向的对象内容可变吗？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFinal</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> MyClass myClass = <span class="keyword">new</span> MyClass(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">    myClass.i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(myClass.i);</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 打印结果: 4</span></span><br></pre></td></tr></table></figure><p>这段代码可以顺利编译通过并且有输出结果，输出结果为4。这说明引用变量被final修饰之后，虽然不能再指向其他对象，但是它<strong>指向的对象的内容是可变的</strong></p><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xiaoxi/p/6392154.html" target="_blank" rel="noopener">浅谈Java中的final关键字</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-修饰类&quot;&gt;&lt;a href=&quot;#1-修饰类&quot; class=&quot;headerlink&quot; title=&quot;1. 修饰类&quot;&gt;&lt;/a&gt;1. 修饰类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当用final修饰一个类时，表明这个类&lt;strong&gt;不能被继承&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一个类你永远不会让他被继承，就可以用final进行修饰。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;final类中的成员变量可以根据需要设为final，但是要注意 &lt;strong&gt;final类中的所有成员方法都会被隐式地指定为final方法&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt; 在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---异常处理</title>
    <link href="http://yoursite.com/2019/03/21/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/21/Java基础知识---异常处理/</id>
    <published>2019-03-21T11:45:27.000Z</published>
    <updated>2019-03-21T12:50:16.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-异常的概念"><a href="#一-异常的概念" class="headerlink" title="一. 异常的概念"></a>一. 异常的概念</h1><p>​    <strong>异常指的是运行期出现的错误，也就是当程序开始执行以后执行期出现的错误</strong>。出现错误时观察错误的名字和行号最为重要。</p><ul><li>Java 异常是 Java 提供的用于<strong>处理程序中错误的一种机制</strong></li></ul><a id="more"></a><ul><li>所谓错误是指在程序运行的过程中发生的一些异常事件(eg: 除0溢出, 数组下标越界, 所要读取的文件不存在)</li><li>设计良好的程序应该在异常发生时提供处理这些错误的方法,是的程序不会因为异常的发生而阻断或产生不可预见的结果</li><li>Java 程序的执行过程中,如出现异常事件,可以生成一个异常类对象。该异常类对象封装了异常事件的信息并将提交给<strong>Java运行时系统</strong>(Java 运行时系统默认处理是直接把这个异常对象里面包装的信息打印出来)。这个过程称为<strong>抛出(throw)异常</strong></li><li>当 Java 运行时系统接收到的异常对象时, 会寻找能处理这一异常的代码，并将当前异常对象交给其处理,这一过程称为<strong>捕获(catch)异常</strong></li></ul><h1 id="二-异常的分类"><a href="#二-异常的分类" class="headerlink" title="二. 异常的分类"></a>二. 异常的分类</h1><ul><li><strong>Error</strong> : 称为<strong>错误</strong>，由Java虚拟机生成并抛出，包括动态链接失效，虚拟机错误的，<strong>程序对其不作处理</strong></li><li><strong>Exception</strong> : <strong>所有异常类的父类</strong>，其子类对应了各种各样可能出现的异常事件，一般需要用户<strong>显示的声明或捕获</strong></li><li><strong>Runtime Exception</strong> : 一类特殊的异常, 如被0除，数组下标超范围等，<strong>其产生比较频繁处理麻烦</strong>，如果显示的声明或捕获会对程序可读性和运行效率影响很大，因此由<strong>系统自动检测并将他们交给缺省的异常处理程序</strong>，<strong>用户可不必对其处理</strong></li></ul><h1 id="三、异常的捕获和处理"><a href="#三、异常的捕获和处理" class="headerlink" title="三、异常的捕获和处理"></a>三、异常的捕获和处理</h1><p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p><h2 id="3-1-try-catch-finally语句"><a href="#3-1-try-catch-finally语句" class="headerlink" title="3.1 try-catch-finally语句"></a>3.1 try-catch-finally语句</h2><ul><li><code>try{...}</code>：负责捕获异常，一旦try中发现异常，程序的控制权将被移交给catch块中的异常处理程序,如果没有异常产生,所有的catch代码段都被略过不执行。</li></ul><p>　　<strong>【try语句块不可以独立存在，必须与 catch 或者 finally 块同存】</strong></p><ul><li><code>catch{...}</code> ：对异常进行处理,比如发出警告：提示、检查配置、网络连接，记录错误等。执行完catch块之后程序跳出catch块，继续执行后面的代码。</li></ul><p>　   【编写catch块的注意事项：多个catch块处理的异常类，要按照<strong>先catch子类后catch父类的处理方式</strong>，因为会”就近处理”异常(由上自下)】</p><ul><li><p><code>finally{...}</code> : 最终执行的代码，用于关闭和释放资源。无论是否抛出异常,finally所指定的代码都要被执行.</p><p>【通常在finally语句中可以惊醒资源的清除工作,如:关闭打开的文件,删除临时文件】</p></li></ul><h5 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//一些会抛出的异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>（Exception e）&#123;</span><br><span class="line"><span class="comment">//第一个catch</span></span><br><span class="line"><span class="comment">//处理该异常的代码块</span></span><br><span class="line">&#125;<span class="keyword">catch</span>（Exception2 e）&#123;</span><br><span class="line"><span class="comment">//第二个catch，可以有多个catch</span></span><br><span class="line"><span class="comment">//处理该异常的代码块</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    System.out.println(<span class="string">"异常抛出了！！"</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//最终要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ol><li><p>finally中最好不要包含return，否则程序会提前退出，返回会覆盖try或catch中保存的返回值。 </p></li><li><p>printStackTrace()可以输出异常信息。</p></li><li>return值为-1为抛出异常的习惯写法。</li><li>如果方法中try,catch,finally中没有返回语句，则会调用这三个语句块之外的return结果。</li><li>finally 在try中的return之后 在返回主调函数之前执行。</li></ol><h2 id="3-2-throw和throws关键字"><a href="#3-2-throw和throws关键字" class="headerlink" title="3.2 throw和throws关键字"></a>3.2 throw和throws关键字</h2><p>Java中的 <strong>异常抛出</strong> 通常使用throw和throws关键字来实现。</p><h2 id="3-3-throw"><a href="#3-3-throw" class="headerlink" title="3.3 throw"></a>3.3 throw</h2><p>将产生的异常抛出，是抛出异常的一个<strong>动作</strong></p><p>一般会用于程序出现某种逻辑时程序员<strong>主动抛出</strong>某种特定类型的异常</p><h5 id="语法格式-throw-异常对象"><a href="#语法格式-throw-异常对象" class="headerlink" title="语法格式 throw (异常对象)"></a>语法格式 throw (异常对象)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    String s = <span class="string">"abc"</span>; </span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">"abc"</span>)) &#123; </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      System.out.println(s); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-throws"><a href="#3-4-throws" class="headerlink" title="3.4 throws"></a>3.4 throws</h2><p>声明将要抛出何种类型的异常(<strong>声明</strong>),一个方法可以导致一个异常但不处理它，它必须指定这种行为以使方法的调用者可以保护它们自己而不发生异常</p><h5 id="语法格式-1"><a href="#语法格式-1" class="headerlink" title="语法格式"></a>语法格式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">person</span><span class="params">(String name)</span> <span class="title">throws</span> <span class="params">(Exception1, Exception2)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>throw与throws的比较</strong></p><ol><li>throws 出现在方法头；而throw出现在方法体。</li><li>throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。</li><li>两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</li></ol><h5 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doA</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="title">throws</span> <span class="params">(Exception1,Exception2,Exception3)</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         ......</span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception1 e) &#123;</span><br><span class="line">       <span class="keyword">throw</span> e;</span><br><span class="line">          </span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception2 e) &#123;</span><br><span class="line">       System.out.println(<span class="string">"出错了！"</span>);</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(a!=b)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> Exception3(<span class="string">"自定义异常"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h5><ol><li>代码块中可能会产生3个异常，(Exception1,Exception2,Exception3)。</li><li>如果产生Exception1异常，则<strong>捕获之后再抛出</strong>，由该方法的调用者去处理。</li><li>如果产生Exception2异常，则该方法自己处理了（即System.out.println(“出错了！”);）。所以该方法就<strong>不会再向外抛出Exception2异常了</strong>，void doA() throws Exception1,Exception3 里面的<strong>Exception2也就不用写了。因为已经用try-catch语句捕获并处理了。</strong></li><li>Exception3异常是该方法的某段逻辑出错，程序员自己做了处理，在该段逻辑错误的情况下抛出异常Exception3，则该方法的调用者也要处理此异常。这里用到了自定义异常</li></ol><h4 id="使用throw和throws关键字需要注意以下几点："><a href="#使用throw和throws关键字需要注意以下几点：" class="headerlink" title="使用throw和throws关键字需要注意以下几点："></a>使用throw和throws关键字需要注意以下几点：</h4><ol><li><p>throws的异常列表可以是抛出一条异常，也可以是抛出多条异常，每个类型的异常中间用逗号隔开 </p></li><li><p>方法体中调用会抛出异常的方法或者是先抛出一个异常：用throw new Exception（） throw写在方法体里，表示“抛出异常”这个动作。</p></li><li><p>如果某个方法调用了抛出异常的方法，那么必须添加try catch语句去尝试捕获这种异常， 或者添加声明，将异常抛出给更上一层的调用者进行处理 </p></li></ol><h1 id="四-自定义异常"><a href="#四-自定义异常" class="headerlink" title="四. 自定义异常"></a>四. 自定义异常</h1><p>略</p><h1 id="五-习惯"><a href="#五-习惯" class="headerlink" title="五. 习惯"></a>五. 习惯</h1><p>​    当捕获到异常以后一定要做出处理，哪怕是把这个异常的错误信息打印出来，这是一种良好的编程习惯。如果不处理，那就是把这个错误悄悄地隐藏起来了，可是这个错误依然是存在的，只不过看不到了而已。这是一种非常危险的编程习惯，绝对不能这样做，捕获到异常就一定要做出处理，实在处理不了就把异常抛出去，让别的方法去处理。总之就是不能捕获到异常之后却又不做出相应的处理，这是一种非常不好的编程习惯。</p><p>　　任何方法往外抛能处理的异常的时候都有一种简单的写法：“<strong>throws</strong> <strong>Exception</strong>”，因为Exception类是所有能处理的异常类的根基类，因此抛出Exception类就会抛出所有能够被处理的异常类里了。使用“<strong>throws</strong> <strong>Exception</strong>”抛出所有能被处理的异常之后，这些被抛出来的异常就是交给JAVA运行时系统处理了，而处理的方法是把这些异常的相关错误堆栈信息全部打印出来。除了在做测试以外，在实际当中编程的时候，在main方法里抛Exception是一个非常不好的编程习惯，应该使用try……catch去捕获异常并处理掉捕获后的异常。不能直接在main方法里把Exception抛出去交给JAVA运行时系统出力就完事了，这是一种不负责任的表现。<strong>如果想把程序写得特别健壮，使用try……catch去捕获异常并处理掉捕获后的异常是必不可少的做法。</strong></p><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/hysum/p/7112011.html" target="_blank" rel="noopener">JAVA异常与异常处理详解</a></p><p>​    <a href="http://how2j.cn/k/exception/exception-trycatch/336.html" target="_blank" rel="noopener">异常处理</a></p><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3627390.html" target="_blank" rel="noopener">java基础学习总结——异常处理</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-异常的概念&quot;&gt;&lt;a href=&quot;#一-异常的概念&quot; class=&quot;headerlink&quot; title=&quot;一. 异常的概念&quot;&gt;&lt;/a&gt;一. 异常的概念&lt;/h1&gt;&lt;p&gt;​    &lt;strong&gt;异常指的是运行期出现的错误，也就是当程序开始执行以后执行期出现的错误&lt;/strong&gt;。出现错误时观察错误的名字和行号最为重要。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java 异常是 Java 提供的用于&lt;strong&gt;处理程序中错误的一种机制&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Typoro快捷键</title>
    <link href="http://yoursite.com/2019/03/20/typero%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2019/03/20/typero快捷键/</id>
    <published>2019-03-20T13:53:27.000Z</published>
    <updated>2019-03-20T14:08:06.316Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>插入表格</td><td>Ctrl+T</td></tr><tr><td>关闭</td><td>Ctrl+W</td></tr><tr><td>下划线</td><td>Ctrl+U</td></tr><tr><td>斜体</td><td>Ctrl+I</td></tr><tr><td></td><td>Ctrl+O</td></tr><tr><td>标题</td><td>Ctrl+数字</td></tr><tr><td>插入链接</td><td>Ctrl+K</td></tr><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://blog.csdn.net/a1406075864/article/details/80364999" target="_blank" rel="noopener">Typora快捷键</a></p><p>​    <a href="https://blog.csdn.net/he_han_san/article/details/81115100" target="_blank" rel="noopener">typora 快捷键[补充]</a></p><p>​    <a href="https://blog.csdn.net/qq_41648756/article/details/81057290#typora%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%B4%E5%90%88" target="_blank" rel="noopener">typora</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;插入表格&lt;/td&gt;
&lt;td&gt;Ctrl+T&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;关闭&lt;/td&gt;
&lt;td&gt;Ctrl+W&lt;/t
      
    
    </summary>
    
      <category term="快捷键" scheme="http://yoursite.com/categories/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
    
      <category term="快捷键" scheme="http://yoursite.com/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>Java常用类---StringUtils</title>
    <link href="http://yoursite.com/2019/03/20/Java%E5%B8%B8%E7%94%A8%E7%B1%BB---StringUtils/"/>
    <id>http://yoursite.com/2019/03/20/Java常用类---StringUtils/</id>
    <published>2019-03-20T12:53:27.000Z</published>
    <updated>2019-03-22T11:39:22.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-转换"><a href="#一-转换" class="headerlink" title="一. 转换"></a>一. 转换</h1><blockquote><p> <code>StringUtils</code> 中涉及大小写转换以及判断字符串大小写的方法</p></blockquote><a id="more"></a><h3 id="1-1-字符串首字母大小写转换"><a href="#1-1-字符串首字母大小写转换" class="headerlink" title="1.1 字符串首字母大小写转换"></a>1.1 字符串首字母大小写转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.capitalize(<span class="keyword">null</span>)); <span class="comment">// null (注意此处不会报异常)</span></span><br><span class="line">StringUtils.capitalize(<span class="string">"china"</span>)); <span class="comment">// China (首字母转大写)</span></span><br><span class="line"></span><br><span class="line">StringUtils.uncapitalize(<span class="keyword">null</span>)); <span class="comment">// null  </span></span><br><span class="line">StringUtils.uncapitalize(<span class="string">"CHINA"</span>)); <span class="comment">// cHINA (首字母转小写)</span></span><br></pre></td></tr></table></figure><h3 id="1-2-字符串整体大小写转换"><a href="#1-2-字符串整体大小写转换" class="headerlink" title="1.2 字符串整体大小写转换"></a>1.2 字符串整体大小写转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.upperCase(<span class="keyword">null</span>)); <span class="comment">// null</span></span><br><span class="line">StringUtils.upperCase(<span class="string">"china"</span>)); <span class="comment">// CHINA (全部转为大写)</span></span><br><span class="line">StringUtils.upperCase(<span class="string">"china"</span>, Locale.ENGLISH)); <span class="comment">// CHINA (按照指定规则转换为大写)</span></span><br><span class="line"></span><br><span class="line">StringUtils.lowerCase(<span class="keyword">null</span>)); <span class="comment">// null</span></span><br><span class="line">StringUtils.lowerCase(<span class="string">"CHINA"</span>)); <span class="comment">// china (全部转换为小写)</span></span><br><span class="line">StringUtils.lowerCase(<span class="string">"CHINA"</span>, Locale.ENGLISH)); <span class="comment">// china (按照指定转换规则转换为小写)</span></span><br></pre></td></tr></table></figure><h3 id="1-3-字符串大小写互换"><a href="#1-3-字符串大小写互换" class="headerlink" title="1.3 字符串大小写互换"></a>1.3 字符串大小写互换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.swapCase(<span class="keyword">null</span>)); <span class="comment">// null</span></span><br><span class="line">StringUtils.swapCase(<span class="string">"chINA"</span>)); <span class="comment">// CHina</span></span><br></pre></td></tr></table></figure><h3 id="1-4-判断字符串是否全部是大写或小写-空或空白符均为false"><a href="#1-4-判断字符串是否全部是大写或小写-空或空白符均为false" class="headerlink" title="1.4 判断字符串是否全部是大写或小写(空或空白符均为false)"></a>1.4 判断字符串是否全部是大写或小写(空或空白符均为false)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.isAllUpperCase(<span class="keyword">null</span>)); <span class="comment">// false</span></span><br><span class="line">StringUtils.isAllUpperCase(<span class="string">""</span>)); <span class="comment">// false</span></span><br><span class="line">StringUtils.isAllUpperCase(<span class="string">" "</span>)); <span class="comment">// false</span></span><br><span class="line">StringUtils.isAllUpperCase(<span class="string">"CHINA"</span>)); <span class="comment">// true</span></span><br><span class="line">StringUtils.isAllLowerCase(<span class="keyword">null</span>)); <span class="comment">// false</span></span><br><span class="line">StringUtils.isAllLowerCase(<span class="string">""</span>)); <span class="comment">// false</span></span><br><span class="line">StringUtils.isAllLowerCase(<span class="string">" "</span>)); <span class="comment">// false</span></span><br><span class="line">StringUtils.isAllLowerCase(<span class="string">"china"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="二-移除"><a href="#二-移除" class="headerlink" title="二. 移除"></a>二. 移除</h1><p>  从字符串中<strong>移除匹配的字符或字符序列</strong>，如果要移除的字符或字符序列在字符串中不存在，即无匹配，则不进行移除</p><h3 id="2-1-移除单个字符"><a href="#2-1-移除单个字符" class="headerlink" title="2.1 移除单个字符"></a>2.1 移除单个字符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.remove(<span class="keyword">null</span>, <span class="string">'a'</span>)); <span class="comment">// null (注意此处及下一行为null)</span></span><br><span class="line">StringUtils.remove(<span class="string">'china'</span>, <span class="keyword">null</span>) <span class="comment">// china </span></span><br><span class="line">StringUtils.remove(<span class="string">"china"</span>, <span class="string">'i'</span>)); <span class="comment">// chna</span></span><br><span class="line">StringUtils.remove(<span class="string">"china"</span>, <span class="string">'b'</span>)); <span class="comment">// china (如果要移除的字符不存在，则返回原字符串</span></span><br></pre></td></tr></table></figure><h3 id="2-2-移除指定字符序列"><a href="#2-2-移除指定字符序列" class="headerlink" title="2.2 移除指定字符序列"></a>2.2 移除指定字符序列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.remove(<span class="string">"china"</span>, <span class="string">"in"</span>)); <span class="comment">// cha</span></span><br><span class="line">StringUtils.remove(<span class="string">"china"</span>, <span class="string">"nin"</span>)); <span class="comment">// 没有匹配到字符串, china</span></span><br></pre></td></tr></table></figure><h3 id="2-3-移除开头匹配的字符序列"><a href="#2-3-移除开头匹配的字符序列" class="headerlink" title="2.3 移除开头匹配的字符序列"></a>2.3 移除开头匹配的字符序列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.removeStart(<span class="string">"china"</span>, <span class="string">"ch"</span>)); <span class="comment">// ina</span></span><br><span class="line">StringUtils.removeStartIgnoreCase(<span class="string">"china"</span>, <span class="string">"CHI"</span>)); <span class="comment">// na (忽略大小写)</span></span><br></pre></td></tr></table></figure><h3 id="2-4-移除结尾匹配的字符序列"><a href="#2-4-移除结尾匹配的字符序列" class="headerlink" title="2.4 移除结尾匹配的字符序列"></a>2.4 移除结尾匹配的字符序列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.removeEnd(<span class="string">"china"</span>, <span class="string">"na"</span>)); <span class="comment">// chi</span></span><br><span class="line">StringUtils.removeEndIgnoreCase(<span class="string">"china"</span>, <span class="string">"NA"</span>)); <span class="comment">// chi (忽略大小写)</span></span><br></pre></td></tr></table></figure><h3 id="2-5-移除空白字符"><a href="#2-5-移除空白字符" class="headerlink" title="2.5 移除空白字符"></a>2.5 移除空白字符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.deleteWhitespace(<span class="keyword">null</span>)); <span class="comment">// null</span></span><br><span class="line">StringUtils.deleteWhitespace(<span class="string">" c h  i\tn\ra"</span>)); <span class="comment">// china</span></span><br></pre></td></tr></table></figure><h1 id="三-替换"><a href="#三-替换" class="headerlink" title="三. 替换"></a>三. 替换</h1><h1 id="四-反转"><a href="#四-反转" class="headerlink" title="四. 反转"></a>四. 反转</h1><h1 id="五-截取字符串"><a href="#五-截取字符串" class="headerlink" title="五. 截取字符串"></a>五. 截取字符串</h1><h3 id="5-1-截取指定位置的字符串"><a href="#5-1-截取指定位置的字符串" class="headerlink" title="5.1 截取指定位置的字符串"></a>5.1 截取指定位置的字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.substring(<span class="string">"hello"</span>, <span class="number">1</span>); <span class="comment">// 结果是：ello, 截取的字符串包括前面的(起始是0)</span></span><br><span class="line">StringUtils.substring(<span class="string">"hello"</span>, <span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 结果是：el, 截取的字符串不包括后面的,[1,3)</span></span><br></pre></td></tr></table></figure><h3 id="5-2-截取指定字符串之前-之后的内容"><a href="#5-2-截取指定字符串之前-之后的内容" class="headerlink" title="5.2 截取指定字符串之前/之后的内容"></a>5.2 截取指定字符串之前/之后的内容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.substringBefore(<span class="string">"helloWorld"</span>, <span class="string">"o"</span>); <span class="comment">// 结果是：hell</span></span><br><span class="line">StringUtils.substringBeforeLast(<span class="string">"helloWorld"</span>, <span class="string">"o"</span>); <span class="comment">// 结果是：helloW,一直找到最后一个指定的字符串</span></span><br><span class="line">StringUtils.substringAfter(<span class="string">"helloWorld"</span>, <span class="string">"o"</span>);  <span class="comment">// 结果是：World</span></span><br><span class="line">StringUtils.substringAfterLast(<span class="string">"helloWorld"</span>, <span class="string">"o"</span>);<span class="comment">// 结果是：rld</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 总结: 带有 Last 的都是找到最后一个字符</span></span><br></pre></td></tr></table></figure><h3 id="5-3-截取参数2和参数3中间的字符"><a href="#5-3-截取参数2和参数3中间的字符" class="headerlink" title="5.3 截取参数2和参数3中间的字符"></a>5.3 截取参数2和参数3中间的字符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.substringBetween(<span class="string">"hello_world_I_love_you"</span>, <span class="string">"_"</span>, <span class="string">"_"</span>);</span><br><span class="line"><span class="comment">// 结果是: world</span></span><br><span class="line">StringUtils.substringsBetween(<span class="string">"hello_world_I_love_you"</span>, <span class="string">"_"</span>, <span class="string">"_"</span>);</span><br><span class="line"><span class="comment">// 返回的是一个数组,循环遍历,打印结果为: world love</span></span><br></pre></td></tr></table></figure><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://blog.csdn.net/lh_qq/article/details/80242842" target="_blank" rel="noopener">java StringUtils截取字符串</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-转换&quot;&gt;&lt;a href=&quot;#一-转换&quot; class=&quot;headerlink&quot; title=&quot;一. 转换&quot;&gt;&lt;/a&gt;一. 转换&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; &lt;code&gt;StringUtils&lt;/code&gt; 中涉及大小写转换以及判断字符串大小写的方法&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java常用类" scheme="http://yoursite.com/categories/java%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java常用类" scheme="http://yoursite.com/tags/java%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---String类(2)</title>
    <link href="http://yoursite.com/2019/03/20/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---String%E7%B1%BB(2)/"/>
    <id>http://yoursite.com/2019/03/20/Java基础知识---String类(2)/</id>
    <published>2019-03-20T12:53:27.000Z</published>
    <updated>2019-03-21T00:49:45.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-String常用方法"><a href="#一-String常用方法" class="headerlink" title="一. String常用方法"></a>一. String常用方法</h1><h2 id="1-1-基本操作"><a href="#1-1-基本操作" class="headerlink" title="1.1 基本操作"></a>1.1 基本操作</h2><ul><li><strong>int length()</strong> : 获取字符串的长度</li><li><strong>int index(int ch)</strong> : 返回指定字符串在此字符串中第一次出现的索引</li><li><strong>int lastIndexOf(int ch)</strong> : 返回指定字符在此字符串中最后一次出现的索引</li><li><strong>char charAt(int index)</strong> : 返回字符串中index位置上的字符,其中index的取值范围是:0 ~ (length-1)<a id="more"></a></li></ul><h2 id="1-2-转换操作"><a href="#1-2-转换操作" class="headerlink" title="1.2 转换操作"></a>1.2 转换操作</h2><h2 id="1-3-替换与去除"><a href="#1-3-替换与去除" class="headerlink" title="1.3 替换与去除"></a>1.3 替换与去除</h2><h2 id="1-4-截取和分割"><a href="#1-4-截取和分割" class="headerlink" title="1.4 截取和分割"></a>1.4 截取和分割</h2><ul><li><strong>String[] split(String reges)</strong> : 根据参数regex将原来的字符串分割为若干个字符串</li><li><strong>String substring(int beginIndex)</strong>: 截取从索引 beginIndex后的所有字符</li><li><strong>String substring(int beginIndex, int endIndex)</strong>: 截取从索引 beginIndex 到 endIndex 索引之间字符</li></ul><h2 id="1-5-判断操作"><a href="#1-5-判断操作" class="headerlink" title="1.5 判断操作"></a>1.5 判断操作</h2><ul><li><strong>boolean startWith(String prefix)</strong> : 判断此字符串是否以指定的字符串开始</li><li><strong>boolean endWith(String prefix)</strong> : 判断此字符串是否以指定的字符串j结束</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><strong>Remove(int startIndex)</strong>：删除此字符串中从指定位置到最后位置的所有字符</li></ul><h1 id="StringUtils"><a href="#StringUtils" class="headerlink" title="StringUtils"></a>StringUtils</h1><p><a href="https://blog.csdn.net/qq_39964694/article/details/80338734" target="_blank" rel="noopener">StringUtils类常用方法：转换、移除、替换、反转</a></p><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/zhangyinhua/p/7689974.html" target="_blank" rel="noopener">Java常用类（二）String类详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-String常用方法&quot;&gt;&lt;a href=&quot;#一-String常用方法&quot; class=&quot;headerlink&quot; title=&quot;一. String常用方法&quot;&gt;&lt;/a&gt;一. String常用方法&lt;/h1&gt;&lt;h2 id=&quot;1-1-基本操作&quot;&gt;&lt;a href=&quot;#1-1-基本操作&quot; class=&quot;headerlink&quot; title=&quot;1.1 基本操作&quot;&gt;&lt;/a&gt;1.1 基本操作&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;int length()&lt;/strong&gt; : 获取字符串的长度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;int index(int ch)&lt;/strong&gt; : 返回指定字符串在此字符串中第一次出现的索引&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;int lastIndexOf(int ch)&lt;/strong&gt; : 返回指定字符在此字符串中最后一次出现的索引&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;char charAt(int index)&lt;/strong&gt; : 返回字符串中index位置上的字符,其中index的取值范围是:0 ~ (length-1)&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---String类(深入理解)</title>
    <link href="http://yoursite.com/2019/03/20/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---String%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/03/20/Java基础知识---String类/</id>
    <published>2019-03-20T12:53:27.000Z</published>
    <updated>2019-03-20T15:05:11.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-String类"><a href="#一-String类" class="headerlink" title="一. String类"></a>一. String类</h1><h3 id="1-1-源码-String成员属性"><a href="#1-1-源码-String成员属性" class="headerlink" title="1.1 源码(String成员属性)"></a>1.1 源码(String成员属性)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可以看出"><a href="#可以看出" class="headerlink" title="可以看出"></a>可以看出</h4><ol><li><p>String类是 <strong>final 类</strong>，也即意味着String类<strong>不能被继承</strong>，并且它的成员方法都<strong>默认为final方法</strong>。在Java中，被final修饰的类是<strong>不允许被继承的</strong>，并且该类中的成员方法都默认为final方法</p></li><li><p>上面列举出了String类中一些的成员属性，从上面可以看出String类其实是<strong>通过char数组来保存字符串的</strong></p></li></ol><h3 id="1-2-源码-String方法"><a href="#1-2-源码-String方法" class="headerlink" title="1.2 源码(String方法)"></a>1.2 源码(String方法)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endIndex &gt; count) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &gt; endIndex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex - beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == count)) ? <span class="keyword">this</span> :</span><br><span class="line">        <span class="keyword">new</span> String(offset + beginIndex, endIndex - beginIndex, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[count + otherLen];</span><br><span class="line">    getChars(<span class="number">0</span>, count, buf, <span class="number">0</span>);</span><br><span class="line">    str.getChars(<span class="number">0</span>, otherLen, buf, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(<span class="number">0</span>, count + otherLen, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可以看出-1"><a href="#可以看出-1" class="headerlink" title="可以看出"></a>可以看出</h4><ol><li><p>无论是sub操做还是concat都<strong>不是在原有的字符串上进行的</strong>，而是<strong>重新生成了一个新的字符串对象</strong>。也就是说进行这些操作后，最原始的字符串并没有被改变。</p></li><li><p>在这里要永远记住一点：<strong>“String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”</strong>。</p></li></ol><h1 id="二-字符串常量池"><a href="#二-字符串常量池" class="headerlink" title="二. 字符串常量池"></a>二. 字符串常量池</h1><p>​      我们知道字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。</p><p>​    JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：<strong>使用字符串常量池</strong>。<strong>每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串</strong>（这点对理解上面至关重要）。</p><p>​    Java中的常量池，实际上分为两种形态：<strong>静态常量池</strong>和<strong>运行时常量池</strong>。</p><ul><li><strong>静态常量池</strong>，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。</li><li><strong>运行时常量池</strong>，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，<strong>我们常说的常量池，就是指方法区中的运行时常量池</strong>。</li></ul><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String a = <span class="string">"chenssy"</span>;</span><br><span class="line">String b = <span class="string">"chenssy"</span>;</span><br><span class="line"></span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">"chenssy"</span>);</span><br></pre></td></tr></table></figure><p>a, b(保存在栈中)和字面上的chenssy都是<strong>指向JVM字符串常量池中的”chenssy”对象</strong>，他们指向同一个对象</p><p>​    new关键字一定会<strong>产生一个对象chenssy</strong>（注意这个chenssy和上面的chenssy<strong>不同</strong>），同时这个对象是<strong>存储在堆</strong>中。所以上面应该产生了两个对象：保存在栈中的c和保存堆中chenssy。但是在Java中根本就不存在两个完全一模一样的字符串对象。故<strong>堆中的chenssy应该是引用字符串常量池中chenssy</strong>。所以c、chenssy、池chenssy的关系应该是：c —&gt; chenssy —&gt; 池chenssy。所以我们修改内存中的值，他变化的是<strong>所有</strong>。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><blockquote><p>栈: a, b, c      堆: chenssy(c指向的对象)    JVM字符串常量: chenssy</p></blockquote><p>虽然a、b、c、chenssy是不同的对象，但是从String的内部结构我们是可以理解上面的。String  c = new  String(“chenssy”);虽然c的内容是创建在堆中，但是他的内部value还是指向JVM常量池的chenssy的value，它构造chenssy时所用的参数依然是chenssy字符串常量。</p><h5 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用字面值的方式赋值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str1=<span class="string">"aaa"</span>;</span><br><span class="line">    String str2=<span class="string">"aaa"</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(str1==str2);<span class="comment">// true 可以看出str1跟str2是指向同一个对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，<strong>结果为：true</strong><br>分析：</p><ol><li><p>当执行 <code>String str1=&quot;aaa&quot;</code> 时，JVM首先会<strong>去字符串池中查找</strong>是否存在”aaa”这个对象</p><ul><li><p>如果不存在，则在字符串池中创建”aaa”这个对象然后将池中”aaa”这个对象的引用地址返回给字符串常量str1，这样str1会指向池中”aaa”这个字符串对象；</p></li><li><p>如果存在，则不创建任何对象，直接将池中”aaa”这个对象的地址返回，赋给字符串常量。</p></li></ul></li><li>当创建字符串对象str2时，字符串池中已经存在”aaa”这个对象，直接把<strong>对象”aaa”的引用地址返回给str2，这样str2指向了池中”aaa”这个对象</strong>，也就是说str1和str2<strong>指向了同一个对象</strong>，因此语句 <code>System.out.println(str1 == str2)</code> 输出：true</li></ol><h5 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用new关键字新建一个字符串对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str3 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">    String str4 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(str3==str4);<span class="comment">// false 可以看出用new的方式是生成不同的对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，<strong>结果为：false</strong></p><p>分析： </p><ol><li>采用new关键字新建一个字符串对象时，JVM首先在<strong>字符串池中查找</strong>有没有”aaa”这个字符串对象，<ul><li>如果有，则不在池中再去创建”aaa”这个对象了，直接<strong>在堆中创建一个”aaa”字符串对象，然后将堆中的这个”aaa”对象的地址返回赋给引用str3</strong>，这样，str3就指向了堆中创建的这个”aaa”字符串对象；</li><li>如果没有，则首先在字符串池中创建一个”aaa”字符串对象，然后再在堆中创建一个”aaa”字符串对象，然后将堆中这个”aaa”字符串对象的地址返回赋给str3引用，这样，str3指向了堆中创建的这个”aaa”字符串对象。</li></ul></li><li>当执行 <code>String  str4=new  String(&quot;aaa&quot;)</code> 时， 因为采用 new 关键字创建对象时，每次new出来的都是一个新的对象，也即是说引用<strong>str3和str4指向的是两个不同的对象</strong>，因此语句 <code>System.out.println(str3  == str4)</code> 输出：false</li></ol><h5 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译期确定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s0 = <span class="string">"helloworld"</span>;</span><br><span class="line">    String s1 = <span class="string">"helloworld"</span>;</span><br><span class="line">    String s2 = <span class="string">"hello"</span>+<span class="string">"world"</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(s0==s1); <span class="comment">//true 可以看出s0跟s1是指向同一个对象 </span></span><br><span class="line">    System.out.println(s0==s2); <span class="comment">//true 可以看出s0跟s2是指向同一个对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，<strong>结果为：true、true</strong></p><p>分析：</p><ol><li>s0和s1中的”helloworld”都是字符串常量，它们在编译期就被确定了，所以 <code>s0==s1</code> 为true；</li><li>“hello” 和 “world” 也都是字符串常量，当一个字符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以<strong>s2也同样在编译期就被解析为一个字符串常量，所以s2也是常量池中”helloworld”的一个引用</strong>。所以我们得出 <code>s0==s1==s2</code></li></ol><h5 id="例子4"><a href="#例子4" class="headerlink" title="例子4"></a>例子4</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译期无法确定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s0 = <span class="string">"helloworld"</span>; </span><br><span class="line">    String s1 = <span class="keyword">new</span> String(<span class="string">"helloworld"</span>); </span><br><span class="line">    String s2 = <span class="string">"hello"</span> + <span class="keyword">new</span> String(<span class="string">"world"</span>); </span><br><span class="line"></span><br><span class="line">    System.out.println( s0==s1 ); <span class="comment">// false  </span></span><br><span class="line">    System.out.println( s0==s2 ); <span class="comment">// false </span></span><br><span class="line">    System.out.println( s1==s2 ); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，<strong>结果为：false、false、false</strong></p><p>分析：</p><ol><li><p>用 <code>new String()</code> 创建的<strong>字符串不是常量</strong>，不能在编译期就确定，所以new String() 创建的字符串<strong>不放入常量池中</strong>，它们有自己的地址空间(在堆中,堆中的对象又指向常量池中的字符串)</p></li><li><p>s0 还是常量池中”helloworld”的引用，s1因为无法在编译期确定，所以是运行时创建的新对象”helloworld”的引用，s2因为有后半部分new  String(”world”)所以也无法在编译期确定，所以也是一个新创建对象”helloworld”的引用</p></li></ol><h5 id="例子5"><a href="#例子5" class="headerlink" title="例子5"></a>例子5</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 继续-编译期无法确定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str1=<span class="string">"abc"</span>;   </span><br><span class="line">    String str2=<span class="string">"def"</span>;   </span><br><span class="line">    String str3=str1+str2;</span><br><span class="line"></span><br><span class="line">    System.out.println(str3==<span class="string">"abcdef"</span>); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，<strong>结果为：false</strong></p><p>分析：</p><ol><li>因为str3指向<strong>堆中的</strong>“abcdef”对象，而”abcdef”是<strong>字符串池中的</strong>对象，所以结果为false</li><li>JVM 对 <code>String str=&quot;abc&quot;</code> 对象放在常量池中是在编译时做的，而 <code>String str3=str1+str2</code> 是在<strong>运行时刻才能知道的</strong>。new对象也是在运行时才做的</li><li><strong><code>+</code></strong> 运算符会在堆中建立来两个String对象，这两个对象的值分别是”abc”和”def”，也就是说<strong>从字符串池中复制这两个值，然后在堆中创建两个对象</strong>，然后再建立对象str3,然后将”abcdef”的堆地址赋给str3。</li></ol><h5 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h5><ol><li><p>栈中开辟一块中间存放引用str1，str1指向池中String常量”abc”。 </p></li><li><p>栈中开辟一块中间存放引用str2，str2指向池中String常量”def”。 </p></li><li><p>栈中开辟一块中间存放引用str3。</p></li><li><p>str1 + str2通过StringBuilder的最后一步toString()方法还原一个新的String对象”abcdef”，因此堆中开辟一块空间存放此对象。</p></li><li><p>引用str3指向堆中(str1 + str2)所还原的新String对象。 </p></li><li><p>str3指向的对象在堆中，而常量”abcdef”在池中，输出为false。</p></li><li><p>最后: </p><blockquote><p>栈中: 3个, str1, str2, str3</p><p>字符串池中: 3个, “abc”, “def”, “abcdef”</p><p>堆中: 3个, str1, str2, (str1+str2)</p></blockquote></li></ol><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xiaoxi/p/6036701.html" target="_blank" rel="noopener">深入理解Java中的String</a>    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-String类&quot;&gt;&lt;a href=&quot;#一-String类&quot; class=&quot;headerlink&quot; title=&quot;一. String类&quot;&gt;&lt;/a&gt;一. String类&lt;/h1&gt;&lt;h3 id=&quot;1-1-源码-String成员属性&quot;&gt;&lt;a href=&quot;#1-1-源码
      
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---String类(深入理解)</title>
    <link href="http://yoursite.com/2019/03/20/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---String%E7%B1%BB(%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3)/"/>
    <id>http://yoursite.com/2019/03/20/Java基础知识---String类(深入理解)/</id>
    <published>2019-03-20T12:53:27.000Z</published>
    <updated>2019-03-27T09:24:03.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-String类"><a href="#一-String类" class="headerlink" title="一. String类"></a>一. String类</h1><h3 id="1-1-源码-String成员属性"><a href="#1-1-源码-String成员属性" class="headerlink" title="1.1 源码(String成员属性)"></a>1.1 源码(String成员属性)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="可以看出"><a href="#可以看出" class="headerlink" title="可以看出"></a>可以看出</h4><ol><li><p>String类是 <strong>final 类</strong>，也即意味着String类<strong>不能被继承</strong>，并且它的成员方法都<strong>默认为final方法</strong>。在Java中，被final修饰的类是<strong>不允许被继承的</strong>，并且该类中的成员方法都默认为final方法</p></li><li><p>上面列举出了String类中一些的成员属性，从上面可以看出String类其实是<strong>通过char数组来保存字符串的</strong></p></li></ol><h3 id="1-2-源码-String方法"><a href="#1-2-源码-String方法" class="headerlink" title="1.2 源码(String方法)"></a>1.2 源码(String方法)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endIndex &gt; count) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &gt; endIndex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex - beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == count)) ? <span class="keyword">this</span> :</span><br><span class="line">        <span class="keyword">new</span> String(offset + beginIndex, endIndex - beginIndex, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[count + otherLen];</span><br><span class="line">    getChars(<span class="number">0</span>, count, buf, <span class="number">0</span>);</span><br><span class="line">    str.getChars(<span class="number">0</span>, otherLen, buf, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(<span class="number">0</span>, count + otherLen, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可以看出-1"><a href="#可以看出-1" class="headerlink" title="可以看出"></a>可以看出</h4><ol><li><p>无论是sub操做还是concat都<strong>不是在原有的字符串上进行的</strong>，而是<strong>重新生成了一个新的字符串对象</strong>。也就是说进行这些操作后，最原始的字符串并没有被改变。</p></li><li><p>在这里要永远记住一点：<strong>“String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”</strong>。</p></li></ol><h1 id="二-字符串常量池"><a href="#二-字符串常量池" class="headerlink" title="二. 字符串常量池"></a>二. 字符串常量池</h1><p>​      我们知道字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。</p><p>​    JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：<strong>使用字符串常量池</strong>。<strong>每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串</strong>（这点对理解上面至关重要）。</p><p>​    Java中的常量池，实际上分为两种形态：<strong>静态常量池</strong>和<strong>运行时常量池</strong>。</p><ul><li><strong>静态常量池</strong>，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。</li><li><strong>运行时常量池</strong>，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，<strong>我们常说的常量池，就是指方法区中的运行时常量池</strong>。</li></ul><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String a = <span class="string">"chenssy"</span>;</span><br><span class="line">String b = <span class="string">"chenssy"</span>;</span><br><span class="line"></span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">"chenssy"</span>);</span><br></pre></td></tr></table></figure><p>a, b(保存在栈中)和字面上的chenssy都是<strong>指向JVM字符串常量池中的”chenssy”对象</strong>，他们指向同一个对象</p><p>​    new关键字一定会<strong>产生一个对象chenssy</strong>（注意这个chenssy和上面的chenssy<strong>不同</strong>），同时这个对象是<strong>存储在堆</strong>中。所以上面应该产生了两个对象：保存在栈中的c和保存堆中chenssy。但是在Java中根本就不存在两个完全一模一样的字符串对象。故<strong>堆中的chenssy应该是引用字符串常量池中chenssy</strong>。所以c、chenssy、池chenssy的关系应该是：c —&gt; chenssy —&gt; 池chenssy。所以我们修改内存中的值，他变化的是<strong>所有</strong>。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><blockquote><p>栈: a, b, c      堆: chenssy(c指向的对象)    JVM字符串常量: chenssy</p></blockquote><p>虽然a、b、c、chenssy是不同的对象，但是从String的内部结构我们是可以理解上面的。String  c = new  String(“chenssy”);虽然c的内容是创建在堆中，但是他的内部value还是指向JVM常量池的chenssy的value，它构造chenssy时所用的参数依然是chenssy字符串常量。</p><h5 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用字面值的方式赋值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str1=<span class="string">"aaa"</span>;</span><br><span class="line">    String str2=<span class="string">"aaa"</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(str1==str2);<span class="comment">// true 可以看出str1跟str2是指向同一个对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，<strong>结果为：true</strong><br>分析：</p><ol><li><p>当执行 <code>String str1=&quot;aaa&quot;</code> 时，JVM首先会<strong>去字符串池中查找</strong>是否存在”aaa”这个对象</p><ul><li><p>如果不存在，则在字符串池中创建”aaa”这个对象然后将池中”aaa”这个对象的引用地址返回给字符串常量str1，这样str1会指向池中”aaa”这个字符串对象；</p></li><li><p>如果存在，则不创建任何对象，直接将池中”aaa”这个对象的地址返回，赋给字符串常量。</p></li></ul></li><li>当创建字符串对象str2时，字符串池中已经存在”aaa”这个对象，直接把<strong>对象”aaa”的引用地址返回给str2，这样str2指向了池中”aaa”这个对象</strong>，也就是说str1和str2<strong>指向了同一个对象</strong>，因此语句 <code>System.out.println(str1 == str2)</code> 输出：true</li></ol><h5 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用new关键字新建一个字符串对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str3 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">    String str4 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(str3==str4);<span class="comment">// false 可以看出用new的方式是生成不同的对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，<strong>结果为：false</strong></p><p>分析： </p><ol><li>采用new关键字新建一个字符串对象时，JVM首先在<strong>字符串池中查找</strong>有没有”aaa”这个字符串对象，<ul><li>如果有，则不在池中再去创建”aaa”这个对象了，直接<strong>在堆中创建一个”aaa”字符串对象，然后将堆中的这个”aaa”对象的地址返回赋给引用str3</strong>，这样，str3就指向了堆中创建的这个”aaa”字符串对象；</li><li>如果没有，则首先在字符串池中创建一个”aaa”字符串对象，然后再在堆中创建一个”aaa”字符串对象，然后将堆中这个”aaa”字符串对象的地址返回赋给str3引用，这样，str3指向了堆中创建的这个”aaa”字符串对象。</li></ul></li><li>当执行 <code>String  str4=new  String(&quot;aaa&quot;)</code> 时， 因为采用 new 关键字创建对象时，每次new出来的都是一个新的对象，也即是说引用<strong>str3和str4指向的是两个不同的对象</strong>，因此语句 <code>System.out.println(str3  == str4)</code> 输出：false</li></ol><h5 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译期确定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s0 = <span class="string">"helloworld"</span>;</span><br><span class="line">    String s1 = <span class="string">"helloworld"</span>;</span><br><span class="line">    String s2 = <span class="string">"hello"</span>+<span class="string">"world"</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(s0==s1); <span class="comment">//true 可以看出s0跟s1是指向同一个对象 </span></span><br><span class="line">    System.out.println(s0==s2); <span class="comment">//true 可以看出s0跟s2是指向同一个对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，<strong>结果为：true、true</strong></p><p>分析：</p><ol><li>s0和s1中的”helloworld”都是字符串常量，它们在编译期就被确定了，所以 <code>s0==s1</code> 为true；</li><li>“hello” 和 “world” 也都是字符串常量，当一个字符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以<strong>s2也同样在编译期就被解析为一个字符串常量，所以s2也是常量池中”helloworld”的一个引用</strong>。所以我们得出 <code>s0==s1==s2</code></li></ol><h5 id="例子4"><a href="#例子4" class="headerlink" title="例子4"></a>例子4</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译期无法确定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s0 = <span class="string">"helloworld"</span>; </span><br><span class="line">    String s1 = <span class="keyword">new</span> String(<span class="string">"helloworld"</span>); </span><br><span class="line">    String s2 = <span class="string">"hello"</span> + <span class="keyword">new</span> String(<span class="string">"world"</span>); </span><br><span class="line"></span><br><span class="line">    System.out.println( s0==s1 ); <span class="comment">// false  </span></span><br><span class="line">    System.out.println( s0==s2 ); <span class="comment">// false </span></span><br><span class="line">    System.out.println( s1==s2 ); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，<strong>结果为：false、false、false</strong></p><p>分析：</p><ol><li><p>用 <code>new String()</code> 创建的<strong>字符串不是常量</strong>，不能在编译期就确定，所以new String() 创建的字符串<strong>不放入常量池中</strong>，它们有自己的地址空间(在堆中,堆中的对象又指向常量池中的字符串)</p></li><li><p>s0 还是常量池中”helloworld”的引用，s1因为无法在编译期确定，所以是运行时创建的新对象”helloworld”的引用，s2因为有后半部分new  String(”world”)所以也无法在编译期确定，所以也是一个新创建对象”helloworld”的引用</p></li></ol><h5 id="例子5"><a href="#例子5" class="headerlink" title="例子5"></a>例子5</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 继续-编译期无法确定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str1=<span class="string">"abc"</span>;   </span><br><span class="line">    String str2=<span class="string">"def"</span>;   </span><br><span class="line">    String str3=str1+str2;</span><br><span class="line"></span><br><span class="line">    System.out.println(str3==<span class="string">"abcdef"</span>); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，<strong>结果为：false</strong></p><p>分析：</p><ol><li>因为str3指向<strong>堆中的</strong>“abcdef”对象，而”abcdef”是<strong>字符串池中的</strong>对象，所以结果为false</li><li>JVM 对 <code>String str=&quot;abc&quot;</code> 对象放在常量池中是在编译时做的，而 <code>String str3=str1+str2</code> 是在<strong>运行时刻才能知道的</strong>。new对象也是在运行时才做的</li><li><strong><code>+</code></strong> 运算符会在堆中建立来两个String对象，这两个对象的值分别是”abc”和”def”，也就是说<strong>从字符串池中复制这两个值，然后在堆中创建两个对象</strong>，然后再建立对象str3,然后将”abcdef”的堆地址赋给str3。</li></ol><h5 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h5><ol><li><p>栈中开辟一块中间存放引用str1，str1指向池中String常量”abc”。 </p></li><li><p>栈中开辟一块中间存放引用str2，str2指向池中String常量”def”。 </p></li><li><p>栈中开辟一块中间存放引用str3。</p></li><li><p>str1 + str2通过StringBuilder的最后一步toString()方法还原一个新的String对象”abcdef”，因此堆中开辟一块空间存放此对象。</p></li><li><p>引用str3指向堆中(str1 + str2)所还原的新String对象。 </p></li><li><p>str3指向的对象在堆中，而常量”abcdef”在池中，输出为false。</p></li><li><p>最后: </p><blockquote><p>栈中: 3个, str1, str2, str3</p><p>字符串池中: 3个, “abc”, “def”, “abcdef”</p><p>堆中: 3个, str1, str2, (str1+str2)</p></blockquote></li></ol><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xiaoxi/p/6036701.html" target="_blank" rel="noopener">深入理解Java中的String</a>    </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-String类&quot;&gt;&lt;a href=&quot;#一-String类&quot; class=&quot;headerlink&quot; title=&quot;一. String类&quot;&gt;&lt;/a&gt;一. String类&lt;/h1&gt;&lt;h3 id=&quot;1-1-源码-String成员属性&quot;&gt;&lt;a href=&quot;#1-1-源码-String成员属性&quot; class=&quot;headerlink&quot; title=&quot;1.1 源码(String成员属性)&quot;&gt;&lt;/a&gt;1.1 源码(String成员属性)&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;java&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Serializable&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Comparable&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;&amp;gt;, &lt;span class=&quot;title&quot;&gt;CharSequence&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/** The value is used for character storage. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; value[];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/** The offset is the first index of the storage that is used. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; offset;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---线程(3)</title>
    <link href="http://yoursite.com/2019/03/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E7%BA%BF%E7%A8%8B(3)/"/>
    <id>http://yoursite.com/2019/03/19/Java基础知识---线程(3)/</id>
    <published>2019-03-19T12:10:23.000Z</published>
    <updated>2019-03-20T01:19:44.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-一个典型的-Java-线程安全例子"><a href="#一-一个典型的-Java-线程安全例子" class="headerlink" title="一. 一个典型的 Java 线程安全例子"></a>一. 一个典型的 Java 线程安全例子</h1><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account(<span class="string">"123456"</span>, <span class="number">1000</span>);</span><br><span class="line">        DrawMoneyRunnable drawMoneyRunnable = <span class="keyword">new</span> DrawMoneyRunnable(account, <span class="number">700</span>);</span><br><span class="line">        Thread myThread1 = <span class="keyword">new</span> Thread(drawMoneyRunnable);</span><br><span class="line">        Thread myThread2 = <span class="keyword">new</span> Thread(drawMoneyRunnable);</span><br><span class="line">        myThread1.start();</span><br><span class="line">        myThread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DrawMoneyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">// 取钱数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> drawAmount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawMoneyRunnable</span><span class="params">(Account account, <span class="keyword">double</span> drawAmount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.drawAmount = drawAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果取钱数小于余额</span></span><br><span class="line">        <span class="keyword">if</span> (account.getBalance() &gt;= drawAmount) &#123;  <span class="comment">//1</span></span><br><span class="line">            System.out.println(<span class="string">"取钱成功， 取出钱数为："</span> + drawAmount);</span><br><span class="line">            <span class="keyword">double</span> balance = account.getBalance() - drawAmount;</span><br><span class="line">            <span class="comment">// 更新余额</span></span><br><span class="line">            account.setBalance(balance);</span><br><span class="line">            System.out.println(<span class="string">"余额为："</span> + balance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"><span class="comment">// 银行卡密码</span></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="comment">// 银行卡余额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line"><span class="comment">// 两个构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String accountNo, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// get/set 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAccountNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountNo</span><span class="params">(String accountNo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountNo = accountNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子很容易理解，有一张银行卡，里面有1000的余额，程序模拟你和你老婆同时在取款机进行取钱操作的场景。多次运行此程序，可能具有多个不同组合的输出结果。其中一种可能的输出为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">取钱成功， 取出钱数为：<span class="number">700.0</span></span><br><span class="line">余额为：<span class="number">300.0</span></span><br><span class="line">取钱成功， 取出钱数为：<span class="number">700.0</span></span><br><span class="line">余额为：<span class="number">-400.0</span></span><br></pre></td></tr></table></figure><p>对于一张只有1000余额的银行卡，你们一共可以取出1400，<strong>这显然是有问题的</strong>。</p><p>​    问题在于 <strong>Java多线程环境下的执行的不确定性</strong>。CPU可能<strong>随机的在多个处于就绪状态中的线程中进行切换</strong></p><p>​    因此，很有可能出现如下情况：当thread1执行到//1处代码时，判断条件为true，<strong>此时CPU切换到thread2，执行//1处代码，发现依然为真</strong>，然后执行完thread2，接着切换到thread1，接着执行完毕。</p><blockquote><p>讲到线程安全问题，其实是指<strong>多线程环境下对共享资源的访问可能会引起此共享资源的不一致性</strong>。因此，为避免线程安全问题，应该<strong>避免多线程环境下对此共享资源的并发访问</strong>。</p></blockquote><h1 id="二-同步方法"><a href="#二-同步方法" class="headerlink" title="二. 同步方法"></a>二. 同步方法</h1><p>对共享资源进行访问的<strong>方法定义中加上synchronized关键字修饰</strong>，使得此方法称为<strong>同步方法</strong>。</p><p>可以简单理解成对此方法<strong>进行了加锁</strong>，其锁对象为当前方法所在的对象自身。多线程环境下，当执行此方法时，首先都要获得此同步锁<strong>（且同时最多只有一个线程能够获得）</strong>，只有<strong>当线程执行完此同步方法后，才会释放锁对象，其他的线程才有可能获取此同步锁，</strong>以此类推…</p><blockquote><p>只有一个对象可以执行此方法,其他的都要在后面排队,等他使用完,其他的对象才可以使用,次方法只能同时被一个对象使用</p></blockquote><p>在上例中，共享资源为account对象，当使用同步方法时，可以解决线程安全问题。只需在<strong>run()方法前加上synshronized关键字</strong>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-同步代码块"><a href="#三-同步代码块" class="headerlink" title="三. 同步代码块"></a>三. 同步代码块</h1><p>解决线程安全问题其实只需限制对共享资源访问的不确定性即可。使用同步方法时，使得整个方法体都成为了同步执行状态，会使得可能出现同步范围过大的情况，于是，针对需要同步的代码可以直接另一种同步方式—同步代码块来解决。</p><p>同步代码块的格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;             </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<strong>obj 为锁对象</strong>，因此，选择哪一个对象作为锁是至关重要的。一般情况下，都是<strong>选择此共享资源对象作为锁对象</strong>。</p><p>如上例中，最好选用<strong>account对象作为锁对象</strong>. (当然，选用this也是可以的，那是因为创建线程使用了runnable 方式，如果是直接继承Thread方式创建的线程，使用this对象作为同步锁会其实没有起到任何作用，因为是不同的对象了。因此，选择同步锁时需要格外小心…)</p><h1 id="四-Lock-对象同步锁"><a href="#四-Lock-对象同步锁" class="headerlink" title="四.Lock 对象同步锁"></a>四.Lock 对象同步锁</h1><p>上面我们可以看出，正因为对同步锁对象的选择需要如此小心，有没有什么简单点的解决方案呢？</p><p>以方便同步锁对象与共享资源解耦，同时又能很好的解决线程安全问题。</p><p>使用 <strong>Lock对象同步锁</strong> 可以方便的解决此问题，唯一需要注意的一点是Lock对象需要与资源对象同样具有一对一的关系。Lock对象同步锁一般格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示定义Lock同步锁对象，此对象与共享资源具有一对一关系</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//...  需要进行线程安全同步的代码   </span></span><br><span class="line">        <span class="comment">// 释放Lock锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五-wait-notify-notifyAll-线程通信"><a href="#五-wait-notify-notifyAll-线程通信" class="headerlink" title="五. wait()/notify()/notifyAll()线程通信"></a>五. wait()/notify()/notifyAll()线程通信</h1><p>任何Object对象都可以作为这三个方法的主调，在实际的多线程编程中，<strong>只有同步锁对象调这三个方法</strong>，才能完成对多线程间的线程通信。Obj.wait() , 与 Obj.notify() <strong>必须要与 synchronized(Obj) 一起使用</strong>，也就是wait,与notify是针对<strong>已经获取了Obj锁</strong>进行操作.</p><ul><li><p><strong>wait()：</strong> 导致==<strong>当前线程等待</strong>==并使其进入到等待阻塞状态。直到其他线程==<strong>调用该同步锁对象</strong>==的notify()或notifyAll()方法来唤醒此线程。</p><ol><li><p>wait()方法执行后，当前线程<strong>立即进入到等待阻塞状态，其后面的代码不会执行</strong></p></li><li><p>当wait线程唤醒后并执行时，是接着上次执行到的wait()方法代码后面继续往下执行的</p></li></ol></li><li><p><strong>notify()：</strong> 唤醒在<strong>此同步锁对象</strong>上等待的单个线程，如果有多个线程都在此同步锁对象上等待，则会任意选择其中某个线程进行唤醒操作</p><ol><li><p>如果notify()/notifyAll()后面还有代码，还会继续进行，<strong>直到当前线程执行完毕</strong>才会释放同步锁对象</p></li><li><p>notify()/notifyAll()执行后，如果右面有sleep()方法，则会使当前线程进入到阻塞状态，<strong>但是同步对象锁没有释放，依然自己保留</strong>，那么一定时候后还是会继续执行此线程,接下来同上</p></li></ol></li><li><strong>notifyAll()：</strong> 唤醒在此同步锁对象上等待的<strong>所有线程</strong>，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程</li></ul><h4 id="解释wait-中的当前线程"><a href="#解释wait-中的当前线程" class="headerlink" title="解释wait()中的当前线程"></a>解释wait()中的当前线程</h4><p>​    jdk的解释中，说wait()的作用是让“当前线程”等待, <strong>而“当前线程”是指正在cpu上运行的线程！而不是这个对象进行等待.</strong></p><h4 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWait</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;     </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;     </span><br><span class="line">    <span class="keyword">private</span> Object prev;     </span><br><span class="line">    <span class="keyword">private</span> Object self;     </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TestWait</span><span class="params">(String name, Object prev, Object self)</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">this</span>.name = name;     </span><br><span class="line">        <span class="keyword">this</span>.prev = prev;     </span><br><span class="line">        <span class="keyword">this</span>.self = self;     </span><br><span class="line">    &#125;     </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">10</span>;     </span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;     </span><br><span class="line">            <span class="keyword">synchronized</span> (prev) &#123;     </span><br><span class="line">                <span class="keyword">synchronized</span> (self) &#123;     </span><br><span class="line">                    System.out.print(name + <span class="string">" "</span>);     </span><br><span class="line">                    count--;    </span><br><span class="line">                      </span><br><span class="line">                    self.notify();     </span><br><span class="line">                &#125;     </span><br><span class="line">                <span class="keyword">try</span> &#123;     </span><br><span class="line">                    prev.wait();     </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;     </span><br><span class="line">                    e.printStackTrace();     </span><br><span class="line">                &#125;     </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;     </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;     </span><br><span class="line">        Object a = <span class="keyword">new</span> Object();     </span><br><span class="line">        Object b = <span class="keyword">new</span> Object();     </span><br><span class="line">        Object c = <span class="keyword">new</span> Object();     </span><br><span class="line">        TestWait pa = <span class="keyword">new</span> TestWait(<span class="string">"A"</span>, c, a);     </span><br><span class="line">        TestWait pb = <span class="keyword">new</span> TestWait(<span class="string">"B"</span>, a, b);     </span><br><span class="line">        TestWait pc = <span class="keyword">new</span> TestWait(<span class="string">"C"</span>, b, c);     </span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line">        <span class="keyword">new</span> Thread(pa).start();  </span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);  <span class="comment">//确保按顺序A、B、C执行, 很重要</span></span><br><span class="line">        <span class="keyword">new</span> Thread(pb).start();  </span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);    </span><br><span class="line">        <span class="keyword">new</span> Thread(pc).start();     </span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);    </span><br><span class="line">        &#125;     </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印结果: A B C A B C A B C A B C A B C A B C A B C A B C A B C A B C </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h4><p>从大的方向上来讲，该问题为<strong>三线程间的同步唤醒操作</strong>，主要的目的就是 ThreadA -&gt; ThreadB -&gt; ThreadC -&gt; ThreadA 循环执行三个线程。</p><p>为了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能继续执行。一个对象锁是<strong>prev，就是前一个线程所持有的对象锁</strong>。还有一个就是<strong>自身对象锁</strong>。</p><p>主要的思想就是，为了控制执行的顺序，必须要先持有prev锁，也就前一个线程要释放自身对象锁，再去申请自身对象锁，两者兼备时打印，之后首先调用self.notify()释放自身对象锁，唤醒下一个等待线程，再调用prev.wait()释放prev对象锁，终止当前线程，等待循环结束后再次被唤醒。</p><p>看起来似乎没什么问题，但如果你仔细想一下，就会发现有问题，就是初始条件，三个线程按照A,B,C的顺序来启动，按照前面的思考，A唤醒B，B唤醒C，C再唤醒A。但是这种假设依赖于JVM中线程调度、执行的顺序。<strong>所以需要在main方法中设置sleep()方法,保证创建的顺序</strong>.</p><h3 id="为什么notify-wait-等函数定义在Object中，而不是Thread中"><a href="#为什么notify-wait-等函数定义在Object中，而不是Thread中" class="headerlink" title="为什么notify(), wait()等函数定义在Object中，而不是Thread中"></a>为什么notify(), wait()等函数定义在Object中，而不是Thread中</h3><p>notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。</p><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/skywang12345/p/3479224.html" target="_blank" rel="noopener">Java多线程系列–“基础篇”05之 线程等待与唤醒</a></p><p>​    <a href="https://www.cnblogs.com/yjd_hycf_space/p/7526608.html" target="_blank" rel="noopener">Java多线程学习（总结很详细！！！）</a></p><p>​    <a href="https://www.cnblogs.com/lwbqqyumidi/p/3821389.html" target="_blank" rel="noopener">Java总结篇系列：Java多线程（三）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-一个典型的-Java-线程安全例子&quot;&gt;&lt;a href=&quot;#一-一个典型的-Java-线程安全例子&quot; class=&quot;headerlink&quot; title=&quot;一. 一个典型的 Java 线程安全例子&quot;&gt;&lt;/a&gt;一. 一个典型的 Java 线程安全例子&lt;/h1&gt;&lt;h4 id=&quot;范例&quot;&gt;&lt;a href=&quot;#范例&quot; class=&quot;headerlink&quot; title=&quot;范例&quot;&gt;&lt;/a&gt;范例&lt;/h4&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Git---将本地项目上传到Github</title>
    <link href="http://yoursite.com/2019/03/19/Git---%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0Github/"/>
    <id>http://yoursite.com/2019/03/19/Git---将本地项目上传到Github/</id>
    <published>2019-03-19T07:20:05.000Z</published>
    <updated>2019-03-25T00:20:43.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-关键步骤"><a href="#一-关键步骤" class="headerlink" title="一. 关键步骤"></a>一. 关键步骤</h1><ol><li><p>在本地创建一个版本库（即文件夹），通过git init把它变成Git仓库；</p><p><code>git init</code></p></li><li><p>把项目复制到这个文件夹里面，再通过git add .把项目添加到仓库；</p><p><code>git add .</code></p></li></ol><a id="more"></a><ol start="3"><li><p>再通过git commit -m “注释内容”把项目提交到仓库；</p><p><code>git commit -m “first commit”</code>    </p></li><li><p>在Github上<strong>设置好SSH密钥</strong> 后，新建一个远程仓库，通过 git remote add origin <a href="https://github.com/sladning/test" target="_blank" rel="noopener">https://github.com/sladning/test</a> 将本地仓库和远程仓库进行关联；</p><p><code>git remote add origin https://github.com/sladning/test</code></p></li><li><ul><li><p>最后通过 git push -u origin master <strong>把本地仓库的项目推送到远程仓库</strong>（也就是Github）上；（若新建远程仓库的时候自动创建了README文件会报错，解决办法看下面）。</p><p><code>git push -u origin master</code></p></li><li><p>由于新建的远程仓库<strong>是空的</strong>，所以要<strong>加上-u这个参数</strong>，等远程仓库里面<strong>有了内容之后</strong>，下次再从本地库上传内容的时候<strong>只需下面</strong>这样就可以了</p><p><code>git push origin master</code></p></li></ul></li></ol><h1 id="二-注"><a href="#二-注" class="headerlink" title="二. 注"></a>二. 注</h1><h4 id="关于-README-md"><a href="#关于-README-md" class="headerlink" title="关于 README.md"></a>关于 <strong>README.md</strong></h4><ol><li><p>创建远程仓库的时候，如果你<strong>勾选了Initialize this repository with a README</strong>（就是创建仓库的时候自动给你创建一个README文件）</p></li><li><p>那么到了将本地仓库内容推送到远程仓库的时候就会<strong>报一个failed to push some refs to  <a href="https://github.com/guyibang/TEST2.git的错" target="_blank" rel="noopener">https://github.com/guyibang/TEST2.git的错</a></strong></p></li><li>这是由于你新创建的那个仓库里面的README文件不在本地仓库目录中，这时我们可以通过以下命令先将内容合并以下：<code>git pull --rebase origin master</code></li><li>再push就能成功了。</li></ol><hr><p>参考博文:</p><p>​    <a href="https://blog.csdn.net/zamamiro/article/details/70172900" target="_blank" rel="noopener">Git的使用–如何将本地项目上传到Github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-关键步骤&quot;&gt;&lt;a href=&quot;#一-关键步骤&quot; class=&quot;headerlink&quot; title=&quot;一. 关键步骤&quot;&gt;&lt;/a&gt;一. 关键步骤&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在本地创建一个版本库（即文件夹），通过git init把它变成Git仓库；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git init&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把项目复制到这个文件夹里面，再通过git add .把项目添加到仓库；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git add .&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---EL表达式</title>
    <link href="http://yoursite.com/2019/03/19/JavaWeb---EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/19/JavaWeb---EL表达式/</id>
    <published>2019-03-19T03:26:27.000Z</published>
    <updated>2019-03-21T14:58:06.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-EL表达式简介"><a href="#一-EL表达式简介" class="headerlink" title="一. EL表达式简介"></a>一. EL表达式简介</h1><p>　　EL 全名为 <strong>Expression Language</strong>。</p><a id="more"></a><h4 id="EL主要作用："><a href="#EL主要作用：" class="headerlink" title="EL主要作用："></a>EL主要作用：</h4><ol><li><strong>获取数据</strong><br>EL表达式主要用于<strong>替换 JSP 页面中的脚本表达式</strong>，以从各种类型的web域中<strong>检索 java 对象、获取数据</strong>。(某个web域 中的对象，访问javabean的属性、访问list集合、访问map集合、访问数组)</li><li><strong>执行运算</strong><br>利用 EL 表达式可以在JSP页面中执行一些基本的关系运算、逻辑运算和算术运算，以<strong>在JSP页面中完成一些简单的逻辑运算</strong>。${user==null}</li><li><strong>获取web开发常用对象</strong><br>EL 表达式<strong>定义了一些隐式对象，利用这些隐式对象</strong>，web开发人员可以很轻松获得对web常用对象的引用，从而获得这些对象中的数据。</li><li><strong>调用Java方法</strong><br>EL表达式允许用户开发自定义EL函数，以在JSP页面中通过EL表达式调用Java类的方法。</li></ol><h1 id="二-获取数据"><a href="#二-获取数据" class="headerlink" title="二. 获取数据"></a>二. 获取数据</h1><p>　　使用EL表达式获取数据语法：<strong><code>${标识符}</code></strong><br>　　EL表达式语句在执行时，会调用 <strong>pageContext.findAttribute 方法</strong>，用 标识符 为关键字，分别从<strong>page、request、session、application</strong>四个域中查找相应的对象，找到则返回相应对象，找不到则返回 ””  （注意，<strong>不是null，而是空字符串</strong>）。</p><p>　　EL表达式可以很轻松<strong>获取JavaBean的属性</strong>，或获取数组、Collection、Map类型集合的数据</p><h2 id="2-1-获取-JavaBean-的属性"><a href="#2-1-获取-JavaBean-的属性" class="headerlink" title="2.1 获取 JavaBean 的属性"></a>2.1 获取 JavaBean 的属性</h2><p>通过 <strong><code>.</code></strong> 符号操作就可以了。</p><p>如<code>${hero.name}</code> ，</p><ul><li><p>如果属性是<strong>非boolean类型</strong>, 会自动调用 <strong>getXXX</strong> 方法</p></li><li><p>如果属性是<strong>boolean类型</strong>，会自动调用 <strong>isXXX</strong> 方法</p></li></ul><h5 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person 的 JavaBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 姓名 String类型</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//是否已婚 boolean类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> married;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMarried</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> married;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMarried</span><span class="params">(<span class="keyword">boolean</span> married)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.married = married;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- 在jsp页面中，使用el表达式可以获取bean的属性 --&gt;</span><br><span class="line">    &lt;% </span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.setName(<span class="string">"Mike"</span>);</span><br><span class="line">    p.setMarried(True);</span><br><span class="line">        request.setAttribute(<span class="string">"person"</span>,p);</span><br><span class="line">    %&gt;</span><br><span class="line">        使用el表达式可以获取bean的属性：$&#123;person.name&#125;, $&#123;person.married&#125;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h4 id="el表达式获取数据范例"><a href="#el表达式获取数据范例" class="headerlink" title="el表达式获取数据范例"></a>el表达式获取数据范例</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;% </span><br><span class="line">    request.setAttribute(<span class="string">"name"</span>,<span class="string">"孤傲苍狼"</span>);</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;%--$&#123;name&#125;等同于pageContext.findAttribute(<span class="string">"name"</span>) --%&gt;</span><br><span class="line">    使用EL表达式获取数据：$&#123;name&#125;  </span><br><span class="line"></span><br><span class="line">    &lt;hr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;!-- 在jsp页面中，使用el表达式可以获取bean中的。。。。。。。。。的属性 --&gt;</span><br><span class="line">    &lt;% </span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    Address address = <span class="keyword">new</span> Address();</span><br><span class="line">    person.setAddress(address);</span><br><span class="line"></span><br><span class="line">    request.setAttribute(<span class="string">"person"</span>,person);</span><br><span class="line">    %&gt;</span><br><span class="line">    $&#123;person.address.name&#125;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 在jsp页面中，使用el表达式获取list集合中指定位置的数据 --&gt;</span><br><span class="line">    &lt;% </span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">    p1.setName(<span class="string">"孤傲苍狼"</span>);</span><br><span class="line"></span><br><span class="line">    Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">    p2.setName(<span class="string">"白虎神皇"</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">    list.add(p1);</span><br><span class="line">    list.add(p2);</span><br><span class="line"></span><br><span class="line">    request.setAttribute(<span class="string">"list"</span>,list);</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;!-- 取list指定位置的数据 --&gt;</span><br><span class="line">    $&#123;list[<span class="number">1</span>].name&#125; </span><br><span class="line"></span><br><span class="line">    &lt;!-- 迭代List集合 --&gt;</span><br><span class="line">    &lt;c:forEach <span class="keyword">var</span>=<span class="string">"person"</span> items=<span class="string">"$&#123;list&#125;"</span>&gt;</span><br><span class="line">        $&#123;person.name&#125;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 在jsp页面中，使用el表达式获取map集合的数据 --&gt;</span><br><span class="line">    &lt;% </span><br><span class="line">    Map&lt;String,String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String,String&gt;();</span><br><span class="line">    map.put(<span class="string">"a"</span>,<span class="string">"aaaaxxx"</span>);</span><br><span class="line">    map.put(<span class="string">"b"</span>,<span class="string">"bbbb"</span>);</span><br><span class="line">    map.put(<span class="string">"c"</span>,<span class="string">"cccc"</span>);</span><br><span class="line">    map.put(<span class="string">"1"</span>,<span class="string">"aaaa1111"</span>);</span><br><span class="line">    request.setAttribute(<span class="string">"map"</span>,map);</span><br><span class="line">    %&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 根据关键字取map集合的数据 --&gt;</span><br><span class="line">    $&#123;map.c&#125;  </span><br><span class="line">    $&#123;map[<span class="string">"1"</span>]&#125;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;!-- 迭代Map集合 --&gt;</span><br><span class="line">    &lt;c:forEach <span class="keyword">var</span>=<span class="string">"me"</span> items=<span class="string">"$&#123;map&#125;"</span>&gt;</span><br><span class="line">        $&#123;me.key&#125;=$&#123;me.value&#125;&lt;br/&gt;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="1-7、EL注意事项"><a href="#1-7、EL注意事项" class="headerlink" title="1.7、EL注意事项"></a>1.7、EL注意事项</h3><p>　　EL表达式是JSP 2.0规范中的一门技术 。因此，若想正确解析EL表达式，需使用支持Servlet2.4/JSP2.0技术的WEB服务器。<br>注意：有些Tomcat服务器如不能使用EL表达式<br>    （1）升级成tomcat6<br>    （2）在 JSP 中加入<strong>&lt;%@ page isELIgnored=”false” %&gt;</strong></p><h3 id="1-8、EL表达式保留关键字"><a href="#1-8、EL表达式保留关键字" class="headerlink" title="1.8、EL表达式保留关键字"></a>1.8、EL表达式保留关键字</h3><table><thead><tr><th>And</th><th>eq</th><th>gt</th><th>true</th></tr></thead><tbody><tr><td>Or</td><td>ne</td><td>le</td><td>false</td></tr><tr><td>No</td><td>lt</td><td>ge</td><td>null</td></tr><tr><td>instanceof</td><td>empty</td><td>div</td><td>mod</td></tr></tbody></table><p>​    保留字的意思是指变量在命名时，应该<strong>避开上述的名字</strong>，以免程序编译时发生错误，关于EL表达式的内容的总结就这么多。</p><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3938361.html" target="_blank" rel="noopener">javaweb学习总结(二十九)——EL表达式</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-EL表达式简介&quot;&gt;&lt;a href=&quot;#一-EL表达式简介&quot; class=&quot;headerlink&quot; title=&quot;一. EL表达式简介&quot;&gt;&lt;/a&gt;一. EL表达式简介&lt;/h1&gt;&lt;p&gt;　　EL 全名为 &lt;strong&gt;Expression Language&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---JSTL标签库之核心标签</title>
    <link href="http://yoursite.com/2019/03/19/JavaWeb---JSTL%E6%A0%87%E7%AD%BE%E5%BA%93%E4%B9%8B%E6%A0%B8%E5%BF%83%E6%A0%87%E7%AD%BE/"/>
    <id>http://yoursite.com/2019/03/19/JavaWeb---JSTL标签库之核心标签/</id>
    <published>2019-03-19T02:40:27.000Z</published>
    <updated>2019-04-04T08:54:43.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-JSTL标签库介绍"><a href="#一-JSTL标签库介绍" class="headerlink" title="一. JSTL标签库介绍　　"></a>一. JSTL标签库介绍　　</h1><p>　　JSTL标签库的使用是<strong>为弥补 html 标签的不足</strong>，规范自定义标签的使用而诞生的,是一个 JSP 的标签集合, 使用 JSLT 标签的目的就是 <strong>不希望在 jsp 页面中出现 java 逻辑代码</strong></p><a id="more"></a><h1 id="二-JSTL标签库的分类"><a href="#二-JSTL标签库的分类" class="headerlink" title="二. JSTL标签库的分类"></a>二. JSTL标签库的分类</h1><ul><li>核心标签(用得最多)</li><li>国际化标签(I18N格式化标签)</li><li>数据库标签(SQL标签，很少使用)</li><li>XML标签(几乎不用)</li><li>JSTL函数(EL函数)</li></ul><h1 id="三-核心标签库使用说明"><a href="#三-核心标签库使用说明" class="headerlink" title="三. 核心标签库使用说明"></a>三. 核心标签库使用说明</h1><p>　　JSTL 的核心标签库标签共13个，使用这些标签能够完成 JSP 页面的基本功能，减少编码工作。</p><p>从功能上可以分为 4 类</p><ul><li><strong>表达式控制标签：</strong> out 标签、set 标签、remove 标签、catch 标签。</li><li><strong>流程控制标签：</strong> if 标签、choose 标签、when 标签、otherwise 标签</li><li><strong>循环标签：</strong> forEach 标签、forTokens 标签</li><li><strong>URL操作标签：</strong> import 标签、url 标签、redirect 标签、param 标签</li></ul><p>在JSP页面引入核心标签库的代码为：</p><p>​    <strong><code>&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</code></strong></p><h2 id="3-1-表达式控制标签"><a href="#3-1-表达式控制标签" class="headerlink" title="3.1 表达式控制标签"></a>3.1 表达式控制标签</h2><h3 id="1-lt-c-out-gt-标签"><a href="#1-lt-c-out-gt-标签" class="headerlink" title="1) &lt;c:out&gt; 标签"></a>1) <code>&lt;c:out&gt;</code> 标签</h3><p>主要是<strong>用来输出数据对象（字符串、表达式）的内容或结果</strong></p><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:out value=<span class="string">"&lt;string&gt;"</span> <span class="keyword">default</span>=<span class="string">"&lt;string&gt;"</span> escapeXml=<span class="string">"&lt;true|false&gt;"</span>/&gt;</span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><table><thead><tr><th style="text-align:left"><strong>属性</strong></th><th><strong>描述</strong></th><th style="text-align:center"><strong>是否必要</strong></th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left">value</td><td>要输出的内容</td><td style="text-align:center">是</td><td style="text-align:left">无</td></tr><tr><td style="text-align:left">default</td><td>输出的默认值</td><td style="text-align:center">否</td><td style="text-align:left">主体中的内容</td></tr><tr><td style="text-align:left">escapeXml</td><td>是否忽略XML特殊字符</td><td style="text-align:center">否</td><td style="text-align:left">true</td></tr></tbody></table><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;c:out value="&amp;lt 未使用转义字符 &amp;gt" escapeXml="true" default="默认值"&gt;&lt;/c:out&gt;&lt;br/&gt;</span><br><span class="line">    &lt;c:out value="&amp;lt 使用转义字符 &amp;gt" escapeXml="false" default="默认值"&gt;&lt;/c:out&gt;&lt;br/&gt;</span><br><span class="line">    &lt;c:out value="$&#123;null&#125;" escapeXml="false"&gt;使用的表达式结果为null，则输出该默认值&lt;/c:out&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h5 id="打印结果"><a href="#打印结果" class="headerlink" title="打印结果"></a>打印结果</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt 未使用转义字符 &amp;gt</span><br><span class="line">&lt; 使用转义字符 &gt;</span><br><span class="line">使用的表达式结果为null，则输出该默认值</span><br></pre></td></tr></table></figure><h3 id="2-lt-c-set-gt-标签"><a href="#2-lt-c-set-gt-标签" class="headerlink" title="2) &lt;c:set&gt; 标签"></a>2) <code>&lt;c:set&gt;</code> 标签</h3><p>设置变量值和对象属性</p><h4 id="语法格式-1"><a href="#语法格式-1" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set</span><br><span class="line">   <span class="keyword">var</span>=<span class="string">"&lt;string&gt;"</span></span><br><span class="line">   value=<span class="string">"&lt;string&gt;"</span></span><br><span class="line">   target=<span class="string">"&lt;string&gt;"</span></span><br><span class="line">   property=<span class="string">"&lt;string&gt;"</span></span><br><span class="line">   scope=<span class="string">"&lt;string&gt;"</span>/&gt;</span><br></pre></td></tr></table></figure><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><table><thead><tr><th><strong>属性</strong></th><th><strong>描述</strong></th><th><strong>是否必要</strong></th><th><strong>默认值</strong></th></tr></thead><tbody><tr><td>value</td><td>要存储的值</td><td>否</td><td>主体的内容</td></tr><tr><td>target</td><td>要修改的属性所属的对象</td><td>否</td><td>无</td></tr><tr><td>property</td><td>要修改的属性</td><td>否</td><td>无</td></tr><tr><td>var</td><td>存储信息的变量</td><td>否</td><td>无</td></tr><tr><td>scope</td><td>var属性的作用域</td><td>否</td><td>Page</td></tr></tbody></table><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">"salary"</span> scope=<span class="string">"session"</span> value=<span class="string">"$&#123;2000*2&#125;"</span>/&gt;</span><br><span class="line">&lt;c:out value=<span class="string">"$&#123;salary&#125;"</span>/&gt;</span><br><span class="line">&lt;!-- 运行结果: <span class="number">4000</span> --&gt;</span><br></pre></td></tr></table></figure><h2 id="3-2-表达式控制标签"><a href="#3-2-表达式控制标签" class="headerlink" title="3.2 表达式控制标签"></a>3.2 表达式控制标签</h2><h3 id="1-lt-c-if-gt-标签"><a href="#1-lt-c-if-gt-标签" class="headerlink" title="1) &lt;c:if&gt; 标签"></a>1) <code>&lt;c:if&gt;</code> 标签</h3><p>判断表达式的值，如果表达式的值<strong>为 true</strong> 则执行其主体内容</p><h4 id="语法格式-2"><a href="#语法格式-2" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"&lt;boolean&gt;"</span> <span class="keyword">var</span>=<span class="string">"&lt;string&gt;"</span> scope=<span class="string">"&lt;string&gt;"</span>&gt;</span><br><span class="line">   ...</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure><h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:left">描述</th><th style="text-align:center">是否必要</th><th style="text-align:center">默认值</th></tr></thead><tbody><tr><td style="text-align:center">test</td><td style="text-align:left">条件</td><td style="text-align:center">是</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">var</td><td style="text-align:left">用于存储条件结果的变量</td><td style="text-align:center">否</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">scope</td><td style="text-align:left">var属性的作用域</td><td style="text-align:center">否</td><td style="text-align:center">page</td></tr></tbody></table><h4 id="实例-模拟-if-else"><a href="#实例-模拟-if-else" class="headerlink" title="实例 (模拟 if-else )"></a>实例 (模拟 if-else )</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">"salary"</span> scope=<span class="string">"session"</span> value=<span class="string">"$&#123;2000*2&#125;"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;salary &gt; 2000&#125;"</span> <span class="keyword">var</span>=<span class="string">"flag"</span> scope=<span class="string">"session"</span>&gt;</span><br><span class="line">   &lt;p&gt;我的工资为: &lt;c:out value=<span class="string">"$&#123;salary&#125;"</span>/&gt;&lt;p&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;not flag&#125;"</span>&gt;</span><br><span class="line">   &lt;p&gt;我的工资为: &lt;c:out value=<span class="string">"$&#123;salary&#125;"</span>/&gt;&lt;p&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure><h4 id="3-3-循环标签"><a href="#3-3-循环标签" class="headerlink" title="3.3 循环标签"></a>3.3 循环标签</h4><h3 id="forEach-语法格式"><a href="#forEach-语法格式" class="headerlink" title="forEach 语法格式"></a>forEach 语法格式</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach</span><br><span class="line">    items=<span class="string">"&lt;object&gt;"</span> </span><br><span class="line">    begin=<span class="string">"&lt;int&gt;"</span></span><br><span class="line">    end=<span class="string">"&lt;int&gt;"</span></span><br><span class="line">    step=<span class="string">"&lt;int&gt;"</span></span><br><span class="line">    <span class="keyword">var</span>=<span class="string">"&lt;string&gt;"</span></span><br><span class="line">    varStatus=<span class="string">"&lt;string&gt;"</span> &gt;</span><br></pre></td></tr></table></figure><h4 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h4><table><thead><tr><th>属性</th><th>描述</th><th><strong>是否必要</strong></th><th>默认值</th></tr></thead><tbody><tr><td>items</td><td>要被循环的信息</td><td>否</td><td>无</td></tr><tr><td>begin</td><td>开始的元素（0=第一个元素，1=第二个元素）</td><td>否</td><td>0</td></tr><tr><td>end</td><td>最后一个元素（0=第一个元素，1=第二个元素）</td><td>否</td><td>Last element</td></tr><tr><td>step</td><td>每一次迭代的步长</td><td>否</td><td>1</td></tr><tr><td>var</td><td>代表当前条目的变量名称</td><td>否</td><td>无</td></tr><tr><td>varStatus</td><td>代表循环状态的变量名称</td><td>否</td><td>无</td></tr></tbody></table><h4 id="实例-表格隔行背景色变化"><a href="#实例-表格隔行背景色变化" class="headerlink" title="实例 (表格隔行背景色变化,)"></a>实例 (表格隔行背景色变化,)</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">"item"</span> items=<span class="string">"&#123;contents&#125;"</span> varStatus=<span class="string">"status"</span>&gt;</span><br><span class="line">&lt;tr &lt;c:<span class="keyword">if</span> test=<span class="string">"&#123;status.count%2==0&#125;"</span>&gt;bgcolor=<span class="string">"#CCCCFE"</span>/c:<span class="keyword">if</span> align=<span class="string">"left"</span>&gt;</span><br><span class="line">xxx</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3943390.html" target="_blank" rel="noopener">javaweb学习总结(二十八)——JSTL标签库之核心标签</a></p><p>​    <a href="http://www.runoob.com/jsp/jsp-jstl.html" target="_blank" rel="noopener">菜鸟教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-JSTL标签库介绍&quot;&gt;&lt;a href=&quot;#一-JSTL标签库介绍&quot; class=&quot;headerlink&quot; title=&quot;一. JSTL标签库介绍　　&quot;&gt;&lt;/a&gt;一. JSTL标签库介绍　　&lt;/h1&gt;&lt;p&gt;　　JSTL标签库的使用是&lt;strong&gt;为弥补 html 标签的不足&lt;/strong&gt;，规范自定义标签的使用而诞生的,是一个 JSP 的标签集合, 使用 JSLT 标签的目的就是 &lt;strong&gt;不希望在 jsp 页面中出现 java 逻辑代码&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---线程(2)</title>
    <link href="http://yoursite.com/2019/03/18/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E7%BA%BF%E7%A8%8B(2)/"/>
    <id>http://yoursite.com/2019/03/18/Java基础知识---线程(2)/</id>
    <published>2019-03-18T11:40:23.000Z</published>
    <updated>2019-03-20T00:05:25.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四-线程控制的基本方法"><a href="#四-线程控制的基本方法" class="headerlink" title="四. 线程控制的基本方法"></a>四. 线程控制的基本方法</h1><ul><li><code>isAlive()</code> : 判断线程是否还”活着”, 即线程是否还未终止</li><li><code>getPriority()</code> : 获得线程的优先级数值</li><li><code>setPriority()</code>  : 设置线程的优先级数值</li><li><code>Thread.sleep()</code> : 将当前线程睡眠指定毫秒数</li><li><code>join()</code> 调用某线程的该方法,将当前线程与该线程 “合并”, 即等待该线程结束, 再回复当前线程的运行</li><li><code>yield()</code>  : 让出CPU, 当前线程进入就绪队列等待调度</li><li><code>wait()</code> : 当前线程进入对象的 wait pool</li><li><code>notify()\notigyAll()</code> : 唤醒对象的 wait pool 中的一个/所有等待线程</li></ul><a id="more"></a><h2 id="3-3-sleep-join-yield-方法介绍"><a href="#3-3-sleep-join-yield-方法介绍" class="headerlink" title="3.3 sleep/join/yield 方法介绍"></a>3.3 sleep/join/yield 方法介绍</h2><p>主线程的概念<br>所有进程，至少会有一个线程即主线程，即main方法开始执行，就会有一个看不见的主线程存在。</p><h2 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep() 方法"></a>sleep() 方法</h2><p>​    让当前的正在执行的线程<strong>暂停指定的时间，并进入阻塞状态</strong>。在其睡眠的时间段内，该线程由于<strong>不是处于就绪状态</strong>，因此不会得到执行的机会。即使此时系统中没有任何其他可执行的线程，出于sleep()中的线程也不会执行。因此<strong>sleep()方法常用来暂停线程执行</strong>。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>可以调用Thread的静态方法 <code>public static void sleep(long millis) throws InterruptedEcception</code> 使得当前线程休眠(暂时停止执行 millis 毫秒)</li><li>因为是静态方法, sleep可以有类名直接调用, Thread.sleep(…) </li></ul><blockquote><p>Thread.sleep(1000); 表示当前线程暂停1000毫秒 ，其他线程不受影响</p></blockquote><h5 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSleep</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用start()方法启动新开辟的线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"主线程开始启动"</span>);</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 静态方法的调用可以直接使用“类名.静态方法名”或者“对象的引用.静态方法名”的方式来调用</span></span><br><span class="line">        Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">            System.out.println(<span class="string">"主线程睡眠了4秒种后再次启动了"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用interrupt()方法去结束掉一个线程的执行并不是一个很好的做法</span></span><br><span class="line">        <span class="comment">// thread.interrupt();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 改变循环条件，结束死循环</span></span><br><span class="line">        thread.flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当发生InterruptedException时，直接把循环的条件设置为false即可退出死循环，</span></span><br><span class="line"><span class="comment">         * 继而结束掉子线程的执行，这是一种比较好的结束子线程的做法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用interrupt()方法把正在运行的线程打断相当于是主线程一盆凉水泼上去把正在执行分线程打断了</span></span><br><span class="line"><span class="comment">         * 分线程被打断之后就会抛InterruptedException异常，这样就会执行return语句返回，</span></span><br><span class="line"><span class="comment">         * 结束掉线程的执行所以这里的分线程在执行完4秒钟之后就结束掉了线程的执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;<span class="comment">// 定义一个标记，用来控制循环的条件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 注意：这里不能在run()方法的后面直接写throw Exception来抛异常， </span></span><br><span class="line"><span class="comment">         * 因为现在是要重写从Thread类继承而来的run()方法,重写方法不能抛出比被重写的方法的不同的异常。</span></span><br><span class="line"><span class="comment">         *  所以这里只能写try……catch()来捕获异常</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">"=========="</span> + <span class="keyword">new</span> Date().toLocaleString() + <span class="string">"==========="</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在本类中声明的静态方法时调用时直接写静态方法名即可</span></span><br><span class="line">            <span class="comment">// 这里是让这个新开辟的线程每隔一秒睡眠一次，然后睡眠一秒钟后再次启动该线程</span></span><br><span class="line">                sleep(<span class="number">1000</span>); <span class="comment">// 睡眠的时如果被打断就会抛出InterruptedException异常</span></span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 睡眠的时一盘冷水泼过来就有可能会打断睡眠 </span></span><br><span class="line">                <span class="comment">// 因此让正在运行线程被一些意外的原因中断的时候有可能会抛被打扰中断(InterruptedException)的异常</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 线程被中断后就返回，相当于是结束线程</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">主线程开始启动</span></span><br><span class="line"><span class="comment">==========2019-3-19 16:54:53===========</span></span><br><span class="line"><span class="comment">==========2019-3-19 16:54:54===========</span></span><br><span class="line"><span class="comment">==========2019-3-19 16:54:55===========</span></span><br><span class="line"><span class="comment">==========2019-3-19 16:54:56===========</span></span><br><span class="line"><span class="comment">主线程睡眠了4秒种后再次启动了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="join-方法"><a href="#join-方法" class="headerlink" title="join() 方法"></a>join() 方法</h2><p>合并某个线程</p><p><strong>让一个线程等待另一个线程完成才继续执行。</strong>如A线程线程执行体中调用B线程的join()方法，则A线程被阻塞，直到B线程执行完为止，A才能得以继续执行</p><h5 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"主线程运行开始!"</span>);</span><br><span class="line">Thread1 mTh1 = <span class="keyword">new</span> Thread1(<span class="string">"A"</span>);</span><br><span class="line">Thread1 mTh2 = <span class="keyword">new</span> Thread1(<span class="string">"B"</span>);</span><br><span class="line">mTh1.start();</span><br><span class="line">mTh2.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加入main()方法中</span></span><br><span class="line">mTh1.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加入main()方法中</span></span><br><span class="line">mTh2.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"主线程运行结束!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name);</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">" 线程运行开始!"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"子线程"</span> + name + <span class="string">"运行 : "</span> + i);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 睡眠时间随机</span></span><br><span class="line">sleep((<span class="keyword">int</span>) Math.random() * <span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">" 线程运行结束!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>​    在很多情况下，主线程生成并起动了子线程<strong>，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束</strong>，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是<strong>主线程需要等待子线程执行完成之后再结束</strong>，这个时候就要用到 join() 方法了</p><h2 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield() 方法"></a>yield() 方法</h2><p>​    <strong>暂停当前正在执行的线程对象(</strong>让出CPU)，并执行其他线程</p><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><ul><li><p><strong>yield()从未导致线程转到等待/睡眠/阻塞状态</strong> </p></li><li><p>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。当调用线程的 yield() 方法时，线程从<strong>运行状态转换为就绪状态</strong>，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU<strong>仍然调度了A线程的情况</strong>。</p></li></ul><h5 id="范例-2"><a href="#范例-2" class="headerlink" title="范例"></a>范例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadYield</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadYield</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>(name);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;  </span><br><span class="line">            System.out.println(<span class="string">""</span> + <span class="keyword">this</span>.getName() + <span class="string">"-----"</span> + i);  </span><br><span class="line">            <span class="comment">// 当i为30时，该线程就会把CPU时间让掉，让其他或者自己的线程执行（也就是谁先抢到谁执行）  </span></span><br><span class="line">            <span class="keyword">if</span> (i ==<span class="number">30</span>) &#123;  </span><br><span class="line">                <span class="keyword">this</span>.yield();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">        ThreadYield yt1 = <span class="keyword">new</span> ThreadYield(<span class="string">"张三"</span>);  </span><br><span class="line">        ThreadYield yt2 = <span class="keyword">new</span> ThreadYield(<span class="string">"李四"</span>);  </span><br><span class="line">        yt1.start();  </span><br><span class="line">        yt2.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>第一种情况: 李四 (线程) 当执行到30时会CPU时间让掉，这时<strong>张三(线程)抢到CPU时间并执行</strong>。</p><p>第二种情况: 李四 (线程) 当执行到30时会CPU时间让掉，这时<strong>李四 (线程) 抢到CPU时间并执行</strong>。</p><h4 id="sleep-和-yield-的区别"><a href="#sleep-和-yield-的区别" class="headerlink" title="sleep() 和 yield() 的区别"></a>sleep() 和 yield() 的区别</h4><ul><li><p>sleep()使当前线程进入停滞状态，所以执行<strong>sleep()的线程在指定的时间内肯定不会被执行</strong>；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程<strong>有可能在进入到可执行状态后马上又被执行</strong>。</p></li><li><p>sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短<strong>是由程序设定的</strong>，yield 方法使当前线程让出 CPU 占有权，但<strong>让出的时间是不可设定的</strong></p><blockquote><p> 实际上，yield()方法对应了如下操作：先检测当前<strong>是否有相同优先级的线程处于同可运行状态</strong>，如有，则把 CPU  的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为<strong>“退让”</strong>，它把运行机会让给了同等优先级的其他线程</p></blockquote></li><li><p>sleep 方法<strong>允许较低优先级的线程获得运行机会</strong>，但 yield()  方法执行时，当前线程仍处在可运行状态，所以，<strong>不可能让出较低优先级的线程些时获得 CPU 占有权</strong>。</p></li></ul><p>在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行</p><h2 id="4-改变线程的优先级-setPriority-："><a href="#4-改变线程的优先级-setPriority-：" class="headerlink" title="4. 改变线程的优先级/setPriority()："></a>4. 改变线程的优先级/setPriority()：</h2><p>每个线程在执行时都具有一定的优先级，<strong>优先级高的线程具有较多的执行机会</strong>。每个线程默认的优先级都与创建它的线程的优先级相同。<strong>main线程默认具有普通优先级</strong>。</p><p><strong>设置线程优先级</strong>：<code>setPriority(int priorityLevel)</code></p><p>参数 priorityLevel 范围在1-10之间，常用的有如下三个静态常量值：</p><ul><li><p>MAX_PRIORITY: 10</p></li><li><p>MIN_PRIORITY: 1</p></li><li><p>NORM_PRIORITY: 5</p></li></ul><p><strong>获取线程优先级</strong>：getPriority()</p><h5 id="范例-3"><a href="#范例-3" class="headerlink" title="范例"></a>范例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPriority</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread myThread = <span class="keyword">new</span> MyThread03();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"main thread i = "</span> + i);</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="comment">// 当 i=5 时,将myThread的优先级设为最高</span></span><br><span class="line">myThread.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">myThread.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread03</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><p>​    <strong>具有较高线程优先级的线程对象仅表示此线程具有较多的执行机会，而非优先执行。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;四-线程控制的基本方法&quot;&gt;&lt;a href=&quot;#四-线程控制的基本方法&quot; class=&quot;headerlink&quot; title=&quot;四. 线程控制的基本方法&quot;&gt;&lt;/a&gt;四. 线程控制的基本方法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;isAlive()&lt;/code&gt; : 判断线程是否还”活着”, 即线程是否还未终止&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getPriority()&lt;/code&gt; : 获得线程的优先级数值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setPriority()&lt;/code&gt;  : 设置线程的优先级数值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Thread.sleep()&lt;/code&gt; : 将当前线程睡眠指定毫秒数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;join()&lt;/code&gt; 调用某线程的该方法,将当前线程与该线程 “合并”, 即等待该线程结束, 再回复当前线程的运行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yield()&lt;/code&gt;  : 让出CPU, 当前线程进入就绪队列等待调度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wait()&lt;/code&gt; : 当前线程进入对象的 wait pool&lt;/li&gt;
&lt;li&gt;&lt;code&gt;notify()\notigyAll()&lt;/code&gt; : 唤醒对象的 wait pool 中的一个/所有等待线程&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---super关键字</title>
    <link href="http://yoursite.com/2019/03/18/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---super%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/03/18/Java基础知识---super关键字/</id>
    <published>2019-03-18T09:40:27.000Z</published>
    <updated>2019-03-25T06:23:05.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-super-关键字作用"><a href="#一-super-关键字作用" class="headerlink" title="一. super 关键字作用"></a>一. super 关键字作用</h1><ol><li>主要存在于子类方法中，用于指向子类对象中<strong>父类对象</strong></li><li>访问父类的属性</li><li>访问父类的函数</li><li>访问父类的构造函数</li></ol><a id="more"></a><h1 id="二-super-注意的地方"><a href="#二-super-注意的地方" class="headerlink" title="二. super 注意的地方"></a>二. super 注意的地方</h1><ul><li><p>this 和 super 很像，this指向的是当前对象的调用，super指向的是<strong>当前调用对象的父类</strong>。</p></li><li><p>类加载完毕，创建对象，父类的构造方法会被调用（默认自动无参），然后执行子类相应构造创建了一个子类对象，<strong>该子类对象还包含了一个父类对象。该父类对象在子类对象内部</strong>。</p></li><li>this super 只能在有对象的前提下使用，<strong>不能在static方法内使用</strong>。</li></ul><h1 id="三-super关键字的使用"><a href="#三-super关键字的使用" class="headerlink" title="三. super关键字的使用"></a>三. super关键字的使用</h1><h2 id="1-子类隐式调用父类构造函数"><a href="#1-子类隐式调用父类构造函数" class="headerlink" title="1. 子类隐式调用父类构造函数"></a>1. 子类隐式调用父类构造函数</h2><p>子类的构造函数默认第一行会默认调用父类无参的构造函数，隐式语句 <code>super();</code></p><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Son(<span class="keyword">int</span> y) &#123;</span><br><span class="line">    <span class="comment">// super();隐式语句</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.y = y + x;</span><br><span class="line">    System.out.println(<span class="string">"这是子类的有参构造"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-子类显式调用父类构造函数"><a href="#2-子类显式调用父类构造函数" class="headerlink" title="2. 子类显式调用父类构造函数"></a>2. 子类显式调用父类构造函数</h2><p>​    在子类构造函数 <strong>第一行</strong> 通过super关键字调用<strong>父类任何构造函数</strong>。如果显式调用父类构造函数，编译器自动添加的调用<strong>父类无参数的构造就消失</strong>。构造函数间的调用<strong>只能放在第一行，只能调用一次</strong> 。<strong>super()和this()不能同时存在构造函数第一行</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Son(<span class="keyword">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">super</span>(y);<span class="comment">// 子类显式调用父类构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.y = y + x;</span><br><span class="line">    System.out.println(<span class="string">"这是子类的有参构造"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">value = <span class="number">100</span>;</span><br><span class="line">System.out.println(<span class="string">"父类的value属性值 = "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类除了继承父类所具有的valu属性外，自己又另外声明了一个value属性，此时的子类拥有两个value属性。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在子类ChildClass里面重写了从父类继承下来的method()方法里面的实现，即重写(覆盖)了method()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用super作为父类对象的引用对象来调用父类对象里面的f()方法</span></span><br><span class="line"><span class="keyword">super</span>.method();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个value是子类自己定义的那个value，不是从父类继承下来的那个value</span></span><br><span class="line">value = <span class="number">200</span>;</span><br><span class="line">System.out.println(<span class="string">"子类的value属性值="</span> + value);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"修改父类的value之前,值为: "</span> + <span class="keyword">super</span>.value);</span><br><span class="line"><span class="keyword">super</span>.value = <span class="number">300</span>;</span><br><span class="line">System.out.println(<span class="string">"修改父类的value之后,值为: "</span> + <span class="keyword">super</span>.value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSuper</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Son son = <span class="keyword">new</span> Son();</span><br><span class="line">son.method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 打印结果:</span></span><br><span class="line"><span class="comment"> * 父类的value属性值 = 100</span></span><br><span class="line"><span class="comment"> * 子类的value属性值=200</span></span><br><span class="line"><span class="comment"> * 修改父类的value之前,值为: 100</span></span><br><span class="line"><span class="comment"> * 修改父类的value之后,值为: 300</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>详细的内存分析见 <strong>参考博文</strong></p><h1 id="四-super思考"><a href="#四-super思考" class="headerlink" title="四. super思考"></a>四. super思考</h1><p>如果开发者自定义了一个类，<strong>没有显示的进行类的继承</strong>，那么该类中成员函数是否可以使用super关键字？</p><p>答: <strong>可以使用</strong>，继承了Object类，Object类是所有类的父类</p><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://blog.csdn.net/qq_33642117/article/details/51919528" target="_blank" rel="noopener">Java super关键字详解</a></p><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3635948.html" target="_blank" rel="noopener">java基础学习总结——super关键字</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-super-关键字作用&quot;&gt;&lt;a href=&quot;#一-super-关键字作用&quot; class=&quot;headerlink&quot; title=&quot;一. super 关键字作用&quot;&gt;&lt;/a&gt;一. super 关键字作用&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;主要存在于子类方法中，用于指向子类对象中&lt;strong&gt;父类对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;访问父类的属性&lt;/li&gt;
&lt;li&gt;访问父类的函数&lt;/li&gt;
&lt;li&gt;访问父类的构造函数&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---this关键字</title>
    <link href="http://yoursite.com/2019/03/18/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---this%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/03/18/Java基础知识---this关键字/</id>
    <published>2019-03-18T09:19:27.000Z</published>
    <updated>2019-03-20T00:05:01.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概念"><a href="#一-概念" class="headerlink" title="一. 概念"></a>一. 概念</h1><p>​    this 关键字代表<strong>自身</strong></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>this关键字必须放在<strong>非静态方法里面</strong></li><li>当必须指出 <strong>当前使用方法的对象是谁</strong> 时要使用 this</li><li>有时使用 this 可以处理方法中 <strong>成员变量和参数重名的现象</strong></li><li>this 可以看做是 <strong>一个变量</strong>, 它的值是当前对象的引用</li></ul><a id="more"></a><h1 id="二-在程序中使用用途"><a href="#二-在程序中使用用途" class="headerlink" title="二. 在程序中使用用途:"></a>二. 在程序中使用用途:</h1><ul><li><p>使用this关键字 <strong>引用成员变量</strong></p></li><li><p>使用this关键字在 <strong>自身构造方法内部引用其它构造方法</strong></p></li><li><p>使用this关键字代表 <strong>自身类的对象</strong></p></li><li><p>使用this关键字<strong>引用成员方法</strong></p></li></ul><h2 id="1-使用-this-引用成员变量"><a href="#1-使用-this-引用成员变量" class="headerlink" title="1. 使用 this 引用成员变量"></a>1. 使用 this 引用成员变量</h2><p>​    在一个类的方法或构造方法内部，可以使用<strong>“this.成员变量名”</strong>这样的格式来引用成员变量名<strong>，有些时候可以省略，有些时候不能省略</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceVariable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceVariable</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在该代码的<strong>构造方法和setA方法内部</strong>，都是用this.a引用类的成员变量。因为无论在构造方法还是setA方法内部，<strong>都包含2个变量名为a的变量</strong>，一个是参数a，另外一个是成员变量a。按照Java语言的变量作用范围规定，<strong>参数a的作用范围为构造方法或方法内部，成员变量a的作用范围是类的内部</strong>，这样在构造方法和setA方法内部就<strong>存在了变量a的冲突</strong>，Java语言规定当变量作用范围重叠时，<strong>作用域小的变量覆盖作用域大的变量。</strong>所以<strong>在构造方法和setA方法内部，参数a起作用</strong>。</li><li><strong>这样需要访问成员变量a则必须使用this进行引用</strong>。当然，如果变量名不发生重叠，则this可以省略。</li><li>但是<strong>为了增强代码的可读性，一般将参数的名称和成员变量的名称保持一致</strong>，所以this的使用频率在规范的代码内部应该很多。</li></ol><h2 id="2-引用构造方法"><a href="#2-引用构造方法" class="headerlink" title="2. 引用构造方法"></a>2. 引用构造方法</h2><p>​    在一个类的<strong>构造方法内部</strong>，也可以<strong>使用this关键字引用其它的构造方法</strong>，这样可以降低代码的重复，也可以<strong>使所有的构造方法保持统一</strong>，这样方便以后的代码修改和维护，也方便代码的阅读。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceConstructor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceConstructor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceConstructor</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>这里在不带参数的构造方法内部，<strong>使用this调用了另外一个构造方法</strong>，其中<strong>0是根据需要传递的参数的值</strong></li><li>当一个类内部的构造方法比较多时，可以<strong>只书写一个构造方法的内部功能代码，然后其它的构造方法都通过调用该构造方法实现</strong>，这样既保证了所有的构造是统一的，也降低了代码的重复。</li><li>在实际使用时，需要注意的是，在构造方法内部使用this关键字调用其它的构造方法时，<strong>调用的代码只能出现在构造方法内部的第一行可执行代码</strong>。这样，在构造方法内部使用this关键字调用构造方法<strong>最多会出现一次</strong>。</li></ol><h2 id="3-代表自身对象"><a href="#3-代表自身对象" class="headerlink" title="3. 代表自身对象"></a>3. 代表自身对象</h2><p>​    在一个类的内部，也可以使用this代表自身类的对象，或者换句话说，<strong>每个类内部都有一个隐含的成员变量，该成员变量的类型是该类的类型，该成员变量的名称是this</strong>，实际使用this代表自身类的对象的</p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>​    假设我们<strong>在堆内存new了一个对象</strong>，在这个对象里面你有一个引用 this，<strong>this 指向这个对象自己</strong>，所以这就是this，<strong>这个new出来的对象名字是什么，我们不知道，不知道也没关系</strong>，因为这并不影响这个对象在内存里面的存在，<strong>这个对象只要在内存中存在，他就一定有一个引用this</strong> ,在 <strong>类的方法定义中</strong> 使用的 this 关键字代表 <strong>使用该方法的==对象的引用==</strong></p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceObject</span> </span>&#123;</span><br><span class="line">    ReferenceObject instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">    instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    构造方法内部，<strong>将对象this的值赋值给instance</strong>，在test方法内部，输出对象this的内容，这里的this都<strong>代表自身类型的对象。</strong></p><h2 id="4-引用成员方法"><a href="#4-引用成员方法" class="headerlink" title="4. 引用成员方法"></a>4. 引用成员方法</h2><p> 在一个类的内部，成员方法之间的互相调用时也可以使用“this.方法名(参数)”来进行引用，<strong>只是所有这样的引用中this都可以省略，</strong>所以这里就不详细介绍了</p><h1 id="三-内存中的分析"><a href="#三-内存中的分析" class="headerlink" title="三. 内存中的分析"></a>三. 内存中的分析</h1><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如何区分两个 i</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在 Leaf 类里面定义一个成员变量 i </span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 Leaf 这个类的构造方法,构造方法里面有一个局部变量i,这个i与成员变量i同名</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this.i 中使用this就是为了却分开成员变量i和形参i,如果这里不写this,而是直接写"i=i",这样就不好区分了,因此有时使用this可以处理方法中成员变量和参数重名的情况</span></span><br><span class="line">        <span class="comment">// 后面这个 i 是构造方法里面声明的形参i,在这里有一个原则,当你确定不了一个参数到时指的是哪一个变量的时候,赵丽这个参数最近的声明(就近声明原则)</span></span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Leaf <span class="title">increament</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">// 这个方法要求的返回类型是Leaf本身的类型,也就是指向Leaf的一个引用,既然是要指向Leaf的一个引用,return this,this指向自身,自身又是Leaf.因此使用 return this 返回的值就是 Leaf本身</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Leaf leaf = <span class="keyword">new</span> Leaf(<span class="number">100</span>);</span><br><span class="line">        leaf.increament().increament().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在内存中分析main方法的执行过程"><a href="#在内存中分析main方法的执行过程" class="headerlink" title="在内存中分析main方法的执行过程*"></a>在内存中分析main方法的执行过程*</h4><ol><li><strong>Leaf leaf = new Leaf(100);</strong></li></ol><p>　　程序执行到这里的时候，栈空间里面有一个变量leaf，它指向了我们new出来的在堆空间里面的Leaf对象。new这个Leaf对象的时候，调用了构造方法Leaf(),这个构造方法里面有一个形参 i，所以在栈空间里面给构造方法分配有一小块内存，名字叫i用来装传递过来的实参。这里传过来的实参是100，所以 i 里面装的值就是100。得到这个值之后，构造方法继续执行，执行 <code>this.i = i;</code> 这里就是把栈空间里面的 i 的值通过值传递给Leaf对象里面的成员变量i，所以成员变量 i 的值也变成了100。</p><ol start="2"><li><strong>leaf.increament().increament().print();</strong></li></ol><p>详情见参考博文</p><h1 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h1><p>​    this<strong>一般出现在方法里面</strong>，当这个方法还没有调用的时候，this指的是谁并不知道。但是实际当中，<strong>你如果new了一个对象出来，那么this指的就是当前这个对象</strong>。对哪个对象调用方法，this指的就是调用方法的这个对象（你对哪个对象调用这个方法，this指的就是谁）。<strong>如果再new一个对象，这个对象他也有自己的this，他自己的this就当然指的是他自己了</strong>。</p><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://blog.csdn.net/javaniuniu/article/details/52447502" target="_blank" rel="noopener">JAVA中this的三种用法的详解</a></p><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3636071.html" target="_blank" rel="noopener">java基础学习总结——this关键字</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-概念&quot;&gt;&lt;a href=&quot;#一-概念&quot; class=&quot;headerlink&quot; title=&quot;一. 概念&quot;&gt;&lt;/a&gt;一. 概念&lt;/h1&gt;&lt;p&gt;​    this 关键字代表&lt;strong&gt;自身&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;注意&quot;&gt;&lt;a href=&quot;#注意&quot; class=&quot;headerlink&quot; title=&quot;注意&quot;&gt;&lt;/a&gt;注意&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;this关键字必须放在&lt;strong&gt;非静态方法里面&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当必须指出 &lt;strong&gt;当前使用方法的对象是谁&lt;/strong&gt; 时要使用 this&lt;/li&gt;
&lt;li&gt;有时使用 this 可以处理方法中 &lt;strong&gt;成员变量和参数重名的现象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;this 可以看做是 &lt;strong&gt;一个变量&lt;/strong&gt;, 它的值是当前对象的引用&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---对象转型</title>
    <link href="http://yoursite.com/2019/03/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/15/Java基础知识---对象转型/</id>
    <published>2019-03-15T06:41:51.000Z</published>
    <updated>2019-03-24T03:31:12.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-对象转型介绍"><a href="#一-对象转型介绍" class="headerlink" title="一. 对象转型介绍"></a>一. 对象转型介绍</h1><h3 id="1-1-解释"><a href="#1-1-解释" class="headerlink" title="1.1 解释"></a>1.1 解释</h3><p>把一种形式转成另外一种形式就叫转型</p><blockquote><ul><li>基础数据类型的转型, (例如: 把 float 类型转成 int 类型，把 float 类型转成 double 类型)</li><li>对象领域里面对象之间的转型。</li></ul></blockquote><h4 id="对象转型分为两种："><a href="#对象转型分为两种：" class="headerlink" title="对象转型分为两种："></a>对象转型分为两种：</h4><ol><li>向上转型 </li><li>向下转型</li></ol><a id="more"></a><h1 id="二-向上转型"><a href="#二-向上转型" class="headerlink" title="二. 向上转型"></a>二. 向上转型</h1><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义:"></a>2.1 定义:</h3><p>​    <strong>子类引用的对象转换为父类类型</strong>称为向上转型, 通俗地说就是是将子类对象转为父类对象.父类对象可以是接口</p><h3 id="2-2-解释"><a href="#2-2-解释" class="headerlink" title="2.2 解释"></a>2.2 解释</h3><p>​    比如说我有两个类，一个是父类Animal，另一个是Dog类为子类. <code>Animal c = new Dog();</code></p><h3 id="2-3-实例"><a href="#2-3-实例" class="headerlink" title="2.3 实例"></a>2.3 实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjectShift</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Animal a = <span class="keyword">new</span> Animal(<span class="string">"name"</span>);</span><br><span class="line">Dog d = <span class="keyword">new</span> Dog(<span class="string">"dogname"</span>, <span class="string">"black"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向上转型, a这个引用不指向Animal类的实例对象了，而是指向了Dog这个类的一个实例对象</span></span><br><span class="line">        a = <span class="keyword">new</span> Dog(<span class="string">"bigyellow"</span>, <span class="string">"yellow"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>一个父类(基类)对象的引用是<strong>不可以访问其子类对象新增加</strong>的成员(属性和方法)的。</li></ul><h1 id="三-对象的向下转型"><a href="#三-对象的向下转型" class="headerlink" title="三. 对象的向下转型"></a>三. 对象的向下转型</h1><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p>父类引用的对象转换为子类类型成为向下转型</p><h3 id="3-2-解释"><a href="#3-2-解释" class="headerlink" title="3.2 解释"></a>3.2 解释</h3><p>​    比如说我有两个类，一个是父类Animal，另一个是Dog类为子类. <code>Dog d1 = (Dog) a;</code></p><h3 id="3-3-实例"><a href="#3-3-实例" class="headerlink" title="3.3 实例"></a>3.3 实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjectShift</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">Animal a = <span class="keyword">new</span> Animal(<span class="string">"AnimalName"</span>);</span><br><span class="line">Dog d = <span class="keyword">new</span> Dog(<span class="string">"dogName"</span>, <span class="string">"black"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 向下转型</span></span><br><span class="line"><span class="comment">// 父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，</span></span><br><span class="line"><span class="comment">// 但是运行时会出现java.lang.ClassCastException错误</span></span><br><span class="line"><span class="comment">// Dog dd = (Dog) a;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向下转型,父类引用的对象如果引用的是指向的子类对象，那么在向下转型的过程中是安全的。也就是编译是不会出错误的</span></span><br><span class="line"><span class="comment">// 这里使用强制转换，把指向Animal类的引用对象a转型成指向Dog类对象的引用，</span></span><br><span class="line"><span class="comment">// 这样转型后的引用对象d1就可以直接访问Dog类对象里面的新增的成员了。</span></span><br><span class="line">        a = <span class="keyword">new</span> Dog(<span class="string">"bigyellow"</span>, <span class="string">"yellow"</span>);</span><br><span class="line">Dog d1 = (Dog) a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><ul><li><p>如果<strong>父类引用的对象如果引用的是指向的子类对象</strong>，那么在向下转型的过程中是安全的。也就是编译是不会出错误的。</p></li><li><p>如果<strong>父类引用的对象是父类本身</strong>，那么在向下转型的过程中是不安全的，编译不会出错，但是运行时会出现java.lang.ClassCastException错误<strong>。它可以使用instanceof来避免出错此类错误。</strong></p></li></ul><h1 id="四-完整实例"><a href="#四-完整实例" class="headerlink" title="四. 完整实例"></a>四. 完整实例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String eyeColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String n, String c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(n); <span class="comment">// 调用父类Animal的构造方法</span></span><br><span class="line"><span class="keyword">this</span>.eyeColor = c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog类添加自己特有的属性</span></span><br><span class="line"><span class="keyword">public</span> String furColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String n, String c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(n); <span class="comment">// 调用父类Animal的构造方法</span></span><br><span class="line"><span class="keyword">this</span>.furColor = c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjectShift</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Animal a = <span class="keyword">new</span> Animal(<span class="string">"AnimalName"</span>);</span><br><span class="line">Cat c = <span class="keyword">new</span> Cat(<span class="string">"catName"</span>, <span class="string">"blue"</span>);</span><br><span class="line">Dog d = <span class="keyword">new</span> Dog(<span class="string">"dogName"</span>, <span class="string">"black"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a instanceof Animal这句话的意思是a是一只动物吗？</span></span><br><span class="line"><span class="comment">// a是Animal这个类里面的是一个实例对象，所以a当然是一只动物，其结果为true。</span></span><br><span class="line">System.out.println(String.format(<span class="string">"a instanceof Animal的结果是%s"</span>, a <span class="keyword">instanceof</span> Animal)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// c是Cat类的实例对象的引用，即c代表的就是这个实例对象，所以“c是一只动物”打印出来的结果也是true。</span></span><br><span class="line">System.out.println(String.format(<span class="string">"c instanceof Animal的结果是%s"</span>, c <span class="keyword">instanceof</span> Animal)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里判断说“动物是一只猫”，不符合逻辑，所以打印出来的结果是false。</span></span><br><span class="line">System.out.println(String.format(<span class="string">"a instanceof Cat的结果是%s"</span>, a <span class="keyword">instanceof</span> Cat));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下转型</span></span><br><span class="line"><span class="comment">// 父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，</span></span><br><span class="line"><span class="comment">// 但是运行时会出现java.lang.ClassCastException错误</span></span><br><span class="line"><span class="comment">// Dog dd = (Dog) a;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向上转型 a这个引用不指向Animal类的实例对象了，而是指向了Dog这个类的一个实例对象</span></span><br><span class="line"><span class="comment"> * 这里也就是父类对象的引用指向了子类的一个实例对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">a = <span class="keyword">new</span> Dog(<span class="string">"bigyellow"</span>, <span class="string">"yellow"</span>);</span><br><span class="line">System.out.println(a.name); <span class="comment">// bigyellow</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里的furColor属性是子类在继承父类的基础上新增加的一个属性，是父类没有的。</span></span><br><span class="line"><span class="comment"> * 因此这里使用父类的引用对象a去访问子类对象里面新增加的成员变量是不允许的，</span></span><br><span class="line"><span class="comment"> * 因为在编译器眼里，你a就是Animal类对象的一个引用对象，你只能去访问Animal类对象里面所具有的name属性，</span></span><br><span class="line"><span class="comment"> * 除了Animal类里面的属性可以访问以外，其它类里面的成员变量a都没办法访问。</span></span><br><span class="line"><span class="comment"> * 这里furColor属性是Dog类里面的属性，因此你一个Animal类的引用是无法去访问Dog类里面的成员变量的，</span></span><br><span class="line"><span class="comment"> * 尽管你a指向的是子类Dog的一个实例对象，但因为子类Dog从父类Animal继承下来，</span></span><br><span class="line"><span class="comment"> * 所以new出一个子类对象的时候，这个子类对象里面会包含有一个父类对象，</span></span><br><span class="line"><span class="comment"> * 因此这个a指向的正是这个子类对象里面的父类对象，因此尽管a是指向Dog类对象的一个引用，</span></span><br><span class="line"><span class="comment"> * 但是在编译器眼里你a就是只是一个Animal类的引用对象，你a就是只能访问Animal类里面所具有的成员变量， 别的你都访问不了。</span></span><br><span class="line"><span class="comment"> * 因此一个父类(基类)对象的引用是不可以访问其子类对象新增加的成员(属性和方法)的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// System.out.println(a.furColor);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里判断说“a是一只Dog”是true。 因为instanceof探索的是实际当中你整个对象到底是什么东西，</span></span><br><span class="line"><span class="comment">// 并不是根据你的引用把对象看出什么样来判断的。</span></span><br><span class="line">System.out.println(String.format(<span class="string">"a instanceof Dog的结果是%s"</span>, a <span class="keyword">instanceof</span> Dog));<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下转型,父类引用的对象如果引用的是指向的子类对象，那么在向下转型的过程中是安全的。也就是编译是不会出错误的</span></span><br><span class="line"><span class="comment">// 这里使用强制转换，把指向Animal类的引用对象a转型成指向Dog类对象的引用，</span></span><br><span class="line"><span class="comment">// 这样转型后的引用对象d1就可以直接访问Dog类对象里面的新增的成员了。</span></span><br><span class="line">Dog d1 = (Dog) a;</span><br><span class="line">System.out.println(d1.furColor); <span class="comment">// yellow</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细解释见 <strong>参考博文</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对象转型可以使父类对象的引用可以指向子类对象，<strong>给程序带来了比较好的可扩展性</strong>：我们可以在一个方法的参数里面定义父类的引用，然后实际当中传的时候传的是子类的对象，然后我们再在方法里面判断这个传过来的子类对象到底属于哪个子类，然后再去执行这个子类里面的方法或者调用这个子类里面的成员变量，因此程序的可扩展性比单独定义好多个方法要好一些。不过这个可扩展性还没有达到最好，使用多态就可以让程序的扩展性达到极致。</p><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/zxxiaoxia/p/4178049.html" target="_blank" rel="noopener">java上转型和下转型（对象的多态性）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-对象转型介绍&quot;&gt;&lt;a href=&quot;#一-对象转型介绍&quot; class=&quot;headerlink&quot; title=&quot;一. 对象转型介绍&quot;&gt;&lt;/a&gt;一. 对象转型介绍&lt;/h1&gt;&lt;h3 id=&quot;1-1-解释&quot;&gt;&lt;a href=&quot;#1-1-解释&quot; class=&quot;headerlink&quot; title=&quot;1.1 解释&quot;&gt;&lt;/a&gt;1.1 解释&lt;/h3&gt;&lt;p&gt;把一种形式转成另外一种形式就叫转型&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;基础数据类型的转型, (例如: 把 float 类型转成 int 类型，把 float 类型转成 double 类型)&lt;/li&gt;
&lt;li&gt;对象领域里面对象之间的转型。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;对象转型分为两种：&quot;&gt;&lt;a href=&quot;#对象转型分为两种：&quot; class=&quot;headerlink&quot; title=&quot;对象转型分为两种：&quot;&gt;&lt;/a&gt;对象转型分为两种：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;向上转型 &lt;/li&gt;
&lt;li&gt;向下转型&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---反射</title>
    <link href="http://yoursite.com/2019/03/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2019/03/15/Java基础知识---反射/</id>
    <published>2019-03-15T06:41:51.000Z</published>
    <updated>2019-04-05T00:31:40.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-什么是反射"><a href="#一-什么是反射" class="headerlink" title="一. 什么是反射"></a>一. 什么是反射</h1><p>​    反射之中包含了一个<strong>「反」</strong>字，所以想要解释反射就必须先从<strong>「正」</strong>开始解释。</p><a id="more"></a><h2 id="1-1-正射"><a href="#1-1-正射" class="headerlink" title="1.1 正射"></a>1.1 正射</h2><p>​    一般情况下，我们使用某个类时<strong>必定知道</strong>它是什么类，是用来做什么的。于是我们<strong>直接对这个类进行实例化</strong>，之后使用这个类对象进行操作。</p><h4 id="正射范例"><a href="#正射范例" class="headerlink" title="正射范例"></a>正射范例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行类对象的初始化，可以理解为「正」。</span></span><br><span class="line">Apple apple = <span class="keyword">new</span> Apple(); <span class="comment">//直接初始化，「正射」</span></span><br><span class="line">apple.setPrice(<span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"Apple Price:"</span> + apple.getPrice());</span><br></pre></td></tr></table></figure><h2 id="1-2-反射"><a href="#1-2-反射" class="headerlink" title="1.2 反射"></a>1.2 反射</h2><p>​    反射则是<strong>一开始并不知道我要初始化的类对象是什么</strong>，自然也无法使用 new 关键字来创建对象了。</p><p>这时候，我们<strong>使用 JDK 提供的反射 API 进行反射调用</strong> </p><h4 id="反射范例"><a href="#反射范例" class="headerlink" title="反射范例"></a>反射范例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用反射获取一个对象的步骤：</span></span><br><span class="line"><span class="comment">// 1. 获取类的 Class 对象, 类对象</span></span><br><span class="line">Class clz = Class.forName(<span class="string">"how2j10.Apple"</span>);</span><br><span class="line"><span class="comment">// 2. 根据 Class 对象实例获取 Constructor 对象, 构造器</span></span><br><span class="line">Constructor appleConstructor = clz.getConstructor();</span><br><span class="line"><span class="comment">// 3. 使用 Constructor 对象的 newInstance 方法获取反射类对象, 通过构造器实例化</span></span><br><span class="line">Object appleObj = appleConstructor.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果要调用某一个方法，则需要经过下面的步骤</span></span><br><span class="line"><span class="comment">// 1. 获取方法的 Method 对象</span></span><br><span class="line">Method setPriceMethod = clz.getMethod(<span class="string">"setPrice"</span>, <span class="keyword">int</span>.class);</span><br><span class="line"><span class="comment">// 2. 利用 invoke 方法调用方法</span></span><br><span class="line">setPriceMethod.invoke(appleObj, <span class="number">14</span>);</span><br><span class="line">Method getPriceMethod = clz.getMethod(<span class="string">"getPrice"</span>);</span><br><span class="line">System.out.println(<span class="string">"Apple Price:"</span> + getPriceMethod.invoke(appleObj));</span><br></pre></td></tr></table></figure><p>​    上面两段代码的执行结果，其实是完全一样的。</p><p>​    但是其思路完全不一样，第一段代码在<strong>未运行时就已经确定了要运行的类（Apple）</strong>，而第二段代码则是在<strong>运行时通过字符串值才得知要运行的类（com.chenshuyi.reflect.Apple）</strong>。</p><h4 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h4><blockquote><p><strong>反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。</strong></p></blockquote><h1 id="二-获取反射中的-Class-对象-类对象"><a href="#二-获取反射中的-Class-对象-类对象" class="headerlink" title="二. 获取反射中的 Class 对象(类对象)"></a>二. 获取反射中的 Class 对象(类对象)</h1><h2 id="2-1-类对象"><a href="#2-1-类对象" class="headerlink" title="2.1 类对象"></a>2.1 类对象</h2><p>​    <strong>概念:</strong> 类对象用于<strong>提供类本身的信息</strong>，比如有几种构造方法， 有多少属性，有哪些普通方法</p><h4 id="什么是类对象"><a href="#什么是类对象" class="headerlink" title="什么是类对象"></a>什么是类对象</h4><ul><li><p><strong>对象之间的区别: </strong>garen和teemo都是Hero对象，他们的区别在于，各自有不同的名称，血量，伤害值。</p></li><li><p><strong>类之间的区别:</strong> Hero和Item都是类，他们的区别在于<strong>有不同的方法，不同的属性</strong>。</p></li></ul><blockquote><p><strong>==类对象，就是用于描述这种类，都有什么属性，什么方法的==</strong></p></blockquote><p>在反射中，要获取一个类或调用一个类的方法，我们<strong>首先需要获取到该类的 Class 对象</strong>。</p><h2 id="2-2-获取class对象-类对象"><a href="#2-2-获取class对象-类对象" class="headerlink" title="2.2 获取class对象(类对象)"></a>2.2 获取class对象(类对象)</h2><ol><li>在 Java API 中，获取 Class 类对象有三种方法</li><li>在一个JVM中，<strong>一种类，只会有一个类对象存在</strong>。所以三种方式取出来的<strong>class对象</strong>，<strong>都是一样的</strong>。</li></ol><h4 id="方法范例"><a href="#方法范例" class="headerlink" title="方法范例"></a>方法范例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// how2j10 是包名, Apple 是类名</span></span><br><span class="line">String className = <span class="string">"how2j10.Apple"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 使用 Class.forName 静态方法。当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。</span></span><br><span class="line">Class clz = Class.forName(className);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用 .class 方法。 这种方法只适合在编译前就知道操作的 Class。</span></span><br><span class="line">Class clz = Apple.class;</span><br><span class="line">Class clz = <span class="keyword">this</span>.class;<span class="comment">// 这种调用本类的类对象,常用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 第三种，使用类对象的 getClass() 方法。</span></span><br><span class="line">Class clz = <span class="keyword">new</span> Apple().getClass();</span><br><span class="line">System.out.println(<span class="string">"clz的值为:"</span> + clz);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果: clz的值为:class how2j10.Apple</span></span><br></pre></td></tr></table></figure><h2 id="2-3-注意"><a href="#2-3-注意" class="headerlink" title="2.3 注意:"></a>2.3 注意:</h2><p>​    <strong>获取类对象的时候，会导致类属性被初始化</strong></p><p>​    <strong>无论什么途径获取类对象，都会导致静态属性被初始化，而且只会执行一次</strong>。（除了直接使用 Class c = Hero.class 这种方式，这种方式不会导致静态属性被初始化）</p><h1 id="三-通过反射获取构造方法并使用"><a href="#三-通过反射获取构造方法并使用" class="headerlink" title="三. 通过反射获取构造方法并使用"></a>三. 通过反射获取构造方法并使用</h1><h2 id="3-1-获取单个的构造方法，并调用："><a href="#3-1-获取单个的构造方法，并调用：" class="headerlink" title="3.1  获取单个的构造方法，并调用："></a>3.1  获取单个的构造方法，并调用：</h2><ul><li><code>public Constructor getConstructor(Class... parameterTypes)</code> : 获取<strong>单个的”公有的”构造方法</strong>：</li><li><code>public Constructor getDeclaredConstructor(Class... parameterTypes)</code>: 获取<strong>“某个构造方法”可以是私有的，或受保护、默认、公有</strong> </li></ul><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取构造器</span></span><br><span class="line">Constructor appleConstructor = clz.getConstructor();</span><br></pre></td></tr></table></figure><h2 id="3-3-调用构造方法："><a href="#3-3-调用构造方法：" class="headerlink" title="3.3 调用构造方法："></a>3.3 调用构造方法：</h2><p>​    <strong>newInstance</strong>是 Constructor类的方法<strong>（管理构造函数的类）</strong></p><h5 id="api的解释为："><a href="#api的解释为：" class="headerlink" title="api的解释为："></a>api的解释为：</h5><ul><li><p><code>newInstance(Object... initargs)</code> : 使用此 Constructor 对象表示的构造方法来<strong>创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。</strong></p></li><li><p>它的返回值是T类型，所以newInstance是创建了一个<strong>构造方法的声明类的新实例对象</strong>。并为之调用</p></li></ul><h5 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  通过构造器实例化,使用 Constructor 对象的 newInstance 方法获取反射类对象</span></span><br><span class="line">Object appleObj = appleConstructor.newInstance();</span><br></pre></td></tr></table></figure><h1 id="四-获取成员变量"><a href="#四-获取成员变量" class="headerlink" title="四. 获取成员变量"></a>四. 获取成员变量</h1><h3 id="4-1-获取成员变量并调用"><a href="#4-1-获取成员变量并调用" class="headerlink" title="4.1 获取成员变量并调用"></a>4.1 获取成员变量并调用</h3><ul><li><h4 id="批量的"><a href="#批量的" class="headerlink" title="批量的"></a>批量的</h4><ul><li><p><strong><code>Field[] getFields()</code></strong>: 获取所有的”公有字段”</p></li><li><p><strong><code>Field[] getDeclaredFields()</code></strong>: 获取所有字段，包括：私有、受保护、默认、公有</p></li></ul></li><li><h4 id="获取单个的"><a href="#获取单个的" class="headerlink" title="获取单个的"></a>获取单个的</h4><ul><li><p><strong><code>public Field getField(String fieldName)</code></strong> : 获取某个”公有的”字段；</p></li><li><p><strong><code>public Field getDeclaredField(String fieldName)</code></strong> : 获取某个字段***(可以是私有的)</p></li></ul></li></ul><h3 id="4-2-设置字段的值"><a href="#4-2-设置字段的值" class="headerlink" title="4.2 设置字段的值"></a>4.2 设置字段的值</h3><p>​    <code>Field --&gt; public void set(Object obj,Object value)</code></p><p>参数说明：</p><ol><li>obj : 要设置的字段所在的<strong>对象</strong>；</li><li>value : 要为字段设置的<strong>值</strong>；</li></ol><h5 id="范例-2"><a href="#范例-2" class="headerlink" title="范例"></a>范例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fields</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取Class对象</span></span><br><span class="line">        Class stuClass = Class.forName(<span class="string">"fanshe.field.Student"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.获取字段</span></span><br><span class="line">        System.out.println(<span class="string">"********获取公有字段**并调用*********"</span>);</span><br><span class="line">        Field f = stuClass.getField(<span class="string">"name"</span>);</span><br><span class="line">        System.out.println(f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.获取一个对象</span></span><br><span class="line">        <span class="comment">// 产生Student对象 --&gt; Student stu = new Student();</span></span><br><span class="line">        Object obj = stuClass.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.为字段设置值</span></span><br><span class="line">        <span class="comment">// 为Student对象中的name属性赋值 --&gt; stu.name = "刘德华"</span></span><br><span class="line">        f.set(obj, <span class="string">"刘德华"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五-获取成员方法并调用"><a href="#五-获取成员方法并调用" class="headerlink" title="五. 获取成员方法并调用"></a>五. 获取成员方法并调用</h1><h3 id="5-1-获取成员方法："><a href="#5-1-获取成员方法：" class="headerlink" title="5.1 获取成员方法："></a>5.1 获取成员方法：</h3><ul><li><h4 id="批量的批量的"><a href="#批量的批量的" class="headerlink" title="批量的批量的"></a>批量的批量的</h4><ul><li><p><strong><code>public Method[] getMethods()</code></strong> : 获取所有”公有方法”；（包含了父类的方法也包含Object类）</p></li><li><p><strong><code>public Method[] getDeclaredMethods()</code></strong> : 获取所有的成员方法，包括私有的(不包括继承的)</p></li></ul></li><li><h4 id="获取单个的："><a href="#获取单个的：" class="headerlink" title="获取单个的："></a>获取单个的：</h4><ol><li><p><strong><code>public Method getMethod(String name,Class&lt;?&gt;... parameterTypes)</code></strong></p><p>参数说明</p><ul><li><p>name : 方法名；</p></li><li><p>Class … : 形参的Class类型对象</p></li></ul></li><li><p><strong><code>public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)</code></strong></p></li></ol></li></ul><h3 id="5-2-成员方法调用"><a href="#5-2-成员方法调用" class="headerlink" title="5.2 成员方法调用"></a>5.2 成员方法调用</h3><p>​    <strong><code>Method --&gt; public Object invoke(Object obj,Object... args)</code></strong></p><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h5><ul><li><p>obj : 要调用方法的对象；</p><ul><li>args : 调用方式时所传递的实参；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodClass</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 1.获取Class对象</span></span><br><span class="line">Class stuClass = Class.forName(<span class="string">"fanshe.method.Student"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"***************获取公有的show1()方法*******************"</span>);</span><br><span class="line">        <span class="comment">//2. 获取方法</span></span><br><span class="line">Method m = stuClass.getMethod(<span class="string">"show1"</span>, String.class);</span><br><span class="line">System.out.println(m);</span><br><span class="line"><span class="comment">// 3.实例化一个Student对象</span></span><br><span class="line">Object obj = stuClass.getConstructor().newInstance();</span><br><span class="line">        <span class="comment">// 4.方法的调用,一个是要调用的对象（获取有反射），一个是实参</span></span><br><span class="line">m.invoke(obj, <span class="string">"刘德华"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"***************获取私有的show4()方法******************"</span>);</span><br><span class="line">m = stuClass.getDeclaredMethod(<span class="string">"show4"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">System.out.println(m);</span><br><span class="line">m.setAccessible(<span class="keyword">true</span>);<span class="comment">//解除私有限定</span></span><br><span class="line">Object result = m.invoke(obj, <span class="number">20</span>);<span class="comment">//需要两个参数，一个是要调用的对象（获取有反射），一个是实参</span></span><br><span class="line">System.out.println(<span class="string">"返回值："</span> + result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六-通过反射运行配置文件内容"><a href="#六-通过反射运行配置文件内容" class="headerlink" title="六. 通过反射运行配置文件内容"></a>六. 通过反射运行配置文件内容</h1><h3 id="6-1-反射的作用"><a href="#6-1-反射的作用" class="headerlink" title="6.1 反射的作用"></a>6.1 反射的作用</h3><ol><li><p>我们利用反射和配置文件，可以使：<strong>应用程序更新时，对源码无需进行任何修改</strong></p></li><li><p>我们只需要<strong>将新类发送给客户端，并修改配置文件即可</strong></p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h5 id="student类"><a href="#student类" class="headerlink" title="student类"></a>student类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"is show()"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置文件</strong>以 txt 文件为例子（<strong>pro.txt</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className = cn.fanshe.Student</span><br><span class="line">methodName = show</span><br></pre></td></tr></table></figure><h5 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 1.通过反射获取Class对象</span></span><br><span class="line">Class stuClass = Class.forName(getValue(<span class="string">"className"</span>)); <span class="comment">//"cn.fanshe.Student"</span></span><br><span class="line"><span class="comment">// 2.获取 show()方法</span></span><br><span class="line">Method m = stuClass.getMethod(getValue(<span class="string">"methodName"</span>)); <span class="comment">//show</span></span><br><span class="line"><span class="comment">// 3.调用show()方法</span></span><br><span class="line">m.invoke( stuClass.getConstructor().newInstance());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法接收一个 key，在配置文件中获取相应的 value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getValue</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">Properties pro = <span class="keyword">new</span> Properties();<span class="comment">//获取配置文件的对象</span></span><br><span class="line">FileReader in = <span class="keyword">new</span> FileReader(<span class="string">"pro.txt"</span>);<span class="comment">//获取输入流</span></span><br><span class="line">pro.load(in);<span class="comment">//将流加载到配置文件对象中</span></span><br><span class="line">in.close();</span><br><span class="line"><span class="keyword">return</span> pro.getProperty(key);<span class="comment">//返回根据key获取的value值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果: is show()</span></span><br></pre></td></tr></table></figure><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>​    当我们升级这个系统时，<strong>不要Student类</strong>，而需要<strong>新写一个Student2的类时</strong>，这时<strong>只需要更改pro.txt</strong>的文件内容就可以了。<strong>代码就一点不用改动</strong></p><h5 id="要替换的student2类"><a href="#要替换的student2类" class="headerlink" title="要替换的student2类"></a>要替换的student2类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"is show2()"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置文件更改为"><a href="#配置文件更改为" class="headerlink" title="配置文件更改为"></a>配置文件更改为</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className = cn.fanshe.Student2</span><br><span class="line">methodName = show2</span><br></pre></td></tr></table></figure><h5 id="控制台输出："><a href="#控制台输出：" class="headerlink" title="控制台输出："></a>控制台输出：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印结果: is show2()</span></span><br></pre></td></tr></table></figure><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html" target="_blank" rel="noopener">大白话说Java反射：入门、使用、原理</a></p><p>​    <a href="https://blog.csdn.net/sinat_38259539/article/details/71799078" target="_blank" rel="noopener">Java基础之—反射（非常重要）</a></p><p>​    <a href="http://how2j.cn/k/reflection/reflection-method/109.html" target="_blank" rel="noopener">how2j</a></p><p>​    <a href="https://blog.csdn.net/codejas/article/details/78635926" target="_blank" rel="noopener">Java 反射机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-什么是反射&quot;&gt;&lt;a href=&quot;#一-什么是反射&quot; class=&quot;headerlink&quot; title=&quot;一. 什么是反射&quot;&gt;&lt;/a&gt;一. 什么是反射&lt;/h1&gt;&lt;p&gt;​    反射之中包含了一个&lt;strong&gt;「反」&lt;/strong&gt;字，所以想要解释反射就必须先从&lt;strong&gt;「正」&lt;/strong&gt;开始解释。&lt;/p&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---多态</title>
    <link href="http://yoursite.com/2019/03/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%A4%9A%E6%80%81/"/>
    <id>http://yoursite.com/2019/03/15/Java基础知识---多态/</id>
    <published>2019-03-15T06:41:51.000Z</published>
    <updated>2019-03-22T03:16:31.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概念"><a href="#一-概念" class="headerlink" title="一. 概念"></a>一. 概念</h1><p>多态是<strong>同一个行为具有多个不同表现形式</strong>或形态的能力(同一个事件发生在不同的对象上会产生不同的结果)</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ol><li><p>现实中，比如我们<strong>按下 F1 键</strong>这个动作: 1. 如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档; 2. 如果当前在 Word 下弹出的就是 Word 帮助; 3. 在 Windows 下弹出的就是 Windows 帮助和支持。</p></li><li><p>Java中操作符 <code>+</code>: 1. 可以作为算数运算; 2. 可以作为字符串连接</p></li><li>Java中类的多态: 父类引用指向子类对象</li></ol><a id="more"></a><h1 id="二-观察类的多态现象"><a href="#二-观察类的多态现象" class="headerlink" title="二. 观察类的多态现象"></a>二. 观察类的多态现象</h1><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><h5 id="MagicPotion-java"><a href="#MagicPotion-java" class="headerlink" title="MagicPotion.java"></a>MagicPotion.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicPotion</span> <span class="keyword">extends</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">effect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"蓝瓶使用后，可以回魔法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="LifePotion-java"><a href="#LifePotion-java" class="headerlink" title="LifePotion.java"></a>LifePotion.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifePotion</span> <span class="keyword">extends</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">effect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"血瓶使用后，可以回血"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Item-java"><a href="#Item-java" class="headerlink" title="Item.java"></a>Item.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">effect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"物品使用后，可以有效果 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Item i1= <span class="keyword">new</span> LifePotion();</span><br><span class="line">        Item i2 = <span class="keyword">new</span> MagicPotion();</span><br><span class="line">        System.out.print(<span class="string">"i1 是Item类型，执行effect打印:"</span>);</span><br><span class="line">        i1.effect();</span><br><span class="line">        System.out.print(<span class="string">"i2 也是Item类型，执行effect打印:"</span>);</span><br><span class="line">        i2.effect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印结果: </span></span><br><span class="line"><span class="comment"> * i1 是Item类型，执行effect打印:血瓶使用后，可以回血</span></span><br><span class="line"><span class="comment"> * i2 也是Item类型，执行effect打印:蓝瓶使用后，可以回魔法</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h5 id="观察类的多态现象"><a href="#观察类的多态现象" class="headerlink" title="观察类的多态现象"></a>观察类的多态现象</h5><ol><li>i1和i2都是Item类型</li><li>都调用effect方法</li><li>输出不同的结果</li></ol><blockquote><p><strong>多态: 都是同一个类型，调用同一个方法，却能呈现不同的状态</strong>  </p></blockquote><h1 id="三-多态存在的三个必要条件"><a href="#三-多态存在的三个必要条件" class="headerlink" title="三. 多态存在的三个必要条件"></a>三. 多态存在的三个必要条件</h1><h3 id="3-1-继承"><a href="#3-1-继承" class="headerlink" title="3.1 继承"></a>3.1 继承</h3><p>类的多态发生在父类调用指向子类对象, 所以一定有子类继承父类</p><h3 id="3-2-重写"><a href="#3-2-重写" class="headerlink" title="3.2 重写"></a>3.2 重写</h3><p>子类对父类中某些方法进行重新定义</p><p>父类调用相同的方法, 实现却不一样,所以必定有重写</p><h3 id="3-3-向上转型"><a href="#3-3-向上转型" class="headerlink" title="3.3  向上转型"></a>3.3  向上转型</h3><p>将子类的引用赋给父类对象(父类引用指向子类对象)</p><h1 id="四-多态的实现方式"><a href="#四-多态的实现方式" class="headerlink" title="四. 多态的实现方式"></a>四. 多态的实现方式</h1><h3 id="4-1-重写"><a href="#4-1-重写" class="headerlink" title="4.1 重写"></a>4.1 重写</h3><p>子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p><h3 id="4-2-接口"><a href="#4-2-接口" class="headerlink" title="4.2 接口"></a>4.2 接口</h3><ol><li><p>生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。</p></li><li><p>java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。</p></li></ol><h3 id="4-3-抽象类和抽象方法"><a href="#4-3-抽象类和抽象方法" class="headerlink" title="4.3 抽象类和抽象方法"></a>4.3 抽象类和抽象方法</h3><h1 id="五-深入理解多态"><a href="#五-深入理解多态" class="headerlink" title="五. 深入理解多态"></a>五. 深入理解多态</h1><p>也叫<strong>动态绑定</strong> : 动态绑定是指在 <strong>执行期间</strong> (而非编译期间) <strong>判断所引用对象的实际类型，根据其实际的类型调用其相应的方法</strong></p><h4 id="总结动态绑定（多态）"><a href="#总结动态绑定（多态）" class="headerlink" title="总结动态绑定（多态）"></a>总结动态绑定（多态）</h4><p>动态绑定是指在“执行期间”（而非编译期间）判断所引用的实际对象类型，根据其实际的类型调用其相应的方法。所以实际当中找要调用的方法时是动态的去找的，new的是谁就找谁的方法，这就叫动态绑定。动态绑定帮助我们的程序的可扩展性达到了极致</p><h1 id="六-多态存在的意义"><a href="#六-多态存在的意义" class="headerlink" title="六. 多态存在的意义"></a>六. 多态存在的意义</h1><h4 id="范例1"><a href="#范例1" class="headerlink" title="范例1"></a>范例1</h4><p>假设你要设计一个通用框架，这个框架会涉及到数据库的操作，但是你不能限定用户用哪个数据库，这个时候你就可以用到多态。</p><ol><li><p>你可以设计一个接口：DataBaseDao</p></li><li><p>然后，每个不同的数据库，你可以编写接口的实现类，比如：SQLServerDao, MySqlDao, DB2Dao等等<br>当用户使用你框架的时候，他就可以用多态，实现自己的数据库连接功能：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 针对SQLServer的接口实现，这里dao就是多态</span></span><br><span class="line">DaoBaseDao dao = <span class="keyword">new</span> SQLServerDao(); </span><br><span class="line">dao.connect();</span><br></pre></td></tr></table></figure></li></ol><h4 id="范例2"><a href="#范例2" class="headerlink" title="范例2"></a>范例2</h4><p>实例: <a href="https://blog.csdn.net/guomutian911/article/details/48938125" target="_blank" rel="noopener">【超经典】Java多态有什么好处？怎样用？</a></p><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3644035.html" target="_blank" rel="noopener">java基础学习总结——多态(动态绑定)</a>    </p><p>​    <a href="http://www.runoob.com/java/java-polymorphism.html" target="_blank" rel="noopener">Java 多态</a></p><p>​    <a href="http://how2j.cn/module/54.html" target="_blank" rel="noopener">接口与继承</a></p><p>​    <a href="https://www.cnblogs.com/chenssy/p/3372798.html" target="_blank" rel="noopener">java提高篇(四)—–理解java的三大特性之多态</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-概念&quot;&gt;&lt;a href=&quot;#一-概念&quot; class=&quot;headerlink&quot; title=&quot;一. 概念&quot;&gt;&lt;/a&gt;一. 概念&lt;/h1&gt;&lt;p&gt;多态是&lt;strong&gt;同一个行为具有多个不同表现形式&lt;/strong&gt;或形态的能力(同一个事件发生在不同的对象上会产生不同的结果)&lt;/p&gt;
&lt;h4 id=&quot;例子&quot;&gt;&lt;a href=&quot;#例子&quot; class=&quot;headerlink&quot; title=&quot;例子&quot;&gt;&lt;/a&gt;例子&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;现实中，比如我们&lt;strong&gt;按下 F1 键&lt;/strong&gt;这个动作: 1. 如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档; 2. 如果当前在 Word 下弹出的就是 Word 帮助; 3. 在 Windows 下弹出的就是 Windows 帮助和支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java中操作符 &lt;code&gt;+&lt;/code&gt;: 1. 可以作为算数运算; 2. 可以作为字符串连接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Java中类的多态: 父类引用指向子类对象&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---框架图解</title>
    <link href="http://yoursite.com/2019/03/14/JavaWeb-%E6%A1%86%E6%9E%B6%E5%9B%BE%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/03/14/JavaWeb-框架图解/</id>
    <published>2019-03-14T13:40:31.000Z</published>
    <updated>2019-03-15T08:34:47.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-MVC-模式"><a href="#1-MVC-模式" class="headerlink" title="1. MVC 模式"></a>1. MVC 模式</h2><p><img src="/2019/03/14/JavaWeb-框架图解/MVC模式.png" alt="MVC模式"></p><a id="more"></a><h2 id="2-sevlet"><a href="#2-sevlet" class="headerlink" title="2. sevlet"></a>2. sevlet</h2><p><img src="/2019/03/14/JavaWeb-框架图解/servlet.png" alt="servlet"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-MVC-模式&quot;&gt;&lt;a href=&quot;#1-MVC-模式&quot; class=&quot;headerlink&quot; title=&quot;1. MVC 模式&quot;&gt;&lt;/a&gt;1. MVC 模式&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/03/14/JavaWeb-框架图解/MVC模式.png&quot; alt=&quot;MVC模式&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
      <category term="图解" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---JSP指令</title>
    <link href="http://yoursite.com/2019/03/14/JavaWeb---JSP%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/03/14/JavaWeb---JSP指令/</id>
    <published>2019-03-14T12:41:51.000Z</published>
    <updated>2019-03-25T03:01:14.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JSP-指令简介"><a href="#一、JSP-指令简介" class="headerlink" title="一、JSP 指令简介"></a>一、JSP 指令简介</h2><p>　　JSP指令（directive）是为 JSP 引擎而设计的，它们并<strong>不直接产生任何可见输出</strong>，而只是告诉引擎 <strong>如何处理JSP页面中的其余部分</strong>。</p><p>在 JSP 2.0规范中共定义了三个指令：</p><ul><li>page指令</li><li>Include指令</li><li>taglib指令</li></ul><blockquote><p>JSP指令的基本语法格式：<strong>&lt;%@ 指令 属性名=”值” %&gt;</strong></p></blockquote><a id="more"></a><h5 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=gb2312"</span>%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--如果一个指令有多个属性，这多个属性可以写在一个指令中，也可以分开写--&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=gb2312"</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.Date"</span>%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--也可以写作--&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=gb2312"</span> <span class="keyword">import</span>=<span class="string">"java.util.Date"</span>%&gt;</span><br></pre></td></tr></table></figure><h1 id="二、Page指令"><a href="#二、Page指令" class="headerlink" title="二、Page指令"></a>二、Page指令</h1><p>​    page指令 <strong>用于定义 JSP 页面的==各种属性==</strong> ，无论page指令出现在JSP页面中的什么地方，它作用的都是<strong>整个JSP页面</strong>，为了保持程序的可读性和遵循良好的编程习惯，page指令最好是放在<strong>整个JSP页面的起始位置</strong>。</p><h5 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--指令完整语法--&gt;</span><br><span class="line">&lt;%@ page </span><br><span class="line">    [ language=<span class="string">"java"</span> ] </span><br><span class="line">    [ extends=<span class="string">"package.class"</span> ] </span><br><span class="line">    [ <span class="keyword">import</span>=<span class="string">"&#123;package.class | package.*&#125;, ..."</span> ] </span><br><span class="line">    [ session=<span class="string">"true | false"</span> ] </span><br><span class="line">    [ buffer=<span class="string">"none | 8kb | sizekb"</span> ] </span><br><span class="line">    [ autoFlush=<span class="string">"true | false"</span> ] </span><br><span class="line">    [ isThreadSafe=<span class="string">"true | false"</span> ] </span><br><span class="line">    [ info=<span class="string">"text"</span> ] </span><br><span class="line">    [ errorPage=<span class="string">"relative_url"</span> ] </span><br><span class="line">    [ isErrorPage=<span class="string">"true | false"</span> ] </span><br><span class="line">    [ contentType=<span class="string">"mimeType [ ;charset=characterSet ]"</span> | <span class="string">"text/html ; charset=ISO-8859-1"</span> ] </span><br><span class="line">    [ pageEncoding=<span class="string">"characterSet | ISO-8859-1"</span> ] </span><br><span class="line">    [ isELIgnored=<span class="string">"true | false"</span> ]  &lt;!--是否忽略 EL 表达式--&gt;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h1 id="三-include指令"><a href="#三-include指令" class="headerlink" title="三. include指令"></a>三. include指令</h1><p>在JSP中对于包含有<strong>两种语句形式</strong>：</p><ol><li><code>@include</code> 指令</li><li><code>&lt;jsp:include&gt;</code> 指令</li></ol><h2 id="3-1-include指令"><a href="#3-1-include指令" class="headerlink" title="3.1 @include指令"></a>3.1 @include指令</h2><ul><li><p>@include可以<strong>包含任意的文件</strong>，当然，只是把文件的内容包含进来。</p></li><li><p>include指令用于引入其它JSP页面，如果使用include指令引入了其它JSP页面，那么<strong>JSP引擎将把这两个JSP翻译成一个servlet</strong>。所以include指令引入通常也称之<strong>为静态引入</strong>。</p></li></ul><p>语法：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--其中的file属性用于指定被引入文件的路径。路径以“/”开头，表示代表当前web应用。--&gt;</span><br><span class="line">&lt;%@ include file=<span class="string">"relativeURL"</span>%&gt;</span><br></pre></td></tr></table></figure><h4 id="include指令细节注意问题："><a href="#include指令细节注意问题：" class="headerlink" title="include指令细节注意问题："></a>include指令细节注意问题：</h4><ol><li>被引入的文件必须遵循 JSP 语法。</li><li>被引入的文件<strong>可以使用任意的扩展名</strong>，即使其扩展名是html，JSP引擎也会按照处理jsp页面的方式处理它里面的内容，为了见明知意，JSP规范建议使用 .jspf（JSP fragments(片段)）作为静态引入文件的扩展名。</li><li>由于使用include指令将会涉及到2个JSP页面，并会把2个JSP翻译成一个servlet，所以这2个JSP页面的指令不能冲突(除了pageEncoding和导包除外)。</li></ol><h5 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h5><p>　　新建head.jspf页面和foot.jspf页面，分别作为jsp页面的头部和尾部，存放于<strong>WebRoot下的jspfragments文件夹中</strong>，代码如下：</p><p><strong>head.jspf代码：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;h1 style="color:red;"&gt;网页头部&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p><strong>foot.jspf代码：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;h1 style="color:blue;"&gt;网页尾部&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>　　在<strong>WebRoot文件夹下</strong>创建一个IncludeTagTest.jsp页面，在IncludeTagTest.jsp页面中使用<strong>@include</strong>指令<strong>引入</strong>head.jspf页面和foot.jspf页面，代码如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;jsp的Include指令测试&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;%--使用include标签引入引入其它JSP页面--%&gt;</span><br><span class="line">    &lt;%<span class="meta">@include</span> file=<span class="string">"/jspfragments/head.jspf"</span> %&gt;</span><br><span class="line">    &lt;h1&gt;网页主体内容&lt;/h1&gt;</span><br><span class="line">    &lt;%<span class="meta">@include</span> file=<span class="string">"/jspfragments/foot.jspf"</span> %&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="3-2-总结-include-指令"><a href="#3-2-总结-include-指令" class="headerlink" title="3.2 总结 @include 指令"></a>3.2 总结 @include 指令</h2><p>　　使用@include<strong>可以包含任意的内容</strong>，文件的后缀是什么都无所谓。这种<strong>把别的文件内容包含到自身页面的@include语句就叫作静态包含</strong>，作用只是把别的页面内容包含进来，属于静态包含</p><h2 id="3-3-jsp-include指令"><a href="#3-3-jsp-include指令" class="headerlink" title="3.3 jsp:include指令"></a>3.3 jsp:include指令</h2><p>　　<strong>jsp:include指令</strong>为动态包含，如果被包含的页面是JSP，则先处理之后再将结果包含，而如果包含的是非*.jsp文件，则只是把文件内容静态包含进来，功能与@include类似。后面再具体介绍</p><h1 id="四-taglib-指令"><a href="#四-taglib-指令" class="headerlink" title="四. taglib 指令"></a>四. taglib 指令</h1><h2 id="4-1-引入"><a href="#4-1-引入" class="headerlink" title="4.1 引入"></a>4.1 引入</h2><p>Taglib 指令是<strong>定义一个标签库以及其自定义标签的前缀</strong>.<br>需要导入<strong>standard.jar</strong> ; <strong>jsp-api.jar</strong>  两个包 </p><p>在 JSP 页面中<strong>使用第三方的标签库</strong>时，需要使用 taglib 指令来 “导包”。例如：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> prefix=<span class="string">"c"</span>%&gt;</span><br></pre></td></tr></table></figure><h5 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h5><ul><li><p><strong>prefix</strong> : 标签库别名 </p></li><li><p><strong>uri</strong> : 是由第三方标签库定义的，所以你需要知道第三方定义的uri</p></li></ul><h2 id="4-2-标签库引入-jsp-文件时-uri-有两种写法"><a href="#4-2-标签库引入-jsp-文件时-uri-有两种写法" class="headerlink" title="4.2 标签库引入 jsp 文件时 uri 有两种写法"></a>4.2 标签库引入 jsp 文件时 uri 有两种写法</h2><ol><li><p>自定义</p></li><li><p>标准定义 </p></li></ol><p>当打开一个tld文件时，在文件的头部会有一个uri节点，里面的内容即为uri的标准定义。</p><p>使用标准定义的优点在于，不用在web.xml下加上上面的代码</p><h5 id="源码-Referenced-Library-standard-jar-META-INF-c-tld"><a href="#源码-Referenced-Library-standard-jar-META-INF-c-tld" class="headerlink" title="源码 Referenced Library/standard.jar/META-INF/c.tld"></a>源码 Referenced Library/standard.jar/META-INF/c.tld</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;short-name&gt;c&lt;/short-name&gt;</span><br><span class="line">&lt;uri&gt;http:<span class="comment">//java.sun.com/jsp/jstl/core&lt;/uri&gt;</span></span><br></pre></td></tr></table></figure><h5 id="jsp"><a href="#jsp" class="headerlink" title="jsp"></a>jsp</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">    pageEncoding=<span class="string">"utf-8"</span>%&gt; </span><br><span class="line">&lt;%@ taglib uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> prefix=<span class="string">"c"</span> %&gt; </span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE&gt; </span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span>&gt; </span><br><span class="line">        &lt;title&gt;collection&lt;/title&gt; </span><br><span class="line">    &lt;/head&gt; </span><br><span class="line">    &lt;body&gt; </span><br><span class="line">    &lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3778993.html" target="_blank" rel="noopener">javaweb学习总结(十六)——JSP指令</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、JSP-指令简介&quot;&gt;&lt;a href=&quot;#一、JSP-指令简介&quot; class=&quot;headerlink&quot; title=&quot;一、JSP 指令简介&quot;&gt;&lt;/a&gt;一、JSP 指令简介&lt;/h2&gt;&lt;p&gt;　　JSP指令（directive）是为 JSP 引擎而设计的，它们并&lt;strong&gt;不直接产生任何可见输出&lt;/strong&gt;，而只是告诉引擎 &lt;strong&gt;如何处理JSP页面中的其余部分&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 JSP 2.0规范中共定义了三个指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;page指令&lt;/li&gt;
&lt;li&gt;Include指令&lt;/li&gt;
&lt;li&gt;taglib指令&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;JSP指令的基本语法格式：&lt;strong&gt;&amp;lt;%@ 指令 属性名=”值” %&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---JSP基础语法</title>
    <link href="http://yoursite.com/2019/03/14/JavaWeb---JSP%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/14/JavaWeb---JSP基础语法/</id>
    <published>2019-03-14T12:18:51.000Z</published>
    <updated>2019-03-15T08:22:33.558Z</updated>
    
    <content type="html"><![CDATA[<p>​    任何语言都有自己的语法，JAVA 中有，JS P虽然是在JAVA上的一种应用，但是依然有其<strong>自己扩充的语法</strong>，而且在 JSP 中，<strong>所有的 JAVA 语句都可以使用</strong>。</p><h1 id="一-JSP-模版元素"><a href="#一-JSP-模版元素" class="headerlink" title="一. JSP 模版元素"></a>一. JSP 模版元素</h1><ul><li>JSP 页面中的 <strong>HTML 内容</strong> 称之为 <strong>JSP 模版元素</strong> 。 </li><li>JSP 模版元素定义了网页的 <strong>基本骨架</strong> ，即定义了页面的结构和外观。</li></ul><a id="more"></a><h1 id="二、JSP表达式"><a href="#二、JSP表达式" class="headerlink" title="二、JSP表达式"></a>二、JSP表达式</h1><p>　　JSP 脚本表达式（expression）用于将程序数据输出到客户端</p><p>​    语法：<strong>&lt;%= 变量或表达式 %&gt;</strong></p><p>举例：输出当前系统时间:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= <span class="keyword">new</span> java.util.Date() %&gt;</span><br></pre></td></tr></table></figure><p>　　JSP引擎在翻译脚本表达式时，会将<strong>程序数据转成字符串</strong>，然后在<strong>相应位置用out.print(…) 将数据输给客户端</strong>。<br>　　JSP脚本表达式中的变量或表达式后面<strong>不能有分号（;）</strong>。</p><h1 id="三、JSP脚本片断"><a href="#三、JSP脚本片断" class="headerlink" title="三、JSP脚本片断"></a>三、JSP脚本片断</h1><p>　　JSP脚本片断(scriptlet)用于在JSP页面中编写多行Java代码。</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在&lt;% %&gt;中可以定义变量、编写语句，不能定义方法--&gt;</span><br><span class="line">&lt;% </span><br><span class="line">多行java代码 </span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p><strong>范例:</strong> 在Scriptlet中<strong>定义变量、编写语句</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;<span class="comment">//声明变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*编写语句*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    out.println(<span class="string">"&lt;h1&gt;Sum="</span>+sum+<span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>JSP脚本片断中<strong>只能</strong>出现java代码，不能出现其它模板元素， JSP引擎在翻译JSP页面中，会将JSP脚本片断中的Java代码将被原封不动地放到Servlet的_jspService方法中。</li><li>JSP脚本片断中的Java代码必须严格遵循Java语法，例如，每执行语句后面必须<strong>用分号（;）结束</strong>。</li><li>在一个 JSP 页面中可以有多个脚本片断，在两个或多个脚本片断之间可以嵌入文本、HTML标记和其他JSP元素。</li></ul><h1 id="四、JSP声明"><a href="#四、JSP声明" class="headerlink" title="四、JSP声明"></a>四、JSP声明</h1><p>JSP页面中编写的所有代码，默认会翻译到 servlet 的 service 方法中， 而 JSP <strong>声明</strong>中的 java代码 被翻译到 <strong><code>_jspService</code>方法的外面</strong>。</p><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%！ </span><br><span class="line">java代码</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>​    所以，JSP声明可用于<strong>定义JSP页面转换成的Servlet程序的静态代码块、成员变量和方法</strong> 。 多个静态代码块、变量和函数可以定义在一个JSP声明中，也可以分别单独定义在多个JSP声明中。JSP隐式对象的作用范围仅限于Servlet的 <code>_jspService</code> 方法，所以在 JSP 声明中不能使用这些隐式对象。</p><h5 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">"loading Servlet!"</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> globalVar = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jspInit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"initializing jsp!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jspDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"destroying jsp!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h1 id="五-JSP注释"><a href="#五-JSP注释" class="headerlink" title="五. JSP注释"></a>五. JSP注释</h1><p>在 JSP 中，注释有两大类：</p><ul><li>显式注释：直接使用<strong>HTML</strong>风格的注释：<strong>&lt;!- -</strong> <strong>注释内容**</strong>- -&gt;</li><li>隐式注释：直接使用<strong>JAVA</strong>的注释：<strong>//</strong>、<strong>/*……***</strong>/**</li><li>JSP<strong>自己的注释：</strong>&lt;%- -注释内容- -%&gt;</li></ul><h5 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--这个注释可以看见--&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">//JAVA中的单行注释</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        JAVA中的多行注释</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--JSP自己的注释--%&gt;</span><br></pre></td></tr></table></figure><p>区别</p><p>​    HTML的注释在浏览器中查看源文件的时候是<strong>可以看得到</strong>的，而JAVA注释和JSP注释在浏览器中查看源文件时是<strong>看不到注释的内容</strong></p><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3776512.html" target="_blank" rel="noopener">javaweb学习总结(十五)——JSP基础语法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    任何语言都有自己的语法，JAVA 中有，JS P虽然是在JAVA上的一种应用，但是依然有其&lt;strong&gt;自己扩充的语法&lt;/strong&gt;，而且在 JSP 中，&lt;strong&gt;所有的 JAVA 语句都可以使用&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&quot;一-JSP-模版元素&quot;&gt;&lt;a href=&quot;#一-JSP-模版元素&quot; class=&quot;headerlink&quot; title=&quot;一. JSP 模版元素&quot;&gt;&lt;/a&gt;一. JSP 模版元素&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JSP 页面中的 &lt;strong&gt;HTML 内容&lt;/strong&gt; 称之为 &lt;strong&gt;JSP 模版元素&lt;/strong&gt; 。 &lt;/li&gt;
&lt;li&gt;JSP 模版元素定义了网页的 &lt;strong&gt;基本骨架&lt;/strong&gt; ，即定义了页面的结构和外观。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---JavaWeb开发入门</title>
    <link href="http://yoursite.com/2019/03/14/JavaWeb---JavaWeb%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/03/14/JavaWeb---JavaWeb开发入门/</id>
    <published>2019-03-14T11:09:51.000Z</published>
    <updated>2019-03-15T08:20:53.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-基本概念"><a href="#一-基本概念" class="headerlink" title="一. 基本概念"></a>一. 基本概念</h1><h2 id="1-1-WEB-开发的相关知识"><a href="#1-1-WEB-开发的相关知识" class="headerlink" title="1.1 WEB 开发的相关知识"></a>1.1 WEB 开发的相关知识</h2><blockquote><p>WEB，在英语中web即<strong>表示网页</strong>的意思，它用于表示<strong>Internet主机上供外界访问的资源</strong>。</p></blockquote><p>Internet上供外界访问的Web资源分为：</p><ol><li><strong>静态web资源</strong>（如html 页面）：指web页面中供人们<strong>浏览的数据始终是不变的</strong>。</li><li><strong>动态web资源</strong>：指web页面中供人们浏览的数据是**</li></ol><a id="more"></a><p>由程序产生的，不同时间点访问web页面看到的内容各不相同**。</p><p>　　静态web资源开发技术：Html<br>　　常用动态web资源开发技术：JSP/Servlet、ASP、PHP等<br>　　在 Java 中，动态web资源开发技术统称为 <strong>==Javaweb==</strong>。</p><h2 id="1-2-WEB应用程序"><a href="#1-2-WEB应用程序" class="headerlink" title="1.2 WEB应用程序"></a>1.2 WEB应用程序</h2><p>　　WEB应用程序指<strong>供浏览器访问的程序</strong>，通常也<strong>简称为web应用</strong>。例如有a.html 、b.html…..多个web资源，这多个web资源用于对外提供服务，此时应把这多个web资源放在一个目录中，以组成一个web应用（或web应用程序）<br>　　<strong>一个web应用由多个静态web资源和动态web资源组成</strong>，如:html、css、js文件，Jsp文件、java程序、支持jar包、配置文件等等。<br>　　Web应用开发好后，若想供外界访问，需要<strong>把web应用所在目录交给web服务器管理</strong>，这个过程称之为<strong>虚似目录的映射</strong></p><h1 id="二-WEB服务器"><a href="#二-WEB服务器" class="headerlink" title="二. WEB服务器"></a>二. WEB服务器</h1><h2 id="2-1-WEB服务器简介"><a href="#2-1-WEB服务器简介" class="headerlink" title="2.1 WEB服务器简介"></a>2.1 WEB服务器简介</h2><p>　　1. Web服务器是指<strong>驻留于因特网上某种类型计算机的程序</strong>，是可以向发出请求的浏览器提供文档的<strong>程序</strong>。当Web浏览器（客户端）连到服务器上并请求文件时，服务器将处理该请求并将文件反馈到该浏览器上，附带的信息会告诉浏览器如何查看该文件（即文件类型）。</p><p><img src="https://images0.cnblogs.com/i/289233/201405/152304507501851.jpg" alt="img"></p><p>　　2、服务器是一种<strong>被动程序</strong>：只有当Internet上运行在其他计算机中的浏览器发出请求时，服务器才会响应。</p><p><img src="https://images0.cnblogs.com/i/289233/201405/152305257189334.png" alt="img"></p><h2 id="2-2、常见的Web服务器介绍"><a href="#2-2、常见的Web服务器介绍" class="headerlink" title="2.2、常见的Web服务器介绍"></a>2.2、常见的Web服务器介绍</h2><h4 id="1-WebLogic"><a href="#1-WebLogic" class="headerlink" title="1. WebLogic"></a>1. WebLogic</h4><h4 id="2-WebSphere"><a href="#2-WebSphere" class="headerlink" title="2. WebSphere"></a>2. WebSphere</h4><h4 id="3-Tomcat"><a href="#3-Tomcat" class="headerlink" title="3. Tomcat"></a>3. Tomcat</h4><p>　　TomcatTomcat是一个<strong>实现了JAVA EE标准的最小的WEB服务器</strong>，是Apache 软件基金会的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。因为Tomcat 技术先进、性能稳定，而且开源免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。<strong>学习JavaWeb开发一般都使用Tomcat服务器</strong>，该服务器支持全部JSP以及Servlet规范，启动界面如图：</p><p><img src="https://images0.cnblogs.com/i/289233/201405/152327264213217.png" alt="img"></p><h4 id="4-IIS"><a href="#4-IIS" class="headerlink" title="4. IIS"></a>4. IIS</h4><blockquote><p>学习web开发，需要先安装一台web服务器，然后再在web服务器中开发相应的web资源，供用户使用浏览器访问。</p></blockquote><h1 id="三-搭建JavaWeb应用开发环境——Tomcat服务器"><a href="#三-搭建JavaWeb应用开发环境——Tomcat服务器" class="headerlink" title="三. 搭建JavaWeb应用开发环境——Tomcat服务器"></a>三. 搭建JavaWeb应用开发环境——Tomcat服务器</h1><h2 id="3-1-疑问：学习web开发，为什么必须要先装一个WEB服务器？"><a href="#3-1-疑问：学习web开发，为什么必须要先装一个WEB服务器？" class="headerlink" title="3.1 疑问：学习web开发，为什么必须要先装一个WEB服务器？"></a>3.1 疑问：学习web开发，为什么必须要先装一个WEB服务器？</h2><p>　　在本地计算机上随便创建一个 web 页面，用户是<strong>无法访问到的</strong>，但是如果启动 tomcat 服务器，把 web 页面放在 tomcat 服务器中，用户就可以访问了。这说明什么问题？<br>  　　1. 不管什么 web 资源，<strong>想被远程计算机访问</strong>，都必须有<strong>一个与之对应的网络通信程序</strong>，当用户来访问时，这个网络通信程序读取 web 资源数据，并把数据发送给来访者。<br>  　　2. WEB 服务器就是这样一个程序，它用于<strong>完成底层网络通迅</strong>。使用这些服务器，We应用的开发者<strong>只需要关注web资源怎么编写</strong>，而<strong>不需要关心资源如何发送到客户端手中</strong>，从而极大的减轻了开发者的开发工作量。</p><h3 id="3-2、下载和安装Tomcat服务器"><a href="#3-2、下载和安装Tomcat服务器" class="headerlink" title="3.2、下载和安装Tomcat服务器"></a>3.2、下载和安装Tomcat服务器</h3><h5 id="见参考博客"><a href="#见参考博客" class="headerlink" title="见参考博客"></a>见参考博客</h5><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3729033.html" target="_blank" rel="noopener">JavaWeb学习总结(一)——JavaWeb开发入门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-基本概念&quot;&gt;&lt;a href=&quot;#一-基本概念&quot; class=&quot;headerlink&quot; title=&quot;一. 基本概念&quot;&gt;&lt;/a&gt;一. 基本概念&lt;/h1&gt;&lt;h2 id=&quot;1-1-WEB-开发的相关知识&quot;&gt;&lt;a href=&quot;#1-1-WEB-开发的相关知识&quot; class=&quot;headerlink&quot; title=&quot;1.1 WEB 开发的相关知识&quot;&gt;&lt;/a&gt;1.1 WEB 开发的相关知识&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;WEB，在英语中web即&lt;strong&gt;表示网页&lt;/strong&gt;的意思，它用于表示&lt;strong&gt;Internet主机上供外界访问的资源&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Internet上供外界访问的Web资源分为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;静态web资源&lt;/strong&gt;（如html 页面）：指web页面中供人们&lt;strong&gt;浏览的数据始终是不变的&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态web资源&lt;/strong&gt;：指web页面中供人们浏览的数据是**&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---JSP原理</title>
    <link href="http://yoursite.com/2019/03/14/JavaWeb---JSP%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/14/JavaWeb---JSP原理/</id>
    <published>2019-03-14T10:41:51.000Z</published>
    <updated>2019-03-15T08:22:06.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-什么是-JSP？"><a href="#一-什么是-JSP？" class="headerlink" title="一. 什么是 JSP？"></a>一. 什么是 JSP？</h2><p>　　JSP全称是 Java Server Pages ，它和 servle 技术一样，都是SUN公司定义的一种用于<strong>开发动态web资源的技术</strong>。<br>　　JSP 这门技术的最大的特点在于，<strong>写 jsp 就像在写 html </strong>，但它相比 html 而言，html 只能为用户提供静态数据，而 <strong>Jsp 技术允许在页面中嵌套java代码，为用户提供动态数据</strong>。</p><a id="more"></a><h2 id="二-JSP原理"><a href="#二-JSP原理" class="headerlink" title="二. JSP原理"></a>二. JSP原理</h2><h2 id="2-1-Web服务器是如何调用并执行一个jsp页面的？"><a href="#2-1-Web服务器是如何调用并执行一个jsp页面的？" class="headerlink" title="2.1 Web服务器是如何调用并执行一个jsp页面的？"></a>2.1 Web服务器是如何调用并执行一个jsp页面的？</h2><p>　　浏览器向服务器发请求，<strong>不管访问的是什么资源，其实都是在访问Servlet</strong>，所以<strong>当访问一个jsp页面时，其实也是在访问一个Servlet</strong></p><p>​    服务器在执行jsp的时候，首先<strong>==把jsp翻译成一个Servlet==</strong>，所以我们访问 jsp 时，其实不是在访问 jsp，而是<strong>在访问 jsp 翻译过后的那个Servlet</strong></p><ol><li><p>当我们通过浏览器访问index.jsp时，服务器首先将 <code>index.jsp</code> <strong>翻译成</strong>一个<strong><code>index_jsp.class</code></strong></p></li><li><p><code>index_jsp</code> 这个类是继承 <code>org.apache.jasper.runtime.HttpJspBase</code> 这个类的</p></li><li><p><code>HttpJspBase</code> 类是继承 <code>HttpServlet</code> 的，所以index_jsp类也是<strong>一个Servlet</strong>，所以当浏览器访问服务器上的 <code>index.jsp</code> 页面时，其实就是在访问<strong><code>index_jsp</code> 这个Servlet</strong>，<code>index_jsp</code> 这个 Servlet 使用<code>_jspService</code> 这个方法处理请求。</p></li></ol><h2 id="2-2-Jsp页面中的java代码服务器是如何执行的？"><a href="#2-2-Jsp页面中的java代码服务器是如何执行的？" class="headerlink" title="2.2 Jsp页面中的java代码服务器是如何执行的？"></a>2.2 Jsp页面中的java代码服务器是如何执行的？</h2><p>　　在 jsp 中编写的 java 代码会被翻译到 <code>_jspService</code> 方法中去，当执行 <code>_jspService</code>方法处理请求时，就会执行在jsp编写的java代码了，所以Jsp页面中的java代码服务器是通过调用_jspService方法处理请求时执行的。</p><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3764991.html" target="_blank" rel="noopener">javaweb学习总结(十四)——JSP原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-什么是-JSP？&quot;&gt;&lt;a href=&quot;#一-什么是-JSP？&quot; class=&quot;headerlink&quot; title=&quot;一. 什么是 JSP？&quot;&gt;&lt;/a&gt;一. 什么是 JSP？&lt;/h2&gt;&lt;p&gt;　　JSP全称是 Java Server Pages ，它和 servle 技术一样，都是SUN公司定义的一种用于&lt;strong&gt;开发动态web资源的技术&lt;/strong&gt;。&lt;br&gt;　　JSP 这门技术的最大的特点在于，&lt;strong&gt;写 jsp 就像在写 html &lt;/strong&gt;，但它相比 html 而言，html 只能为用户提供静态数据，而 &lt;strong&gt;Jsp 技术允许在页面中嵌套java代码，为用户提供动态数据&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Java面试经典题目(11-15题)</title>
    <link href="http://yoursite.com/2019/03/14/Java%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE(11-15%E9%A2%98)/"/>
    <id>http://yoursite.com/2019/03/14/Java面试经典题目(11-15题)/</id>
    <published>2019-03-14T01:56:00.000Z</published>
    <updated>2019-03-20T02:54:04.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="11-进程和线程的区别是什么？"><a href="#11-进程和线程的区别是什么？" class="headerlink" title="11. 进程和线程的区别是什么？"></a>11. 进程和线程的区别是什么？</h1><p>答案:</p><h4 id="通俗解释什么是进程和线程"><a href="#通俗解释什么是进程和线程" class="headerlink" title="通俗解释什么是进程和线程:"></a>通俗解释什么是进程和线程:</h4><ol><li>开个QQ，开了一个进程；开了迅雷，开了一个进程。  </li><li>在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。</li><li>所以运行某个软件，相当于开了一个进程。在这个软件运行的过程里（在这个进程里），多个工作支撑的完成QQ的运行，那么这“多个工作”就是多个线程。 </li><li><strong>所以一个进程管着多个线程。</strong></li></ol><a id="more"></a><h4 id="专业解释"><a href="#专业解释" class="headerlink" title="专业解释"></a>专业解释</h4><pre><code>1. 进程是执行着的应用程序2. 线程是进程内部的一个执行序列。3. 一个进程可以有多个线程。线程又叫做轻量级进程。 </code></pre><h4 id="线程与进程的区别归纳"><a href="#线程与进程的区别归纳" class="headerlink" title="线程与进程的区别归纳"></a>线程与进程的区别归纳</h4><h5 id="优质答案一"><a href="#优质答案一" class="headerlink" title="优质答案一"></a>优质答案一</h5><ul><li><p>进程是运行中的程序，线程是进程的内部的一个执行序列 </p></li><li><p>进程是资源分配的单元，线程是执行行单元(进程是资源分配的基本单位, 线程是调度的基本单位)</p></li><li><p>进程间切换代价大，线程间切换代价小 </p></li><li><p>进程拥有资源多，线程拥有资源少 </p></li><li><p>多个线程共享进程的资源 </p></li></ul><h5 id="优质答案二"><a href="#优质答案二" class="headerlink" title="优质答案二"></a>优质答案二</h5><p>   <strong>a.地址空间和其它资源</strong>：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。  </p><p>   <strong>b.通信：</strong>进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。  </p><p>   <strong>c.调度和切换</strong>：线程上下文切换比进程上下文切换要快得多。  </p><p>   d.在多线程OS中，进程不是一个可执行的实体。  </p><h3 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h3><h4 id="1-进程是什么？"><a href="#1-进程是什么？" class="headerlink" title="1. 进程是什么？"></a>1. 进程是什么？</h4><p>程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。</p><h4 id="2-进程和线程的并发层次不同："><a href="#2-进程和线程的并发层次不同：" class="headerlink" title="2. 进程和线程的并发层次不同："></a>2. 进程和线程的并发层次不同：</h4><p>进程属于在处理器这一层上提供的抽象；线程则属于在进程这个层次上再提供了一层并发的抽象。</p><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">进程与线程的一个简单解释</a></p><p>​    <a href="https://blog.csdn.net/zsl091125/article/details/52540348" target="_blank" rel="noopener">进程篇：进程和线程的本质和区别</a></p><p>​    <a href="https://www.cnblogs.com/tiankong101/p/4229584.html" target="_blank" rel="noopener">深入理解进程和线程</a></p><p>​    <a href="https://blog.csdn.net/zheng548/article/details/54669908" target="_blank" rel="noopener">线程与进程的区别</a></p><h1 id="12-创建线程有几种不同的方式？你喜欢哪一种？为什么？"><a href="#12-创建线程有几种不同的方式？你喜欢哪一种？为什么？" class="headerlink" title="12. 创建线程有几种不同的方式？你喜欢哪一种？为什么？"></a>12. 创建线程有几种不同的方式？你喜欢哪一种？为什么？</h1><h4 id="1-方式"><a href="#1-方式" class="headerlink" title="1. 方式"></a>1. 方式</h4><ol><li>继承Thread类，重写run方法；</li><li>实现Runnable接口，重写run方法，但是比继承Thread类好用，实现接口还可以继承类，避免了单继承带来的局限性；</li><li>实现callable接口，重写call方法，有返回值。</li><li>使用实现了Executor接口的ThreadPoolExecutor来创建线程池。  </li></ol><h4 id="2-选择"><a href="#2-选择" class="headerlink" title="2. 选择"></a>2. 选择</h4><p>   一般情况下，常见的是第二种。 <strong>Runnable接口</strong>有如下好处： </p><ol><li>避免点继承的局限，一个类可以继承多个接口。 </li><li>适合于资源的共享 </li></ol><blockquote><p>线程详细见: xxxxxx</p></blockquote><hr><h5 id="参考博文-1"><a href="#参考博文-1" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.nowcoder.com/questionTerminal/e33c72bceb4343879948342e2b6e3bca" target="_blank" rel="noopener">牛客网优质答案</a></p><p>时间: 2019.3.14</p><h1 id="13-概括的解释下线程的几种可用状态"><a href="#13-概括的解释下线程的几种可用状态" class="headerlink" title="13. 概括的解释下线程的几种可用状态"></a>13. 概括的解释下线程的几种可用状态</h1><p>答:</p><ol><li><strong>新建(new)：</strong>新创建了一个线程对象。     </li><li><strong>可运行(runnable)：</strong>线程对象创建后，其他线程(比如main线程) <strong>调用了该对象的start()方法</strong>。该状态的线程位于可运行线程池中，<strong>等待</strong>被线程调度选中，获取 cpu 的使用权。     </li><li><strong>运行(running)：</strong>可运行状态(runnable)的线程<strong>获得了 cpu 时间片(timeslice), 执行程序代码</strong>。     </li><li><strong>阻塞(block)：</strong>阻塞状态是指线程因为某种原因<strong>放弃了 cpu 使用权</strong>，即让出了cpu 时间片(timeslice), <strong>暂时停止运行</strong>。直到线程进入可运行(runnable)状态，才有机会再次获得cpu 时间片(timeslice)转到运行(running)状态。阻塞的情况分三种：            <ul><li><strong>等待阻塞：</strong>运行(running)的线程执行o.wait()方法, JVM会把该线程放入等待队列( waitting queue )中。     </li><li><strong>同步阻塞：</strong> 运行(running)的线程在获取对象的同步锁时, 若该同步锁被别的线程占用，则       JVM会把该线程放入锁池(lock pool)中。     </li><li><strong>其他阻塞:</strong> 运行(running)的线程执行 Thread.sleep(longms)或t.join() 方法，或者发出了I/O       请求时，JVM会把该线程置为阻塞状态。当 sleep() 状态超时、join() 等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。     </li></ul></li><li><strong>死亡(dead)</strong>：线程run()、 main()方法执行结束，或者因异常退出了 run() 方法，则该线程结束生命周期。死亡的线程不可再次复生。</li></ol><h1 id="14-同步方法和同步代码块的区别是什么？"><a href="#14-同步方法和同步代码块的区别是什么？" class="headerlink" title="14. 同步方法和同步代码块的区别是什么？"></a>14. 同步方法和同步代码块的区别是什么？</h1><p>答:</p><h4 id="同步方法-粗粒度锁"><a href="#同步方法-粗粒度锁" class="headerlink" title="同步方法(粗粒度锁):"></a><strong>同步方法(粗粒度锁):</strong></h4><p>由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用给方法前，要获取内置锁，否则处于阻塞状态。</p><ol><li><p>修饰一般方法:  获取的是当前调用对象 this 上的锁, 代码: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰静态方法: 获取当前类的字节码对象上的锁, 代码: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注:</strong> synchronized修饰静态方法，如果调用该静态方法，<strong>将锁住整个类</strong></p><h4 id="同步代码块-细粒度锁"><a href="#同步代码块-细粒度锁" class="headerlink" title="同步代码块(细粒度锁):"></a><strong>同步代码块(细粒度锁):</strong></h4><p>即有synchronized修饰符修饰的语句块，被该关键词修饰的语句块，将加上内置锁。实现同步。 </p><p>同步代码块可以指定获取哪个对象上的锁, obj 任意, 代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;             </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>同步是高开销的操作，因此尽量减少同步的内容。通常没有必要同步整个方法，同步部分代码块即可。 </p></li><li><p>同步方法默认用this或者当前类class对象作为锁。 </p></li><li><p>同步代码块可以选择以什么来加锁，比同步方法要更颗粒化，我们可以选择只同步会发生问题的部分代码而不是整个方法。</p></li></ul><h4 id="补-为何使用同步？"><a href="#补-为何使用同步？" class="headerlink" title="补: 为何使用同步？"></a>补: 为何使用同步？</h4><p>   java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（增删改查），将<strong>会导致数据的不准确，相互之间产生冲突</strong>。类似于在atm取钱，银行数据确没有变，这是不行的，要存在于一个事务中。因此加入了同步锁，以避免在该线程没有结束前，调用其他线程。从而保证了变量的唯一性，准确性。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;11-进程和线程的区别是什么？&quot;&gt;&lt;a href=&quot;#11-进程和线程的区别是什么？&quot; class=&quot;headerlink&quot; title=&quot;11. 进程和线程的区别是什么？&quot;&gt;&lt;/a&gt;11. 进程和线程的区别是什么？&lt;/h1&gt;&lt;p&gt;答案:&lt;/p&gt;
&lt;h4 id=&quot;通俗解释什么是进程和线程&quot;&gt;&lt;a href=&quot;#通俗解释什么是进程和线程&quot; class=&quot;headerlink&quot; title=&quot;通俗解释什么是进程和线程:&quot;&gt;&lt;/a&gt;通俗解释什么是进程和线程:&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;开个QQ，开了一个进程；开了迅雷，开了一个进程。  &lt;/li&gt;
&lt;li&gt;在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。&lt;/li&gt;
&lt;li&gt;所以运行某个软件，相当于开了一个进程。在这个软件运行的过程里（在这个进程里），多个工作支撑的完成QQ的运行，那么这“多个工作”就是多个线程。 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;所以一个进程管着多个线程。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="java面试常考题目" scheme="http://yoursite.com/categories/java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java面试常考题目" scheme="http://yoursite.com/tags/java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---Servlet开发(2)</title>
    <link href="http://yoursite.com/2019/03/13/JavaWeb---Servlet%E5%BC%80%E5%8F%91(2)/"/>
    <id>http://yoursite.com/2019/03/13/JavaWeb---Servlet开发(2)/</id>
    <published>2019-03-13T13:41:51.000Z</published>
    <updated>2019-04-04T13:29:44.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-ServletConfig讲解"><a href="#一-ServletConfig讲解" class="headerlink" title="一. ServletConfig讲解"></a>一. ServletConfig讲解</h2><h3 id="1-1-配置-Servlet-初始化参数"><a href="#1-1-配置-Servlet-初始化参数" class="headerlink" title="1.1. 配置 Servlet 初始化参数"></a>1.1. 配置 Servlet 初始化参数</h3><p>　　在Servlet的配置文件 <strong>web.xml</strong> 中，可以使用一个或多个 <code>&lt;init-param&gt;</code> 标签为servlet配置一些初始化参数。</p><a id="more"></a><h5 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ServletConfigDemo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>gacl.servlet.study.ServletConfigDemo1<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置ServletConfigDemo1的初始化参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>name<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>gacl<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>password<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>123<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2、通过-ServletConfig-获取-Servlet-的初始化参数"><a href="#1-2、通过-ServletConfig-获取-Servlet-的初始化参数" class="headerlink" title="1.2、通过 ServletConfig 获取 Servlet 的初始化参数"></a>1.2、通过 ServletConfig 获取 Servlet 的初始化参数</h3><p>　　当 servle t配置了初始化参数后，web 容器在创建 servlet 实例对象时，<strong>会自动将这些初始化参数封装到 ServletConfig 对象中</strong>，并<strong>在调用 servlet 的 init 方法时，将 ServletConfig 对象传递给servlet</strong>。进而，我们通过 ServletConfig 对象就可以得到当前servlet的初始化参数信息。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletConfigDemo1</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义ServletConfig对象来接收配置的初始化参数</span></span><br><span class="line">    <span class="keyword">private</span> ServletConfig config;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.config = config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取在 web.xml 中配置的初始化参数</span></span><br><span class="line">        <span class="comment">// 获取指定的初始化参数</span></span><br><span class="line">        String paramVal = <span class="keyword">this</span>.config.getInitParameter(<span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有的初始化参数</span></span><br><span class="line">        Enumeration&lt;String&gt; e = config.getInitParameterNames();</span><br><span class="line">        <span class="keyword">while</span>(e.hasMoreElements())&#123;</span><br><span class="line">            String name = e.nextElement();</span><br><span class="line">            String value = config.getInitParameter(name);</span><br><span class="line">            response.getWriter().print(name + <span class="string">"="</span> + value + <span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、ServletContext对象"><a href="#二、ServletContext对象" class="headerlink" title="二、ServletContext对象"></a>二、ServletContext对象</h2><p>　　<strong>WEB容器在启动时</strong>，它会为每个WEB应用程序都创建<strong>一个对应的 ServletContext 对象</strong>，它<strong>代表当前web应用</strong>。<br>　　ServletConfig 对象中维护了 ServletContext 对象的引用，开发人员在编写servlet时，<strong>可以通过ServletConfig.getServletContext 方法获得 ServletContext 对象</strong>。<br>　　由于一个 WEB 应用中的 <strong>所有 Servlet共享同一个 ServletContext 对象</strong> ，因此 <strong>Servlet 对象之间可以通过ServletContext 对象来实现通讯</strong> 。ServletContext 对象通常也被称之为 context 域对象</p><h2 id="三-ServletContext的应用"><a href="#三-ServletContext的应用" class="headerlink" title="三. ServletContext的应用"></a>三. ServletContext的应用</h2><h3 id="3-1-多个Servlet通过ServletContext对象实现数据共享"><a href="#3-1-多个Servlet通过ServletContext对象实现数据共享" class="headerlink" title="　　3.1 多个Servlet通过ServletContext对象实现数据共享"></a>　　3.1 多个Servlet通过ServletContext对象实现数据共享</h3><p><strong>范例: Demo1 和 Demo2 通过 ServletContext 对象实现数据共享</strong></p><h5 id="Demo1"><a href="#Demo1" class="headerlink" title="Demo1"></a>Demo1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ServletConfig对象中维护了ServletContext对象的引用，开发人员在编写servlet时，</span></span><br><span class="line"><span class="comment"> * 可以通过ServletConfig.getServletContext方法获得ServletContext对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletContextDemo1</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String data = <span class="string">"xdp_gacl"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得ServletContext对象</span></span><br><span class="line">        ServletContext context = <span class="keyword">this</span>.getServletConfig().getServletContext();</span><br><span class="line">        <span class="comment">// 另一种获取方法</span></span><br><span class="line">        <span class="comment">// request.getServletContext()</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将data存储到ServletContext对象中</span></span><br><span class="line">        context.setAttribute(<span class="string">"data"</span>, data);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Demo2"><a href="#Demo2" class="headerlink" title="Demo2"></a>Demo2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletContextDemo2</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得ServletContext对象</span></span><br><span class="line">        ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从ServletContext对象中取出数据</span></span><br><span class="line">        String data = (String) context.getAttribute(<span class="string">"data"</span>);</span><br><span class="line">        response.getWriter().print(<span class="string">"data = "</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器上输出结果: data = xdp_gacl</p><h3 id="3-2-获取WEB应用的初始化参数"><a href="#3-2-获取WEB应用的初始化参数" class="headerlink" title="3.2 获取WEB应用的初始化参数"></a>3.2 获取WEB应用的初始化参数</h3><p>在web.xml文件中使用<context-param>标签配置WEB应用的初始化参数，如下所示：</context-param></p><p>范例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletContextDemo3</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取整个web站点的初始化参数</span></span><br><span class="line">        String contextInitParam = context.getInitParameter(<span class="string">"name"</span>);</span><br><span class="line">        response.getWriter().print(contextInitParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-用servletContext实现请求转发"><a href="#3-3-用servletContext实现请求转发" class="headerlink" title="3.3 用servletContext实现请求转发"></a>3.3 用servletContext实现请求转发</h2><h5 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletContextDemo4</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String data = <span class="string">"&lt;h1&gt;&lt;font color='red'&gt;abcdefghjkl&lt;/font&gt;&lt;/h1&gt;"</span>;</span><br><span class="line">        response.getOutputStream().write(data.getBytes());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取ServletContext对象</span></span><br><span class="line">        ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取请求转发对象(RequestDispatcher)</span></span><br><span class="line">        RequestDispatcher rd = context.getRequestDispatcher(<span class="string">"/servlet/ServletContextDemo5"</span>);</span><br><span class="line">        rd.forward(request, response);<span class="comment">//调用forward方法实现请求转发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4利用ServletContext对象读取资源文件"><a href="#3-4利用ServletContext对象读取资源文件" class="headerlink" title="3.4利用ServletContext对象读取资源文件"></a>3.4利用ServletContext对象读取资源文件</h2><p>略</p><h1 id="四-在客户端缓存Servlet的输出"><a href="#四-在客户端缓存Servlet的输出" class="headerlink" title="四. 在客户端缓存Servlet的输出"></a>四. 在客户端缓存Servlet的输出</h1><p>略</p><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3763559.html" target="_blank" rel="noopener">javaweb学习总结(六)——Servlet开发(二)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-ServletConfig讲解&quot;&gt;&lt;a href=&quot;#一-ServletConfig讲解&quot; class=&quot;headerlink&quot; title=&quot;一. ServletConfig讲解&quot;&gt;&lt;/a&gt;一. ServletConfig讲解&lt;/h2&gt;&lt;h3 id=&quot;1-1-配置-Servlet-初始化参数&quot;&gt;&lt;a href=&quot;#1-1-配置-Servlet-初始化参数&quot; class=&quot;headerlink&quot; title=&quot;1.1. 配置 Servlet 初始化参数&quot;&gt;&lt;/a&gt;1.1. 配置 Servlet 初始化参数&lt;/h3&gt;&lt;p&gt;　　在Servlet的配置文件 &lt;strong&gt;web.xml&lt;/strong&gt; 中，可以使用一个或多个 &lt;code&gt;&amp;lt;init-param&amp;gt;&lt;/code&gt; 标签为servlet配置一些初始化参数。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---Servlet开发(1)</title>
    <link href="http://yoursite.com/2019/03/13/JavaWeb---Servlet%E5%BC%80%E5%8F%91(1)/"/>
    <id>http://yoursite.com/2019/03/13/JavaWeb---Servlet开发(1)/</id>
    <published>2019-03-13T13:23:51.000Z</published>
    <updated>2019-03-15T08:23:50.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-Servlet简介"><a href="#一-Servlet简介" class="headerlink" title="一. Servlet简介"></a>一. Servlet简介</h1><p>Servlet是sun公司提供的一门用于 <strong>开发动态web资源的技术</strong></p><p>若想开发一个动态web资源(即开发<strong>一个Java程序向浏览器输出数据</strong>)，需要完成以下2个步骤：</p><ol><li><p>编写一个 Java 类，<strong>实现 servlet 接口</strong>。</p></li><li><p>把开发好的 Java类<strong>部署到 web 服务器</strong>中。</p></li></ol><p>按照一种约定俗成的称呼习惯，通常我们也把实现了<strong>servlet接口的java程序</strong>，称之为<strong>Servlet</strong></p><a id="more"></a><h1 id="二-Servlet的运行过程"><a href="#二-Servlet的运行过程" class="headerlink" title="二. Servlet的运行过程"></a>二. Servlet的运行过程</h1><p>Servlet程序是由 <strong>WEB服务器</strong> 调用，web服务器 <strong>收到客户端的 Servlet 访问请求后:</strong> </p><p>​    ① Web服务器首先 <strong>检查是否已经装载并创建</strong>了该Servlet的<strong>实例对象</strong>。如果是，则直接执行第④步，否则，执行第②步。</p><p>​    ② 装载并创建该Servlet的一个实例对象。 </p><p>​    ③ 调用Servlet实例对象的 <strong>init()方法</strong>。</p><p>​    ④ 创建一个用于封装 <strong>HTTP请求消息的 <code>HttpServletRequest</code> 对象</strong> 和一个 <strong>代表HTTP响应消息的 <code>HttpServletResponse</code> 对象</strong> ，然后调用Servlet的<strong>service()方法</strong>并将 <strong>请求和响应对象</strong> 作为参数传递进去</p><p>​    ⑤ WEB应用程序被 <strong>停止或重新启动之前</strong>，Servlet引擎将 <strong>卸载Servlet</strong> ，并在卸载之前调用Servlet的<code>destroy()</code>方法。</p><h1 id="三-Servlet调用图"><a href="#三-Servlet调用图" class="headerlink" title="三. Servlet调用图"></a>三. Servlet调用图</h1><p><img src="https://images0.cnblogs.com/i/289233/201405/311054556978749.png" alt="Servlet调用图"></p><h1 id="四-Servlet接口实现类"><a href="#四-Servlet接口实现类" class="headerlink" title="四. Servlet接口实现类"></a>四. Servlet接口实现类</h1><p>　　Servlet接口SUN公司定义了两个默认实现类，分别为：<strong>GenericServlet、HttpServlet</strong>。</p><p>　　<strong>==HttpServlet==</strong> 指能够<strong>处理HTTP请求的servlet</strong>，它在原有Servlet接口上添加了一些与HTTP协议处理方法，它比Servlet接口的功能更为强大。因此开发人员在编写Servlet时，<strong>通常应继承这个类</strong>，而避免直接去实现Servlet接口。<br>　　HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会<strong>自动判断用户的请求方式</strong>，如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。因此，开发人员在编写Servlet时，<strong>通常只需要覆写doGet或doPost方法，而不要去覆写service方法</strong></p><h1 id="五-Servlet开发注意细节"><a href="#五-Servlet开发注意细节" class="headerlink" title="五. Servlet开发注意细节"></a>五. Servlet开发注意细节</h1><h2 id="4-1-Servlet访问URL映射配置"><a href="#4-1-Servlet访问URL映射配置" class="headerlink" title="4.1 Servlet访问URL映射配置"></a>4.1 Servlet访问URL映射配置</h2><p>　　由于客户端是通过<strong>URL地址访问web服务器中的资源</strong>，所以Servlet程序若想被外界访问，必须把servlet程序映射到一个URL地址上，这个工作在==<strong>web.xml文件</strong>==中使用<code>&lt;servlet&gt;</code>元素和<code>&lt;servlet-mapping&gt;</code>元素完成。</p><ul><li><code>&lt;servlet&gt;</code>元素用于<strong>注册Servlet</strong>，它包含有两个主要的子元素：<code>&lt;servlet-name&gt;</code>和<code>&lt;servlet-class&gt;</code>，分别用于设置<strong>Servlet的注册名称</strong>和<strong>Servlet的完整类名</strong>。 </li><li><code>&lt;servlet-mapping&gt;</code>元素用于<strong>映射</strong>一个<strong>已注册</strong>的Servlet的<strong>一个对外访问路径</strong>，它包含有两个子元素：<code>&lt;servlet-name&gt;</code>和<code>&lt;url-pattern&gt;</code>，分别用于指定<strong>Servlet的注册名称</strong>和<strong>Servlet的对外访问路径</strong>。</li></ul><blockquote><p>都是成对出现的 <strong>有注册,有映射</strong></p></blockquote><h3 id="web-xml-是什么"><a href="#web-xml-是什么" class="headerlink" title="web.xml 是什么"></a>web.xml 是什么</h3><ul><li><p>web.xml文件用来<strong>初始化配置信息</strong>：比如Welcome页面、servlet、servlet-mapping、filter、listener、启动加载级别等</p></li><li><p>每个xml文件都有定义它书写规则的Schema文件，也就是说javaEE的定义 web.xml 所对应的 xml Schema 文件中定义了多少种标签元素，web.xml中就可以出现它所定义的标签元素，也就具备哪些特定的功能。</p></li></ul><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ServletDemo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>gacl.servlet.study.ServletDemo1<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ServletDemo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet/ServletDemo1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>同一个Servlet可以被映射到多个URL上，即<strong>多个<servlet-mapping>元素的<servlet-name>子元素</servlet-name></servlet-mapping></strong>的设置值可以是<strong>同一个Servlet的注册名<servlet-name></servlet-name></strong>。</p></blockquote><h2 id="4-2-Servlet与普通Java类的区别"><a href="#4-2-Servlet与普通Java类的区别" class="headerlink" title="4.2 Servlet与普通Java类的区别　　"></a>4.2 Servlet与普通Java类的区别　　</h2><p>　　Servlet是一个供其他Java程序（Servlet引擎）调用的Java类，<strong>不能独立运行</strong>，它的运行完全由<strong>Servlet引擎来控制和调度</strong>。<br>　　针对客户端的多次Servlet请求，通常情况下，<strong>服务器只会创建一个Servlet实例对象</strong>，也就是说Servlet实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至<strong>web容器退出</strong>，servlet实例对象才会销毁。<br>　　在Servlet的整个生命周期内，Servlet的<strong><code>init()</code>方法只被调用一次</strong>。而对一个Servlet的每次访问请求都导致Servlet引擎调用一次servlet的<code>service()</code>方法。对于每次访问请求，Servlet引擎都会创建一个新的<code>HttpServletRequest</code>请求对象和一个新的<code>HttpServletResponse</code>响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。  </p><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3760336.html" target="_blank" rel="noopener">javaweb学习总结(五)——Servlet开发(一)</a></p><p>​    <a href="https://www.cnblogs.com/yqskj/articles/2233061.html" target="_blank" rel="noopener">web.xml文件的作用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-Servlet简介&quot;&gt;&lt;a href=&quot;#一-Servlet简介&quot; class=&quot;headerlink&quot; title=&quot;一. Servlet简介&quot;&gt;&lt;/a&gt;一. Servlet简介&lt;/h1&gt;&lt;p&gt;Servlet是sun公司提供的一门用于 &lt;strong&gt;开发动态web资源的技术&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;若想开发一个动态web资源(即开发&lt;strong&gt;一个Java程序向浏览器输出数据&lt;/strong&gt;)，需要完成以下2个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;编写一个 Java 类，&lt;strong&gt;实现 servlet 接口&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把开发好的 Java类&lt;strong&gt;部署到 web 服务器&lt;/strong&gt;中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;按照一种约定俗成的称呼习惯，通常我们也把实现了&lt;strong&gt;servlet接口的java程序&lt;/strong&gt;，称之为&lt;strong&gt;Servlet&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---继承</title>
    <link href="http://yoursite.com/2019/03/13/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2019/03/13/Java基础知识---继承/</id>
    <published>2019-03-13T00:17:27.000Z</published>
    <updated>2019-03-25T06:21:18.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概念"><a href="#一-概念" class="headerlink" title="一. 概念"></a>一. 概念</h1><ul><li>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</li><li>子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的 一些属性或方法</li></ul><a id="more"></a><h1 id="二-类的继承格式"><a href="#二-类的继承格式" class="headerlink" title="二. 类的继承格式"></a>二. 类的继承格式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java继承的关键字是：extends</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 父类 </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是 Java 不支持多继承，但支持多重继承(接口)</p></blockquote><h1 id="三-继承的特性"><a href="#三-继承的特性" class="headerlink" title="三. 继承的特性"></a>三. 继承的特性</h1><ul><li>子类拥有父类非 private 的属性、方法。</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li><li>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C  类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类。</li><li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）</li></ul><h1 id="四-为什么需要继承"><a href="#四-为什么需要继承" class="headerlink" title="四. 为什么需要继承"></a>四. 为什么需要继承</h1><ol><li>提高代码的 <strong>复用性</strong> (复用性主要是可以多次使用，不用再多次写同样的代码）)。</li><li>提高程序的扩展性。</li></ol><h1 id="五-Java中子类能继承父类的私有属性吗"><a href="#五-Java中子类能继承父类的私有属性吗" class="headerlink" title="五. Java中子类能继承父类的私有属性吗"></a>五. Java中子类能继承父类的私有属性吗</h1><p>答: 不能</p><p><strong>Java官方文档的解释</strong> : 子类 <strong>不能继承父类的私有属性</strong>，但是如果子类中公有的方法影响到了父类私有属性，那么私有属性是能够被子类使用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father_</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;<span class="comment">// 私有属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(name + <span class="string">"is telling!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(name + <span class="string">"is speaking!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father_</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJicheng</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Child c = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="comment">// tell方法是可以用的</span></span><br><span class="line">c.tell();</span><br><span class="line"></span><br><span class="line"><span class="comment">//报错，父类的私有方法不可见</span></span><br><span class="line"><span class="comment">// c.speak();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从继承的概念来说"><a href="#从继承的概念来说" class="headerlink" title="从继承的概念来说"></a><strong>从继承的概念来说</strong></h4><p>​    private和final不被继承</p><h4 id="从内存的角度来说"><a href="#从内存的角度来说" class="headerlink" title="从内存的角度来说"></a><strong>从内存的角度来说</strong></h4><p>​    <strong>类的一切都被继承</strong>(从父类构造方法被调用就知道了，因为new一个对象，就会调用构造方法，子类被 new 的时候就会调用父类的构造方法，所以从内存的角度来说，<strong>子类拥有一个完整的父类</strong>)。<strong>子类对象所引用的内存中有父类对象</strong>。</p><p>​    子类的对象是给父类的私有属性分配了空间的，但是没有访问的权限，不算是继承.</p><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://blog.csdn.net/Javaniuniu/article/details/70173727" target="_blank" rel="noopener">Java继承总结</a></p><p>​    <a href="http://www.runoob.com/Java/Java-inheritance.html" target="_blank" rel="noopener">菜鸟教程</a></p><p>​    <a href="https://www.cnblogs.com/cbs-writing/p/7088450.html" target="_blank" rel="noopener">Java中子类能继承父类的私有属性吗？</a></p><p>​    <a href="https://www.zhihu.com/question/51345942/answer/145388196" target="_blank" rel="noopener">知乎答案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-概念&quot;&gt;&lt;a href=&quot;#一-概念&quot; class=&quot;headerlink&quot; title=&quot;一. 概念&quot;&gt;&lt;/a&gt;一. 概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。&lt;/li&gt;
&lt;li&gt;子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的 一些属性或方法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---接口</title>
    <link href="http://yoursite.com/2019/03/13/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2019/03/13/Java基础知识---接口/</id>
    <published>2019-03-13T00:17:27.000Z</published>
    <updated>2019-03-19T03:32:49.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概念"><a href="#一-概念" class="headerlink" title="一. 概念"></a>一. 概念</h2><ul><li><strong>官方解释:</strong> Java接口是一系列方法的声明，是一些方法特征的集合，<strong>一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）</strong></li></ul><a id="more"></a><ul><li><strong>通俗理解:</strong> 接口可以理解为一种特殊的抽象类(<strong>100%的抽象类, 所有的方法都是抽象方法</strong>)，里面全部是由<strong>全局常量</strong>和<strong>公共的抽象方法(方法的定义)</strong>所组成,<strong>而没有变量和方法的实现</strong></li></ul><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java中定义接口</span></span><br><span class="line"><span class="comment"> * 把一个类定义成一个接口的格式是把声明类的关键字class用声明接口的关键字interface替换掉即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JavaInterfaces</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 常量的声明格式, 都是公共的、静态的，不能改变的</span></span><br><span class="line">    <span class="comment">// 下面两种都可以,因为在接口里面默认的属性声明都是“public static final”的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> id=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> id=<span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法的声明</span></span><br><span class="line">    <span class="comment">// 在接口里面的声明的方法都是抽象方法,默认是抽象的，因此在接口里面的抽象方法都会把abstract关键字省略掉</span></span><br><span class="line">    <span class="comment">// 在接口里面声明的抽象方法默认是“public(公共的)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-特点"><a href="#二-特点" class="headerlink" title="二. 特点"></a>二. 特点</h2><ul><li><p>接口指明了一个类必须要做什么和不能做什么，相当于类的蓝图</p></li><li><p>接口可以继承其他的接口,并添加新的属性和抽象方法.</p></li><li><p><strong>抽象方法只能存在于抽象类或者接口中，但抽象类中却能存在非抽象方法，即有方法体的方法。接口是百分之百的抽象类</strong></p></li><li><p>接口是解决<strong>Java无法使用多继承</strong>的一种手段,, 实际中更多的作用是<strong>制定标准</strong>的。</p><blockquote><p><strong>一个类可以实现多个接口, 接口里面的成员变量不专属于某个对象，都是静态的成员变量，是属于整个类的,不会存在对象之间互相冲突的问题。实现多个接口，也就实现了多重继承</strong></p></blockquote></li><li><p>见范例</p></li><li><p><strong>接口和接口之间可以相互继承，类和类之间可以相互继承，类和接口之间，只能是类来实现接口</strong></p></li></ul><h1 id="三-重点"><a href="#三-重点" class="headerlink" title="三. 重点"></a>三. 重点</h1><ul><li>一个类如果要实现某个接口的话，那么它必须要实现这个接口中的所有方法。</li><li><strong>不能直接去实例化一个接口，因为接口中的方法都是抽象的，是没有方法体的</strong>. 但是，<strong>我们可以使用接口类型的引用指向一个实现了该接口的对象，并且可以调用这个接口中的方法</strong>(Java多态的特性).</li></ul><h1 id="四-接口的进一步理解"><a href="#四-接口的进一步理解" class="headerlink" title="四. 接口的进一步理解"></a>四. 接口的进一步理解</h1><p>​    如果某个设备需要向电脑中读取或者写入某些东西，这些设备一般都是采用USB方式与电脑连接的，我们发现，只要带有USB功能的设备就可以插入电脑中使用了，那么我们可以认为USB就是一种功能，这种功能能够做出很多的事情（实现很多的方法），其实USB就可以看做是一种标准，一种接口，只要实现了USB标准的设备我就认为你已经拥有了USB这种功能。（因为你实现了我USB标准中规定的方法）</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先声明USB接口：其中规定了要实现USB接口就必须实现接口规定实现的read( )和write( )这两个方法。</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个USB类实现USB接口。（实现其中的方法）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YouPan</span> <span class="keyword">implements</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"U盘正在通过USB功能读取数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"U盘正在通过USB功能写入数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个键盘类实现USB接口。（实现其中的方法）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JianPan</span> <span class="keyword">implements</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"键盘正在通过USB功能读取数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"键盘正在通过USB功能写入数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生成一个实现可USB接口（标准）的U盘对象</span></span><br><span class="line">        YouPan youPan = <span class="keyword">new</span> YouPan();</span><br><span class="line">        <span class="comment">// 调用U盘的read( )方法读取数据</span></span><br><span class="line">        youPan.read();</span><br><span class="line">        <span class="comment">// 调用U盘的write( )方法写入数据</span></span><br><span class="line">        youPan.write();</span><br><span class="line">        <span class="comment">// 生成一个实现可USB接口（标准）的键盘对象</span></span><br><span class="line">        JianPan jianPan = <span class="keyword">new</span> JianPan();</span><br><span class="line">        <span class="comment">// 调用键盘的read( )方法读取数据</span></span><br><span class="line">        jianPan.read();</span><br><span class="line">        <span class="comment">// 调用键盘的write( )方法写入数据</span></span><br><span class="line">        jianPan.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3651121.html" target="_blank" rel="noopener">java基础学习总结——接口</a></p><p>​    <a href="https://blog.csdn.net/qq_19782019/article/details/80259836" target="_blank" rel="noopener">JAVA基础——接口（全网最详细教程）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-概念&quot;&gt;&lt;a href=&quot;#一-概念&quot; class=&quot;headerlink&quot; title=&quot;一. 概念&quot;&gt;&lt;/a&gt;一. 概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;官方解释:&lt;/strong&gt; Java接口是一系列方法的声明，是一些方法特征的集合，&lt;strong&gt;一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---抽象</title>
    <link href="http://yoursite.com/2019/03/13/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%8A%BD%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/03/13/java基础知识---抽象/</id>
    <published>2019-03-13T00:17:27.000Z</published>
    <updated>2019-03-21T13:14:48.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-抽象的出现"><a href="#一-抽象的出现" class="headerlink" title="一. 抽象的出现"></a>一. 抽象的出现</h1><p>​    在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中<strong>没有包含足够的信息</strong>来描绘一个具体的对象，这样的类就是抽象类</p><p>​    在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口</p><h1 id="二-抽象方法"><a href="#二-抽象方法" class="headerlink" title="二.抽象方法"></a>二.抽象方法</h1><p>​    <strong>一种特殊的方法：它只有声明，而没有具体的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明格式</span></span><br><span class="line"><span class="comment">// 抽象方法必须用abstract关键字进行修饰</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>抽象方法必须定义在抽象类中。</p></blockquote><h1 id="三-抽象类"><a href="#三-抽象类" class="headerlink" title="三. 抽象类"></a>三. 抽象类</h1><h2 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h2><p>​    抽象方法的类(一个类含有抽象方法，则称这个类为抽象类), 抽象类必须在类前用 <strong>abstract关键字 </strong>修饰。</p><blockquote><p> 一个类不包含抽象方法，只是用abstract修饰的话也是抽象类。也就是说抽象类不一定必须含有抽象方法。</p></blockquote><h2 id="2-2-特点"><a href="#2-2-特点" class="headerlink" title="2.2 特点"></a>2.2 特点</h2><ul><li><p>子类继承父类时，如果这个父类里面有抽象方法，并且子类觉得可以去实现父类的所有抽象方法，那么子类必须去实现父类的所有抽象方法, 父类里面的抽象方法，子类如果觉得实现不了，那么把就子类也声明成一个抽象类</p></li><li><p>因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。<strong>父类里面的方法是抽象的，那么对于整个类来说，它就有一个没有实现的方法，这个方法不知道怎么去实现，那么这个类是就是残缺不全的，因此这个类应该被定义为一个抽象类</strong></p></li><li><p>含有抽象方法的类必须被声明为抽象类</p><blockquote><p>不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法</p></blockquote></li><li><p>抽象类必须被继承</p><blockquote><p>抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情</p></blockquote></li><li><p>抽象方法必须被重写</p><blockquote><p>从某种意义上来说，抽象方法就是被用来重写的，所以在父类声明的抽象方法一定要在子类里面重写</p></blockquote></li></ul><h5 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类Animal</span></span><br><span class="line"><span class="comment"> * 在class的前面加上abstract，即声明成这样：abstract class Animal</span></span><br><span class="line"><span class="comment"> * 这样Animal类就成了一个抽象类了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法</span></span><br><span class="line"><span class="comment">     * 这里只有方法的定义，没有方法的实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">enjoy</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里的子类Cat从抽象类Animal继承下来，自然也继承了Animal类里面声明的抽象方法enjoy()，</span></span><br><span class="line"><span class="comment"> * 但子类Cat觉得自己去实现这个enjoy()方法也不合适，因此它把它自己也声明成一个抽象的类，</span></span><br><span class="line"><span class="comment"> * 那么，谁去实现这个抽象的enjoy方法，谁继承了子类，那谁就去实现这个抽象方法enjoy()。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Cat添加自己独有的属性</span></span><br><span class="line">    <span class="keyword">public</span> String eyeColor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String n, String c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(n);<span class="comment">//调用父类Animal的构造方法</span></span><br><span class="line">        <span class="keyword">this</span>.eyeColor = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类BlueCat继承抽象类Cat，并且实现了从父类Cat继承下来的抽象方法enjoy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlueCat</span> <span class="keyword">extends</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlueCat</span><span class="params">(String n, String c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(n, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现了抽象方法enjoy</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enjoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"蓝猫叫..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类Dog继承抽象类Animal，并且实现了抽象方法enjoy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dog类添加自己特有的属性</span></span><br><span class="line">    <span class="keyword">public</span> String furColor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String n, String c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(n);<span class="comment">//调用父类Animal的构造方法</span></span><br><span class="line">        <span class="keyword">this</span>.furColor = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enjoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狗叫...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbstract</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 把Cat类声明成一个抽象类以后，就不能再对Cat类进行实例化了，</span></span><br><span class="line"><span class="comment">         * 因为抽象类是残缺不全的，缺胳膊少腿的，因此抽象类不能被实例化。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//Cat c = new Cat("Catname","blue");</span></span><br><span class="line">        Dog d = <span class="keyword">new</span> Dog(<span class="string">"dogname"</span>,<span class="string">"black"</span>);</span><br><span class="line">        d.enjoy();<span class="comment">//调用自己实现了的enjoy方法</span></span><br><span class="line">        </span><br><span class="line">        BlueCat c = <span class="keyword">new</span> BlueCat(<span class="string">"BlueCatname"</span>,<span class="string">"blue"</span>);</span><br><span class="line">        c.enjoy();<span class="comment">//调用自己实现了的enjoy方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-抽象类和普通类的区别："><a href="#2-3-抽象类和普通类的区别：" class="headerlink" title="2.3 抽象类和普通类的区别："></a>2.3 抽象类和普通类的区别：</h2><ol><li>抽象方法必须为<strong>public或者protected</strong>（因为如果为private，则不能被子类继承，子类便无法实现该方法,没有意义），缺省情况下默认为public</li><li>抽象类不能用来创建对象</li><li>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。</li></ol><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="http://www.importnew.com/12399.html" target="_blank" rel="noopener">Java抽象类与接口的区别</a></p><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3648398.html" target="_blank" rel="noopener">java基础学习总结——抽象类</a></p><p>​    <a href="https://www.cnblogs.com/dolphin0520/p/3811437.html" target="_blank" rel="noopener">深入理解Java的接口和抽象类</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-抽象的出现&quot;&gt;&lt;a href=&quot;#一-抽象的出现&quot; class=&quot;headerlink&quot; title=&quot;一. 抽象的出现&quot;&gt;&lt;/a&gt;一. 抽象的出现&lt;/h1&gt;&lt;p&gt;​    在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中&lt;strong&gt;没有包含足够的信息&lt;/strong&gt;来描绘一个具体的对象，这样的类就是抽象类&lt;/p&gt;
&lt;p&gt;​    在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口&lt;/p&gt;
&lt;h1 id=&quot;二-抽象方法&quot;&gt;&lt;a href=&quot;#二-抽象方法&quot; class=&quot;headerlink&quot; title=&quot;二.抽象方法&quot;&gt;&lt;/a&gt;二.抽象方法&lt;/h1&gt;&lt;p&gt;​    &lt;strong&gt;一种特殊的方法：它只有声明，而没有具体的实现&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 声明格式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 抽象方法必须用abstract关键字进行修饰&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java面试经典题目(6-10题)</title>
    <link href="http://yoursite.com/2019/03/12/Java%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE(6-10%E9%A2%98)/"/>
    <id>http://yoursite.com/2019/03/12/Java面试经典题目(6-10题)/</id>
    <published>2019-03-12T14:40:00.000Z</published>
    <updated>2019-03-19T03:30:12.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？"><a href="#6-Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？" class="headerlink" title="6. Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？"></a>6. Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？</h1><a id="more"></a><p>答案: </p><h4 id="方法覆盖-重写-的原则："><a href="#方法覆盖-重写-的原则：" class="headerlink" title="方法覆盖(重写)的原则："></a>方法覆盖(重写)的原则：</h4><ol><li>重写方法的方法名称、参数列表必须与原方法的相同，返回类型可以相同也可以是原类型的子类型(从Java SE5开始支持)。   </li><li>重写方法不能比原方法访问性差（即访问权限不允许缩小）。   </li><li>重写方法不能比原方法抛出更多的异常。   </li><li>被重写的方法 <strong>不能为final类型</strong> ，因为final修饰的方法是无法重写的。   </li><li>被重写的方法 <strong>不能为private</strong> ，否则在其子类中只是新定义了一个方法，并没有对其进行重写。   </li><li>被重写的方法 <strong>不能为static</strong> 。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足重写条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足重写条件，但是仍然不会发生重写，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。   </li><li>重写是 <strong>发生在运行时的</strong> ，因为编译期编译器不知道并且没办法确定该去调用哪个方法，JVM会在代码运行的时候作出决定。 </li></ol><h4 id="方法重载的原则："><a href="#方法重载的原则：" class="headerlink" title="方法重载的原则："></a>方法重载的原则：</h4><ol><li>方法名称必须相同。   </li><li>参数列表必须不同（个数不同、或类型不同、参数类型排列顺序不同等）。   </li><li>方法的返回类型可以相同也可以不相同。   </li><li>仅仅返回类型不同不足以成为方法的重载。   </li><li>重载是 <strong>发生在编译时的</strong> ，因为编译器可以根据参数的类型来选择使用哪个方法。 </li></ol><h4 id="重写和重载的不同："><a href="#重写和重载的不同：" class="headerlink" title="重写和重载的不同："></a>重写和重载的不同：</h4><ol><li>方法重写要求参数列表必须一致，而方法重载要求参数列表必须不一致。   </li><li>方法重写要求返回类型必须一致(或为其子类型)，方法重载对此没有要求。   </li><li>方法重写只能用于子类重写父类的方法(覆盖者可能不会限制它所覆盖的方法的访问)，方法重载用于同一个类中的所有方法。   </li><li>方法重写对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。   </li><li>父类的一个方法只能被子类重写一次，而一个方法可以在所有的类中可以被重载多次。   </li><li>重载是编译时多态，重写是运行时多态。</li></ol><h5 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h5><p>​    <a href="https://www.nowcoder.com/questionTerminal/7b2152a85b9a4ebab6dfda7e995a8491" target="_blank" rel="noopener">牛客网优质答案</a></p><h1 id="7-Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"><a href="#7-Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？" class="headerlink" title="7. Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"></a>7. Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？</h1><p>答案:</p><h2 id="什么是构造方法？"><a href="#什么是构造方法？" class="headerlink" title="什么是构造方法？"></a>什么是构造方法？</h2><p>主要作用:** 完成对象的初始化工作(如果写的类里面没有构造函数,那么编译器会默认加上一个无参数且方法体为空的构造函数)</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>使用 new + 构造方法创建一个新的对象</li><li>构造函数是定义在 Java类中的一个用来 <strong>初始化对象</strong> 的函数</li><li>(new一个东西的时候，实际上你调用的是一个构造方法，构造方法就是把自己构造成一个新的对象，所以叫构造方法，构造一个新对象用的方法叫构造方法)</li><li>构造函数与类同名, 且没有返回值(构造方法的名字必须和类的名字完全一模一样，包括大小写,这个方法的名字和类名完全相同，并且没有返回值，也就是在这个方法前面不能写任何的方法的返回类型修饰符，连void都不可以写)</li></ul><h2 id="什么是构造方法重载？"><a href="#什么是构造方法重载？" class="headerlink" title="什么是构造方法重载？"></a>什么是构造方法重载？</h2><p>Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己 <strong>唯一的参数列表</strong> 。</p><h2 id="什么是复制构造方法？"><a href="#什么是复制构造方法？" class="headerlink" title="什么是复制构造方法？"></a>什么是复制构造方法？</h2><h4 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h4><h5 id="C-中的复制构造函数通常有三种作用"><a href="#C-中的复制构造函数通常有三种作用" class="headerlink" title="C++中的复制构造函数通常有三种作用:"></a>C++中的复制构造函数通常有三种作用:</h5><ol><li>对象作为函数参数   </li><li>对象作为函数返回值   </li><li>使用一个对象对另一个对象初始化。</li></ol><blockquote><p>C++语法允许用户定义自己的复制构造函数以实现自定义的复制，比如说进行深复制。Java并不支持这样的复制构造函数。但是这并不代表Java中没有这种机制，在Java中Object类的clone()方法就是这种机制的体现  </p></blockquote><p> Java中不支持构造函数的复制。构造函数的复制属于C++的内容。</p><p>时间: 2019.3.12</p><h1 id="8-Java支持多继承么？"><a href="#8-Java支持多继承么？" class="headerlink" title="8. Java支持多继承么？"></a>8. Java支持多继承么？</h1><p>答案:</p><ol><li><strong>Java中类不支持多继承，只支持单继承（即一个类只有一个父类）.</strong></li><li>Java中的 <strong>接口</strong> 支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）</li></ol><h1 id="9-接口和抽象类的区别是什么？"><a href="#9-接口和抽象类的区别是什么？" class="headerlink" title="9. 接口和抽象类的区别是什么？"></a>9. 接口和抽象类的区别是什么？</h1><p>答案:</p><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><ul><li>类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</li><li>接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。</li><li>抽象类可以在不提供接口方法实现的情况下实现接口。</li></ul><h4 id="语法层面上的区别"><a href="#语法层面上的区别" class="headerlink" title="语法层面上的区别"></a>语法层面上的区别</h4><ol><li>抽象类可以提供成员方法的实现细节(成员函数可以是private，protected或者是public)，而接口中只能存在public abstract 方法(默认是public的)</li><li>抽象类中的成员变量可以是各种类型的(包含非final的变量)，而接口中的成员变量只能是public static final类型的；</li><li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</li><li>接口中所有的方法默认的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ol><h4 id="设计层面上的区别"><a href="#设计层面上的区别" class="headerlink" title="设计层面上的区别"></a>设计层面上的区别</h4><blockquote><p>从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p></blockquote><ul><li>抽象类是对一种事物的抽象，即 <strong>对类抽象</strong> ，而接口是 <strong>对行为的抽象</strong> 。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。</li></ul><p>举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将飞行这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly(  )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，<strong>继承是一个  “是不是”的关系，而 接口 实现则是  “有没有”的关系</strong> 。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p><ul><li>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。</li></ul><p>什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt  B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt  B和ppt  C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.nowcoder.com/questionTerminal/bdb310cc6e384e78b2564dfd3ba4197c" target="_blank" rel="noopener">牛客网优质答案</a></p><p>​    <a href="http://www.importnew.com/12399.html" target="_blank" rel="noopener">Java抽象类与接口的区别</a></p><p>​    <a href="https://www.cnblogs.com/dolphin0520/p/3811437.html" target="_blank" rel="noopener">深入理解Java的接口和抽象类</a></p><p>时间: 2019.3.13</p><h1 id="10-什么是值传递和引用传递？"><a href="#10-什么是值传递和引用传递？" class="headerlink" title="10. 什么是值传递和引用传递？"></a>10. 什么是值传递和引用传递？</h1><p>答案:</p><p><strong>一般认为,Java内的基础类型数据传递都是值传递. Java中实例对象的传递是引用传递</strong></p><ul><li><p>值传递，顾名思义<strong>传递的是其值</strong>，也可以理解为副本给你，任意修改，<strong>原本不变</strong>。</p></li><li><p>引用传递，顾名思义<strong>传递本身</strong>，或者说<strong>传递的是地址</strong>，修改的是本身或者是<strong>原本地址里的内容</strong>。</p></li></ul><blockquote><p>值传递，原本不改变，引用传递，原本改变</p></blockquote><h5 id="详细解析见：知乎答案"><a href="#详细解析见：知乎答案" class="headerlink" title="详细解析见：知乎答案"></a>详细解析见：<a href="https://www.zhihu.com/question/31203609/answer/50992895" target="_blank" rel="noopener">知乎答案</a></h5><p>参考博文:</p><p>​    <a href="https://www.nowcoder.com/questionTerminal/b296e9e1c40542ec8677c1e452b6b576" target="_blank" rel="noopener">牛客网答案</a></p><p>时间: 2019.3.14</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;6-Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？&quot;&gt;&lt;a href=&quot;#6-Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？&quot; class=&quot;headerlink&quot; title=&quot;6. Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？&quot;&gt;&lt;/a&gt;6. Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？&lt;/h1&gt;
    
    </summary>
    
      <category term="java面试常考题目" scheme="http://yoursite.com/categories/java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java面试常考题目" scheme="http://yoursite.com/tags/java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构---顺序表的概念及实现</title>
    <link href="http://yoursite.com/2019/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/03/12/数据结构---顺序表的概念及实现/</id>
    <published>2019-03-12T12:50:53.000Z</published>
    <updated>2019-03-15T09:15:53.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>​    逻辑关系相邻的两个结点在 <strong>物理位置</strong> 上也相邻, 结点的逻辑次序和物理次序一致</p><a id="more"></a><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>​    <strong>数组</strong></p><h3 id="数组的优缺点"><a href="#数组的优缺点" class="headerlink" title="数组的优缺点"></a>数组的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>存取速度快</strong> O(1) 可以直接根据下标找到内存位置</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>浪费存储空间. 要求实现估计容量,比较困难,需要的空间过大,造成浪费,过小将导致溢出</li><li><strong>插入和删除</strong> 运算不方便,效率低,时间复杂度为O(n)</li><li>顺序表的存储空间不容易扩充.</li></ul><h3 id="基本操作的实现"><a href="#基本操作的实现" class="headerlink" title="基本操作的实现"></a>基本操作的实现</h3><ol><li>初始化数组</li><li>判断数组是否为空</li><li>判断数组是否满</li><li>显示数组内容</li><li>向数组中追加元素</li><li>向数组中指定的位置插入元素</li><li>删除指定元素</li><li>数组进行倒置</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先定义结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Arr</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> len; <span class="comment">// 数组能存取的最大元素个数</span></span><br><span class="line"><span class="keyword">int</span> currentNum;<span class="comment">// 当前元素的个数</span></span><br><span class="line"><span class="keyword">int</span> * pBase;<span class="comment">// 存储指向数组元素的指针 </span></span><br><span class="line">&#125; Arr;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 初始化数组</span></span><br><span class="line"><span class="comment">* 所需要的参数: 结构体, 数组长度 </span></span><br><span class="line"><span class="comment">* 让指针指向分配的数组</span></span><br><span class="line"><span class="comment">*  判断判断内存是否分配失败,如果没有失败,其他两个参数进行赋值 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initArr</span><span class="params">(Arr * pArr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 分配4*len字节长度的内存,这是pBase可以指向数组中的第一个元素，可以作为数组变量名称使用。</span></span><br><span class="line">pArr-&gt;pBase = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*len);</span><br><span class="line"><span class="comment">// 判断内存是否分配失败 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == pArr-&gt;pBase)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"动态内存分配失败!"</span>) ;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// pArray 中的值进行初始化</span></span><br><span class="line">pArr-&gt;len = len;</span><br><span class="line">pArr-&gt;currentNum = <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断数组是否为空</span></span><br><span class="line"><span class="comment">* 判断条件应该是当前数组中的元素是不是 0 个 </span></span><br><span class="line"><span class="comment">* 参数: 数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(Arr * pArr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == pArr-&gt;currentNum)&#123;</span><br><span class="line"><span class="comment">// 若数组为空,返回true </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断数组是否满了</span></span><br><span class="line"><span class="comment">* 判断条件应该是 len 和 currentNum 是否相等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(Arr * pArr)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果满了,返回 true </span></span><br><span class="line"><span class="keyword">if</span>(pArr-&gt;len == pArr-&gt;currentNum) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 显示数组内容</span></span><br><span class="line"><span class="comment">* 先判断数组是否为空,若为空,打印数组为空</span></span><br><span class="line"><span class="comment">* 若不为空,则利用指针循环遍历,全部打印出来 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showArr</span><span class="params">(Arr * pArr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isEmpty(pArr)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"数组为空!\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t\t此时数组中的所有元素为: \n"</span>); </span><br><span class="line"><span class="comment">// 注意应该是 i &lt; pArr-&gt;currentNum</span></span><br><span class="line"><span class="comment">// 不是  i &lt; pArr-&gt;len</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pArr-&gt;currentNum; i++) &#123;</span><br><span class="line"><span class="comment">// 是数组,所以是 pArr-&gt;pBase[i]</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d \t"</span>, pArr-&gt;pBase[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n------------------------------------------------\n"</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 向数组中追加元素</span></span><br><span class="line"><span class="comment">* 参数:数组, 追加的值 </span></span><br><span class="line"><span class="comment">* 先判断数组是否已经满了</span></span><br><span class="line"><span class="comment">* 如果满了,则不可以追加元素,打印追加失败</span></span><br><span class="line"><span class="comment">* 如果未满,进行追加 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(Arr * pArr, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>( isFull(pArr) ) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"数组已经满了,无法添加!\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"添加元素为 %d\t"</span>, val);</span><br><span class="line"></span><br><span class="line">pArr-&gt;pBase[pArr-&gt;currentNum] = val;</span><br><span class="line"><span class="comment">// 当前个数+1</span></span><br><span class="line">pArr-&gt;currentNum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 向数组中指定的位置插入元素</span></span><br><span class="line"><span class="comment">* 参数: 数组地址, 位置, 值</span></span><br><span class="line"><span class="comment">* 首先判断数组是否满 </span></span><br><span class="line"><span class="comment">* 再判断插入的位置是否合法 </span></span><br><span class="line"><span class="comment">* 将插入位置后面的元素向后移动一个 </span></span><br><span class="line"><span class="comment">* 再插入到相应的位置 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(Arr * pArr, <span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>( isFull(pArr) ) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"数组已经满了,无法插入!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 插入的位置不能小于1，同时不能比最后一个元素位置大一</span></span><br><span class="line"><span class="comment">// 注意是 pos &gt; pArr-&gt;len+1</span></span><br><span class="line"><span class="keyword">if</span>  (pos &lt; <span class="number">1</span> || pos &gt; pArr-&gt;len+<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 移动范围是从第pos个到底cnu个 </span></span><br><span class="line"><span class="comment">// 注意判断条件 i = pArr-&gt;currentlen</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = pArr-&gt;currentNum; i &gt; pos; i--) &#123;</span><br><span class="line"><span class="comment">// 若以i表示要移动元素的位置，从一开始的。右边都是i-1,若左移，左边是i-2,右移，左边是i</span></span><br><span class="line">pArr-&gt;pBase[<span class="number">1</span>] = pArr-&gt;pBase[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行插入的值的赋值</span></span><br><span class="line">pArr-&gt;pBase[pos<span class="number">-1</span>] = val;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"在第%d的位置插入元素: %d"</span>, pos, val);</span><br><span class="line">pArr-&gt;currentNum++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 向数组中指定的位置插入元素</span></span><br><span class="line"><span class="comment">* 参数: 数组地址, 位置, 值(地址,将返回去) </span></span><br><span class="line"><span class="comment">* 先判断位置是否合法</span></span><br><span class="line"><span class="comment">* 在进行删除 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">delete_</span><span class="params">(Arr * pArr, <span class="keyword">int</span> pos, <span class="keyword">int</span> *val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;<span class="number">1</span> || pos&gt;pArr-&gt;currentNum) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"删除失败，位置不合法\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 获取删除元素的值 </span></span><br><span class="line">*val = pArr-&gt;pBase[pos<span class="number">-1</span>];</span><br><span class="line"><span class="comment">// 注意循环条件 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=pos; i&lt;pArr-&gt;currentNum; i++)&#123;</span><br><span class="line">pArr-&gt;pBase[i<span class="number">-1</span>] = pArr-&gt;pBase[i];</span><br><span class="line">&#125; </span><br><span class="line">pArr-&gt;currentNum--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数组元素进行倒置</span></span><br><span class="line"><span class="comment">* 首先判断数组是否为空 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inverse</span><span class="params">(Arr * pArr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>( isEmpty(pArr) ) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"倒置失败，因数组为空"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;<span class="comment">// 数组的第一个元素</span></span><br><span class="line"><span class="keyword">int</span> end = pArr-&gt;currentNum<span class="number">-1</span>;<span class="comment">// 数组的最后一个元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"数组元素进行倒置"</span>); </span><br><span class="line"><span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line"><span class="comment">// 利用一个 temp 临时数据进行数据交换 </span></span><br><span class="line"><span class="keyword">int</span> temp = pArr-&gt;pBase[start];</span><br><span class="line">pArr-&gt;pBase[start] = pArr-&gt;pBase[end];</span><br><span class="line">pArr-&gt;pBase[end] = temp;</span><br><span class="line"><span class="comment">// 下一组 </span></span><br><span class="line">start++;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 代码测试 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Arr arr;</span><br><span class="line"><span class="comment">// 将结构体的地址作为实参，这样才能修改结构体中的值</span></span><br><span class="line"><span class="comment">// 如果传的是结构体变量，那么将进行拷贝，不会改变值</span></span><br><span class="line">initArr(&amp;arr, <span class="number">6</span>);</span><br><span class="line"><span class="comment">// 进行追加</span></span><br><span class="line">append(&amp;arr, <span class="number">1</span>);</span><br><span class="line">append(&amp;arr, <span class="number">2</span>);</span><br><span class="line">append(&amp;arr, <span class="number">3</span>);</span><br><span class="line">append(&amp;arr, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 进行显示 </span></span><br><span class="line">showArr(&amp;arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素 </span></span><br><span class="line">insert(&amp;arr, <span class="number">5</span>, <span class="number">88</span>);</span><br><span class="line">showArr(&amp;arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">delete_(&amp;arr, <span class="number">1</span>, &amp;val);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"删除了元素 %d"</span>, val);</span><br><span class="line">showArr(&amp;arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行倒置 </span></span><br><span class="line">inverse(&amp;arr);</span><br><span class="line">    showArr(&amp;arr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文:"></a>参考博文:</h5><p>​    <a href="https://blog.csdn.net/Davidluo001/article/details/46447817" target="_blank" rel="noopener">数据结构基础（1）–数组C语言实现–动态内存分配</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;顺序表&quot;&gt;&lt;a href=&quot;#顺序表&quot; class=&quot;headerlink&quot; title=&quot;顺序表&quot;&gt;&lt;/a&gt;顺序表&lt;/h1&gt;&lt;h3 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h3&gt;&lt;p&gt;​    逻辑关系相邻的两个结点在 &lt;strong&gt;物理位置&lt;/strong&gt; 上也相邻, 结点的逻辑次序和物理次序一致&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>C语言---常用函数</title>
    <link href="http://yoursite.com/2019/03/12/C%E8%AF%AD%E8%A8%80---%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/03/12/C语言---常用函数/</id>
    <published>2019-03-12T10:23:51.000Z</published>
    <updated>2019-03-15T08:16:17.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言常用函数"><a href="#C语言常用函数" class="headerlink" title="C语言常用函数"></a>C语言常用函数</h1><h2 id="sizeof用法"><a href="#sizeof用法" class="headerlink" title="sizeof用法"></a>sizeof用法</h2><a id="more"></a><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C语言常用函数&quot;&gt;&lt;a href=&quot;#C语言常用函数&quot; class=&quot;headerlink&quot; title=&quot;C语言常用函数&quot;&gt;&lt;/a&gt;C语言常用函数&lt;/h1&gt;&lt;h2 id=&quot;sizeof用法&quot;&gt;&lt;a href=&quot;#sizeof用法&quot; class=&quot;headerlink&quot; title=&quot;sizeof用法&quot;&gt;&lt;/a&gt;sizeof用法&lt;/h2&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---JDBC(1)</title>
    <link href="http://yoursite.com/2019/03/12/JavaWeb---JDBC(1)/"/>
    <id>http://yoursite.com/2019/03/12/JavaWeb---JDBC(1)/</id>
    <published>2019-03-12T09:23:51.000Z</published>
    <updated>2019-03-15T08:22:58.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JDBC相关概念介绍"><a href="#一、JDBC相关概念介绍" class="headerlink" title="一、JDBC相关概念介绍"></a>一、JDBC相关概念介绍</h2><h3 id="1-1、数据库驱动"><a href="#1-1、数据库驱动" class="headerlink" title="1.1、数据库驱动"></a>1.1、数据库驱动</h3><p>　　这里的驱动的概念和平时听到的那种驱动的概念是一样的，比如平时购买的声卡，网卡直接插到计算机上面是不能用的，必须要安装相应的驱动程序之后才能够使用声卡和网卡，同样道理，我们安装好数据库之后，我们的应用程序也是不能直接使用数据库的，必须要通过相应的数据库驱动程序，通过驱动程序去和数据库打交道</p><a id="more"></a><h3 id="1-2、JDBC介绍"><a href="#1-2、JDBC介绍" class="headerlink" title="1.2、JDBC介绍"></a>1.2、JDBC介绍</h3><p>　　SUN公司为了简化、统一对数据库的操作，定义了一套Java操作数据库的规范（接口），称之为<strong>JDBC</strong> 。这套接口由数据库厂商去实现，这样，开发人员只需要学习jdbc接口，并通过jdbc加载具体的驱动，就可以操作数据库。</p><p>JDBC全称为：<strong>Java Data Base Connectivity（java数据库连接）</strong>，它主要由接口组成。<br><strong>组成JDBC的２个包：</strong></p><ul><li><p>java.sql</p></li><li><p>javax.sql</p></li></ul><p>开发JDBC应用需要以上2个包的支持外，还需要 <strong>导入相应JDBC的数据库实现(即数据库驱动)</strong> 。</p><h2 id="二、编写JDBC程序"><a href="#二、编写JDBC程序" class="headerlink" title="二、编写JDBC程序"></a>二、编写JDBC程序</h2><h3 id="2-1-搭建实验环境"><a href="#2-1-搭建实验环境" class="headerlink" title="2.1. 搭建实验环境"></a>2.1. 搭建实验环境</h3><ol><li><p>在mysql中创建一个库，并 <strong>创建user表和插入表的数据</strong> 。</p></li><li><p>新建一个Java工程，并 <strong>导入数据驱动</strong></p></li><li><p>编写程序从user表中读取数据，并打印在命令行窗口中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConn</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//要连接的数据库URL</span></span><br><span class="line">        String url = <span class="string">"jdbc:mysql://localhost:3306/jdbcStudy"</span>;</span><br><span class="line">        <span class="comment">//连接的数据库时使用的用户名</span></span><br><span class="line">        String username = <span class="string">"root"</span>;</span><br><span class="line">        <span class="comment">//连接的数据库时使用的密码</span></span><br><span class="line">        String password = <span class="string">"XDP"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.加载驱动</span></span><br><span class="line">        <span class="comment">//DriverManager.registerDriver(new com.mysql.jdbc.Driver());不推荐使用这种方式来加载驱动</span></span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);<span class="comment">//推荐使用这种方式来加载驱动</span></span><br><span class="line">        <span class="comment">//2.获取与数据库的链接</span></span><br><span class="line">        Connection conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.获取用于向数据库发送sql语句的statement</span></span><br><span class="line">        Statement st = conn.createStatement();</span><br><span class="line">        </span><br><span class="line">        String sql = <span class="string">"select id,name,password,email,birthday from users"</span>;</span><br><span class="line">        <span class="comment">//4.向数据库发sql,并获取代表结果集的resultset</span></span><br><span class="line">        ResultSet rs = st.executeQuery(sql);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.取出结果集的数据</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">            System.out.println(<span class="string">"id="</span> + rs.getObject(<span class="string">"id"</span>));</span><br><span class="line">            System.out.println(<span class="string">"name="</span> + rs.getObject(<span class="string">"name"</span>));</span><br><span class="line">            System.out.println(<span class="string">"password="</span> + rs.getObject(<span class="string">"password"</span>));</span><br><span class="line">            System.out.println(<span class="string">"email="</span> + rs.getObject(<span class="string">"email"</span>));</span><br><span class="line">            System.out.println(<span class="string">"birthday="</span> + rs.getObject(<span class="string">"birthday"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.关闭链接，释放资源</span></span><br><span class="line">        rs.close();</span><br><span class="line">        st.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//详细解析见原博文</span></span><br></pre></td></tr></table></figure><h3 id="2-2-释放资源"><a href="#2-2-释放资源" class="headerlink" title="2.2 释放资源"></a>2.2 释放资源</h3><p>　　Jdbc程序运行完后，切记要释放程序在运行过程中，创建的那些与数据库进行交互的对象，这些对象通常是ResultSet,  Statement和Connection对象，特别是Connection对象，它是非常稀有的资源，用完后必须马上释放，如果Connection不能及时、正确的关闭，极易导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。<br>　　为确保资源释放代码能运行，资源释放代码也一定要放在finally语句中。</p></li></ol><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文:"></a>参考博文:</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3946207.html" target="_blank" rel="noopener">javaweb学习总结(三十二)——JDBC学习入门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、JDBC相关概念介绍&quot;&gt;&lt;a href=&quot;#一、JDBC相关概念介绍&quot; class=&quot;headerlink&quot; title=&quot;一、JDBC相关概念介绍&quot;&gt;&lt;/a&gt;一、JDBC相关概念介绍&lt;/h2&gt;&lt;h3 id=&quot;1-1、数据库驱动&quot;&gt;&lt;a href=&quot;#1-1、数据库驱动&quot; class=&quot;headerlink&quot; title=&quot;1.1、数据库驱动&quot;&gt;&lt;/a&gt;1.1、数据库驱动&lt;/h3&gt;&lt;p&gt;　　这里的驱动的概念和平时听到的那种驱动的概念是一样的，比如平时购买的声卡，网卡直接插到计算机上面是不能用的，必须要安装相应的驱动程序之后才能够使用声卡和网卡，同样道理，我们安装好数据库之后，我们的应用程序也是不能直接使用数据库的，必须要通过相应的数据库驱动程序，通过驱动程序去和数据库打交道&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---JavaBean</title>
    <link href="http://yoursite.com/2019/03/12/JavaWeb---JavaBean/"/>
    <id>http://yoursite.com/2019/03/12/JavaWeb---JavaBean/</id>
    <published>2019-03-12T08:23:51.000Z</published>
    <updated>2019-04-04T02:07:56.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是-JavaBean"><a href="#一、什么是-JavaBean" class="headerlink" title="一、什么是 JavaBean"></a>一、什么是 JavaBean</h2><p>　　<strong>JavaBean是一个遵循特定写法的Java类</strong>，它通常具有如下特点：</p><ul><li>这个Java类<strong>必须具有一个无参的构造函数</strong></li><li>属性必须<strong>私有化</strong> </li><li>私有化的属性必须通过<strong>public类型的方法暴露给其它程序</strong>，并且方法的命名也必须遵守一定的命名规范(getter和setter)</li><li>如果属性是<strong>boolean</strong>,那么就对应<strong>is和setter</strong>方法</li></ul><a id="more"></a><p><strong>javaBean范例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Person类就是一个最简单的JavaBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------Person类封装的私有属性-------------------------------------</span></span><br><span class="line">    <span class="comment">// 姓名 String类型</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//是否已婚 boolean类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> married;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//------------------Person类的无参数构造方法-----------------------------------</span></span><br><span class="line">    <span class="comment">// 无参数构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//------------------Person类对外提供的用于访问私有属性的public方法----------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMarried</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> married;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMarried</span><span class="params">(<span class="keyword">boolean</span> married)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.married = married;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JavaBean在J2EE开发中，通常用于封装数据，对于遵循以上写法的JavaBean组件，其它程序可以通过反射技术实例化JavaBean对象，并且通过反射那些遵守命名规范的方法，从而获知JavaBean的属性，进而调用其属性保存数据</p></blockquote><h2 id="二、JavaBean的属性"><a href="#二、JavaBean的属性" class="headerlink" title="二、JavaBean的属性"></a>二、JavaBean的属性</h2><ul><li><strong>JavaBean的属性可以是任意类型，并且一个JavaBean可以有多个属性</strong>。每个属性通常都需要具有相应的setter、 getter方法，setter方法称为属性修改器，getter方法称为属性访问器。</li><li>属性修改器必须以小写的set前缀开始，后跟属性名，且属性名的第一个字母要改为大写，例如，name属性的修改器名称为setName，password属性的修改器名称为setPassword。 </li><li>属性访问器通常以小写的get前缀开始，后跟属性名，且属性名的第一个字母也要改为大写，例如，name属性的访问器名称为getName，password属性的访问器名称为getPassword。 </li><li>一个JavaBean的某个属性也可以只有set方法或get方法，这样的属性通常也称之为只写、只读属性。</li></ul><h4 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文:"></a>参考博文:</h4><p><a href="https://www.cnblogs.com/xdp-gacl/p/3871730.html" target="_blank" rel="noopener">javaweb学习总结(二十)——JavaBean总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是-JavaBean&quot;&gt;&lt;a href=&quot;#一、什么是-JavaBean&quot; class=&quot;headerlink&quot; title=&quot;一、什么是 JavaBean&quot;&gt;&lt;/a&gt;一、什么是 JavaBean&lt;/h2&gt;&lt;p&gt;　　&lt;strong&gt;JavaBean是一个遵循特定写法的Java类&lt;/strong&gt;，它通常具有如下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个Java类&lt;strong&gt;必须具有一个无参的构造函数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;属性必须&lt;strong&gt;私有化&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;私有化的属性必须通过&lt;strong&gt;public类型的方法暴露给其它程序&lt;/strong&gt;，并且方法的命名也必须遵守一定的命名规范(getter和setter)&lt;/li&gt;
&lt;li&gt;如果属性是&lt;strong&gt;boolean&lt;/strong&gt;,那么就对应&lt;strong&gt;is和setter&lt;/strong&gt;方法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>how2J天猫整站---笔记</title>
    <link href="http://yoursite.com/2019/03/12/how2J%E5%A4%A9%E7%8C%AB%E6%95%B4%E7%AB%99J2EE---%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/03/12/how2J天猫整站J2EE---笔记/</id>
    <published>2019-03-12T04:23:51.000Z</published>
    <updated>2019-03-12T13:13:20.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-关于表"><a href="#一-关于表" class="headerlink" title="一.关于表"></a>一.关于表</h1><h4 id="表与表之间的关系，基本上是3种"><a href="#表与表之间的关系，基本上是3种" class="headerlink" title="表与表之间的关系，基本上是3种"></a>表与表之间的关系，基本上是3种</h4><ul><li>一对一</li><li>一对多</li><li>多对一</li></ul><h3 id="表的杂谈"><a href="#表的杂谈" class="headerlink" title="表的杂谈"></a>表的杂谈</h3><ul><li>修改表结构是代价最大的改动</li><li>在建表过程中，会设置外键约束，所以表和表之间有依赖关系。 因此会先建立被外键指向的表</li><li>一般说来，对于一个新项目，建表的时候，会把sql语句都准备好，一次性执行</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-关于表&quot;&gt;&lt;a href=&quot;#一-关于表&quot; class=&quot;headerlink&quot; title=&quot;一.关于表&quot;&gt;&lt;/a&gt;一.关于表&lt;/h1&gt;&lt;h4 id=&quot;表与表之间的关系，基本上是3种&quot;&gt;&lt;a href=&quot;#表与表之间的关系，基本上是3种&quot; class=&quot;headerlink&quot; title=&quot;表与表之间的关系，基本上是3种&quot;&gt;&lt;/a&gt;表与表之间的关系，基本上是3种&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;一对一&lt;/li&gt;
&lt;li&gt;一对多&lt;/li&gt;
&lt;li&gt;多对一&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;表的杂谈&quot;&gt;&lt;a href=&quot;#表的杂谈&quot; class=&quot;headerlink&quot; title=&quot;表的杂谈&quot;&gt;&lt;/a&gt;表的杂谈&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;修改表结构是代价最大的改动&lt;/li&gt;
&lt;li&gt;在建表过程中，会设置外键约束，所以表和表之间有依赖关系。 因此会先建立被外键指向的表&lt;/li&gt;
&lt;li&gt;一般说来，对于一个新项目，建表的时候，会把sql语句都准备好，一次性执行&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="how2J" scheme="http://yoursite.com/categories/how2J/"/>
    
    
      <category term="how2J" scheme="http://yoursite.com/tags/how2J/"/>
    
  </entry>
  
  <entry>
    <title>eclipse---快捷键</title>
    <link href="http://yoursite.com/2019/03/12/eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2019/03/12/eclipse快捷键/</id>
    <published>2019-03-12T04:23:51.000Z</published>
    <updated>2019-03-15T08:17:49.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="eclipse快捷键"><a href="#eclipse快捷键" class="headerlink" title="eclipse快捷键"></a>eclipse快捷键</h1><h4 id="eclipse配置折叠-展开代码快捷键"><a href="#eclipse配置折叠-展开代码快捷键" class="headerlink" title="eclipse配置折叠/展开代码快捷键"></a>eclipse配置折叠/展开代码快捷键</h4><p>​    <a href="https://blog.csdn.net/HFUTLXM/article/details/78916599" target="_blank" rel="noopener">如何设置</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;eclipse快捷键&quot;&gt;&lt;a href=&quot;#eclipse快捷键&quot; class=&quot;headerlink&quot; title=&quot;eclipse快捷键&quot;&gt;&lt;/a&gt;eclipse快捷键&lt;/h1&gt;&lt;h4 id=&quot;eclipse配置折叠-展开代码快捷键&quot;&gt;&lt;a href=&quot;#eclipse配置折叠-展开代码快捷键&quot; class=&quot;headerlink&quot; title=&quot;eclipse配置折叠/展开代码快捷键&quot;&gt;&lt;/a&gt;eclipse配置折叠/展开代码快捷键&lt;/h4&gt;&lt;p&gt;​    &lt;a href=&quot;https://blog.csdn.net/HFUTLXM/article/details/78916599&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何设置&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="eclipse" scheme="http://yoursite.com/categories/eclipse/"/>
    
    
      <category term="eclipse" scheme="http://yoursite.com/tags/eclipse/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---线程(1)</title>
    <link href="http://yoursite.com/2019/03/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E7%BA%BF%E7%A8%8B(1)/"/>
    <id>http://yoursite.com/2019/03/12/Java基础知识---线程(1)/</id>
    <published>2019-03-12T02:40:23.000Z</published>
    <updated>2019-03-19T12:12:09.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-线程的基本概念"><a href="#一-线程的基本概念" class="headerlink" title="一. 线程的基本概念"></a>一. 线程的基本概念</h1><p>线程是一个程序里面不同的执行路径</p><p>每一个分支都叫做一个线程，main()叫做主分支，也叫主线程</p><a id="more"></a><h3 id="程序的执行过程"><a href="#程序的执行过程" class="headerlink" title="程序的执行过程"></a>程序的执行过程</h3><p>​    首先把程序的代码放到<strong>内存的代码区</strong>里面，代码放到代码区后并<strong>没有马上开始执行</strong>，但这时候说明了一个进程准备开始，<strong>进程已经产生了，但还没有开始执行</strong>，这就是进程，所以<strong>进程其实是一个静态的概念</strong>，它本身就不能动。</p><p><strong>进程:</strong> 机器上的一个.class文件，机器上的一个.exe文件，这个叫做一个进程</p><blockquote><p>平常所说的进程的执行指的是<strong>进程里面主线程</strong>开始执行了，也就是<strong>main()方法</strong>开始执行了。</p><p>==<strong>进程是一个静态的概念，在我们机器里面实际上运行的都是线程。</strong>==</p></blockquote><h4 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充:"></a>知识补充:</h4><blockquote><p>CPU难道真的很神通广大，能够同时执行那么多程序吗？</p><p><strong>不是的</strong>，CPU的执行是这样的：CPU的速度很快，一秒钟可以算好几亿次，因此CPU把自己的时间分成一个个小时间片，我这个时间片执行你一会，下一个时间片执行他一会，再下一个时间片又执行其他人一会，虽然有几十个线程，但一样可以在<strong>很短的时间内</strong>把他们通通都执行一遍，但对我们人来说，<strong>CPU的执行速度太快了，因此看起来就像是在同时执行一样</strong>，但<strong>实际上在一个时间点上，CPU只有一个线程在运行</strong>。</p></blockquote><h2 id="小总结-学习线程首先要理清楚三个概念"><a href="#小总结-学习线程首先要理清楚三个概念" class="headerlink" title="小总结(学习线程首先要理清楚三个概念):"></a>小总结(学习线程首先要理清楚三个概念):</h2><ol><li>进程：进程是一个<strong>静态的概念</strong></li><li>线程：一个程序里面的，<strong>一个进程里面不同的执行路径</strong> (一个进程里面有<strong>一个主线程叫main()方法</strong>)。</li><li><strong>在同一个时间点上，一个CPU只能支持一个线程在执行</strong>。因为CPU运行的速度很快，因此我们看起来的感觉就像是多线程一样。</li></ol><blockquote><p>什么才是真正的多线程？</p><p>答: 如果你的机器是双CPU，或者是双核，这确确实实是多线程。</p></blockquote><h1 id="二-线程的创建和启动"><a href="#二-线程的创建和启动" class="headerlink" title="二. 线程的创建和启动"></a>二. 线程的创建和启动</h1><p>​    在 JAVA 里面，JAVA的线程是通过<code>java.lang.Thread</code>类来实现的，<strong>每一个Thread对象代表一个新的线程</strong>。</p><p>创建一个新线程出来有<strong>两种方法</strong>：</p><ol><li>从Thread类继承</li><li>实现接口</li></ol><h2 id="2-1-继承Thread类"><a href="#2-1-继承Thread类" class="headerlink" title="2.1 继承Thread类"></a>2.1 继承Thread类</h2><h5 id="继承Thread类，重写该类的run-方法"><a href="#继承Thread类，重写该类的run-方法" class="headerlink" title="继承Thread类，重写该类的run()方法"></a>继承Thread类，重写该类的run()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 定义Thread的子类并实现run()方法</span></span><br><span class="line"><span class="comment"> * 并发进行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个新的线程 r3, 此线程进入新建(new)状态</span></span><br><span class="line">Runner3 r3 = <span class="keyword">new</span> Runner3();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用start()方法使得线程进入就绪状态(runnable),此时此线程并不一定会马上得以执行，这取决于CPU调度时机</span></span><br><span class="line">r3.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"mainMethod："</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner3</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="comment">// 重写run()方法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"Runner3："</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*打印结果:</span></span><br><span class="line"><span class="comment">    mainMethod：0</span></span><br><span class="line"><span class="comment">    Runner3：0</span></span><br><span class="line"><span class="comment">    mainMethod：1</span></span><br><span class="line"><span class="comment">    Runner3：1</span></span><br><span class="line"><span class="comment">    Runner3：2</span></span><br><span class="line"><span class="comment">    Runner3：3</span></span><br><span class="line"><span class="comment">    Runner3：4</span></span><br><span class="line"><span class="comment">    mainMethod：2</span></span><br><span class="line"><span class="comment">    mainMethod：3</span></span><br><span class="line"><span class="comment">    mainMethod：4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>start() 方法的调用后并不是立即执行多线程代码，而是使得该线程变为就绪状态(Runnable)，什么时候运行是由操作系统决定的</li><li><p>多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。</p></li><li><p>所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的</p></li></ul><h2 id="2-2-使用实现-Runnable-接口创建和启动新线程"><a href="#2-2-使用实现-Runnable-接口创建和启动新线程" class="headerlink" title="2.2 使用实现 Runnable 接口创建和启动新线程"></a>2.2 使用实现 Runnable 接口创建和启动新线程</h2><p>实现Runnable接口，并重写该接口的run()方法</p><p>该 run() 方法同样是线程执行体，创建Runnable实现类的实例，并<strong>以此实例作为Thread类的target来创建Thread对象</strong>，<strong>该Thread对象才是真正的线程对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 开辟一个新的线程来调用run方法</span></span><br><span class="line"><span class="comment"> * 程序执行到 t.start() 后开辟了一条新的线程,主线程继续向下执行</span></span><br><span class="line"><span class="comment"> * t.start() 这条线程是 run() 方法执行的线程,</span></span><br><span class="line"><span class="comment"> * run() 方法和 main() 方法再在交替进行,或者说叫并行执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个新的线程对象r1, 此线程进入新建状态</span></span><br><span class="line">Runner1 r1 = <span class="keyword">new</span> Runner1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里使用的是Thread(Runnable target)构造方法</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r1); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start()方法使得线程进入就绪状</span></span><br><span class="line">t.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"maintheod："</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类用来实现 Runnable 接口，实现Runnable接口就表示这个类是一个线程类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="comment">// 每个线程都是方法run()来完成其操作的，方法run()称为线程体</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"Runner1："</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*打印结果:</span></span><br><span class="line"><span class="comment">    maintheod：0</span></span><br><span class="line"><span class="comment">    maintheod：1</span></span><br><span class="line"><span class="comment">    Runner1：0</span></span><br><span class="line"><span class="comment">    maintheod：2</span></span><br><span class="line"><span class="comment">    Runner1：1</span></span><br><span class="line"><span class="comment">    maintheod：3</span></span><br><span class="line"><span class="comment">    Runner1：2</span></span><br><span class="line"><span class="comment">    Runner1：3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="补-不开辟新线程直接调用run-方法"><a href="#补-不开辟新线程直接调用run-方法" class="headerlink" title="补:不开辟新线程直接调用run() 方法"></a>补:不开辟新线程直接调用run() 方法</h4><p>首先进入主程序, 子程序 r2 执行完之后主程序 main() 在继续执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 不开辟新线程直接调用run方法</span></span><br><span class="line"><span class="comment"> * 首先进入主程序, 子程序 r2 执行完之后主程序 main() 在继续执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zn</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这里new了一个线程类的对象出来</span></span><br><span class="line">Runner2 r2 = <span class="keyword">new</span> Runner2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个称为方法调用，方法调用的执行是run()方法执行完之后才会继续执行main()方法</span></span><br><span class="line">r2.run();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread t = new Thread(r2);</span></span><br><span class="line"><span class="comment">// t.start();</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"maintheod："</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类用来实现 Runnable 接口，实现Runnable接口就表示这个类是一个线程类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个线程都是方法run()来完成其操作的，方法run()称为线程体</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"Runner2："</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*打印结果:</span></span><br><span class="line"><span class="comment">    Runner2：0</span></span><br><span class="line"><span class="comment">    Runner2：1</span></span><br><span class="line"><span class="comment">    Runner2：2</span></span><br><span class="line"><span class="comment">    Runner2：3</span></span><br><span class="line"><span class="comment">    maintheod：0</span></span><br><span class="line"><span class="comment">    maintheod：1</span></span><br><span class="line"><span class="comment">    maintheod：2</span></span><br><span class="line"><span class="comment">    maintheod：3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="Thread和Runnable之间到底是什么关系呢？"><a href="#Thread和Runnable之间到底是什么关系呢？" class="headerlink" title="Thread和Runnable之间到底是什么关系呢？"></a>Thread和Runnable之间到底是什么关系呢？</h4><h5 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">30</span>) &#123;</span><br><span class="line">                Runnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">                Thread thread = <span class="keyword">new</span> MyThread(myRunnable);</span><br><span class="line">                thread.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"in MyRunnable run"</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(Runnable runnable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"in MyThread run"</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>与实现Runnable接口创建线程方式相似，不同的地方在于</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> MyThread(myRunnable);</span><br></pre></td></tr></table></figure></li><li><p>那么这种方式可以顺利创建出一个新的线程么？</p><p>答案是肯定的。至于此时的线程执行体到底是MyRunnable接口中的run()方法还是MyThread类中的run()方法呢？通过输出我们知道<strong>线程执行体是MyThread类中的 run() 方法</strong>。其实原因很简单，因为<strong>Thread类本身也是实现了Runnable接口</strong>，而 run() 方法最先是在Runnable接口中定义的方法</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>Thread类中对Runnable接口中run()方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>当执行到Thread类中的run()方法时，<strong>会首先判断target是否存在</strong>，存在则执行target中的run()方法，也就是实现了Runnable接口并重写了run()方法的类中的run()方法。</p></li><li><p>但是上述给到的列子中，<strong>由于多态的存在，根本就没有执行到Thread类中的run()方法，而是直接先执行了运行时类型即MyThread类中的run()方法</strong></p></li></ul></li></ol><h2 id="2-3-两种方法的选择"><a href="#2-3-两种方法的选择" class="headerlink" title="2.3 两种方法的选择"></a>2.3 两种方法的选择</h2><p><strong>优先选择实现Runnable接口</strong> 去开辟一个新的线程。</p><p><strong>实现Runnable接口比继承Thread类所具有的优势：</strong></p><ol><li><p>适合多个相同的程序代码的线程去处理同一个资源</p></li><li><p>可以避免java中的单继承的限制</p></li><li><p>增加程序的健壮性，代码可以被多个线程共享，代码和数据独立</p></li><li><p>线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类</p></li></ol><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><blockquote><p> main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。</p></blockquote><h1 id="三-线程状态转换"><a href="#三-线程状态转换" class="headerlink" title="三. 线程状态转换"></a>三. 线程状态转换</h1><ol><li><p><strong>新建(new)：</strong>新创建了一个线程对象。     </p></li><li><p><strong>可运行(runnable)：</strong>线程对象创建后，其他线程(比如main线程) <strong>调用了该对象的start()方法</strong>。该状态的线程位于可运行线程池中，<strong>等待</strong>被线程调度选中，获取 cpu 的使用权。     </p></li><li><p><strong>运行(running)：</strong>可运行状态(runnable)的线程<strong>获得了 cpu 时间片(timeslice), 执行程序代码</strong>。     </p></li><li><p><strong>阻塞(block)：</strong>阻塞状态是指线程因为某种原因<strong>放弃了 cpu 使用权</strong>，即让出了cpu 时间片(timeslice), <strong>暂时停止运行</strong>。直到线程进入可运行(runnable)状态，才有机会再次获得cpu 时间片(timeslice)转到运行(running)状态。阻塞的情况分三种：            </p><ul><li><p><strong>等待阻塞：</strong>运行(running)的线程执行o.wait()方法, JVM会把该线程放入等待队列( waitting queue )中。     </p></li><li><p><strong>同步阻塞：</strong> 运行(running)的线程在获取对象的同步锁时, 若该同步锁被别的线程占用，则       JVM会把该线程放入锁池(lock pool)中。     </p></li><li><p><strong>其他阻塞:</strong> 运行(running)的线程执行 Thread.sleep(longms)或t.join() 方法，或者发出了I/O       请求时，JVM会把该线程置为阻塞状态。当 sleep() 状态超时、join() 等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。     </p></li></ul></li><li><p><strong>死亡(dead)</strong>：线程run()、 main()方法执行结束，或者因异常退出了 run() 方法，则该线程结束生命周期。死亡的线程不可再次复生。</p></li></ol><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3633936.html" target="_blank" rel="noopener">java基础学习总结——线程(一)</a></p><p>​    <a href="https://www.cnblogs.com/lwbqqyumidi/p/3817517.html" target="_blank" rel="noopener">Java总结篇系列：Java多线程（二）</a></p><p>​    <a href="https://www.cnblogs.com/yjd_hycf_space/p/7526608.html" target="_blank" rel="noopener">Java多线程学习（总结很详细！！！）</a></p><p>​    <a href="http://how2j.cn/k/thread/thread-methods/354.html#nowhere" target="_blank" rel="noopener">how2j</a></p><p>​    <a href="https://www.nowcoder.com/questionTerminal/f665a4c853b841339e7181a0fdbacfa8" target="_blank" rel="noopener">牛客网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-线程的基本概念&quot;&gt;&lt;a href=&quot;#一-线程的基本概念&quot; class=&quot;headerlink&quot; title=&quot;一. 线程的基本概念&quot;&gt;&lt;/a&gt;一. 线程的基本概念&lt;/h1&gt;&lt;p&gt;线程是一个程序里面不同的执行路径&lt;/p&gt;
&lt;p&gt;每一个分支都叫做一个线程，main()叫做主分支，也叫主线程&lt;/p&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>sql语句</title>
    <link href="http://yoursite.com/2019/03/11/sql%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2019/03/11/sql语句/</id>
    <published>2019-03-11T08:00:00.000Z</published>
    <updated>2019-04-02T09:55:46.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-数据库"><a href="#一-数据库" class="headerlink" title="一. 数据库"></a>一. 数据库</h1><ol><li>创建数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">database</span> <span class="keyword">database</span>-<span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><ol start="2"><li>删除数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">database</span> <span class="keyword">database</span>-<span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>查看当前数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>选择(进入)数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">database</span>-<span class="keyword">name</span>；</span><br></pre></td></tr></table></figure><h1 id="二-表"><a href="#二-表" class="headerlink" title="二. 表"></a>二. 表</h1><ol><li>查看当前数据库所有的表(已经选定数据库)</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>-<span class="keyword">name</span>；</span><br></pre></td></tr></table></figure><ol start="2"><li>创建新表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CEEATE DATABASE database-name</span><br></pre></td></tr></table></figure><ol start="3"><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CEEATE DATABASE database-name</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CEEATE DATABASE database-name</span><br></pre></td></tr></table></figure><p><strong>参考博文:</strong> </p><p><a href="https://www.cnblogs.com/1234abcd/p/5530314.html" target="_blank" rel="noopener">经典SQL语句大全(绝对的经典)</a></p><p><a href="http://how2j.cn/k/tmall-j2ee/tmall-j2ee-943/943.html" target="_blank" rel="noopener">how2J</a></p><p><a href="https://blog.csdn.net/qq_34777600/article/details/81178891" target="_blank" rel="noopener">MySQL数据库–命令行操作</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-数据库&quot;&gt;&lt;a href=&quot;#一-数据库&quot; class=&quot;headerlink&quot; title=&quot;一. 数据库&quot;&gt;&lt;/a&gt;一. 数据库&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;创建数据库&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;database&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;database&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="sql语句" scheme="http://yoursite.com/tags/sql%E8%AF%AD%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---方法的重载和覆盖</title>
    <link href="http://yoursite.com/2019/03/11/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E8%A6%86%E7%9B%96/"/>
    <id>http://yoursite.com/2019/03/11/Java基础知识---方法的重载和覆盖/</id>
    <published>2019-03-11T05:38:55.000Z</published>
    <updated>2019-03-19T03:32:50.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-方法的重载-overload"><a href="#一-方法的重载-overload" class="headerlink" title="一. 方法的重载(overload)"></a>一. 方法的重载(overload)</h1><p>指一个类中可以定义有 <strong>相同的名字</strong> ,但 <strong>参数不同</strong> 的多个方法. 调用时, 会根据 <strong>不同的参数表</strong> 选择对应的方法</p><a id="more"></a><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><ul><li>构造方法</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>方法名一样, 但参数不一样,就是重载(overload)</li><li>参数不一样 (1.参数的个数不一样  2. 参数的类型不一样, 只要有一个就可以)</li><li>方法名一样，参数类型一样，只有返回值不一样，这个不构成重载</li></ol><p><strong>理解:</strong> 多重加载，不同样式的加载</p><h1 id="二-方法的覆盖-override"><a href="#二-方法的覆盖-override" class="headerlink" title="二. 方法的覆盖(override)"></a>二. 方法的覆盖(override)</h1><p>指覆盖了一个方法并且对其重写，以求达到不同的作用,也可以叫做 <strong>重写</strong> </p><h3 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h3><ul><li><p>对 <strong>接口方法</strong> 的实现</p></li><li><p>在 <strong>继承</strong> 中也可能会在 <strong>子类覆盖父类</strong> 中的方法</p></li></ul><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ol><li>覆盖的方法的标志必须要和被覆盖的方法的 <strong>标志</strong> (相同的名字和相同的参数)完全匹配，才能达到覆盖的效果；</li><li>覆盖的方法的返回值必须和被覆盖的方法的返回一致；</li><li>覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；</li><li>被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖</li></ol><p><strong>参考博文</strong></p><p><a href="https://www.cnblogs.com/fanvfan/p/7563307.html" target="_blank" rel="noopener">java中的方法覆盖（Overriding）和方法重载（Overloading）是什么意思？重写跟重载的区别？</a></p><p><a href="https://zhidao.baidu.com/question/1996221.html" target="_blank" rel="noopener">对比Java语言中的覆盖和重载</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-方法的重载-overload&quot;&gt;&lt;a href=&quot;#一-方法的重载-overload&quot; class=&quot;headerlink&quot; title=&quot;一. 方法的重载(overload)&quot;&gt;&lt;/a&gt;一. 方法的重载(overload)&lt;/h1&gt;&lt;p&gt;指一个类中可以定义有 &lt;strong&gt;相同的名字&lt;/strong&gt; ,但 &lt;strong&gt;参数不同&lt;/strong&gt; 的多个方法. 调用时, 会根据 &lt;strong&gt;不同的参数表&lt;/strong&gt; 选择对应的方法&lt;/p&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---修饰符</title>
    <link href="http://yoursite.com/2019/03/11/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <id>http://yoursite.com/2019/03/11/Java基础知识---访问修饰符/</id>
    <published>2019-03-11T05:38:55.000Z</published>
    <updated>2019-03-26T13:25:17.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-Java-修饰符"><a href="#一-Java-修饰符" class="headerlink" title="一. Java 修饰符"></a>一. Java 修饰符</h1><p>Java语言提供了很多修饰符，主要分为以下两类：</p><ul><li>访问修饰符</li><li>非访问修饰符</li></ul><a id="more"></a><p>修饰符用来定义类、方法或者变量，通常放在语句的最前端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> myFlag;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> weeks = <span class="number">9.5</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOXWIDTH = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arguments)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二-访问控制修饰符"><a href="#二-访问控制修饰符" class="headerlink" title="二. 访问控制修饰符"></a>二. 访问控制修饰符</h1><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p><ul><li><p><strong>default</strong> (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法</p><blockquote><p>即是“包访问权限”</p></blockquote></li><li><p><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></p><blockquote><p>表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可以使用</p></blockquote></li><li><p><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法</p><blockquote><p>表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用</p></blockquote></li><li><p><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></p><blockquote><p>protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private</p></blockquote></li></ul><h3 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h3><table><thead><tr><th style="text-align:center">作用域</th><th style="text-align:center">自身</th><th style="text-align:center">同包子类</th><th style="text-align:center">不同包子类</th><th style="text-align:center">同包类</th><th style="text-align:center">其他类</th><th style="text-align:center">总结(所属)</th></tr></thead><tbody><tr><td style="text-align:center">private</td><td style="text-align:center">访问(√)</td><td style="text-align:center">继承(×)</td><td style="text-align:center">继承(×)</td><td style="text-align:center">访问(×)</td><td style="text-align:center">访问(×)</td><td style="text-align:center">只有自己</td></tr><tr><td style="text-align:center">package</td><td style="text-align:center">访问(√)</td><td style="text-align:center">继承(√)</td><td style="text-align:center">继承(×)</td><td style="text-align:center">访问(√)</td><td style="text-align:center">访问(×)</td><td style="text-align:center">同包</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">访问(√)</td><td style="text-align:center">继承(√)</td><td style="text-align:center">继承(√)</td><td style="text-align:center">访问(√)</td><td style="text-align:center">访问(×)</td><td style="text-align:center">同包+子类</td></tr><tr><td style="text-align:center">public</td><td style="text-align:center">访问(√)</td><td style="text-align:center">继承(√)</td><td style="text-align:center">继承(√)</td><td style="text-align:center">访问(√)</td><td style="text-align:center">访问(√)</td><td style="text-align:center">所有</td></tr></tbody></table><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><ol><li><strong>属性</strong> 通常使用private封装起来</li><li><strong>方法</strong> 一般使用public用于被调用</li><li>会 <strong>被子类继承</strong> 的方法，通常使用protected</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>如果一个成员需要被外部包所访问，则必须使用public修饰符；</li><li>如果一个成员需要被定义在<strong>不同包下的子类</strong>所访问，则可以使用public或protected修饰符；</li><li><p>如果一个成员需要被<strong>本包下的其他类所访问</strong>，则可以不用写任何的修饰符，使用public或者protected也行</p></li><li><p>若一个成员想使用同类中其他成员，则使用任意一个修饰符即可；若一个成员不想被任何一个外部的类所访问，则使用private关键字比较恰当</p></li></ul><h1 id="三-非访问修饰符"><a href="#三-非访问修饰符" class="headerlink" title="三. 非访问修饰符"></a>三. 非访问修饰符</h1><p>为了实现一些其他的功能，Java 也提供了许多非访问修饰符。</p><ul><li><p><strong>static 修饰符</strong> : 用来修饰类方法和类变量。</p></li><li><p><strong>final 修饰符</strong> : 用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</p></li><li><p><strong>abstract 修饰符</strong>用来创建抽象类和抽象方法。</p></li><li><p><strong>synchronized 和 volatile 修饰符</strong> : 主要用于线程的编程</p></li></ul><p>详细的见其他文章</p><hr><h5 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h5><p>​    <a href="https://blog.csdn.net/k_young1997/article/details/81109965" target="_blank" rel="noopener">Java中private、public、default、protected的区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-Java-修饰符&quot;&gt;&lt;a href=&quot;#一-Java-修饰符&quot; class=&quot;headerlink&quot; title=&quot;一. Java 修饰符&quot;&gt;&lt;/a&gt;一. Java 修饰符&lt;/h1&gt;&lt;p&gt;Java语言提供了很多修饰符，主要分为以下两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;访问修饰符&lt;/li&gt;
&lt;li&gt;非访问修饰符&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>人间词话---ZJ</title>
    <link href="http://yoursite.com/2019/03/09/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---ZJ/"/>
    <id>http://yoursite.com/2019/03/09/人间词话---ZJ/</id>
    <published>2019-03-09T14:57:13.000Z</published>
    <updated>2019-03-15T09:15:02.200Z</updated>
    
    <content type="html"><![CDATA[<ul><li>没有人会拒绝微笑, 也没有人会拒绝真诚.</li><li>逢山开路, 遇水架桥.</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;没有人会拒绝微笑, 也没有人会拒绝真诚.&lt;/li&gt;
&lt;li&gt;逢山开路, 遇水架桥.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="人间词话" scheme="http://yoursite.com/categories/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
    
      <category term="人间词话" scheme="http://yoursite.com/tags/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>人间词话---送给自己</title>
    <link href="http://yoursite.com/2019/03/09/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E9%80%81%E7%BB%99%E8%87%AA%E5%B7%B1/"/>
    <id>http://yoursite.com/2019/03/09/人间词话---送给自己/</id>
    <published>2019-03-09T14:57:13.000Z</published>
    <updated>2019-03-15T09:14:53.161Z</updated>
    
    <content type="html"><![CDATA[<ul><li>勇者愤怒, 抽刃向更强者.怯者愤怒, 却抽刀向更弱者</li><li>扬在脸上的微笑, 长在心里的善良,融进血液的骨气, 刻在生命里的坚强.</li><li>礼仪最重要的是在昭告自我,真正的宣誓是对自己说的话.   —陈果</li><li>对一切人,一切西乡都保持一种开放二友善的胸襟和气度的时候,才真正成为名副其实的大学生.   —陈果</li></ul><a id="more"></a><ul><li>挫折能使强者更强,弱者更弱,强者在面对中锻炼了自己,弱者在逃避中越发脆弱</li><li>最善言谈者就是最善于倾听的人</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;勇者愤怒, 抽刃向更强者.怯者愤怒, 却抽刀向更弱者&lt;/li&gt;
&lt;li&gt;扬在脸上的微笑, 长在心里的善良,融进血液的骨气, 刻在生命里的坚强.&lt;/li&gt;
&lt;li&gt;礼仪最重要的是在昭告自我,真正的宣誓是对自己说的话.   —陈果&lt;/li&gt;
&lt;li&gt;对一切人,一切西乡都保持一种开放二友善的胸襟和气度的时候,才真正成为名副其实的大学生.   —陈果&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="人间词话" scheme="http://yoursite.com/categories/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
    
      <category term="人间词话" scheme="http://yoursite.com/tags/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
      <category term="送给自己" scheme="http://yoursite.com/tags/%E9%80%81%E7%BB%99%E8%87%AA%E5%B7%B1/"/>
    
  </entry>
  
  <entry>
    <title>人间词话---网易云评论</title>
    <link href="http://yoursite.com/2019/03/09/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%84%E8%AE%BA/"/>
    <id>http://yoursite.com/2019/03/09/人间词话---网易云评论/</id>
    <published>2019-03-09T14:57:13.000Z</published>
    <updated>2019-03-20T02:28:51.238Z</updated>
    
    <content type="html"><![CDATA[<h3 id="卿卿我我"><a href="#卿卿我我" class="headerlink" title="卿卿我我"></a>卿卿我我</h3><ul><li>写歌的人假正经, 听歌的人最无情.人要是桥请起来,听什么都像在唱自己.</li><li>校服是我和她唯一穿过的情侣装, 毕业照是我和她唯一的合影.</li><li>和暗恋的对人对视一眼或者说一句话，都能有一天的内心戏.</li></ul><a id="more"></a><h3 id="情怀"><a href="#情怀" class="headerlink" title="情怀"></a>情怀</h3><ul><li>愿走出半生, 归来仍是少年.</li><li>你小时候相当科学家，想当超人，想拯救世界，但后来你慢慢变了，变成那个只想给爸妈安稳的生活，给她一个美好的未来，给你们的孩子一个温馨的住所。。。你不再是超人，但你撑起了一个家</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;卿卿我我&quot;&gt;&lt;a href=&quot;#卿卿我我&quot; class=&quot;headerlink&quot; title=&quot;卿卿我我&quot;&gt;&lt;/a&gt;卿卿我我&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;写歌的人假正经, 听歌的人最无情.人要是桥请起来,听什么都像在唱自己.&lt;/li&gt;
&lt;li&gt;校服是我和她唯一穿过的情侣装, 毕业照是我和她唯一的合影.&lt;/li&gt;
&lt;li&gt;和暗恋的对人对视一眼或者说一句话，都能有一天的内心戏.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="人间词话" scheme="http://yoursite.com/categories/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
    
      <category term="人间词话" scheme="http://yoursite.com/tags/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---Filter(1)</title>
    <link href="http://yoursite.com/2019/03/08/JavaWeb---Filter(1)/"/>
    <id>http://yoursite.com/2019/03/08/JavaWeb---Filter(1)/</id>
    <published>2019-03-08T03:38:55.000Z</published>
    <updated>2019-03-21T14:38:28.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Filter简介"><a href="#一、Filter简介" class="headerlink" title="一、Filter简介"></a>一、Filter简介</h2><p>　　Filter也称之为<strong>过滤器</strong>，WEB开发人员通过Filter技术，对web服务器<strong>管理的所有web资源</strong>：例如Jsp,  Servlet, 静态图片文件或静态 html  文件等<strong>进行拦截</strong>，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。<br>　　Servlet  API中提供了一个<strong>Filter接口</strong>，开发web应用时，如果编写的Java类实现了这个接口，则<strong>把这个java类称之为过滤器Filter</strong>。通过Filter技术，开发人员可以实现用户在访问某个目标资源之前，对访问的请求和响应进行拦截.</p><a id="more"></a><h2 id="二、Filter是如何实现拦截的？"><a href="#二、Filter是如何实现拦截的？" class="headerlink" title="二、Filter是如何实现拦截的？"></a>二、Filter是如何实现拦截的？</h2><p>　　Filter接口中有一个doFilter方法，当我们编写好Filter，并配置对哪个web资源进行拦截后，WEB服务器每次<strong>在调用web资源的service方法之前，都会先调用一下filter的doFilter方法</strong>，因此，在该方法内编写代码可达到如下目的：</p><ol><li>调用目标资源之前，让一段代码执行。</li><li>是否调用目标资源（即是否让用户访问web资源）。</li><li>调用目标资源之后，让一段代码执行。</li></ol><p>　　web服务器在调用doFilter方法时，会<strong>传递一个filterChain对象</strong>进来，<strong>filterChain对象是filter接口中最重要的一个对象</strong>，它也提供了一个doFilter方法，开发人员可以根据需求决定是否调用此方法，<strong>调用该方法，则web服务器就会调用web资源的service方法，即web资源就会被访问(根据所要访问的网址去寻找资源)</strong>，否则web资源不会被访问(可能会跳转到其他的界面,然后return返回)。</p><h2 id="三、Filter开发入门"><a href="#三、Filter开发入门" class="headerlink" title="三、Filter开发入门"></a>三、Filter开发入门</h2><h3 id="3-1、Filter开发步骤"><a href="#3-1、Filter开发步骤" class="headerlink" title="3.1、Filter开发步骤"></a>3.1、Filter开发步骤</h3><p>Filter开发分为二个步骤：</p><ol><li>编写java类实现Filter接口，并实现其doFilter方法。</li><li>在 web.xml 文件中使用<code>&lt;filter&gt;</code>和<code>&lt;filter-mapping&gt;</code>元素对编写的filter类进行 <strong>注册和映射</strong>，并设置它所能拦截的资源。</li></ol><h5 id="过滤器范例"><a href="#过滤器范例" class="headerlink" title="过滤器范例"></a>过滤器范例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>:filter的三种典型应用：</span></span><br><span class="line"><span class="comment">* 1.可以在filter中根据条件决定是否调用chain.doFilter(request, response)方法，即是否让目标资源执行</span></span><br><span class="line"><span class="comment">* 2.在让目标资源执行之前，可以对request\response作预处理，再让目标资源执行</span></span><br><span class="line"><span class="comment">* 3.在目标资源执行之后，可以捕获目标资源的执行结果，从而实现一些特殊的功能</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterDemo01</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----过滤器初始化----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">            FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对request和response进行一些预处理</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"FilterDemo01执行前！！！"</span>);</span><br><span class="line">        chain.doFilter(request, response);  <span class="comment">//让目标资源执行，放行</span></span><br><span class="line">        System.out.println(<span class="string">"FilterDemo01执行后！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----过滤器销毁----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在web-xml中配置过滤器-详细内容见五"><a href="#在web-xml中配置过滤器-详细内容见五" class="headerlink" title="在web. xml中配置过滤器(详细内容见五)"></a>在web. xml中配置过滤器(详细内容见五)</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置过滤器--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注册过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterDemo01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>me.gacl.web.filter.FilterDemo01<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--映射过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterDemo01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--“/*”表示拦截所有的请求 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="四-Filter的生命周期"><a href="#四-Filter的生命周期" class="headerlink" title="四. Filter的生命周期"></a>四. Filter的生命周期</h1><h3 id="4-1、Filter的创建"><a href="#4-1、Filter的创建" class="headerlink" title="4.1、Filter的创建"></a>4.1、Filter的创建</h3><p>　　Filter的创建和销毁由<strong>WEB服务器负责</strong>。 web 应用程序<strong>启动时</strong>，web 服务器将<strong>创建Filter 的实例对象</strong>，并调用其 <strong>init 方法</strong> ，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作，<strong>filter对象只会创建一次，init方法也只会执行一次</strong>。通过 init 方法的参数，可获得<strong>代表当前filter配置信息的FilterConfig对象</strong>。</p><h3 id="4-2、Filter的销毁"><a href="#4-2、Filter的销毁" class="headerlink" title="4.2、Filter的销毁"></a>4.2、Filter的销毁</h3><p>　　Web容器调用<strong>destroy方法销毁Filter</strong>。destroy方法在Filter的生命周期中<strong>仅执行一次</strong>。在destroy方法中，可以释放过滤器使用的资源。</p><h3 id="4-3、FilterConfig接口"><a href="#4-3、FilterConfig接口" class="headerlink" title="4.3、FilterConfig接口"></a>4.3、FilterConfig接口</h3><p>　　用户在配置filter时，可以使用 <code>&lt;init-param&gt;</code> 为filter配置一些初始化参数，当web容器实例化Filter对象，调用其 <strong>init 方法时</strong> ，会把<strong>封装了filter初始化参数的filterConfig对象</strong>传递进来。因此开发人员在编写filter时，通过filterConfig对象的方法，就可获得：</p><ul><li><p>String getFilterName()：得到filter的名称。</p></li><li><p>String getInitParameter(String name)： 返回在部署描述中指定名称的初始化参数的值。如果不存在返回null.</p></li><li><p>Enumeration getInitParameterNames()：返回过滤器的所有初始化参数的名字的枚举集合。</p></li><li><p>public ServletContext getServletContext()：返回Servlet上下文对象的引用。</p></li></ul><h1 id="五、Filter的部署"><a href="#五、Filter的部署" class="headerlink" title="五、Filter的部署"></a>五、Filter的部署</h1><p>  　　Filter的部署分为两个步骤：</p><ol><li>注册Filter</li><li><p>映射Filter</p><h3 id="5-1-注册Filter"><a href="#5-1-注册Filter" class="headerlink" title="5.1 注册Filter"></a>5.1 注册Filter</h3><p>　　开发好Filter之后，需要在web.xml文件中进行注册，这样才能够被web服务器调用</p><p>在web.xml文件中注册Filter范例：</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;description&gt;用于添加描述信息，该元素的内容可为空，&lt;description&gt;可以不配置。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>FilterDemo02过滤器<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!--&lt;filter-name&gt;用于为过滤器指定一个名字，该元素的内容不能为空--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterDemo02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--&lt;filter-class&gt;元素用于指定过滤器的完整的限定类名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>me.gacl.web.filter.FilterDemo02<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--配置FilterDemo02过滤器的初始化参数--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;init-param&gt;元素用于为过滤器指定初始化参数，它的子元素&lt;param-name&gt;指定参数的名字，&lt;param-value&gt;指定参数的值。在过滤器中，可以使用FilterConfig接口对象来访问初始化参数。如果过滤器不需要指定初始化参数，那么&lt;init-param&gt;元素可以不配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>配置FilterDemo02过滤器的初始化参数<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>name<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>gacl<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-2-映射Filter"><a href="#5-2-映射Filter" class="headerlink" title="5.2 映射Filter"></a>5.2 映射Filter</h3><p>　　在web.xml文件中注册了Filter之后，还要在web.xml文件中映射Filter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--映射过滤器--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--&lt;filter-mapping&gt;元素用于设置一个 Filter 所负责拦截的资源。一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--&lt;filter-name&gt;子元素用于设置filter的注册名称。该值必须是在&lt;filter&gt;元素中声明过的过滤器的名字--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--&lt;url-pattern&gt;设置 filter 所拦截的请求路径(过滤器关联的URL样式)--&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--“/*”表示拦截所有的请求 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;dispatcher&gt;指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是REQUEST,INCLUDE,FORWARD和ERROR之一，默认REQUEST。用户可以设置多个&lt;dispatcher&gt; 子元素用来指定 Filter 对资源的多种调用方式进行拦截。--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>FORWARD<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;dispatcher&gt;</code> 子元素可以设置的值及其意义：</p><ol><li>REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。</li><li>INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。</li><li>FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。</li><li>ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。</li></ol><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3948353.html" target="_blank" rel="noopener">javaweb学习总结(四十二)——Filter(过滤器)学习</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Filter简介&quot;&gt;&lt;a href=&quot;#一、Filter简介&quot; class=&quot;headerlink&quot; title=&quot;一、Filter简介&quot;&gt;&lt;/a&gt;一、Filter简介&lt;/h2&gt;&lt;p&gt;　　Filter也称之为&lt;strong&gt;过滤器&lt;/strong&gt;，WEB开发人员通过Filter技术，对web服务器&lt;strong&gt;管理的所有web资源&lt;/strong&gt;：例如Jsp,  Servlet, 静态图片文件或静态 html  文件等&lt;strong&gt;进行拦截&lt;/strong&gt;，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。&lt;br&gt;　　Servlet  API中提供了一个&lt;strong&gt;Filter接口&lt;/strong&gt;，开发web应用时，如果编写的Java类实现了这个接口，则&lt;strong&gt;把这个java类称之为过滤器Filter&lt;/strong&gt;。通过Filter技术，开发人员可以实现用户在访问某个目标资源之前，对访问的请求和响应进行拦截.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---面向对象(2)</title>
    <link href="http://yoursite.com/2019/03/08/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(2)/"/>
    <id>http://yoursite.com/2019/03/08/Java基础知识---面向对象(2)/</id>
    <published>2019-03-08T03:38:55.000Z</published>
    <updated>2019-03-25T06:00:29.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-Java类的定义"><a href="#一-Java类的定义" class="headerlink" title="一. Java类的定义"></a>一. Java类的定义</h1><h2 id="1-1-关键字"><a href="#1-1-关键字" class="headerlink" title="1.1 关键字"></a>1.1 关键字</h2><p>​    使用 <strong>class</strong> 关键字定义一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 成员变量(属性)定义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//方法定义</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        age = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="二-成员变量"><a href="#二-成员变量" class="headerlink" title="二. 成员变量"></a>二. 成员变量</h1><h2 id="2-1-注意"><a href="#2-1-注意" class="headerlink" title="2.1 注意"></a>2.1 注意</h2><ul><li>成员变量的作用范围为 <strong>整个类体</strong></li><li><p>定义成员变量可以对其初始化, 如果 <strong>不对其初始化</strong> , Java <strong>使用默认的值</strong> 对其初始化(若不记得Java对成员变量默认的初始化是多少的话，定义一个成员变量，不给它初始化，然后直接打印这个成员变量,进行查看)</p></li><li><p>在 <strong>Java</strong> 里面的任何变量首先应该要声明，然后再赋值，然后再使用</p></li></ul><h2 id="2-2-成员变量和局部变量的区别"><a href="#2-2-成员变量和局部变量的区别" class="headerlink" title="2.2 成员变量和局部变量的区别:"></a>2.2 <strong>成员变量和局部变量的区别:</strong></h2><table><thead><tr><th style="text-align:center"></th><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td style="text-align:center">不进行初始化</td><td>默认给初始化</td><td>不默认给初始化, <strong>在方法里面声明一个局部变量如果不给它初始化时就会出错</strong></td></tr></tbody></table><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestChushihua</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> aa;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> bb;</span><br><span class="line"><span class="comment">// aa 必须是 static, 因为要不然需要 new 对象</span></span><br><span class="line">System.out.println(aa);</span><br><span class="line"><span class="comment">// 报错,要求要赋值</span></span><br><span class="line"><span class="comment">// System.out.println(bb);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果: aa的值为:0</span></span><br></pre></td></tr></table></figure><h1 id="三-基本概念-—-引用"><a href="#三-基本概念-—-引用" class="headerlink" title="三. 基本概念 — 引用"></a>三. 基本概念 — 引用</h1><p>​    Java语言中 <strong>除基本类型之外</strong> 的变量类型都称之为引用类型, Java中的对象是通过引用对其操作的</p><h2 id="3-1-基本类型与引用类型的区别"><a href="#3-1-基本类型与引用类型的区别" class="headerlink" title="3.1 基本类型与引用类型的区别"></a>3.1 基本类型与引用类型的区别</h2><table><thead><tr><th></th><th>基本类型</th><th>引用类型</th></tr></thead><tbody><tr><td>实现</td><td>当声明一个int  i=0时，系统会马上给这个i分配一个内存空间（在 <strong>栈内存</strong> 里面分配一小块区域用来装数字0），里面装着一个值为0，以后使用i这个名字马上就可以访问这个内存空间里面的值</td><td>定义好这个类之后，需要使用new关键字把这个类的对象实例化出来，也就是真真正正造出一个对象出来才能使用这个对象</td></tr><tr><td>内存</td><td>占 <strong>一块</strong> 内存</td><td>占 <strong>两块</strong> 内存</td></tr><tr><td>存放位置</td><td>栈内存</td><td>栈内存: 引用对象   堆内存: 真正的内容(new出来的东西)</td></tr></tbody></table><blockquote><p>不论是基本数据类型还是引用类型，<strong>都会先在栈中分配一块内存</strong> ，对于基本类型来说，这块区域包含的是 <strong>基本类型的内容</strong>；而对于引用类型来说，这块区域包含的是 <strong>指向真正内容的指针(存放真正内容的地址)</strong> ，真正的内容被手动的分配在堆上。</p></blockquote><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">float</span> hp;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代表创建了一个Hero对象</span></span><br><span class="line"><span class="comment">//但是也仅仅是创建了一个对象，没有办法访问它</span></span><br><span class="line"><span class="comment">//为了访问这个对象，会使用引用来代表这个对象</span></span><br><span class="line">        <span class="keyword">new</span> Hero();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//"h"这个变量是Hero类型，叫做引用(也叫 引用对象,对象的引用)</span></span><br><span class="line"><span class="comment">//"="的意思指的h这个引用代表右侧创建的对象</span></span><br><span class="line"><span class="comment">//“代表” 在面向对象里，又叫做“指向” </span></span><br><span class="line">        <span class="comment">//引用h指向了新建的Hero对象</span></span><br><span class="line">        Hero h = <span class="keyword">new</span> Hero();  </span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-多个引用，一个对象，一个引用，多个对象区别"><a href="#3-2-多个引用，一个对象，一个引用，多个对象区别" class="headerlink" title="3.2 多个引用，一个对象，一个引用，多个对象区别"></a>3.2 多个引用，一个对象，一个引用，多个对象区别</h2><p>答:</p><ul><li>多个引用指向一个对象，操作的都是同一个对象</li><li>一个引用多个对象，之前的对象就没有办法访问了, 这个引用就指向了另一个对象</li></ul><h1 id="四-类和对象的关系"><a href="#四-类和对象的关系" class="headerlink" title="四. 类和对象的关系"></a>四. 类和对象的关系</h1><h2 id="4-1-如何在内存中区分类和对象"><a href="#4-1-如何在内存中区分类和对象" class="headerlink" title="4,1 如何在内存中区分类和对象"></a>4,1 如何在内存中区分类和对象</h2><ul><li><p>类是 <strong>静态</strong> 的概念, 在<strong>代码区</strong> </p></li><li><p>对象是new出来的, 位于 <strong>堆内存</strong> , <strong>类的每个成员变量在不同的对象中都有不同的值</strong> (除了静态变量,static),<strong>而方法只有一分,执行的时候才占用内存</strong> .</p></li></ul><p><img src="/2019/03/08/Java基础知识---面向对象(2)/blog\source\images\Java基础知识\Java面向对象__引用.png" alt="Java面向对象__引用"></p><h1 id="五-构造方法-函数"><a href="#五-构造方法-函数" class="headerlink" title="五. 构造方法(函数)"></a>五. 构造方法(函数)</h1><blockquote><p><strong>主要作用</strong> :完成对象的初始化工作，(如果写的类里面没有构造函数,那么编译器会默认加上一个无参数且方法体为空的构造函数)</p></blockquote><h2 id="5-1-特点"><a href="#5-1-特点" class="headerlink" title="5.1 特点"></a>5.1 特点</h2><ul><li>使用 new + 构造方法创建一个新的对象</li><li>构造函数是定义在 Java类中的一个用来 <strong>初始化对象</strong> 的函数,(new一个东西的时候，实际上你调用的是一个构造方法，构造方法就是把自己构造成一个新的对象，所以叫构造方法，构造一个新对象用的方法叫构造方法)</li><li>构造函数与类同名, 且没有返回值(构造方法的名字必须和类的名字完全一模一样，包括大小写,这个方法的名字和类名完全相同，并且没有返回值，也就是在这个方法前面不能写任何的方法的返回类型修饰符，连void都不可以写)</li></ul><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;  <span class="comment">//在person这类里面定义两个成员变量id和age,</span></span><br><span class="line">    <span class="keyword">int</span> age=<span class="number">20</span>;  <span class="comment">//给成员变量age赋了初值为20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**这里就是person这个类的一个构造方法</span></span><br><span class="line"><span class="comment">     * 构造方法的规则很简单，和类名要完全一样，一点都不能错，包括大小写。</span></span><br><span class="line"><span class="comment">     * 并且没有返回值，不能写void在它前面修饰</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> _id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> _age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> _id,<span class="keyword">int</span> _age )</span> </span>&#123;</span><br><span class="line">        id = _id;</span><br><span class="line">        age = _age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内存分析见 孤傲苍狼博客</span></span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><blockquote><p>如果类已经有了一个有参数有方法体的构造函数,这时编译器就不会再给它默认加上一个无参且方法体为空的构造函数.可以理解为无参的构造函数被覆盖了.这种情况称为没有默认构造函数</p></blockquote><p>### </p><h2 id="补"><a href="#补" class="headerlink" title="补:"></a>补:</h2><h4 id="数据区、代码区、栈区、堆区-区别"><a href="#数据区、代码区、栈区、堆区-区别" class="headerlink" title="数据区、代码区、栈区、堆区 区别:"></a>数据区、代码区、栈区、堆区 区别:</h4><ol><li><p>栈区(stack)：由系统的编译器自动的释放， <strong>主要用来存放方法中的参数，一些临时的局部变量等</strong> ，并且方法中的参数一般在操作完后，会由编译器自动的释放掉。</p></li><li><p>堆区(heap):由程序员决定，在Java中，如果程序员不释放的话，一般会由垃圾回收机制自动的清理掉。此区域主要用来 <strong>存放我们经常创建的对象、动态的申请的临时空间等</strong> 。</p></li><li><p>数据区(data seg):也称全局区或者静态区，根据名称我们就应该知道用来存放一些全局的东西，比如我们经常用到的 <strong>静态变量、全局变量等</strong> 都会存放到数据区，此区域上的东西都被全局所共享。比如我们可以采取类名.的方式就可以访问到方法，这就是所谓的静态方法，存放到数据区的。</p></li><li><p>代码区：存放 <strong>程序编译后可以执行代码的地方</strong> 。比如执行代码时写的While语句、if条件语句等，都会存放到此</p></li></ol><blockquote><p>理解了内存，就理解了一切，就理解了各种各样的语言。所有的语言无非都是这样：局部变量分配内存永远在栈里面，new出来的东西分配内存永远是在堆里，静态的东西分配内存永远是在数据区。剩下的代码肯定是在代码区</p></blockquote><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文:"></a>参考博文:</h5><p>how2J <a href="http://how2j.cn/k/class-object/class-object-reference/307.html" target="_blank" rel="noopener">类和对象</a></p><p>孤傲苍狼 <a href="https://www.cnblogs.com/xdp-gacl/p/3628880.html" target="_blank" rel="noopener">Java基础学习总结——面向对象2</a></p><p><a href="https://blog.csdn.net/weixin_43896747/article/details/85105144" target="_blank" rel="noopener">Java基本数据类型与引用数据类型 及在堆栈中内存的存储原理</a></p><p><a href="https://blog.csdn.net/luckyzhoustar/article/details/42386629" target="_blank" rel="noopener">数据区、代码区、栈区、堆区</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-Java类的定义&quot;&gt;&lt;a href=&quot;#一-Java类的定义&quot; class=&quot;headerlink&quot; title=&quot;一. Java类的定义&quot;&gt;&lt;/a&gt;一. Java类的定义&lt;/h1&gt;&lt;h2 id=&quot;1-1-关键字&quot;&gt;&lt;a href=&quot;#1-1-关键字&quot; class=&quot;headerlink&quot; title=&quot;1.1 关键字&quot;&gt;&lt;/a&gt;1.1 关键字&lt;/h2&gt;&lt;p&gt;​    使用 &lt;strong&gt;class&lt;/strong&gt; 关键字定义一个类&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 成员变量(属性)定义&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; age = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//方法定义&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getAge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; age; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setAge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        age = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---HttpResponse对象</title>
    <link href="http://yoursite.com/2019/03/08/JavaWeb---HttpServletResponse%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/03/08/JavaWeb---HttpServletResponse对象/</id>
    <published>2019-03-08T03:29:27.000Z</published>
    <updated>2019-03-28T02:38:11.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-HttpServletResponse-对象介绍"><a href="#一-HttpServletResponse-对象介绍" class="headerlink" title="一. HttpServletResponse 对象介绍"></a>一. HttpServletResponse 对象介绍</h1><p>​    <strong>HttpServletResponse对象</strong> 代表<strong>服务器的响应</strong>。这个对象中封装了<strong>向客户端发送数据、发送响应头，发送响应状态码的方法</strong>。查看 HttpServletResponse 的API，可以看到这些相关的方法。<br><a id="more"></a></p><h2 id="1-1-响应状态码的常量"><a href="#1-1-响应状态码的常量" class="headerlink" title="1.1 响应状态码的常量"></a>1.1 响应状态码的常量</h2><p>　　HttpServletResponse 定义了很多状态码的常量(具体可以查看Servlet的API)，当需要<strong>向客户端发送响应状态码时，可以使用这些常量，避免了直接写数字</strong>，常见的状态码对应的常量：</p><ul><li>状态码404对应的常量</li><li>状态码200对应的常量</li><li>状态码500对应的常量</li></ul><h1 id="二-HttpServletResponse常见应用——设置响应头控制浏览器的行为"><a href="#二-HttpServletResponse常见应用——设置响应头控制浏览器的行为" class="headerlink" title="二. HttpServletResponse常见应用——设置响应头控制浏览器的行为"></a>二. HttpServletResponse常见应用——设置响应头控制浏览器的行为</h1><h3 id="通过response实现请求重定向"><a href="#通过response实现请求重定向" class="headerlink" title="通过response实现请求重定向"></a>通过response实现请求重定向</h3><p>　　<strong>请求重定向指：</strong>一个web资源收到客户端请求后，通知<strong>客户端</strong>去访问<strong>另外一个web资源</strong>，这称之为请求重定向。</p><p>　　<strong>应用场景：</strong>用户登陆，用户首先访问登录页面，登录成功后，就会跳转到某个页面，这个过程就是一个请求重定向的过程</p><p>　　<strong>实现方式：</strong> <strong>==response.sendRedirect(String location)==</strong>，即调用response对象的<strong>sendRedirect</strong>方法实现请求重定向<br>　　sendRedirect内部的实现原理：使用response设置 <strong>302状态码和设置location响应头实现重定向</strong></p><h5 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseDemo04</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法: doGet</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. 调用sendRedirect方法实现请求重定向, sendRedirect方法内部调用了</span></span><br><span class="line"><span class="comment">* ① response.setHeader("Location",</span></span><br><span class="line"><span class="comment">* "/JavaWeb_HttpServletResponse_Study_20140615/index.jsp");</span></span><br><span class="line"><span class="comment">* ② response.setStatus(HttpServletResponse.SC_FOUND);//设置302状态码，等同于response.setStatus(302);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">      response.sendRedirect(<span class="string">"/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 2.使用response设置302状态码和设置location响应头实现重定向实现请求重定向</span></span><br><span class="line"><span class="comment">* response.setHeader("Location", "/JavaWeb_HttpServletResponse_Study_20140615/index.jsp");</span></span><br><span class="line"><span class="comment">* response.setStatus(HttpServletResponse.SC_FOUND);</span></span><br><span class="line"><span class="comment">* 设置302状态码，等同于response.setStatus(302);</span></span><br><span class="line"><span class="comment">*/</span>      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法: doPost</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-代表-webapps目录-的常见应用场景"><a href="#3-2-代表-webapps目录-的常见应用场景" class="headerlink" title="3.2 /代表 webapps目录 的常见应用场景"></a>3.2 <code>/</code>代表 webapps目录 的常见应用场景</h2><h3 id="使用sendRedirect实现请求重定向"><a href="#使用sendRedirect实现请求重定向" class="headerlink" title="使用sendRedirect实现请求重定向"></a>使用sendRedirect实现请求重定向</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">"/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"</span>);</span><br></pre></td></tr></table></figure><p>　　服务器发送一个URL地址给浏览器，浏览器拿到URL地址之后，再去请求服务器，所以<strong>这个”/“是给浏览器使用的</strong>，此时 <code>/</code>代表的就是<strong>webapps目录</strong></p><p>​    <code>/JavaWeb_HttpServletResponse_Study_20140615/index.jsp</code>这个地址指的就是 <code>webapps\JavaWeb_HttpServletResponse_Study_20140615\index.jsp</code></p><p>　　<strong>response.sendRedirect(“/项目名称/文件夹目录/页面”);</strong>这种写法是将项目名称 <strong>写死在程序中</strong> 的做法，<strong>不灵活</strong>，万一哪天项目名称变了，此时就得改程序，所以<strong>推荐使用下面的灵活写法</strong>：</p><p>将</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">"/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"</span>);</span><br></pre></td></tr></table></figure><p><strong>这种写法改成</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(request.getContextPath()+<span class="string">"/index.jsp"</span>);</span><br></pre></td></tr></table></figure><p><code>request.getContextPath()</code> 获取到的内容就是 <code>/JavaWeb_HttpServletResponse_Study_20140615</code>，这样就比较灵活了，<strong>使用request.getContextPath()代替”/项目名称”，推荐使用这种方式，灵活方便！</strong></p><h3 id="使用超链接跳转"><a href="#使用超链接跳转" class="headerlink" title="使用超链接跳转"></a>使用超链接跳转</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"&gt;跳转到首页&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>　　这是<strong>客户端浏览器</strong>使用的超链接跳转，这个 <code>/</code> 是给<strong>浏览器使用的</strong> ，此时 <code>/</code> 代表的就是<strong>webapps目录</strong>。</p><p>使用超链接访问web资源，<strong>绝对路径的写法推荐使用下面的写法改进</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="$&#123;pageContext.request.contextPath&#125;/index.jsp"&gt;跳转到首页&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>　　这样就可以避免在路径中出现项目的名称，使用 <strong>${pageContext.request.contextPath}</strong> 取代 <code>/JavaWeb_HttpServletResponse_Study_20140615</code></p><h3 id="Form表单提交"><a href="#Form表单提交" class="headerlink" title="Form表单提交"></a>Form表单提交</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"/JavaWeb_HttpServletResponse_Study_20140615/servlet/CheckServlet"</span> method=<span class="string">"post"</span>&gt;    </span><br><span class="line">&lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>　　这是<strong>客户端浏览器将form表单提交到服务器</strong>，所以这个 <code>/</code> 是给<strong>浏览器使用的</strong>，此时 <code>/</code> 代表的就是webapps目录。</p><p> 对于form表单提交中action属性绝对路径的写法，也推荐使用如下的方式改进：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/servlet/CheckServlet"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p><code>${pageContext.request.contextPath}</code> 得到的就是 <code>/JavaWeb_HttpServletResponse_Study_20140615</code></p><p><code>${pageContext.request.contextPath}</code>的效果等同于<code>request.getContextPath()</code>，两者获取到的都是<strong>“/项目名称”</strong></p><h3 id="js脚本和css样式文件的引用"><a href="#js脚本和css样式文件的引用" class="headerlink" title="js脚本和css样式文件的引用"></a>js脚本和css样式文件的引用</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--使用绝对路径的方式引用js脚本--%&gt;</span><br><span class="line"> &lt;script type="text/javascript" src="$&#123;pageContext.request.contextPath&#125;/js/index.js"&gt;&lt;/script&gt;</span><br><span class="line"> &lt;%--$&#123;pageContext.request.contextPath&#125;与request.getContextPath()写法是得到的效果是一样的--%&gt;</span><br><span class="line"> &lt;script type="text/javascript" src="&lt;%=request.getContextPath()%&gt;/js/login.js"&gt;&lt;/script&gt;</span><br><span class="line"> &lt;%--使用绝对路径的方式引用css样式--%&gt;</span><br><span class="line"> &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"$&#123;pageContext.request.contextPath&#125;/css/index.css"</span> type=<span class="string">"text/css"</span>/&gt;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    <strong>==只要是浏览器向服务器提交的, <code>/</code> 给浏览器使用, 都可以修改成推荐的方式==</strong></p><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3791993.html" target="_blank" rel="noopener">javaweb学习总结(八)——HttpServletResponse对象(二)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-HttpServletResponse-对象介绍&quot;&gt;&lt;a href=&quot;#一-HttpServletResponse-对象介绍&quot; class=&quot;headerlink&quot; title=&quot;一. HttpServletResponse 对象介绍&quot;&gt;&lt;/a&gt;一. HttpServletResponse 对象介绍&lt;/h1&gt;&lt;p&gt;​    &lt;strong&gt;HttpServletResponse对象&lt;/strong&gt; 代表&lt;strong&gt;服务器的响应&lt;/strong&gt;。这个对象中封装了&lt;strong&gt;向客户端发送数据、发送响应头，发送响应状态码的方法&lt;/strong&gt;。查看 HttpServletResponse 的API，可以看到这些相关的方法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---static关键字</title>
    <link href="http://yoursite.com/2019/03/08/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/03/08/Java基础知识---static关键字/</id>
    <published>2019-03-08T03:29:27.000Z</published>
    <updated>2019-03-19T03:32:44.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Static-关键字"><a href="#Static-关键字" class="headerlink" title="Static 关键字"></a>Static 关键字</h1><blockquote><p>static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途</p></blockquote><p><strong>基本作用:</strong> 方便在 <strong>没有创建对象</strong> 的情况下来进行调用(方法/变量),被static修饰的变量和方法其<strong>随着类的加载而被加载</strong> . 只要类被加载了，就可以通过类名去进行访问.</p><a id="more"></a><h1 id="1-静态变量"><a href="#1-静态变量" class="headerlink" title="1. 静态变量"></a>1. 静态变量</h1><ul><li><p>在类中用static声明的成员变量为 <strong>静态成员变量</strong> (也叫<strong>类变量</strong>),</p></li><li><p>其为该类的公共变量,  在第一次使用时被初始化, 这个成员变量 <strong>只有一份</strong> ，而且这一份是这个类 <strong>所有的对象</strong> 共享, 属于整个类的，它不属于专门的某个对象</p><blockquote><p>非静态成员专属于某一个对象，想访问非静态成员必须new一个对象出来才能访问</p></blockquote></li><li><p>static成员变量的初始化顺序按照定义的顺序进行初始化</p></li></ul><h5 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h5><ul><li>注意不能把 <strong>任何方法体内的变量声明为静态</strong> </li></ul><h1 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2. 静态方法"></a>2. 静态方法</h1><ul><li><p>用<strong>static</strong> 声明的方法为静态方法(也叫<strong>类方法</strong>)</p></li><li><p>在静态方法里只能直接调用同类中其他的静态成员（包括变量和方法），而<strong>不能直接访问类中的非静态成员</strong> 。这是因为，对于非静态的方法和变量，需要先创建类的实例对象后才可使用，而静态方法在使用前不用创建任何对象。</p><blockquote><p>对于非静态成员方法，它访问静态成员方法/变量显然是毫无限制的</p></blockquote></li><li><p>静态方法不能以任何方式引用this和super关键字</p><ul><li>因为静态方法在使用前不用创建任何实例对象，当静态方法调用时，this所引用的对象根本没有产生。</li><li>由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了</li></ul></li></ul><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><p>​    想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。</p><p>​    最常见的static方法就是main方法。因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。</p><h1 id="3-静态代码块"><a href="#3-静态代码块" class="headerlink" title="3. 静态代码块"></a>3. 静态代码块</h1><blockquote><p>用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p></blockquote><h5 id="为什么说static块可以用来优化程序性能"><a href="#为什么说static块可以用来优化程序性能" class="headerlink" title="为什么说static块可以用来优化程序性能"></a>为什么说static块可以用来优化程序性能</h5><p>​    是因为它的特性:只会在类加载的时候执行一次。</p><h2 id="初始化的顺序"><a href="#初始化的顺序" class="headerlink" title="初始化的顺序"></a>初始化的顺序</h2><p> 对象属性的初始化有三种方式</p><ul><li>声明时初始化</li><li>静态代码块初始化</li><li>构造函数初始化</li></ul><p>故意<strong>把初始化块，放在构造方法下面</strong>，</p><p><strong>问题：</strong>这三种方式，谁先执行？谁后执行？  </p><h5 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticOrder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明时初始化</span></span><br><span class="line"><span class="keyword">public</span> String name = StaticOrder.getName(<span class="string">"属性声明"</span>);</span><br><span class="line"><span class="comment">// 构造函数初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StaticOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">name = StaticOrder.getName(<span class="string">"构造方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 静态代码块初始化</span></span><br><span class="line">&#123;</span><br><span class="line">name = StaticOrder.getName(<span class="string">"初始化块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 被调用的 getName() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"初始化:  "</span> + name);</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> StaticOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果:</span></span><br><span class="line"><span class="comment">//初始化:  属性声明</span></span><br><span class="line"><span class="comment">//初始化:  初始化块</span></span><br><span class="line"><span class="comment">// 初始化:  构造方法</span></span><br></pre></td></tr></table></figure><h4 id="所以顺序为"><a href="#所以顺序为" class="headerlink" title="所以顺序为:"></a>所以顺序为:</h4><ol><li>声明时初始化</li><li>静态代码块初始化</li><li>构造函数初始化</li></ol><h3 id="杂"><a href="#杂" class="headerlink" title="杂:"></a>杂:</h3><p>​    static可以修饰内部类，但是不能修饰普通类。静态内部类的话可以直接调用静态构造器（不用对象）。</p><p>参考博文:<br>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3637407.html" target="_blank" rel="noopener">java基础学习总结——static关键字</a></p><p>​    <a href="https://www.nowcoder.com/questionTerminal/6f66f55a1f844e21b580e73d36223cf7" target="_blank" rel="noopener">优质答案</a></p><p>​    <a href="https://www.cnblogs.com/tiantianxiangshangg/articles/5080112.html" target="_blank" rel="noopener">java中静态代码块的用法 static用法详解</a></p><p>​    <a href="https://www.cnblogs.com/dolphin0520/p/3799052.html" target="_blank" rel="noopener">Java中的static关键字解析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Static-关键字&quot;&gt;&lt;a href=&quot;#Static-关键字&quot; class=&quot;headerlink&quot; title=&quot;Static 关键字&quot;&gt;&lt;/a&gt;Static 关键字&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;基本作用:&lt;/strong&gt; 方便在 &lt;strong&gt;没有创建对象&lt;/strong&gt; 的情况下来进行调用(方法/变量),被static修饰的变量和方法其&lt;strong&gt;随着类的加载而被加载&lt;/strong&gt; . 只要类被加载了，就可以通过类名去进行访问.&lt;/p&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---HttpServletRequest对象</title>
    <link href="http://yoursite.com/2019/03/08/JavaWeb---HttpServletRequest%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/03/08/JavaWeb---HttpServletRequest对象/</id>
    <published>2019-03-08T03:29:27.000Z</published>
    <updated>2019-04-04T08:08:09.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-HttpServletRequest介绍"><a href="#一-HttpServletRequest介绍" class="headerlink" title="一. HttpServletRequest介绍"></a>一. HttpServletRequest介绍</h1><p>　　HttpServletRequest对象代表 <strong>客户端的请求</strong> ，当 <strong>客户端通过HTTP协议访问服务器</strong> 时，HTTP请求头中的 <strong>所有信息都封装在这个对象中</strong> ，通过这个对象提供的方法，<strong>可以获得客户端请求的所有信息</strong> 。<br><a id="more"></a></p><h1 id="二-Request常用方法"><a href="#二-Request常用方法" class="headerlink" title="二. Request常用方法"></a>二. Request常用方法</h1><h2 id="2-1-获得客户机信息"><a href="#2-1-获得客户机信息" class="headerlink" title="2.1. 获得客户机信息"></a>2.1. 获得客户机信息</h2><p>　　<strong>getRequestURL方法返回客户端发出请求时的完整URL。</strong><br>　　<strong>getRequestURI方法返回请求行中的资源名部分。</strong><br>　　<strong>getQueryString 方法返回请求行中的参数部分。</strong><br>　　getPathInfo方法返回请求URL中的额外路径信息。额外路径信息是请求URL中的位于Servlet的路径之后和查询参数之前的内容，它以“/”开头。<br>　　<strong>getRemoteAddr方法返回发出请求的客户机的IP地址。</strong><br>等</p><h2 id="2-2-获得客户机请求头"><a href="#2-2-获得客户机请求头" class="headerlink" title="2.2 获得客户机请求头"></a>2.2 获得客户机请求头</h2><p>略</p><h2 id="2-3-获得客户机请求参数-客户端提交的数据"><a href="#2-3-获得客户机请求参数-客户端提交的数据" class="headerlink" title="2.3 获得客户机请求参数(客户端提交的数据)"></a>2.3 获得客户机请求参数(客户端提交的数据)</h2><ul><li>getParameter(String)方法<strong>(常用)</strong></li><li>getParameterValues(String name)方法<strong>(常用)</strong></li><li>getParameterNames()方法(<strong>不常用</strong>)</li><li>getParameterMap()方法<strong>(编写框架时常用)</strong></li></ul><p>详细代码见参考博客</p><p>在服务器端使用getParameter方法和getParameterValues方法接收表单参数，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取客户端通过Form表单提交上来的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestDemo03</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">// 客户端是以 UTF-8 编码提交表单数据的，所以需要设置服务器端以UTF-8 的编码进行接收，否则对于中文数据就会产生乱码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 用户名(文本框)：&lt;input type="text" name="username" value="请输入用户名"&gt;</span></span><br><span class="line"><span class="comment">        * 获取填写的用户名</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        String username = request.getParameter(<span class="string">"username"</span>);</span><br><span class="line"><span class="comment">// 获取选中的性别</span></span><br><span class="line">        String sex = request.getParameter(<span class="string">"sex"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取选中的兴趣，因为可以选中多个值，所以获取到的值是一个字符串数组，因此需要使用 getParameterValues 方法来获取</span></span><br><span class="line">        <span class="comment">// &lt;input type="checkbox" name="inst" value="唱歌"&gt;唱歌</span></span><br><span class="line">        String[] insts = request.getParameterValues(<span class="string">"inst"</span>);</span><br><span class="line">        String hiddenField = request.getParameter(<span class="string">"hiddenField"</span>);<span class="comment">//获取隐藏域的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-获取路径"><a href="#2-4-获取路径" class="headerlink" title="2.4 获取路径"></a>2.4 获取路径</h2><h3 id="方法与作用"><a href="#方法与作用" class="headerlink" title="方法与作用"></a>方法与作用</h3><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center"><strong>getServletPath()</strong></td><td style="text-align:left">获取能够与<strong>“url-pattern”中匹配的路径</strong>，注意是完全匹配的部分，<strong>* 的部分不包括</strong></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center"><strong>getPageInfo()</strong></td><td style="text-align:left">与getServletPath()获取的路径<strong>互补</strong>，能够得到的是“url-pattern”中 <strong>*</strong> 的路径部分</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center"><strong>getContextPath()</strong></td><td style="text-align:left">获取项目的<strong>根路径</strong> (<code>getContextPath()</code> 与 <code>req.getServletContext().getContextPath()</code>获取到内容的<strong>是相同的</strong>,都是项目的根路径)</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center"><strong>getRequestURI()</strong></td><td style="text-align:left">获取<strong>根路径到地址结尾</strong></td></tr><tr><td style="text-align:center">5</td><td style="text-align:center"><strong>getRequestURL()</strong></td><td style="text-align:left">获取请求的地址链接（浏览器中输入的地址）</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center"><strong>getServletContext().getRealPath(“/”)</strong></td><td style="text-align:left">获取“/”在机器中的实际地址</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center"><strong>getScheme()</strong></td><td style="text-align:left">获取的是使用的协议(http 或https)</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center"><strong>getProtocol()</strong></td><td style="text-align:left">获取的是协议的名称(HTTP/1.11)</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center"><strong>getServerName()</strong></td><td style="text-align:left">获取的是域名(xxx.com)</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center"><strong>getLocalName()</strong></td><td style="text-align:left">获取到的是IP</td></tr></tbody></table><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><p>请求 <code>http://localhost:8080/testweb/abc/def/ghi/test.html</code> (url-pattern=/abc/def/*)<br>打印的值为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> servletPath: /abc/<span class="function"><span class="keyword">def</span> </span></span><br><span class="line"><span class="function">2. <span class="title">pageInfo</span>:</span> /ghi/test.html</span><br><span class="line"><span class="number">3.</span> contextPath: /testweb</span><br><span class="line"><span class="number">4.</span> uri: /testweb/abc/<span class="function"><span class="keyword">def</span>/<span class="title">ghi</span>/<span class="title">test</span>.<span class="title">html</span></span></span><br><span class="line"><span class="function">5. <span class="title">url</span>:</span> http://localhost:<span class="number">8080</span>/testweb/abc/<span class="function"><span class="keyword">def</span>/<span class="title">ghi</span>/<span class="title">test</span>.<span class="title">html</span></span></span><br><span class="line"><span class="function">6. <span class="title">realPath</span>:</span>G:\java\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\testweb\</span><br></pre></td></tr></table></figure><h2 id="2-5-传参"><a href="#2-5-传参" class="headerlink" title="2.5 传参"></a>2.5 传参</h2><p>setAttribute和getAttribute可以用来在进行服务端跳转的时候，在不同的Servlet之间进行数据共享</p><h1 id="三-request接收表单提交中文参数乱码问题"><a href="#三-request接收表单提交中文参数乱码问题" class="headerlink" title="三. request接收表单提交中文参数乱码问题"></a>三. request接收表单提交中文参数乱码问题</h1><h3 id="3-1-以POST方式提交表单中文参数的乱码问题"><a href="#3-1-以POST方式提交表单中文参数的乱码问题" class="headerlink" title="3.1 以POST方式提交表单中文参数的乱码问题"></a>3.1 以POST方式提交表单中文参数的乱码问题</h3><h5 id="例如有如下的form表单页面"><a href="#例如有如下的form表单页面" class="headerlink" title="例如有如下的form表单页面"></a>例如有如下的form表单页面</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!--提交方式为 POST--&gt;</span><br><span class="line">    &lt;form action=<span class="string">"&lt;%=request.getContextPath()%&gt;/servlet/RequestDemo04"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">        用户名：&lt;input type=<span class="string">"text"</span> name=<span class="string">"userName"</span>/&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"post方式提交表单"</span>&gt; </span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h5 id="servlet-中的代码"><a href="#servlet-中的代码" class="headerlink" title="servlet 中的代码"></a>servlet 中的代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    String username = request.getParameter(<span class="string">"username"</span>);</span><br><span class="line">    System.out.println(<span class="string">"userName:"</span> + userName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果: userName: 佷粈涔?灏辨暣</span></span><br><span class="line"><span class="comment">// 是乱码</span></span><br></pre></td></tr></table></figure><h2 id="3-2-post方式提交中文数据乱码产生的原因和解决办法"><a href="#3-2-post方式提交中文数据乱码产生的原因和解决办法" class="headerlink" title="3.2. post方式提交中文数据乱码产生的原因和解决办法"></a>3.2. post方式提交中文数据乱码产生的原因和解决办法</h2><p>　　之所以会产生乱码，就是因为服务器和客户端<strong>沟通的编码不一致</strong>造成的，因此解决的办法是：在客户端和服务器之间<strong>设置一个统一的编码</strong>，之后就按照此编码进行数据的传输和接收。</p><p>　　由于<strong>客户端是以UTF-8字符编码</strong> 将表单数据传输到服务器端的，因此服务器也需要<strong>设置以UTF-8字符编码进行接收</strong>，要想完成此操作，服务器可以直接使用从ServletRequest接口继承而来的<strong><code>setCharacterEncoding(charset)</code></strong> 方法进行统一的编码设置。修改后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端是以 UTF-8 编码传输数据到服务器端的，所以需要设置服务器端以UTF-8的编码进行接收，否则对于中文数据就会产生乱码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        String userName = request.getParameter(<span class="string">"userName"</span>);</span><br><span class="line">        System.out.println(<span class="string">"userName："</span>+userName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-以GET方式提交表单中文参数的乱码问题"><a href="#3-3-以GET方式提交表单中文参数的乱码问题" class="headerlink" title="3.3 以GET方式提交表单中文参数的乱码问题"></a>3.3 以GET方式提交表单中文参数的乱码问题</h2><h5 id="例如有如下的form表单页面-1"><a href="#例如有如下的form表单页面-1" class="headerlink" title="例如有如下的form表单页面"></a>例如有如下的form表单页面</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!--提交方式为 GET--&gt;</span><br><span class="line">    &lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/servlet/RequestDemo04"</span> method=<span class="string">"get"</span>&gt;</span><br><span class="line">        姓名：&lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span>/&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"get方式提交表单"</span>&gt; </span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h5 id="此时在服务器端接收中文参数时就会出现中文乱码"><a href="#此时在服务器端接收中文参数时就会出现中文乱码" class="headerlink" title="此时在服务器端接收中文参数时就会出现中文乱码"></a>此时在服务器端接收中文参数时就会出现中文乱码</h5><h3 id="3-4-get方式提交中文数据乱码产生的原因和解决办法"><a href="#3-4-get方式提交中文数据乱码产生的原因和解决办法" class="headerlink" title="3.4. get方式提交中文数据乱码产生的原因和解决办法"></a>3.4. get方式提交中文数据乱码产生的原因和解决办法</h3><!-- 　　对于以 **get方式** 传输的数据，request **即使设置了以指定的编码接收数据也是无效的** (至于为什么无效,没有弄明白) --><p>​    默认的还是 <strong>使用ISO8859-1</strong> 这个字符编码来接收数据，客户端以UTF-8的编码传输数据到服务器端，而服务器端的request对象使用的是ISO8859-1这个字符编码来接收数据，<strong>服务器和客户端沟通的编码不一致</strong>因此才会产生中文乱码的。</p><p><strong>解决办法：</strong> 在接收到数据后</p><ol><li>获取request对象以ISO8859-1字符编码接收到的原始数据的字节数组</li><li>通过字节数组以指定的编码构建字符串，解决乱码问题。代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取request对象以ISO8859-1字符编码接收到的原始数据的字节数组，然后通过字节数组以指定的编码构建字符串，解决乱码问题</span></span><br><span class="line">    name = <span class="keyword">new</span> String(name.getBytes(<span class="string">"ISO8859-1"</span>), <span class="string">"UTF-8"</span>) ;</span><br><span class="line">    System.out.println(<span class="string">"name："</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-以超链接形式传递中文参数的乱码问题"><a href="#3-5-以超链接形式传递中文参数的乱码问题" class="headerlink" title="3.5 以超链接形式传递中文参数的乱码问题"></a>3.5 以超链接形式传递中文参数的乱码问题</h3><p>通过超链接后面加参数的形式，例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="$&#123; pageContext.request.contextPath &#125;/servlet/RequestDemo05?userName=gacl&amp;name=徐达沛"&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>点击超链接，数据是以 <strong>get的方式</strong> 传输到服务器的，所以接收中文数据时也会产生中文乱码问题</p><p>解决中文乱码问题的方式与 <strong>上述的以get方式提交表单中文数据乱码处理问题的方式一致</strong> , 如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">name =<span class="keyword">new</span> String(name.getBytes(<span class="string">"ISO8859-1"</span>), <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><p>　　另外，需要提的一点就是 <strong>URL地址后面如果跟了中文数据，那么中文参数最好使用URL编码进行处理</strong> , 如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="$&#123;pageContext.request.contextPath&#125;/servlet/RequestDemo05?userName=gacl&amp;name=&lt;%=URLEncoder.encode("徐达沛", "UTF-8")%&gt;"&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="3-6-提交中文数据乱码问题总结"><a href="#3-6-提交中文数据乱码问题总结" class="headerlink" title="3.6 提交中文数据乱码问题总结"></a>3.6 提交中文数据乱码问题总结</h3><h4 id="提交方式为-POST"><a href="#提交方式为-POST" class="headerlink" title="提交方式为 POST"></a>提交方式为 POST</h4><p>​    只需要在<strong>服务器端设置request对象的编码</strong>即可，客户端以哪种编码提交的，服务器端的request对象就以对应的编码接收，比如客户端是以UTF-8编码提交的</p><h4 id="提交方式为GET"><a href="#提交方式为GET" class="headerlink" title="提交方式为GET"></a>提交方式为GET</h4><p>​    <strong>设置request对象的编码是无效的</strong>，request对象还是以默认的ISO8859-1编码接收数据，因此要想不乱码，只能在接收到数据后再 <strong>手工转换</strong>, 步骤如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.获取获取客户端提交上来的数据，得到的是乱码字符串,data="???è?????"</span></span><br><span class="line">String data = request.getParameter(<span class="string">"paramName"</span>); </span><br><span class="line"><span class="comment">// 2.查找ISO8859-1码表，得到客户机提交的原始数据的字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] source = data.getBytes(<span class="string">"ISO8859-1"</span>); </span><br><span class="line"><span class="comment">// 3.通过字节数组以指定的编码构建字符串，解决乱码</span></span><br><span class="line">data = <span class="keyword">new</span> String(source, <span class="string">"UTF-8"</span>); </span><br><span class="line"><span class="comment">// 或者一步进行</span></span><br><span class="line">data = <span class="keyword">new</span> String(data.getBytes(<span class="string">"ISO8859-1"</span>), <span class="string">"UTF-8"</span>) ;</span><br></pre></td></tr></table></figure><p>　　通过字节数组以 <strong>指定的编码</strong> 构建字符串，这里 <strong>指定的编码</strong> -是根据客户端那边提交数据时使用的字符编码来定的，<strong>如果是GB2312，那么就设置成data = new String(source, “GB2312”)</strong></p><h1 id="四-Request-对象实现请求转发"><a href="#四-Request-对象实现请求转发" class="headerlink" title="四.Request 对象实现请求转发"></a>四.Request 对象实现请求转发</h1><h3 id="4-1-请求转发的基本概念"><a href="#4-1-请求转发的基本概念" class="headerlink" title="4.1 请求转发的基本概念"></a>4.1 请求转发的基本概念</h3><p>​    <strong>请求转发:</strong> 指一个web资源收到客户端请求后，通知<strong>服务器</strong>去调用另外一个web资源进行处理。<br>　　<strong>请求转发的应用场景:</strong> MVC设计模式</p><h5 id="在Servlet中实现请求转发的两种方式："><a href="#在Servlet中实现请求转发的两种方式：" class="headerlink" title="在Servlet中实现请求转发的两种方式："></a>在Servlet中实现请求转发的两种方式：</h5><ol><li>通过 ServletContext 的 <code>getRequestDispatcher(String path)</code> 方法，该方法返回一个 <strong>RequestDispatcher 对象</strong>，调用这个对象的 <code>forward</code> 方法可以实现请求转发。</li></ol><p><strong>例如：将请求转发的test.jsp页面</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RequestDispatcher reqDispatcher = <span class="keyword">this</span>.getServletContext().getRequestDispatcher(<span class="string">"/test.jsp"</span>);</span><br><span class="line"></span><br><span class="line">reqDispatcher.forward(request, response);</span><br></pre></td></tr></table></figure><ol start="2"><li>通过 <strong>request对象</strong> 提供的 <code>getRequestDispatche(String path)</code> 方法，该方法<strong>返回一个RequestDispatcher对象</strong>，调用这个对象的 <code>forward</code> 方法可以实现请求转发。</li></ol><p><strong>例如：将请求转发的test.jsp页面</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">"/test.jsp"</span>).forward(request, response);</span><br></pre></td></tr></table></figure><p>　　request对象同时也是<strong>一个域对象(Map容器)</strong>，开发人员通过request对象在实现转发时，把数据通过request对象带给其它web资源处理。</p><p><strong>request对象作为一个域对象(Map容器)使用时</strong>，主要是通过以下的<strong>四个方法</strong>来操作,如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法: setAttribute(String name,Object o);</span></span><br><span class="line"><span class="comment">// 将数据作为request对象的一个属性存放到request对象中</span></span><br><span class="line">request.setAttribute(<span class="string">"data"</span>, data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: getAttribute(String name);</span></span><br><span class="line"><span class="comment">// 获取request对象的name属性的属性值，</span></span><br><span class="line">request.getAttribute(<span class="string">"data"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: removeAttribute(String name);</span></span><br><span class="line"><span class="comment">// 移除request对象的name属性</span></span><br><span class="line">request.removeAttribute(<span class="string">"data"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: getAttributeNames()</span></span><br><span class="line"><span class="comment">// 获取request对象的所有属性名，返回的是一个</span></span><br><span class="line">Enumeration&lt;String&gt; attrNames = request.getAttributeNames();</span><br></pre></td></tr></table></figure><h3 id="4-2-请求重定向和请求转发的区别"><a href="#4-2-请求重定向和请求转发的区别" class="headerlink" title="4.2 请求重定向和请求转发的区别"></a>4.2 请求重定向和请求转发的区别</h3><p>一个web资源收到客户端请求后</p><ul><li><strong>通知服务器去调用另外一个web资源</strong>进行处理，称之为<strong>请求转发/307</strong></li><li><strong>通知浏览器去访问另外一个web资源</strong>进行处理，称之为<strong>请求重定向/302</strong></li></ul><h1 id="五-request-设置参数"><a href="#五-request-设置参数" class="headerlink" title="五. request 设置参数"></a>五. request 设置参数</h1><h4 id="存储代码"><a href="#存储代码" class="headerlink" title="存储代码"></a>存储代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroEditServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id = Integer.parseInt(request.getParameter(<span class="string">"id"</span>));</span><br><span class="line">        Hero hero = <span class="keyword">new</span> HeroDAO().get(id);</span><br><span class="line">        <span class="comment">// 存进来</span></span><br><span class="line">        request.setAttribute(<span class="string">"hero"</span>, hero);</span><br><span class="line">        request.getRequestDispatcher(<span class="string">"editHero.jsp"</span>).forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拿出来"><a href="#拿出来" class="headerlink" title="拿出来"></a>拿出来</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">    pageEncoding=<span class="string">"UTF-8"</span> <span class="keyword">import</span>=<span class="string">"java.util.*,bean.*,java.sql.*"</span>%&gt;</span><br><span class="line"> </span><br><span class="line">&lt;form action=<span class="string">'updateHero'</span> method=<span class="string">'post'</span>&gt;</span><br><span class="line">    &lt;!-- 将信息提取出来 --&gt;</span><br><span class="line">    名字 ： &lt;input type=<span class="string">'text'</span> name=<span class="string">'name'</span> value=<span class="string">'$&#123;hero.name&#125;'</span>&gt; &lt;br&gt;</span><br><span class="line">    血量 ：&lt;input type=<span class="string">'text'</span> name=<span class="string">'hp'</span> value=<span class="string">'$&#123;hero.hp&#125;'</span>&gt; &lt;br&gt;</span><br><span class="line">    伤害： &lt;input type=<span class="string">'text'</span> name=<span class="string">'damage'</span> value=<span class="string">'$&#123;hero.damage&#125;'</span>&gt; &lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">'hidden'</span> name=<span class="string">'id'</span> value=<span class="string">'$&#123;hero.id&#125;'</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">'submit'</span> value=<span class="string">'更新'</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>可以在拂去端跳转后的.jsp文件取出来</p><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3798347.html" target="_blank" rel="noopener">javaweb学习总结(十)——HttpServletRequest对象(一)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-HttpServletRequest介绍&quot;&gt;&lt;a href=&quot;#一-HttpServletRequest介绍&quot; class=&quot;headerlink&quot; title=&quot;一. HttpServletRequest介绍&quot;&gt;&lt;/a&gt;一. HttpServletRequest介绍&lt;/h1&gt;&lt;p&gt;　　HttpServletRequest对象代表 &lt;strong&gt;客户端的请求&lt;/strong&gt; ，当 &lt;strong&gt;客户端通过HTTP协议访问服务器&lt;/strong&gt; 时，HTTP请求头中的 &lt;strong&gt;所有信息都封装在这个对象中&lt;/strong&gt; ，通过这个对象提供的方法，&lt;strong&gt;可以获得客户端请求的所有信息&lt;/strong&gt; 。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---面向对象(1)</title>
    <link href="http://yoursite.com/2019/03/08/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(1)/"/>
    <id>http://yoursite.com/2019/03/08/Java基础知识---面向对象(1)/</id>
    <published>2019-03-08T02:37:18.000Z</published>
    <updated>2019-03-19T03:32:53.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-面向过程的思想和面向对象的思想"><a href="#一-面向过程的思想和面向对象的思想" class="headerlink" title="一. 面向过程的思想和面向对象的思想"></a>一. 面向过程的思想和面向对象的思想</h1><h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><blockquote><p><strong>自顶向下,逐步细化</strong> </p></blockquote><p>​    <strong>面向解决问题的过程进行编程</strong><br>​    按照步骤化解决问题.(一个问题,分析这个问题如何去解决,第一步做什么, 第二步什么…), 当我们用面向过程的思想去编程或解决问题时，首先一定要把详细的实现过程弄清楚。一旦过程设计清楚，代码的实现简直轻而易举。</p><a id="more"></a><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><blockquote><p>Java 中万物皆对象，模拟真实的现实世界</p></blockquote><p>​    在编程的时候尽可能的去模拟真实的现实世界，按照现实世界中的逻辑去处理一个问题，分析问题中参与其中的有<strong>哪些实体</strong>，这些实体应该<strong>有什么属性和方法</strong>，我们<strong>如何通过调用这些实体的属性和方法</strong>去解决问题。<br>拿到一个问题,应该<strong>分析</strong>: </p><ol><li>这个问题里面有哪些类和对象</li><li>在分析这些类和对象应该具有哪些属性和方法</li><li>分析类和类之间具有什么关系<blockquote><p>设计思维: 合适的方法应该出现在合适的类里面</p></blockquote></li></ol><h1 id="二-类和对象"><a href="#二-类和对象" class="headerlink" title="二. 类和对象"></a>二. 类和对象</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h4 id="一类事物的抽象"><a href="#一类事物的抽象" class="headerlink" title="一类事物的抽象"></a>一类事物的抽象</h4><p>包括属性(静态)和方法(动态)</p><ul><li><strong>属性:</strong> 用来描述这一个对象（类）的<strong>特征</strong> ,比如一个人的属性有身高，肤色，体重等等，</li><li><strong>方法:</strong> 可以<strong>完成一个特定的功能</strong>，方法就像是动作, 比如人可以吃饭，跑步，学习，都可以是方法<blockquote><p>Java中属性就是成员变量,方法就是函数, 不同的叫法</p></blockquote><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h4 id="一类事物的具体的某一个东西-符合这类事物的具体特征"><a href="#一类事物的具体的某一个东西-符合这类事物的具体特征" class="headerlink" title="一类事物的具体的某一个东西(符合这类事物的具体特征)"></a>一类事物的具体的某一个东西(符合这类事物的具体特征)</h4><blockquote><p>在Java中, 对象就是类的实例化</p></blockquote></li></ul><h4 id="随笔"><a href="#随笔" class="headerlink" title="随笔:"></a>随笔:</h4><blockquote><p>对象和类是分不开的，必须首先定义类才能有对象<br>类和对象的关系，类就是<strong>模板</strong>，里面定义着属性和方法，而对象就是<strong>实例</strong>，通过类来创建（new）对象，叫类的实例化</p></blockquote><h1 id="三-面向过程与面向对象的比较"><a href="#三-面向过程与面向对象的比较" class="headerlink" title="三. 面向过程与面向对象的比较"></a>三. 面向过程与面向对象的比较</h1><ol><li>都可以实现代码重用和模块化编程，但是面对对象的模块化更深，数据更封闭，也更安全！因为面向对象的封装性更强！</li><li>面对对象的思维方式更加贴近于现实生活，更容易解决大型的复杂的业务逻辑</li><li>从前期开发角度上来看，面对对象远比面向过程要复杂，但是从维护和扩展功能的角度上来看，面对对象远比面向过程要简单！<blockquote><p>当我们的业务逻辑比较简单时，使用面向过程能更快的实现<br>当我们的业务逻辑比较复杂时，为了将来的维护和扩展，还是面向对象更为靠谱</p></blockquote></li></ol><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/BeiGuo-FengGuang/p/5935763.html" target="_blank" rel="noopener">编程思想：面向对象和面向过程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-面向过程的思想和面向对象的思想&quot;&gt;&lt;a href=&quot;#一-面向过程的思想和面向对象的思想&quot; class=&quot;headerlink&quot; title=&quot;一. 面向过程的思想和面向对象的思想&quot;&gt;&lt;/a&gt;一. 面向过程的思想和面向对象的思想&lt;/h1&gt;&lt;h2 id=&quot;面向过程&quot;&gt;&lt;a href=&quot;#面向过程&quot; class=&quot;headerlink&quot; title=&quot;面向过程&quot;&gt;&lt;/a&gt;面向过程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;自顶向下,逐步细化&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​    &lt;strong&gt;面向解决问题的过程进行编程&lt;/strong&gt;&lt;br&gt;​    按照步骤化解决问题.(一个问题,分析这个问题如何去解决,第一步做什么, 第二步什么…), 当我们用面向过程的思想去编程或解决问题时，首先一定要把详细的实现过程弄清楚。一旦过程设计清楚，代码的实现简直轻而易举。&lt;/p&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>C语言基础知识</title>
    <link href="http://yoursite.com/2019/03/08/C%E8%AF%AD%E8%A8%80---%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/03/08/C语言---基础知识/</id>
    <published>2019-03-08T02:23:51.000Z</published>
    <updated>2019-03-15T08:17:08.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言基础知识"><a href="#C语言基础知识" class="headerlink" title="C语言基础知识:"></a>C语言基础知识:</h1><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体:"></a>结构体:</h2><p><strong>定义:</strong> 将一些已知的数据类型放在一起来定义的一种数据类型</p><blockquote><p>结构体并没有创造出新的数据类型，这点要搞清楚。C语言的结构体和其他高级语言的类有点相似的概念，可以完成对一种事物的抽象。</p></blockquote><a id="more"></a><p><strong>代码中的定义:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构名 // 结构名是结构的标识符不是变量名</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    类型  变量名; </span><br><span class="line">    类型  变量名;</span><br><span class="line">&#125; 结构变量;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">8</span>]; </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">    <span class="keyword">char</span> sex[<span class="number">2</span>]; </span><br><span class="line">    <span class="keyword">char</span> depart[<span class="number">20</span>]; </span><br><span class="line">    <span class="keyword">float</span> wage1, wage2, wage3, wage4, wage5; </span><br><span class="line">&#125; Mike, Marry;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">John</span>;</span><span class="comment">// struct student:类型说明符, John 变量名</span></span><br><span class="line"><span class="comment">// 定义了两个 struct student 类型的变量 Mike, Marry</span></span><br></pre></td></tr></table></figure><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef:"></a>typedef:</h2><blockquote><p>使用 typedef 关键字来定义自己习惯的数据类型名称，来替代系统默认的基本类型名称、数组类型名称、指针类型名称与用户自定义的结构型名称、共用型名称、枚举型名称等。</p></blockquote><p>基本用法</p><h3 id="1-为基本类型数据定义新的类型名"><a href="#1-为基本类型数据定义新的类型名" class="headerlink" title="1. 为基本类型数据定义新的类型名"></a>1. 为基本类型数据定义新的类型名</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> COUNT; <span class="comment">// 为基本类型数据定义新的类型名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">COUNT a = <span class="number">88</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"结果为: %d"</span>, a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果: 结果为: 88</span></span><br></pre></td></tr></table></figure><h3 id="2-为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称"><a href="#2-为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称" class="headerlink" title="2. 为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称"></a>2. 为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以结构体为例，下面我们定义一个名为 Point 的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在调用这个结构体时，我们必须像下面的代码这样来调用这个结构体</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">oPoint2</span>;</span></span><br><span class="line">oPoint2.x = <span class="number">3.3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f"</span>, oPoint2.x); </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果: 3.300000</span></span><br></pre></td></tr></table></figure><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPoint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">&#125; Point;</span><br><span class="line"><span class="comment">// 1.相当于把 x = struct tagPoint &#123; …&#125;</span></span><br><span class="line"><span class="comment">// 2.typedef x Point;</span></span><br><span class="line"><span class="comment">// 可以看做是简写</span></span><br></pre></td></tr></table></figure><p><strong>参考文章:</strong> </p><p>​    <a href="http://c.biancheng.net/view/298.html" target="_blank" rel="noopener">typedef的用法，C语言typedef详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C语言基础知识&quot;&gt;&lt;a href=&quot;#C语言基础知识&quot; class=&quot;headerlink&quot; title=&quot;C语言基础知识:&quot;&gt;&lt;/a&gt;C语言基础知识:&lt;/h1&gt;&lt;h2 id=&quot;结构体&quot;&gt;&lt;a href=&quot;#结构体&quot; class=&quot;headerlink&quot; title=&quot;结构体:&quot;&gt;&lt;/a&gt;结构体:&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;定义:&lt;/strong&gt; 将一些已知的数据类型放在一起来定义的一种数据类型&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;结构体并没有创造出新的数据类型，这点要搞清楚。C语言的结构体和其他高级语言的类有点相似的概念，可以完成对一种事物的抽象。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言---指针</title>
    <link href="http://yoursite.com/2019/03/08/C%E8%AF%AD%E8%A8%80---%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2019/03/08/C语言---指针/</id>
    <published>2019-03-08T02:23:51.000Z</published>
    <updated>2019-03-15T08:16:11.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="一-简单理解"><a href="#一-简单理解" class="headerlink" title="一. 简单理解"></a>一. 简单理解</h2><p><strong>指针变量:</strong> 专门用来存放地址的特殊变量</p><a id="more"></a><table><thead><tr><th></th><th>指针 ( = 变量的值)</th><th>指针变量 ( = 变量)</th></tr></thead><tbody><tr><td>含义</td><td>地址</td><td>存放另一个变量地址的变量</td></tr></tbody></table><blockquote><p>指针与指针变量的关系类似于变量的值与变量的区别.</p><p>指针变量习惯上简称为 <strong>指针</strong> </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, * p;</span><br><span class="line">p = &amp;a;<span class="comment">// "&amp;a" 代表a的地址的值 </span></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p的值为 %d\n"</span>, p); <span class="comment">// p中存放的是 a 的地址 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p的值为 %d"</span>, *p);<span class="comment">// * 号在 引用时表示"指向"操作, *p 代表 a,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "*"仅起到标志的作用, 表示该变量为指针变量, 不是变量名的一部分, 及指针变量名不包括 * </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-复杂类型说明"><a href="#二-复杂类型说明" class="headerlink" title="二. 复杂类型说明"></a>二. 复杂类型说明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> p; <span class="comment">//这是一个普通的整型变量  </span></span><br><span class="line"><span class="keyword">int</span> *p; <span class="comment">//首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针  </span></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组  </span></span><br><span class="line"><span class="keyword">int</span> *p[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组  </span></span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与"()"这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针  </span></span><br><span class="line"><span class="keyword">int</span> **p; <span class="comment">//首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据  </span></span><br><span class="line">Int (*p)(<span class="keyword">int</span>); <span class="comment">//从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针  </span></span><br><span class="line"><span class="keyword">int</span> *(*p(<span class="keyword">int</span>))[<span class="number">3</span>]; <span class="comment">//可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.</span></span><br></pre></td></tr></table></figure><h2 id="三-细说指针"><a href="#三-细说指针" class="headerlink" title="三. 细说指针"></a>三. 细说指针</h2><p>指针是一个 <strong>特殊的变量</strong> ，它里面 <strong>存储的数值</strong> 被解释成为 <strong>内存里的一个地址</strong> 。要搞清一个指针需要搞清指针的四方面的内容：</p><ul><li>指针的类型</li><li>指针所指向的类型</li><li>指针的值或者叫指针所指向的内存区</li><li>指针本身所占据的内存区。</li></ul><h2 id="3-1-指针的类型"><a href="#3-1-指针的类型" class="headerlink" title="3.1 指针的类型"></a>3.1 指针的类型</h2><p>从语法的角度看，你只要<strong>把指针声明语句里的指针名字去掉</strong>，<strong>剩下的部分就是这个指针的类型</strong>。这是指针本身所具有的类型。例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ptr;<span class="comment">//指针的类型是int*</span></span><br><span class="line"><span class="keyword">char</span> * ptr;<span class="comment">//指针的类型是char*</span></span><br><span class="line"><span class="keyword">int</span> ** ptr;<span class="comment">//指针的类型是int**</span></span><br><span class="line"><span class="keyword">int</span> (* ptr)[<span class="number">3</span>];<span class="comment">//指针的类型是int(*)[3]</span></span><br><span class="line"><span class="keyword">int</span> * (* ptr)[<span class="number">4</span>];<span class="comment">//指针的类型是int*(*)[4]</span></span><br></pre></td></tr></table></figure><h2 id="3-2-指针所指向的类型"><a href="#3-2-指针所指向的类型" class="headerlink" title="3.2 指针所指向的类型"></a>3.2 指针所指向的类型</h2><p>当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把<strong>那片内存区里的内容当做什么来看待</strong>。<br>从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符去掉，剩下的就是指针所指向的类型。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ptr; <span class="comment">//指针所指向的类型是int</span></span><br><span class="line"><span class="keyword">char</span> * ptr; <span class="comment">//指针所指向的的类型是char</span></span><br><span class="line"><span class="keyword">int</span> ** ptr; <span class="comment">//指针所指向的的类型是int</span></span><br><span class="line"><span class="keyword">int</span> (*ptr)[<span class="number">3</span>]; <span class="comment">//指针所指向的的类型是int()[3]</span></span><br><span class="line"><span class="keyword">int</span> (ptr)[<span class="number">4</span>]; <span class="comment">//指针所指向的的类型是int*()[4]</span></span><br></pre></td></tr></table></figure><blockquote><p>指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C 越来越熟悉时，你会发现，把与指针搅和在一起的”类型”这个概念分成”指针的类型”和”指针所指向的类型”两个概念，是精通指针的关键点之一。</p></blockquote><h2 id="3-3-指针的值—-或者叫指针所指向的内存区或地址"><a href="#3-3-指针的值—-或者叫指针所指向的内存区或地址" class="headerlink" title="3.3 指针的值—-或者叫指针所指向的内存区或地址"></a>3.3 指针的值—-或者叫指针所指向的内存区或地址</h2><blockquote><p>指针的值是指针本身存储的数值，这个值将被编译器<strong>当作一个地址</strong>，而不是一个一般的数值。</p></blockquote><ul><li><p>在32 位程序里，所有类型的指针的值都是一个32 位整数，因为32 位程序里内存地址全都是32 位长。<strong>指针所指向的内存区就是从指针的值所代表的那个内存地址开始</strong>，长度为sizeof(指针所指向的类型)的一片内存区</p></li><li><p>我们<strong>说一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域</strong>；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。<strong>指针所指向的内存区和指针所指向的类型是两个完全不同的概念</strong>。在3.2例子中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。</p></li></ul><blockquote><h5 id="以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？"><a href="#以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？" class="headerlink" title="以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？"></a>以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？</h5></blockquote><h3 id="3-4-指针本身所占据的内存区"><a href="#3-4-指针本身所占据的内存区" class="headerlink" title="3.4 指针本身所占据的内存区"></a>3.4 指针本身所占据的内存区</h3><p>指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32 位平台里，指针本身占据了4 个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式（后面会解释）是否是左值时很有用</p><h2 id="四-指针的算术运算"><a href="#四-指针的算术运算" class="headerlink" title="四. 指针的算术运算"></a>四. 指针的算术运算</h2><h2 id="五-运算符-amp-和"><a href="#五-运算符-amp-和" class="headerlink" title="五. 运算符 &amp; 和 *"></a>五. 运算符 <code>&amp;</code> 和 <code>*</code></h2><p>这里 <code>&amp;</code> 是取地址运算符，<code>*</code> 是间接运算符。<br><code>&amp;a</code> 的运算结果是<strong>一个指针</strong>，指针的类型是a 的类型加个<code>*</code> ，指针所指向的类型是a 的类型，指针所指向的地址嘛，<strong>那就是a 的地址</strong>。</p><p><code>*p</code> 的运算结果就五花八门了。总之<code>*p</code> 的结果是 <strong>p 所指向的东西</strong>，这个东西有这些特点：它的类型是p 指向的类型，它所占用的地址是p所指向的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">12</span>; <span class="keyword">int</span> b; </span><br><span class="line"><span class="keyword">int</span> *p; <span class="keyword">int</span> **ptr;  </span><br><span class="line">p=&amp;a; <span class="comment">//&amp;a 的结果是一个指针，类型是int*，指向的类型是int，指向的地址是a的地址。  </span></span><br><span class="line">*p=<span class="number">24</span>; <span class="comment">//*p 的结果，在这里它的类型是int，它所占用的地址是p所指向的地址，*p就是变量a。  </span></span><br><span class="line"><span class="comment">// 下面的还有有看懂</span></span><br><span class="line">ptr=&amp;p; <span class="comment">//&amp;p 的结果是个指针，该指针的类型是p 的类型加个*, 在这里是int **。该指针所指向的类</span></span><br><span class="line"><span class="comment">//型是p的类型，这里是int*。该指针所指向的地址就是指针p 自己的地址。  </span></span><br><span class="line">*ptr=&amp;b; <span class="comment">//*ptr 是个指针，&amp;b 的结果也是个指针，且这两个指针  </span></span><br><span class="line"><span class="comment">//的类型和所指向的类型是一样的，所以用&amp;b 来给*ptr 赋  </span></span><br><span class="line"><span class="comment">//值就是毫无问题的了。  </span></span><br><span class="line">**ptr=<span class="number">34</span>; <span class="comment">//*ptr 的结果是ptr 所指向的东西，在这里是一个指针，  </span></span><br><span class="line"><span class="comment">//对这个指针再做一次*运算，结果是一个int 类型的变量。</span></span><br></pre></td></tr></table></figure><h2 id="六-指针表达式"><a href="#六-指针表达式" class="headerlink" title="六. 指针表达式"></a>六. 指针表达式</h2><p>一个表达式的结果如果是一个指针，那么这个表达式就叫指针表式。</p><h2 id="七-数组和指针的关系"><a href="#七-数组和指针的关系" class="headerlink" title="七. 数组和指针的关系"></a>七. 数组和指针的关系</h2><h2 id="八-指针和结构类型的关系"><a href="#八-指针和结构类型的关系" class="headerlink" title="八. 指针和结构类型的关系"></a>八. 指针和结构类型的关系</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> a;  </span><br><span class="line">    <span class="keyword">int</span> b;  </span><br><span class="line">    <span class="keyword">int</span> c;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">// 声明了结构对象ss，并把ss 的成员初始化为20，30 和40。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> <span class="title">ss</span> = &#123;</span><span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明了一个指向结构对象 ss 的指针。它的类型是MyStruct *,它指向的类型是MyStruct。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> *<span class="title">ptr</span> = &amp;<span class="title">ss</span>;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明了一个指向结构对象ss 的指针。但是pstr 和它被指向的类型ptr 是不同的。</span></span><br><span class="line"><span class="keyword">int</span> *pstr = (<span class="keyword">int</span>*)&amp;ss;</span><br></pre></td></tr></table></figure><h4 id="请问怎样通过指针ptr-来访问ss-的三个成员变量？"><a href="#请问怎样通过指针ptr-来访问ss-的三个成员变量？" class="headerlink" title="请问怎样通过指针ptr 来访问ss 的三个成员变量？"></a>请问怎样通过指针ptr 来访问ss 的三个成员变量？</h4><p>答案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;a; <span class="comment">//指向运算符，或者可以这们(*ptr).a,建议使用前者</span></span><br><span class="line">ptr-&gt;b;</span><br><span class="line">ptr-&gt;c;</span><br></pre></td></tr></table></figure><h2 id="九-指针和函数的关系"><a href="#九-指针和函数的关系" class="headerlink" title="九. 指针和函数的关系"></a>九. 指针和函数的关系</h2><p>可以把一个指针声明成为一个指向函数的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">char</span> *,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*pfun1)(<span class="keyword">char</span> ,<span class="keyword">int</span>);</span><br><span class="line">pfun1 = fun1;</span><br><span class="line"><span class="keyword">int</span> a = (*pfun1)(<span class="string">"abcdefg"</span>,<span class="number">7</span>); <span class="comment">//通过函数指针调用函数。</span></span><br></pre></td></tr></table></figure><p>可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *)</span></span>;  </span><br><span class="line"><span class="keyword">int</span> a;  </span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"abcdefghijklmn"</span>;  </span><br><span class="line">a = fun(str);  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *s)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;;)  </span><br><span class="line">    &#123;  </span><br><span class="line">        num+=*s;s++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> num;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中的函数fun 统计一个字符串中各个字符的ASCII 码值之和。前面说了，数组的名字也是一个指针。在函数调用中，当把str作为实参传递给形参s 后，实际是把str 的值传递给了s，s 所指向的地址就和str 所指向的地址一致，但是str 和s 各自占用各自的存储空间。在函数体内对s 进行自加1 运算，并不意味着同时对str 进行了自加1 运算。</p><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://blog.csdn.net/constantin_/article/details/79575638" target="_blank" rel="noopener">C语言指针详解(经典,非常详细)</a></p><p>​    <a href="https://blog.csdn.net/qq_33757398/article/details/81265884" target="_blank" rel="noopener">指针与函数</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;指针&quot;&gt;&lt;a href=&quot;#指针&quot; class=&quot;headerlink&quot; title=&quot;指针&quot;&gt;&lt;/a&gt;指针&lt;/h1&gt;&lt;h2 id=&quot;一-简单理解&quot;&gt;&lt;a href=&quot;#一-简单理解&quot; class=&quot;headerlink&quot; title=&quot;一. 简单理解&quot;&gt;&lt;/a&gt;一. 简单理解&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;指针变量:&lt;/strong&gt; 专门用来存放地址的特殊变量&lt;/p&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---基础语法(2)</title>
    <link href="http://yoursite.com/2019/03/08/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95(2)/"/>
    <id>http://yoursite.com/2019/03/08/Java基础知识---基础语法(2)/</id>
    <published>2019-03-08T01:01:23.000Z</published>
    <updated>2019-03-19T03:32:48.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-语句"><a href="#一-语句" class="headerlink" title="一. 语句"></a>一. 语句</h1><h2 id="1-1-条件语句"><a href="#1-1-条件语句" class="headerlink" title="1.1 条件语句"></a>1.1 条件语句</h2><ul><li>if 语句</li><li>switch 语句</li></ul><h2 id="1-2-循环语句"><a href="#1-2-循环语句" class="headerlink" title="1.2 循环语句"></a>1.2 循环语句</h2><ul><li>for 循环语句</li><li>while 循环与do while 循环</li></ul><h2 id="1-3-break-和-continue-语句"><a href="#1-3-break-和-continue-语句" class="headerlink" title="1.3 break 和 continue 语句"></a>1.3 break 和 continue 语句</h2>  <a id="more"></a><h1 id="二-方法"><a href="#二-方法" class="headerlink" title="二. 方法"></a>二. 方法</h1><p>​    一段用来<strong>完成特定功能</strong>的代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符<span class="number">1</span> 修饰符<span class="number">2</span> ...] 返回值类型 方法名(形式参数列表) &#123;</span><br><span class="line">java 语句;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>方法可以有返回值，但可以不用这个返回值</strong>。方法首先要定义，然后才能调用</p></blockquote><h1 id="三、变量的作用域"><a href="#三、变量的作用域" class="headerlink" title="三、变量的作用域"></a>三、<strong>变量的作用域</strong></h1><p>​    变量的作用域只在“{  }”有效，出了这个“{  }”就没有作用了</p><h1 id="四、递归调用"><a href="#四、递归调用" class="headerlink" title="四、递归调用"></a>四、<strong>递归调用</strong></h1><p>　　递归：<strong>在一个方法内部对自身的调用就称为递归</strong></p><blockquote><p>具体的参考 <strong>孤傲苍狼</strong> 博客</p></blockquote><h1 id="五、程序的执行过程"><a href="#五、程序的执行过程" class="headerlink" title="五、程序的执行过程"></a>五、<strong>程序的执行过程</strong></h1><p><img src="/2019/03/08/Java基础知识---基础语法(2)/chengxu.png" alt="chengxu"></p><p>参考博文:<br>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3627241.html" target="_blank" rel="noopener">java基础学习总结——基础语法2</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-语句&quot;&gt;&lt;a href=&quot;#一-语句&quot; class=&quot;headerlink&quot; title=&quot;一. 语句&quot;&gt;&lt;/a&gt;一. 语句&lt;/h1&gt;&lt;h2 id=&quot;1-1-条件语句&quot;&gt;&lt;a href=&quot;#1-1-条件语句&quot; class=&quot;headerlink&quot; title=&quot;1.1 条件语句&quot;&gt;&lt;/a&gt;1.1 条件语句&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;if 语句&lt;/li&gt;
&lt;li&gt;switch 语句&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-循环语句&quot;&gt;&lt;a href=&quot;#1-2-循环语句&quot; class=&quot;headerlink&quot; title=&quot;1.2 循环语句&quot;&gt;&lt;/a&gt;1.2 循环语句&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;for 循环语句&lt;/li&gt;
&lt;li&gt;while 循环与do while 循环&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-3-break-和-continue-语句&quot;&gt;&lt;a href=&quot;#1-3-break-和-continue-语句&quot; class=&quot;headerlink&quot; title=&quot;1.3 break 和 continue 语句&quot;&gt;&lt;/a&gt;1.3 break 和 continue 语句&lt;/h2&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>数据结构---链表的概念及实现</title>
    <link href="http://yoursite.com/2019/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/03/08/数据结构---单链表的概念及实现/</id>
    <published>2019-03-08T00:24:53.000Z</published>
    <updated>2019-03-15T09:16:27.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>线性表的<strong>链接存储结构</strong>成为链表</p><p>常见的链表: </p><ol><li>单链表(每个节点有一个指针域的链表)</li><li>循环链表</li><li>双链表(每个节点有两个指针域的链表)</li></ol><a id="more"></a><p>特点: </p><ul><li>用一组任意的存储单元存储线性表的数据结构(存储单元可以是连续的,也可以是不连续的</li><li>数据元素的逻辑次序和物理次序 <strong>==不一定一致==</strong></li></ul><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li><p><strong>结点:</strong> 基本单元,由两部分组成</p><ul><li>数据域: 用来存放节点本身的信息</li><li>指针域:用来存放本节点的直接后继节点的地址</li></ul></li><li><p><strong>空指针:</strong> 链表中最后一个节点的指针域不指向任何节点(通常用”∧”或者”NULL”表示</p></li><li><p><strong>头指针:</strong> 指向单链表第一个节点的指针(head)</p></li><li><p><strong>空表:</strong> 之神 head 为空指针,即 head=NULL</p></li><li><p><strong>表头结点:</strong> 第一个节点之前再增加一个类型相同的结点(为了便于实现链表的各种运算, 其他节点成为表结点)</p></li><li><p><strong>表结点:</strong>  除了表头结点其他的结点</p><blockquote><p>在表结点中,第一个节点称为<strong>首结点</strong> ,最后一个节点称为 <strong>尾节点</strong></p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h1&gt;&lt;p&gt;线性表的&lt;strong&gt;链接存储结构&lt;/strong&gt;成为链表&lt;/p&gt;
&lt;p&gt;常见的链表: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单链表(每个节点有一个指针域的链表)&lt;/li&gt;
&lt;li&gt;循环链表&lt;/li&gt;
&lt;li&gt;双链表(每个节点有两个指针域的链表)&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构---线性表</title>
    <link href="http://yoursite.com/2019/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/03/08/数据结构---线性表/</id>
    <published>2019-03-08T00:24:53.000Z</published>
    <updated>2019-03-15T09:16:23.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性表："><a href="#线性表：" class="headerlink" title="线性表："></a>线性表：</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h3><p>​    由 n(n≥0) 个数据特性相同的元素构成的 <strong>有限序列</strong> </p><a id="more"></a><h4 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h4><ul><li>存在唯一的一个被称为”第一个”的数据元素</li><li>存在唯一的一个被称为”最后一个”的数据元素</li><li>除第一个之外, 结构中的每个数据元素均只有一个前驱元素</li><li>除最后一个之外, 结构中的每个数据元素均只有一个后继元素</li></ul><h4 id="存储结构及运算"><a href="#存储结构及运算" class="headerlink" title="存储结构及运算:"></a>存储结构及运算:</h4><ul><li><strong>存储结构方式:</strong>  顺序存储方式(顺序表), 链接存储方式(链表)</li><li><strong>运算:</strong> <ol><li>线性表的初始化 </li><li>求表的长度 </li><li>取出表的元素 </li><li>查找运算</li></ol></li></ul><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul><li>空表: 线性表的长度 n=0</li><li>前驱元素: 如果 a~i~ 和a~i+1~ 是相邻的具有前后关系的两个元素, 则 a~i~ 称为 a~i+1~ 的前驱元素</li><li>后继元素: 如果 a~i~ 和a~i+1~ 是相邻的具有前后关系的两个元素, 则 a~i+1~ 称为 a~i~ 的前驱元素</li></ul><h4 id="随笔"><a href="#随笔" class="headerlink" title="随笔:"></a>随笔:</h4><ul><li>线性表中的数据元素之间的逻辑关系就是其相互位置上的 <strong>邻接关系</strong> ,该关系是线性的,因此,线性表是一种<strong>线性结构</strong> </li><li><strong>常见例子:</strong> 学生成绩表, 列车时刻表, 英文字母表</li></ul><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线性表：&quot;&gt;&lt;a href=&quot;#线性表：&quot; class=&quot;headerlink&quot; title=&quot;线性表：&quot;&gt;&lt;/a&gt;线性表：&lt;/h1&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义:&quot;&gt;&lt;/a&gt;定义:&lt;/h3&gt;&lt;p&gt;​    由 n(n≥0) 个数据特性相同的元素构成的 &lt;strong&gt;有限序列&lt;/strong&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>涂磊老师语录</title>
    <link href="http://yoursite.com/2019/03/07/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E6%88%91%E6%88%90%E9%95%BF---%E6%B6%82%E7%A3%8A/"/>
    <id>http://yoursite.com/2019/03/07/人间词话---自我成长---涂磊/</id>
    <published>2019-03-07T14:54:18.000Z</published>
    <updated>2019-03-15T09:14:33.079Z</updated>
    
    <content type="html"><![CDATA[<ul><li>我们总是善于去伤害那些爱我们的人， 因为我们根本伤害不了那些不爱我们的人;我们总是甘愿被那些我们爱的人伤害，那是因为我爱他们</li><li>喜欢可以心动，而爱一定会心痛；喜欢可以舍得，但爱一定舍不得；喜欢一个人，冬天不过是冬天，不过是漂亮一点而已；但是爱一个人，冬天可以变成春天；爱一个人，她落泪你就会跟着她一起落泪；而喜欢一个人，她落泪你只不过是安慰；喜欢是可以变成爱的，但如果爱了就说不出喜欢；喜欢是不排她的，而爱一定是排她的，唯一的；喜欢与责任无关，而爱一定要负责任，这就是喜欢和爱的区别</li></ul><a id="more"></a><ul><li>春风得意的浪子回头最珍贵，穷途末路的认错悔改最虚伪</li><li>你曾经买了一件很喜欢的衣裳却舍不得穿，郑重地供奉在衣柜里；许久之后，当你再看见它的时候，却发现它已经过时了。所以，你就这样与它错过了。你也曾经买了一块漂亮的蛋糕却舍不得吃，郑重地供奉在冰箱里；许久之后，当你再看见它的时候，却发现它已经过期了。所以，你也这样与它错过了。没有在最喜欢的时候上身的衣裳，没有在最可口的时候品尝的蛋糕，就像没有在最想做的时候去做的事情，都是遗憾。生命也有保存期限，想做的事该趁早去做。如果你只是把你的心愿郑重地供奉在心里，却未曾去实行，那么唯一的结果，就是与它错过，一如那件过时的衣裳，一如那块过期的蛋糕</li><li>有些人注定是你生命中的过客，却总是成为你记忆中的常客，但永远也仅止于做客</li><li>你以为责任是什么？你以为责任就是终身相守，扔几个钱在家里。真正的责任是要在乎你所爱的人的每一分每一秒的感受</li><li>男人无事献殷勤非奸即盗，女人对爱来者不拒不是欺就是爱</li><li>人最伟大的力量不是创造，而是自省！如果不能自我反省，不能看到自身的错误和不足，即使有非凡的力量，创造出的一切都只是埋没自己的坟墓！</li><li>越是嘴上说自己有原则的人，越是圆滑，因为他们的原则便是永远不说负责任的话，永远模棱两可！狡猾的眼神中永远透露的是欺骗，向下的嘴角代表的永远是严肃。</li><li>在我看来，绝大多数现代人的虚荣来自于虚伪，虚伪来自于自卑！在日常生活中衣着光鲜、牛逼哄哄的家伙其实内心很恐慌！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;我们总是善于去伤害那些爱我们的人， 因为我们根本伤害不了那些不爱我们的人;我们总是甘愿被那些我们爱的人伤害，那是因为我爱他们&lt;/li&gt;
&lt;li&gt;喜欢可以心动，而爱一定会心痛；喜欢可以舍得，但爱一定舍不得；喜欢一个人，冬天不过是冬天，不过是漂亮一点而已；但是爱一个人，冬天可以变成春天；爱一个人，她落泪你就会跟着她一起落泪；而喜欢一个人，她落泪你只不过是安慰；喜欢是可以变成爱的，但如果爱了就说不出喜欢；喜欢是不排她的，而爱一定是排她的，唯一的；喜欢与责任无关，而爱一定要负责任，这就是喜欢和爱的区别&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="人间词话" scheme="http://yoursite.com/categories/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
    
      <category term="人间词话" scheme="http://yoursite.com/tags/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
      <category term="人生" scheme="http://yoursite.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
      <category term="智慧" scheme="http://yoursite.com/tags/%E6%99%BA%E6%85%A7/"/>
    
  </entry>
  
  <entry>
    <title>陈果老师语录</title>
    <link href="http://yoursite.com/2019/03/07/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E6%88%91%E6%88%90%E9%95%BF---%E9%99%88%E6%9E%9C/"/>
    <id>http://yoursite.com/2019/03/07/人间词话---自我成长---陈果/</id>
    <published>2019-03-07T14:54:18.000Z</published>
    <updated>2019-03-15T09:14:22.390Z</updated>
    
    <content type="html"><![CDATA[<ul><li>只有心灵才能洞察一切，世界上真正重要的东西要用心去看</li><li>你使用什么样的双眼观世界，就印证了你有怎样的心眼，如果心眼大，你所见的世界宽广无边，如果你心眼小，充满羡慕嫉妒恨，所见的世界也是偏狭丑陋</li><li>选择之所以称之为选择，一定是痛苦的，因为选项是不相上下的，能轻松做决定的，都不叫选择，选择意味着舍弃一种美好，承受一种痛苦，不安</li><li>回忆是一种重逢, 忘记是一份自由.</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;只有心灵才能洞察一切，世界上真正重要的东西要用心去看&lt;/li&gt;
&lt;li&gt;你使用什么样的双眼观世界，就印证了你有怎样的心眼，如果心眼大，你所见的世界宽广无边，如果你心眼小，充满羡慕嫉妒恨，所见的世界也是偏狭丑陋&lt;/li&gt;
&lt;li&gt;选择之所以称之为选择，一定是痛苦的，因为选项是不相上下的，能轻松做决定的，都不叫选择，选择意味着舍弃一种美好，承受一种痛苦，不安&lt;/li&gt;
&lt;li&gt;回忆是一种重逢, 忘记是一份自由.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="人间词话" scheme="http://yoursite.com/categories/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
    
      <category term="人间词话" scheme="http://yoursite.com/tags/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
      <category term="人生" scheme="http://yoursite.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
      <category term="智慧" scheme="http://yoursite.com/tags/%E6%99%BA%E6%85%A7/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---基础语法(1)</title>
    <link href="http://yoursite.com/2019/03/07/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95(1)/"/>
    <id>http://yoursite.com/2019/03/07/Java基础知识---基础语法(1)/</id>
    <published>2019-03-07T14:27:03.000Z</published>
    <updated>2019-03-22T03:27:46.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-标识符"><a href="#一-标识符" class="headerlink" title="一.标识符"></a>一.标识符</h1><p>​    对于各种变量, 方法和类等要素 <strong>命名时使用的字符序列</strong> 称为标识符</p><blockquote><p>凡是自己可以命名的地方都叫标识符, 都遵循标识符的规则</p></blockquote><a id="more"></a><h1 id="二-关键字"><a href="#二-关键字" class="headerlink" title="二.关键字"></a>二.关键字</h1><p>​    一些赋以特定的含义, <strong>用作专门用途的字符串</strong> 成为关键字</p><blockquote><p>大部分编辑会将关键字用特殊方式标出<br>所有Java关键字都是小写英文</p></blockquote><h1 id="三-java基础数据类型"><a href="#三-java基础数据类型" class="headerlink" title="三.  java基础数据类型"></a>三.  java基础数据类型</h1><h2 id="3-1-Java常量"><a href="#3-1-Java常量" class="headerlink" title="3.1 Java常量"></a>3.1 Java常量</h2><p>​    eg: 整型常量: 123, 字符常量: ‘a’</p><blockquote><p>注意: 区分字符常量和字符串常量<br>注意: “常量”这个名词还会用在另外其它语境中表示 <strong>值不可变的变量</strong> </p></blockquote><h2 id="3-2-Java变量"><a href="#3-2-Java变量" class="headerlink" title="3.2 Java变量"></a>3.2 Java变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量i(变量的名字)中存放常量100(变量的值)</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>; </span><br><span class="line"><span class="keyword">float</span> f = <span class="number">3.14</span>;</span><br><span class="line">String s = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><blockquote><p>变量是 <strong>内存</strong> 中的一小块区域, 使用 <strong>变量名</strong> 来访问这块区域<br>因此,每一个变量使用前必须要先 <strong>声明</strong>, 然后必须进行 <strong>赋值</strong> (填充内容), 才能使用</p></blockquote><h3 id="补充-本质上理解"><a href="#补充-本质上理解" class="headerlink" title="补充(本质上理解):"></a>补充(本质上理解):</h3><blockquote><ul><li>一个程序在运行的时候，实际上这个程序是位于内存里面，然后才开始运行。一个.exe文件 <strong>存放在硬盘上是无法运行的</strong> ，在硬盘上看到的.exe文件无非就是一个文件而已，当我们双击这个.exe文件时，运行起来的时候实际上是 <strong>整个.exe文件被放在了在内存里面</strong> ，然后操作系统找到main方法，也就是程序的入口，然后就开始执行了。执行的过程之中，<strong>会不断地在内存里面分配一些区域</strong> </li><li>变量在内存里面就是一小块区域，变量有两个概念，一个是变量的名字，另一个是变量的值<br>即这一小块区域是有名字的，里面装着一个值，因此以后要想访问这小块区域里面的内容就可以根据这小块区域的名字来访问了。因此，<strong>变量的本质就是一小块内存区域</strong> 。<br><strong>变量在内存里面分配多大的存储空间呢？</strong> 答: 不同的变量类型分配不同大小的存储空间，每一个变量都是属于特定的数据类型的，声明成不同的数据类型，它就在内存里面分配不同的存储空间。</li></ul></blockquote><h3 id="Java变量的分类"><a href="#Java变量的分类" class="headerlink" title="Java变量的分类:"></a>Java变量的分类:</h3><p>按被声明的 <strong>位置</strong> 划分:</p><ul><li>局部变量: <strong>方法或语句块内部</strong>定义的变量</li><li>成员变量: <strong>方法外部, 类的内部</strong>定义的变量</li></ul><blockquote><p>类外面不能有变量的声明</p></blockquote><p>按所属数据的 <strong>数据类型</strong> 划分:</p><ul><li><strong>基本</strong>数据类型变量</li><li><strong>引用</strong>数据类型变量</li></ul><h2 id="3-3-Java数据类型"><a href="#3-3-Java数据类型" class="headerlink" title="3.3 Java数据类型"></a>3.3 Java数据类型</h2><h3 id="3-3-1-基本数据类型"><a href="#3-3-1-基本数据类型" class="headerlink" title="3.3.1 基本数据类型"></a>3.3.1 基本数据类型</h3><ul><li><strong>整数型:</strong> byte, short, int, long,</li><li><strong>浮动型:</strong> float, double</li><li><strong>布尔型:</strong> bool</li><li><strong>字符型:</strong> char</li></ul><h3 id="3-3-2-基本数据类型的转换"><a href="#3-3-2-基本数据类型的转换" class="headerlink" title="3.3.2 基本数据类型的转换"></a>3.3.2 基本数据类型的转换</h3><ul><li>boolean 类型不可以转换为其他的数据类型</li><li>容量小的类型自动转换为容量大的数据类型</li><li>容量大的类型转换为容量小的数据类型时, 要加上强制转换符,可能造成精度降低或溢出</li><li>有多种类型的数据混合运算时,系统首先自动的将所有数据类型转换成 <strong>容量最大</strong> 的那一种数据类型,然后在进行计算</li></ul><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConvert</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">123</span>; </span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">456</span>;</span><br><span class="line">        <span class="keyword">double</span> d1 = (i1+i2)*<span class="number">1.2</span>;<span class="comment">//系统将转换为double型运算</span></span><br><span class="line">        <span class="keyword">float</span> f1 = (<span class="keyword">float</span>)((i1+i2)*<span class="number">1.2</span>);<span class="comment">//需要加强制转换符</span></span><br><span class="line">        <span class="keyword">byte</span> b1 = <span class="number">67</span>; </span><br><span class="line">        <span class="keyword">byte</span> b2 = <span class="number">89</span>;</span><br><span class="line">        <span class="keyword">byte</span> b3 = (<span class="keyword">byte</span>)(b1+b2);<span class="comment">//系统将转换为int型运算，需要强制转换符</span></span><br><span class="line">        System.out.println(b3);</span><br><span class="line">        <span class="keyword">double</span> d2 = <span class="number">1e200</span>;</span><br><span class="line">        <span class="keyword">float</span> f2 = (<span class="keyword">float</span>)d2;<span class="comment">//会产生溢出</span></span><br><span class="line">        System.out.println(f2);</span><br><span class="line">        <span class="keyword">float</span> f3 = <span class="number">1.23f</span>;<span class="comment">//必须加f</span></span><br><span class="line">        <span class="keyword">long</span> l1 = <span class="number">123</span>;</span><br><span class="line">        <span class="keyword">long</span> l2 = <span class="number">30000000000L</span>;<span class="comment">//必须加l</span></span><br><span class="line">        <span class="keyword">float</span> f = l1+l2+f3;<span class="comment">//系统将转换为float型计算</span></span><br><span class="line">        <span class="keyword">long</span> l = (<span class="keyword">long</span>)f;<span class="comment">//强制转换会舍去小数部分（不是四舍五入）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-3-引用数据类型"><a href="#3-3-3-引用数据类型" class="headerlink" title="3.3.3 引用数据类型"></a>3.3.3 引用数据类型</h3><ul><li>类(class)</li><li>接口(interface)</li><li>数组</li></ul><h1 id="四-表达式"><a href="#四-表达式" class="headerlink" title="四. 表达式"></a>四. 表达式</h1><p>以 <strong><code>;</code></strong> 结尾的一段代码，即为一个表达式</p><h5 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是两个表达式</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> b = a;</span><br></pre></td></tr></table></figure><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>条件运算符由两个符号组成”<strong>?</strong>“和”<strong>:</strong>“, 要求有3个操作对象,所以也叫它三目运算符</p><p>一般形式为 : <code>表达式1?表达式2:表达式3;</code></p><h5 id="范例-2"><a href="#范例-2" class="headerlink" title="范例"></a>范例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a&lt;b)</span><br><span class="line">    min = a;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    mi n= b;</span><br><span class="line"><span class="comment">// 可以用下面的条件运算符来处理</span></span><br><span class="line"><span class="comment">// 执行过程: 如果 a&lt;b 为真,则表达式取a值, 否则取b值.</span></span><br><span class="line">min = (a&lt;b)?a:b;</span><br></pre></td></tr></table></figure><hr><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文:"></a>参考博文:</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3624567.html" target="_blank" rel="noopener">java基础学习总结——基础语法1</a></p><p>​    <a href="https://www.cnblogs.com/jesonjason/p/5023040.html" target="_blank" rel="noopener">Java中的三目运算符 详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-标识符&quot;&gt;&lt;a href=&quot;#一-标识符&quot; class=&quot;headerlink&quot; title=&quot;一.标识符&quot;&gt;&lt;/a&gt;一.标识符&lt;/h1&gt;&lt;p&gt;​    对于各种变量, 方法和类等要素 &lt;strong&gt;命名时使用的字符序列&lt;/strong&gt; 称为标识符&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;凡是自己可以命名的地方都叫标识符, 都遵循标识符的规则&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Hexo---常用命令</title>
    <link href="http://yoursite.com/2019/03/07/Hexo---%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/03/07/Hexo---常用命令/</id>
    <published>2019-03-07T02:59:05.000Z</published>
    <updated>2019-03-19T07:19:30.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-写文章"><a href="#1-写文章" class="headerlink" title="1. 写文章"></a>1. 写文章</h2><ul><li>写文章<br> 你可以执行下列命令来创建一篇新文章。</li></ul><blockquote><p>hexo new  <title>    #新建文章，可以改成中文的，如“新文章”，如果标题包含空格的话，请使用引号括起来。</title></p></blockquote><ul><li>删除文章<br> 先删除目标文章，然后重新运行</li></ul><blockquote><p>hexo clean # 清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)<br> hexo g -d # 文件生成后立即部署网站</p></blockquote><a id="more"></a><ul><li>写完文章后，你可以使用</li></ul><blockquote><p>hexo g  # 全称<code>hexo generate</code> , 生成静态文件（generate：产生）<br> hexo s  # 全称<code>hexo server</code> , 启动服务器，默认情况下，访问网址为<code>http://localhost:4000/</code>在本地预览效果<br> hexo d  # 全称<code>hexo deploy</code>, 部署网站，同步到github上（deploy：部署）</p></blockquote><h2 id="2-分类和标签"><a href="#2-分类和标签" class="headerlink" title="2. 分类和标签"></a>2. 分类和标签</h2><ul><li>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title: Hello World</span><br><span class="line">date: <span class="number">2013</span>/<span class="number">7</span>/<span class="number">13</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">25</span></span><br></pre></td></tr></table></figure><ul><li>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用</li></ul><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>layout</code></td><td>布局</td><td></td></tr><tr><td><code>title</code></td><td>标题</td><td></td></tr><tr><td><code>date</code></td><td>建立日期</td><td>文件建立日期</td></tr><tr><td><code>updated</code></td><td>更新日期</td><td>文件更新日期</td></tr><tr><td><code>comments</code></td><td>开启文章的评论功能</td><td>true</td></tr><tr><td><code>tags</code></td><td>标签（不适用于分页）</td><td></td></tr><tr><td><code>categories</code></td><td>分类（不适用于分页）</td><td></td></tr><tr><td><code>permalink</code></td><td>覆盖文章网址</td></tr></tbody></table><ul><li><p>分类和标签</p><p>只有文章支持分类和标签，您可以在 <code>Front-matter</code> 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：<strong>分类具有顺序性和层次性</strong>，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br><span class="line"><span class="comment"># 会使分类Games成为PS3的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-写文章&quot;&gt;&lt;a href=&quot;#1-写文章&quot; class=&quot;headerlink&quot; title=&quot;1. 写文章&quot;&gt;&lt;/a&gt;1. 写文章&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;写文章&lt;br&gt; 你可以执行下列命令来创建一篇新文章。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;hexo new  &lt;title&gt;    #新建文章，可以改成中文的，如“新文章”，如果标题包含空格的话，请使用引号括起来。&lt;/title&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;删除文章&lt;br&gt; 先删除目标文章，然后重新运行&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;hexo clean # 清除缓存文件 (&lt;code&gt;db.json&lt;/code&gt;) 和已生成的静态文件 (&lt;code&gt;public&lt;/code&gt;)&lt;br&gt; hexo g -d # 文件生成后立即部署网站&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java面试经典题目（1-5题）</title>
    <link href="http://yoursite.com/2019/03/07/Java%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE(1-5%E9%A2%98)/"/>
    <id>http://yoursite.com/2019/03/07/Java面试经典题目(1-5题)/</id>
    <published>2019-03-07T02:00:00.000Z</published>
    <updated>2019-03-19T03:32:55.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h1><p>答案：</p><blockquote><p>运行原理：Java源程序经过<code>javac</code> 编译器编译成二进制的<code>xx.class</code> 字节码文件, <code>xx.class</code> 在<strong>jvm</strong>（各平台装有不同的jvm）上运行，Java解释器（jvm的一部分）会将<strong>相同的字节码</strong>解释成对应平台的机器码，进而执行。</p></blockquote><a id="more"></a><p>知识：</p><blockquote><p>一份 <code>xx.class</code> 文件(不会变化）被 <strong>不同的jvm</strong> 解释成 <strong>相对应的机器码</strong> </p><p><strong>机器码:</strong> 依附于硬件，根本不存在跨平台行，不同型号的CPU给相同的指令（eg：10011110）,解析成不同的结果</p></blockquote><p>题外知识：</p><blockquote><p><strong>JDK</strong> (Java Development Kit): Java开发工具包，针对于<strong>Java开发员的产品</strong>，JDK是整个Java的核心，包括了JRE, Java工具（Javac【编译Java源码的编译器】，Java程序调试和分析的工具）和Java基础的类库（即Java API)</p><p><strong>JRE</strong> (Java runtime environment)：Java运行环境 ,针对于<strong>使用Java程序的用户</strong>，Java程序运行做需要的软件环境，不是一个开发环境, 包含jvm，Java基础类库, 不包含任何开发工具（如编译器和调试器）。</p><p><strong>JVM</strong> (Java Virtual Machine): Java虚拟机，实现Java跨平台的最核心的部分，JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行</p></blockquote><h1 id="2-JDK和JRE的区别是什么？"><a href="#2-JDK和JRE的区别是什么？" class="headerlink" title="2. JDK和JRE的区别是什么？"></a>2. JDK和JRE的区别是什么？</h1><p>答案：</p><blockquote><p>详细区别见第一题</p><p>如果需要运行Java程序，只需要安装JRE（JRE根据不同操作系统有很多不同的版本）</p><p>如果需要编写Java程序，需要安装JDK</p></blockquote><p>补充知识：</p><blockquote><p>JRE和JVM的区别是什么？</p><p>JRE包括JVM和lib（Jvm所需要的类库），JRE里有运行<code>xx.class</code> 的<code>Java.exe</code> </p><p>只有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库</p></blockquote><p>时间：2019.3.7</p><h1 id="3-”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？"><a href="#3-”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？" class="headerlink" title="3. ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？"></a>3. ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</h1><p>答案:</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p> 表示静态的意思, 可用于修饰 <strong>成员变量</strong>和 <strong>方法</strong> , 静态是随着类的加载而加载, 因此可以直接用类进行访问</p><h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>私有的方法不能被继承，子类就没有访问权限</p><h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><ul><li><p>覆盖基于运动时动态绑定的</p></li><li><p>指覆盖了一个方法并且对其重写，以求达到不同的作用,，但是子类中的访问权限要不低于父类中的访问权限,重写的前提是必须要继承.</p></li></ul><p>Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。 </p><p>私有的方法不能被继承，子类就没有访问权限，肯定也是不能别覆盖的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span>&#123;</span><br><span class="line">   <span class="comment">// 静态方法</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> String <span class="title">greeting</span><span class="params">()</span></span>&#123;   </span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Good night"</span>;   </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function">String <span class="title">name</span><span class="params">()</span></span>&#123;   </span><br><span class="line">     <span class="keyword">return</span> <span class="string">"Richard"</span>;   </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span></span>&#123;   <span class="comment">//子方法,继承Super</span></span><br><span class="line">   <span class="comment">//重写(覆盖)父类当中的静态方法</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> String <span class="title">greeting</span><span class="params">()</span></span>&#123;   </span><br><span class="line">     <span class="keyword">return</span> <span class="string">"Hello"</span>;   </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function">String <span class="title">name</span><span class="params">()</span></span>&#123;   </span><br><span class="line">     <span class="keyword">return</span> <span class="string">"Dick"</span>;   </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;   </span><br><span class="line">    Super s = <span class="keyword">new</span> Sub();   </span><br><span class="line">    System.out.println(s.greeting()+<span class="string">","</span>+s.name());   </span><br><span class="line"></span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：Good night,Dick (静态方法打印的是父类中的)</span></span><br><span class="line"><span class="comment">//这个例子说明“实例方法被覆盖，静态方法被隐藏”</span></span><br></pre></td></tr></table></figure><h1 id="4-是否可以在static环境中访问非static变量？"><a href="#4-是否可以在static环境中访问非static变量？" class="headerlink" title="4. 是否可以在static环境中访问非static变量？"></a>4. 是否可以在static环境中访问非static变量？</h1><p>答案:</p><p>不可以</p><blockquote><p><strong>因为静态的成员属于类，随着类的加载而加载到静态方法区内存，当类加载时，此时不一定有实例创建，没有实例，就不可以访问非静态的成员。</strong></p><p>静态变量属于类变量，随着类的加载而加载，当调用类变量时Java虚拟机会对类的静态变量，静态方法进行初始化，此时如果静态方法中有非静态变量，由于非静态变量是随着实例的创建而创建，此时还没有实例创建，所以非静态变量还没有创建，所以会出现编译错误。  </p></blockquote><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文:"></a>参考博文:</h5><p>​    <a href="https://www.nowcoder.com/questionTerminal/129a7ff6cfeb45ae9d456d9efed69acd" target="_blank" rel="noopener">牛客网优质答案</a></p><p>时间: 2019.3.11</p><h1 id="5-Java支持的数据类型有哪些？什么是自动拆装箱？"><a href="#5-Java支持的数据类型有哪些？什么是自动拆装箱？" class="headerlink" title="5. Java支持的数据类型有哪些？什么是自动拆装箱？"></a>5. Java支持的数据类型有哪些？什么是自动拆装箱？</h1><p>答案:</p><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul><li><strong>整数型:</strong> byte, short, int, long,</li><li><strong>浮动型:</strong> float, double</li><li><strong>布尔型:</strong> bool</li><li><strong>字符型:</strong> char</li></ul><blockquote><p>整数默认int型，小数默认是double型。Float和long类型的必须加后缀。</p></blockquote><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul><li>引用类型也就是我们常说的对象，在Java中每个基础类型的数据都有其包装类，对应上面分别是：<br><strong>Byte, Short, Int, Long, Float, Double, Char, Boolean</strong></li><li>引用类型包括类、数组、接口, String等</li></ul><h4 id="自动装箱和拆箱就是基本类型和引用类型之间的转换"><a href="#自动装箱和拆箱就是基本类型和引用类型之间的转换" class="headerlink" title="自动装箱和拆箱就是基本类型和引用类型之间的转换"></a>自动装箱和拆箱就是基本类型和引用类型之间的转换</h4><ul><li><p>装箱：将基本类型转换成引用类型，如 <code>Integer i = 10;</code></p></li><li><p>拆箱：将引用类型转换成基础类型，如 <code>Integer i = 10;  int j = i;</code></p></li></ul><blockquote><p>转化为引用类型之后，就可以new一个对象，从而就可以调用包装类型中的封装好的方法，方便使用</p></blockquote><h5 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h5><p>​    <a href="https://www.nowcoder.com/questionTerminal/a5eb239111024d1b90cf00f24cfee36f" target="_blank" rel="noopener">牛客网优质答案</a></p><p>时间: 2019.3.12</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？&quot;&gt;&lt;a href=&quot;#1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？&quot;&gt;&lt;/a&gt;1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？&lt;/h1&gt;&lt;p&gt;答案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;运行原理：Java源程序经过&lt;code&gt;javac&lt;/code&gt; 编译器编译成二进制的&lt;code&gt;xx.class&lt;/code&gt; 字节码文件, &lt;code&gt;xx.class&lt;/code&gt; 在&lt;strong&gt;jvm&lt;/strong&gt;（各平台装有不同的jvm）上运行，Java解释器（jvm的一部分）会将&lt;strong&gt;相同的字节码&lt;/strong&gt;解释成对应平台的机器码，进而执行。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java面试常考题目" scheme="http://yoursite.com/categories/java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java面试常考题目" scheme="http://yoursite.com/tags/java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>人间词话---惊艳的文字</title>
    <link href="http://yoursite.com/2019/03/06/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E6%83%8A%E8%89%B3%E7%9A%84%E6%96%87%E5%AD%97/"/>
    <id>http://yoursite.com/2019/03/06/人间词话---惊艳的文字/</id>
    <published>2019-03-06T13:57:13.000Z</published>
    <updated>2019-03-15T09:15:11.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="现代诗"><a href="#现代诗" class="headerlink" title="现代诗"></a>现代诗</h3><ul><li>酒入豪肠，七分酿成了月光，余下的三分啸成剑气，绣口一吐，就半个盛唐。   —余光中《寻李白》</li></ul><a id="more"></a><h3 id="古诗"><a href="#古诗" class="headerlink" title="古诗"></a>古诗</h3><ul><li>少年不知愁滋味,爱上层楼,爱上层楼.为赋新词强说愁.而今识尽愁滋味,欲说还休,欲说还休,却道天凉好个秋.  —辛弃疾《丑奴儿》</li><li>十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。料得年年肠断处，明月夜，短松冈。    —苏轼</li></ul><h3 id="古文"><a href="#古文" class="headerlink" title="古文"></a>古文</h3><ul><li>斯是陋室,惟吾德馨.   —刘禹锡《陋室铭》</li><li>夏虫不可语冰   —孔子</li></ul><h3 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h3><ul><li>我知道我很大胆冒昧, 听说你朋友很多, 我不配高攀, 可是很想在你的朋友里凑个数目.   —钱钟书《围城》</li><li>别客气,我求你明天来.我想去吃,对自己没有好借口,借你的名义,自己享受一下,你就体贴下情,答应了吧.   —钱钟书《围城》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;现代诗&quot;&gt;&lt;a href=&quot;#现代诗&quot; class=&quot;headerlink&quot; title=&quot;现代诗&quot;&gt;&lt;/a&gt;现代诗&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;酒入豪肠，七分酿成了月光，余下的三分啸成剑气，绣口一吐，就半个盛唐。   —余光中《寻李白》&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="人间词话" scheme="http://yoursite.com/categories/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
    
      <category term="人间词话" scheme="http://yoursite.com/tags/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>人间词话---文章</title>
    <link href="http://yoursite.com/2019/03/06/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E6%96%87%E7%AB%A0/"/>
    <id>http://yoursite.com/2019/03/06/人间词话---文章/</id>
    <published>2019-03-06T13:57:13.000Z</published>
    <updated>2019-03-15T09:15:20.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="感谢困难"><a href="#感谢困难" class="headerlink" title="感谢困难"></a>感谢困难</h1><p>​                                                                                林清玄<br>​    我做了一个梦。</p><p>　　梦见我在街上问人：“请问您可不可以给我一些困难、一些挫折，一些痛苦?”</p><p>　　所有的人都拒绝我，我着急地恳求别人：“那么，我雇用您，每小时五百元，请您给我一些折磨!”</p><p>　　那些陌生人摇摇头，沉默地离开，我因找不到愿意折磨我的人而惊醒。</p><p>　　我坐在床上发呆，是呀!困难，折磨，痛苦是多么珍贵!如果一切平顺，谁会静下来沉思，谁会生起智慧，谁又能在平凡安逸的日子中超越自我、登上高峰呢?</p><p>　　如果没有困难，谁又会谦卑地跪下来祈祷?谁又能相信有无边的宇宙?谁又能寄情于来生呢?</p><p>　　我深深地感谢着困难、挫折与痛苦。</p><p>　　也深深地感恩那些曾经折磨过我的人，他们是多么慈悲呀!我并未花钱聘雇他们，他们却以宝贵的时间来考验我、提升我，为了增长我的智慧。</p><a id="more"></a><h1 id="真正的高贵"><a href="#真正的高贵" class="headerlink" title="真正的高贵"></a>真正的高贵</h1><p>​                                                                                海明威</p><p>​    在风平浪静的大海，每个人都是领航员。</p><p>​    但是，只有阳光而无阴影，只有欢乐而无痛苦，那就不是人生。以最幸福的人的生活为例.他的生活也是一团缠结在一起的乱麻。痛苦与幸福交替出现,使得我们一会悲伤，一会高兴，甚至死亡本身也会使生命更加可爱。在人生的清醒的时刻，在悲伤与失落的阴影之下，人们与真实的自我最接近。</p><p>​    在生活和事业的种种事物中，性格比才智更能指导我们, 心灵比头脑更能引导我们,而由判断获得的克制, 耐心和教养比天分更能让我们受益。</p><p>​    我始终相信，内心生活开始更为严谨的人，他的外在生活也会变得更为简朴。在一个物欲横流的年代，但愿我能向世人表明，人类真正需求少得多么可怜。</p><p>​    反思自己的过错不至于重蹈覆辙才是真正的悔悟, 高人一等并没有什么值得夸耀的。真正的高贵是优于过去的自己。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;感谢困难&quot;&gt;&lt;a href=&quot;#感谢困难&quot; class=&quot;headerlink&quot; title=&quot;感谢困难&quot;&gt;&lt;/a&gt;感谢困难&lt;/h1&gt;&lt;p&gt;​                                                                                林清玄&lt;br&gt;​    我做了一个梦。&lt;/p&gt;
&lt;p&gt;　　梦见我在街上问人：“请问您可不可以给我一些困难、一些挫折，一些痛苦?”&lt;/p&gt;
&lt;p&gt;　　所有的人都拒绝我，我着急地恳求别人：“那么，我雇用您，每小时五百元，请您给我一些折磨!”&lt;/p&gt;
&lt;p&gt;　　那些陌生人摇摇头，沉默地离开，我因找不到愿意折磨我的人而惊醒。&lt;/p&gt;
&lt;p&gt;　　我坐在床上发呆，是呀!困难，折磨，痛苦是多么珍贵!如果一切平顺，谁会静下来沉思，谁会生起智慧，谁又能在平凡安逸的日子中超越自我、登上高峰呢?&lt;/p&gt;
&lt;p&gt;　　如果没有困难，谁又会谦卑地跪下来祈祷?谁又能相信有无边的宇宙?谁又能寄情于来生呢?&lt;/p&gt;
&lt;p&gt;　　我深深地感谢着困难、挫折与痛苦。&lt;/p&gt;
&lt;p&gt;　　也深深地感恩那些曾经折磨过我的人，他们是多么慈悲呀!我并未花钱聘雇他们，他们却以宝贵的时间来考验我、提升我，为了增长我的智慧。&lt;/p&gt;
    
    </summary>
    
      <category term="人间词话" scheme="http://yoursite.com/categories/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
    
      <category term="人间词话" scheme="http://yoursite.com/tags/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>Java常见简写</title>
    <link href="http://yoursite.com/2019/02/28/Java%E5%B8%B8%E8%A7%81%E7%AE%80%E5%86%99/"/>
    <id>http://yoursite.com/2019/02/28/Java常见简写/</id>
    <published>2019-02-28T07:29:27.000Z</published>
    <updated>2019-03-19T03:32:54.680Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h4><p> <strong>Object Relational Mapping</strong>  对象关系映射</p><blockquote><p>对象和关系数据库的映射<br>简单说，一个对象，对应数据库里的一条记录</p></blockquote><a id="more"></a><h4 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h4><p>Data Access Object的缩写，这些类专门用于进行数据库访问的操作</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;ORM&quot;&gt;&lt;a href=&quot;#ORM&quot; class=&quot;headerlink&quot; title=&quot;ORM&quot;&gt;&lt;/a&gt;ORM&lt;/h4&gt;&lt;p&gt; &lt;strong&gt;Object Relational Mapping&lt;/strong&gt;  对象关系映射&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对象和关系数据库的映射&lt;br&gt;简单说，一个对象，对应数据库里的一条记录&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>曾仕强教授语录</title>
    <link href="http://yoursite.com/2019/01/10/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E6%88%91%E6%88%90%E9%95%BF---%E6%9B%BE%E4%BB%95%E5%BC%BA/"/>
    <id>http://yoursite.com/2019/01/10/人间词话---自我成长---曾仕强/</id>
    <published>2019-01-10T14:19:18.000Z</published>
    <updated>2019-03-15T09:14:38.862Z</updated>
    
    <content type="html"><![CDATA[<ul><li>很多事情，从不同的角度看，才能体会到其中的奥妙</li><li>做一个领导者，一定要充分了解下属的特性是什么，及时的下达合理的命令，而且效果要非常的良好，此为将才</li><li>事事都透露着一个人的能力</li><li>顾全大局，大局的前提底下，很多细小的事情，不用太过于考虑</li></ul><a id="more"></a><ul><li>一件事，从不同的角度看，都有道理，怎么讲都对，不是对不对的事，是价值观的体现</li><li>得意勿忘形，人在得意时，千万不能忘形，做事情随他爱怎样怎样，变为得意忘形，当一个人处于逆境的时候，他还会谨慎一点，当一个人处顺境的时候，他就开始沉不住气</li><li>形势比人强</li><li>人生的理想在于不断提升自己的层次</li><li>有智慧没知识容易陷入空想，一事无成。有知识没智慧，就不要埋怨被人当做工具使用，用毕即弃。要善用智慧来运用知识，以求合理的表现</li><li>处逆境容易，正因留意，处顺境很难，正因大意</li><li>你要很谨慎地去保留你独特的地方，这个独特之处就是你之所以为人的地方。能够自我成全，才是人最伟大的地方</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;很多事情，从不同的角度看，才能体会到其中的奥妙&lt;/li&gt;
&lt;li&gt;做一个领导者，一定要充分了解下属的特性是什么，及时的下达合理的命令，而且效果要非常的良好，此为将才&lt;/li&gt;
&lt;li&gt;事事都透露着一个人的能力&lt;/li&gt;
&lt;li&gt;顾全大局，大局的前提底下，很多细小的事情，不用太过于考虑&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="人间词话" scheme="http://yoursite.com/categories/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
    
      <category term="人间词话" scheme="http://yoursite.com/tags/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
      <category term="人生" scheme="http://yoursite.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
      <category term="智慧" scheme="http://yoursite.com/tags/%E6%99%BA%E6%85%A7/"/>
    
  </entry>
  
</feed>
