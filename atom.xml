<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sladning</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-14T01:11:57.275Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>刻在心里的坚强</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础知识(2)-基础语法(2)</title>
    <link href="http://yoursite.com/2019/03/14/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-2-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-2/"/>
    <id>http://yoursite.com/2019/03/14/Java基础知识-2-基础语法-2/</id>
    <published>2019-03-14T01:01:23.000Z</published>
    <updated>2019-03-14T01:11:57.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-语句"><a href="#一-语句" class="headerlink" title="一. 语句"></a>一. 语句</h1><h2 id="1-1-条件语句"><a href="#1-1-条件语句" class="headerlink" title="1.1 条件语句"></a>1.1 条件语句</h2><ul><li>if 语句</li><li>switch 语句</li></ul><h2 id="1-2-循环语句"><a href="#1-2-循环语句" class="headerlink" title="1.2 循环语句"></a>1.2 循环语句</h2><ul><li>for 循环语句</li><li>while 循环与do while 循环</li></ul><h2 id="1-3-break-和-continue-语句"><a href="#1-3-break-和-continue-语句" class="headerlink" title="1.3 break 和 continue 语句"></a>1.3 break 和 continue 语句</h2>  <a id="more"></a><h1 id="二-方法"><a href="#二-方法" class="headerlink" title="二. 方法"></a>二. 方法</h1><p>​    一段用来<strong>完成特定功能</strong>的代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符<span class="number">1</span> 修饰符<span class="number">2</span> ...] 返回值类型 方法名(形式参数列表) &#123;</span><br><span class="line">java 语句;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>方法可以有返回值，但可以不用这个返回值</strong>。方法首先要定义，然后才能调用</p></blockquote><h1 id="三、变量的作用域"><a href="#三、变量的作用域" class="headerlink" title="三、变量的作用域"></a>三、<strong>变量的作用域</strong></h1><p>​    变量的作用域只在“{  }”有效，出了这个“{  }”就没有作用了</p><h1 id="四、递归调用"><a href="#四、递归调用" class="headerlink" title="四、递归调用"></a>四、<strong>递归调用</strong></h1><p>　　递归：<strong>在一个方法内部对自身的调用就称为递归</strong></p><blockquote><p>具体的参考 <strong>孤傲苍狼</strong> 博客</p></blockquote><h1 id="五、程序的执行过程"><a href="#五、程序的执行过程" class="headerlink" title="五、程序的执行过程"></a>五、<strong>程序的执行过程</strong></h1><p><a href="https://sladning.github.io/2019/03/14/test/" target="_blank" rel="noopener">程序执行过程</a></p><p><img src="/2019/03/14/Java基础知识-2-基础语法-2/chengxu.png" alt="chengxu"></p><p>参考博文:<br>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3627241.html" target="_blank" rel="noopener">java基础学习总结——基础语法2</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-语句&quot;&gt;&lt;a href=&quot;#一-语句&quot; class=&quot;headerlink&quot; title=&quot;一. 语句&quot;&gt;&lt;/a&gt;一. 语句&lt;/h1&gt;&lt;h2 id=&quot;1-1-条件语句&quot;&gt;&lt;a href=&quot;#1-1-条件语句&quot; class=&quot;headerlink&quot; title=&quot;1.1 条件语句&quot;&gt;&lt;/a&gt;1.1 条件语句&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;if 语句&lt;/li&gt;
&lt;li&gt;switch 语句&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-循环语句&quot;&gt;&lt;a href=&quot;#1-2-循环语句&quot; class=&quot;headerlink&quot; title=&quot;1.2 循环语句&quot;&gt;&lt;/a&gt;1.2 循环语句&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;for 循环语句&lt;/li&gt;
&lt;li&gt;while 循环与do while 循环&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-3-break-和-continue-语句&quot;&gt;&lt;a href=&quot;#1-3-break-和-continue-语句&quot; class=&quot;headerlink&quot; title=&quot;1.3 break 和 continue 语句&quot;&gt;&lt;/a&gt;1.3 break 和 continue 语句&lt;/h2&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="基础语法" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://yoursite.com/2019/03/14/test/"/>
    <id>http://yoursite.com/2019/03/14/test/</id>
    <published>2019-03-14T00:43:00.000Z</published>
    <updated>2019-03-14T00:44:18.250Z</updated>
    
    <content type="html"><![CDATA[<p>测试图片</p><p><img src="/2019/03/14/test/chengxu.png" alt="chengxu"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;测试图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/03/14/test/chengxu.png&quot; alt=&quot;chengxu&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaWeb---Servlet开发(二)</title>
    <link href="http://yoursite.com/2019/03/13/JavaWeb---Servlet%E5%BC%80%E5%8F%91(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2019/03/13/JavaWeb---Servlet开发(二)/</id>
    <published>2019-03-13T13:41:51.000Z</published>
    <updated>2019-03-13T13:41:16.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-ServletConfig讲解"><a href="#一-ServletConfig讲解" class="headerlink" title="一. ServletConfig讲解"></a>一. ServletConfig讲解</h2><h3 id="1-1-配置Servlet初始化参数"><a href="#1-1-配置Servlet初始化参数" class="headerlink" title="1.1. 配置Servlet初始化参数"></a>1.1. 配置Servlet初始化参数</h3><p>　　在Servlet的配置文件web.xml中，可以使用一个或多个<init-param>标签为servlet配置一些初始化参数。</init-param></p><p>参考博文:</p><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3763559.html" target="_blank" rel="noopener">javaweb学习总结(六)——Servlet开发(二)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-ServletConfig讲解&quot;&gt;&lt;a href=&quot;#一-ServletConfig讲解&quot; class=&quot;headerlink&quot; title=&quot;一. ServletConfig讲解&quot;&gt;&lt;/a&gt;一. ServletConfig讲解&lt;/h2&gt;&lt;h3 id=&quot;1-1
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/Java/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---Servlet开发(一)</title>
    <link href="http://yoursite.com/2019/03/13/JavaWeb---Servlet%E5%BC%80%E5%8F%91(%E4%B8%80)/"/>
    <id>http://yoursite.com/2019/03/13/JavaWeb---Servlet开发(一)/</id>
    <published>2019-03-13T13:23:51.000Z</published>
    <updated>2019-03-13T13:34:59.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-Servlet简介"><a href="#一-Servlet简介" class="headerlink" title="一. Servlet简介"></a>一. Servlet简介</h1><p>Servlet是sun公司提供的一门用于<strong>开发动态web资源的技术</strong></p><p>若想用发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤：</p><ol><li><p>编写一个Java类，<strong>实现servlet接口</strong>。</p></li><li><p>把开发好的Java类<strong>部署到web服务器</strong>中。</p></li></ol><p>按照一种约定俗成的称呼习惯，通常我们也把实现了<strong>servlet接口的java程序</strong>，称之为<strong>Servlet</strong></p><h2 id="二-Servlet的运行过程"><a href="#二-Servlet的运行过程" class="headerlink" title="二. Servlet的运行过程"></a>二. Servlet的运行过程</h2><p>Servlet程序是由<strong>WEB服务器</strong>调用，web服务器<strong>收到客户端的Servlet访问请求</strong>后：<br>　　①Web服务器首先<strong>检查是否已经装载并创建</strong>了该Servlet的<strong>实例对象</strong>。如果是，则直接执行第④步，否则，执行第②步。<br>　　②装载并创建该Servlet的一个实例对象。<br>　　③调用Servlet实例对象的<strong>init()方法</strong>。<br>　　④创建一个用于封装<strong>HTTP请求消息的HttpServletRequest对象</strong>和一个<strong>代表HTTP响应消息的HttpServletResponse对象</strong>，然后调用Servlet的<strong>service()方法</strong>并将<strong>请求和响应对象</strong>作为参数传递进去。<br>　　⑤WEB应用程序被<strong>停止或重新启动之前</strong>，Servlet引擎将<strong>卸载Servlet</strong>，并在卸载之前调用Servlet的destroy()方法。</p><h1 id="三-Servlet接口实现类"><a href="#三-Servlet接口实现类" class="headerlink" title="三. Servlet接口实现类"></a>三. Servlet接口实现类</h1><p>　　Servlet接口SUN公司定义了两个默认实现类，分别为：<strong>GenericServlet、HttpServlet</strong>。</p><p>　　<strong>==HttpServlet==</strong>指能够处理HTTP请求的servlet，它在原有Servlet接口上添加了一些与HTTP协议处理方法，它比Servlet接口的功能更为强大。因此开发人员在编写Servlet时，<strong>通常应继承这个类</strong>，而避免直接去实现Servlet接口。<br>　　HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会<strong>自动判断用户的请求方式</strong>，如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。因此，开发人员在编写Servlet时，<strong>通常只需要覆写doGet或doPost方法，而不要去覆写service方法</strong></p><h1 id="四-Servlet开发注意细节"><a href="#四-Servlet开发注意细节" class="headerlink" title="四. Servlet开发注意细节"></a>四. Servlet开发注意细节</h1><h2 id="4-1-Servlet访问URL映射配置"><a href="#4-1-Servlet访问URL映射配置" class="headerlink" title="4.1 Servlet访问URL映射配置"></a>4.1 Servlet访问URL映射配置</h2><p>　　由于客户端是通过<strong>URL地址访问web服务器中的资源</strong>，所以Servlet程序若想被外界访问，必须把servlet程序映射到一个URL地址上，这个工作在==<strong>web.xml文件</strong>==中使用<code>&lt;servlet&gt;</code>元素和<code>&lt;servlet-mapping&gt;</code>元素完成。</p><ul><li><code>&lt;servlet&gt;</code>元素用于<strong>注册Servlet</strong>，它包含有两个主要的子元素：<code>&lt;servlet-name&gt;</code>和<code>&lt;servlet-class&gt;</code>，分别用于设置<strong>Servlet的注册名称</strong>和<strong>Servlet的完整类名</strong>。 </li><li><code>&lt;servlet-mapping&gt;</code>元素用于<strong>映射</strong>一个已注册的Servlet的<strong>一个对外访问路径</strong>，它包含有两个子元素：<code>&lt;servlet-name&gt;</code>和<code>&lt;url-pattern&gt;</code>，分别用于指定<strong>Servlet的注册名称</strong>和<strong>Servlet的对外访问路径</strong>。</li></ul><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ServletDemo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>gacl.servlet.study.ServletDemo1<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ServletDemo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet/ServletDemo1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>同一个Servlet可以被映射到多个URL上，即<strong>多个<servlet-mapping>元素的<servlet-name>子元素</servlet-name></servlet-mapping></strong>的设置值可以是<strong>同一个Servlet的注册名<servlet-name></servlet-name></strong>。</p></blockquote><h2 id="4-2-Servlet与普通Java类的区别"><a href="#4-2-Servlet与普通Java类的区别" class="headerlink" title="4.2 Servlet与普通Java类的区别　　"></a>4.2 Servlet与普通Java类的区别　　</h2><p>　　Servlet是一个供其他Java程序（Servlet引擎）调用的Java类，<strong>不能独立运行</strong>，它的运行完全由<strong>Servlet引擎来控制和调度</strong>。<br>　　针对客户端的多次Servlet请求，通常情况下，<strong>服务器只会创建一个Servlet实例对象</strong>，也就是说Servlet实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至<strong>web容器退出</strong>，servlet实例对象才会销毁。<br>　　在Servlet的整个生命周期内，Servlet的<strong><code>init()</code>方法只被调用一次</strong>。而对一个Servlet的每次访问请求都导致Servlet引擎调用一次servlet的<code>service()</code>方法。对于每次访问请求，Servlet引擎都会创建一个新的<code>HttpServletRequest</code>请求对象和一个新的<code>HttpServletResponse</code>响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。  </p><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3760336.html" target="_blank" rel="noopener">javaweb学习总结(五)——Servlet开发(一)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-Servlet简介&quot;&gt;&lt;a href=&quot;#一-Servlet简介&quot; class=&quot;headerlink&quot; title=&quot;一. Servlet简介&quot;&gt;&lt;/a&gt;一. Servlet简介&lt;/h1&gt;&lt;p&gt;Servlet是sun公司提供的一门用于&lt;strong&gt;开发动态
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/Java/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---抽象类</title>
    <link href="http://yoursite.com/2019/03/13/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/03/13/java基础知识---抽象类/</id>
    <published>2019-03-13T00:17:27.000Z</published>
    <updated>2019-03-13T02:09:40.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-抽象类"><a href="#Java-抽象类" class="headerlink" title="Java 抽象类"></a>Java 抽象类</h1><h2 id="1-抽象方法"><a href="#1-抽象方法" class="headerlink" title="1. 抽象方法"></a>1. 抽象方法</h2><p>​    <strong>一种特殊的方法：它只有声明，而没有具体的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明格式</span></span><br><span class="line"><span class="comment">// 抽象方法必须用abstract关键字进行修饰</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>抽象方法必须定义在抽象类中。</p></blockquote><h2 id="2-抽象类"><a href="#2-抽象类" class="headerlink" title="2. 抽象类"></a>2. 抽象类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​    抽象方法的类(一个类含有抽象方法，则称这个类为抽象类), 抽象类必须在类前用 <strong>abstract关键字 </strong>修饰。</p><blockquote><p> 一个类不包含抽象方法，只是用abstract修饰的话也是抽象类。也就是说抽象类不一定必须含有抽象方法。</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><p>子类继承父类时，如果这个父类里面有抽象方法，并且子类觉得可以去实现父类的所有抽象方法，那么子类必须去实现父类的所有抽象方法, 父类里面的抽象方法，子类如果觉得实现不了，那么把就子类也声明成一个抽象类</p></li><li><p>因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。<strong>父类里面的方法是抽象的，那么对于整个类来说，它就有一个没有实现的方法，这个方法不知道怎么去实现，那么这个类是就是残缺不全的，因此这个类应该被定义为一个抽象类</strong></p></li><li><p>含有抽象方法的类必须被声明为抽象类</p><blockquote><p>不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法</p></blockquote></li><li><p>抽象类必须被继承</p><blockquote><p>抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情</p></blockquote></li><li><p>抽象方法必须被重写</p><blockquote><p>从某种意义上来说，抽象方法就是被用来重写的，所以在父类声明的抽象方法一定要在子类里面重写</p></blockquote></li></ul><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javastudy.summary;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类Animal</span></span><br><span class="line"><span class="comment"> * 在class的前面加上abstract，即声明成这样：abstract class Animal</span></span><br><span class="line"><span class="comment"> * 这样Animal类就成了一个抽象类了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法</span></span><br><span class="line"><span class="comment">     * 这里只有方法的定义，没有方法的实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">enjoy</span><span class="params">()</span></span>; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里的子类Cat从抽象类Animal继承下来，自然也继承了Animal类里面声明的抽象方法enjoy()，</span></span><br><span class="line"><span class="comment"> * 但子类Cat觉得自己去实现这个enjoy()方法也不合适，因此它把它自己也声明成一个抽象的类，</span></span><br><span class="line"><span class="comment"> * 那么，谁去实现这个抽象的enjoy方法，谁继承了子类，那谁就去实现这个抽象方法enjoy()。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cat添加自己独有的属性</span></span><br><span class="line">    <span class="keyword">public</span> String eyeColor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String n, String c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(n);<span class="comment">//调用父类Animal的构造方法</span></span><br><span class="line">        <span class="keyword">this</span>.eyeColor = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类BlueCat继承抽象类Cat，并且实现了从父类Cat继承下来的抽象方法enjoy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlueCat</span> <span class="keyword">extends</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlueCat</span><span class="params">(String n, String c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(n, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现了抽象方法enjoy</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enjoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"蓝猫叫..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类Dog继承抽象类Animal，并且实现了抽象方法enjoy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dog类添加自己特有的属性</span></span><br><span class="line">    <span class="keyword">public</span> String furColor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String n, String c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(n);<span class="comment">//调用父类Animal的构造方法</span></span><br><span class="line">        <span class="keyword">this</span>.furColor = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enjoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狗叫...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbstract</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 把Cat类声明成一个抽象类以后，就不能再对Cat类进行实例化了，</span></span><br><span class="line"><span class="comment">         * 因为抽象类是残缺不全的，缺胳膊少腿的，因此抽象类不能被实例化。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//Cat c = new Cat("Catname","blue");</span></span><br><span class="line">        Dog d = <span class="keyword">new</span> Dog(<span class="string">"dogname"</span>,<span class="string">"black"</span>);</span><br><span class="line">        d.enjoy();<span class="comment">//调用自己实现了的enjoy方法</span></span><br><span class="line">        </span><br><span class="line">        BlueCat c = <span class="keyword">new</span> BlueCat(<span class="string">"BlueCatname"</span>,<span class="string">"blue"</span>);</span><br><span class="line">        c.enjoy();<span class="comment">//调用自己实现了的enjoy方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h4><h5 id="抽象类和普通类的主要有三点区别："><a href="#抽象类和普通类的主要有三点区别：" class="headerlink" title="抽象类和普通类的主要有三点区别："></a>抽象类和普通类的主要有三点区别：</h5><ol><li>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</li><li>抽象类不能用来创建对象。</li><li>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。</li></ol><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="http://www.importnew.com/12399.html" target="_blank" rel="noopener">Java抽象类与接口的区别</a></p><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3648398.html" target="_blank" rel="noopener">java基础学习总结——抽象类</a></p><p>​    <a href="https://www.cnblogs.com/dolphin0520/p/3811437.html" target="_blank" rel="noopener">深入理解Java的接口和抽象类</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-抽象类&quot;&gt;&lt;a href=&quot;#Java-抽象类&quot; class=&quot;headerlink&quot; title=&quot;Java 抽象类&quot;&gt;&lt;/a&gt;Java 抽象类&lt;/h1&gt;&lt;h2 id=&quot;1-抽象方法&quot;&gt;&lt;a href=&quot;#1-抽象方法&quot; class=&quot;headerlink&quot; title=&quot;1. 抽象方法&quot;&gt;&lt;/a&gt;1. 抽象方法&lt;/h2&gt;&lt;p&gt;​    &lt;strong&gt;一种特殊的方法：它只有声明，而没有具体的实现&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 声明格式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 抽象方法必须用abstract关键字进行修饰&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="抽象类" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---接口</title>
    <link href="http://yoursite.com/2019/03/13/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2019/03/13/Java基础知识---接口/</id>
    <published>2019-03-13T00:17:27.000Z</published>
    <updated>2019-03-13T02:09:12.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础知识—接口"><a href="#Java基础知识—接口" class="headerlink" title="Java基础知识—接口"></a>Java基础知识—接口</h1><h2 id="一-概念"><a href="#一-概念" class="headerlink" title="一. 概念"></a>一. 概念</h2><ul><li><strong>官方解释:</strong> Java接口是一系列方法的声明，是一些方法特征的集合，<strong>一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）</strong></li></ul><a id="more"></a><ul><li><strong>通俗理解:</strong> 接口可以理解为一种特殊的抽象类(<strong>100%的抽象类, 所有的方法都是抽象方法</strong>)，里面全部是由<strong>全局常量</strong>和<strong>公共的抽象方法(方法的定义)</strong>所组成,<strong>而没有变量和方法的实现</strong></li></ul><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java中定义接口</span></span><br><span class="line"><span class="comment"> * 把一个类定义成一个接口的格式是把声明类的关键字class用声明接口的关键字interface替换掉即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JavaInterfaces</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 常量的声明格式, 都是公共的、静态的，不能改变的</span></span><br><span class="line">    <span class="comment">// 下面两种都可以,因为在接口里面默认的属性声明都是“public static final”的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> id=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> id=<span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法的声明</span></span><br><span class="line">    <span class="comment">// 在接口里面的声明的方法都是抽象方法,默认是抽象的，因此在接口里面的抽象方法都会把abstract关键字省略掉</span></span><br><span class="line">    <span class="comment">// 在接口里面声明的抽象方法默认是“public(公共的)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-特点"><a href="#二-特点" class="headerlink" title="二. 特点"></a>二. 特点</h2><ul><li><p>接口指明了一个类必须要做什么和不能做什么，相当于类的蓝图</p></li><li><p>接口可以继承其他的接口,并添加新的属性和抽象方法.</p></li><li><p><strong>抽象方法只能存在于抽象类或者接口中，但抽象类中却能存在非抽象方法，即有方法体的方法。接口是百分之百的抽象类</strong></p></li><li><p>接口是解决<strong>Java无法使用多继承</strong>的一种手段,, 实际中更多的作用是<strong>制定标准</strong>的。</p><blockquote><p><strong>一个类可以实现多个接口, 接口里面的成员变量不专属于某个对象，都是静态的成员变量，是属于整个类的,不会存在对象之间互相冲突的问题。实现多个接口，也就实现了多重继承</strong></p></blockquote></li><li><p>见范例</p></li><li><p><strong>接口和接口之间可以相互继承，类和类之间可以相互继承，类和接口之间，只能是类来实现接口</strong></p></li></ul><h1 id="三-重点"><a href="#三-重点" class="headerlink" title="三. 重点"></a>三. 重点</h1><ul><li>一个类如果要实现某个接口的话，那么它必须要实现这个接口中的所有方法。</li><li><strong>不能直接去实例化一个接口，因为接口中的方法都是抽象的，是没有方法体的</strong>. 但是，<strong>我们可以使用接口类型的引用指向一个实现了该接口的对象，并且可以调用这个接口中的方法</strong>(Java多态的特性).</li></ul><h1 id="四-接口的进一步理解"><a href="#四-接口的进一步理解" class="headerlink" title="四. 接口的进一步理解"></a>四. 接口的进一步理解</h1><p>​    如果某个设备需要向电脑中读取或者写入某些东西，这些设备一般都是采用USB方式与电脑连接的，我们发现，只要带有USB功能的设备就可以插入电脑中使用了，那么我们可以认为USB就是一种功能，这种功能能够做出很多的事情（实现很多的方法），其实USB就可以看做是一种标准，一种接口，只要实现了USB标准的设备我就认为你已经拥有了USB这种功能。（因为你实现了我USB标准中规定的方法）</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先声明USB接口：其中规定了要实现USB接口就必须实现接口规定实现的read( )和write( )这两个方法。</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个USB类实现USB接口。（实现其中的方法）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YouPan</span> <span class="keyword">implements</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"U盘正在通过USB功能读取数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"U盘正在通过USB功能写入数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个键盘类实现USB接口。（实现其中的方法）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JianPan</span> <span class="keyword">implements</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"键盘正在通过USB功能读取数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"键盘正在通过USB功能写入数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生成一个实现可USB接口（标准）的U盘对象</span></span><br><span class="line">        YouPan youPan = <span class="keyword">new</span> YouPan();</span><br><span class="line">        <span class="comment">// 调用U盘的read( )方法读取数据</span></span><br><span class="line">        youPan.read();</span><br><span class="line">        <span class="comment">// 调用U盘的write( )方法写入数据</span></span><br><span class="line">        youPan.write();</span><br><span class="line">        <span class="comment">// 生成一个实现可USB接口（标准）的键盘对象</span></span><br><span class="line">        JianPan jianPan = <span class="keyword">new</span> JianPan();</span><br><span class="line">        <span class="comment">// 调用键盘的read( )方法读取数据</span></span><br><span class="line">        jianPan.read();</span><br><span class="line">        <span class="comment">// 调用键盘的write( )方法写入数据</span></span><br><span class="line">        jianPan.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3651121.html" target="_blank" rel="noopener">java基础学习总结——接口</a></p><p>​    <a href="https://blog.csdn.net/qq_19782019/article/details/80259836" target="_blank" rel="noopener">JAVA基础——接口（全网最详细教程）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java基础知识—接口&quot;&gt;&lt;a href=&quot;#Java基础知识—接口&quot; class=&quot;headerlink&quot; title=&quot;Java基础知识—接口&quot;&gt;&lt;/a&gt;Java基础知识—接口&lt;/h1&gt;&lt;h2 id=&quot;一-概念&quot;&gt;&lt;a href=&quot;#一-概念&quot; class=&quot;headerlink&quot; title=&quot;一. 概念&quot;&gt;&lt;/a&gt;一. 概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;官方解释:&lt;/strong&gt; Java接口是一系列方法的声明，是一些方法特征的集合，&lt;strong&gt;一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="接口" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8E%A5%E5%8F%A3/"/>
    
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---继承</title>
    <link href="http://yoursite.com/2019/03/13/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2019/03/13/Java基础知识---继承/</id>
    <published>2019-03-13T00:17:27.000Z</published>
    <updated>2019-03-13T02:09:03.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-继承"><a href="#Java-继承" class="headerlink" title="Java 继承"></a>Java 继承</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</li><li>子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的 一些属性或方法</li></ul><a id="more"></a><h3 id="类的继承格式"><a href="#类的继承格式" class="headerlink" title="类的继承格式"></a>类的继承格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java继承的关键字是：extends</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 父类 </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是 Java 不支持多继承，但支持多重继承。</p></blockquote><h2 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h2><ul><li>子类拥有父类非 private 的属性、方法。</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li><li>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C  类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类。</li><li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li></ul><h2 id="为什么需要继承"><a href="#为什么需要继承" class="headerlink" title="为什么需要继承"></a>为什么需要继承</h2><ol><li>提高代码的 <strong>复用性</strong> (复用性主要是可以多次使用，不用再多次写同样的代码）)。</li><li>提高程序的扩展性。</li></ol><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://blog.csdn.net/javaniuniu/article/details/70173727" target="_blank" rel="noopener">JAVA继承总结</a></p><p>​    <a href="http://www.runoob.com/java/java-inheritance.html" target="_blank" rel="noopener">菜鸟教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-继承&quot;&gt;&lt;a href=&quot;#Java-继承&quot; class=&quot;headerlink&quot; title=&quot;Java 继承&quot;&gt;&lt;/a&gt;Java 继承&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。&lt;/li&gt;
&lt;li&gt;子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的 一些属性或方法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="继承" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BB%A7%E6%89%BF/"/>
    
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java面试经典题目(6-10题)</title>
    <link href="http://yoursite.com/2019/03/12/java%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE(6-10%E9%A2%98)/"/>
    <id>http://yoursite.com/2019/03/12/java面试经典题目(6-10题)/</id>
    <published>2019-03-12T14:40:00.000Z</published>
    <updated>2019-03-13T02:30:26.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？"><a href="#6-Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？" class="headerlink" title="6. Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？"></a>6. Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？</h1><a id="more"></a><p>答案: </p><h4 id="方法覆盖-重写-的原则："><a href="#方法覆盖-重写-的原则：" class="headerlink" title="方法覆盖(重写)的原则："></a>方法覆盖(重写)的原则：</h4><ol><li>重写方法的方法名称、参数列表必须与原方法的相同，返回类型可以相同也可以是原类型的子类型(从Java SE5开始支持)。   </li><li>重写方法不能比原方法访问性差（即访问权限不允许缩小）。   </li><li>重写方法不能比原方法抛出更多的异常。   </li><li>被重写的方法 <strong>不能为final类型</strong> ，因为final修饰的方法是无法重写的。   </li><li>被重写的方法 <strong>不能为private</strong> ，否则在其子类中只是新定义了一个方法，并没有对其进行重写。   </li><li>被重写的方法 <strong>不能为static</strong> 。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足重写条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足重写条件，但是仍然不会发生重写，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。   </li><li>重写是 <strong>发生在运行时的</strong> ，因为编译期编译器不知道并且没办法确定该去调用哪个方法，JVM会在代码运行的时候作出决定。 </li></ol><h4 id="方法重载的原则："><a href="#方法重载的原则：" class="headerlink" title="方法重载的原则："></a>方法重载的原则：</h4><ol><li>方法名称必须相同。   </li><li>参数列表必须不同（个数不同、或类型不同、参数类型排列顺序不同等）。   </li><li>方法的返回类型可以相同也可以不相同。   </li><li>仅仅返回类型不同不足以成为方法的重载。   </li><li>重载是 <strong>发生在编译时的</strong> ，因为编译器可以根据参数的类型来选择使用哪个方法。 </li></ol><h4 id="重写和重载的不同："><a href="#重写和重载的不同：" class="headerlink" title="重写和重载的不同："></a>重写和重载的不同：</h4><ol><li>方法重写要求参数列表必须一致，而方法重载要求参数列表必须不一致。   </li><li>方法重写要求返回类型必须一致(或为其子类型)，方法重载对此没有要求。   </li><li>方法重写只能用于子类重写父类的方法(覆盖者可能不会限制它所覆盖的方法的访问)，方法重载用于同一个类中的所有方法。   </li><li>方法重写对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。   </li><li>父类的一个方法只能被子类重写一次，而一个方法可以在所有的类中可以被重载多次。   </li><li>重载是编译时多态，重写是运行时多态。</li></ol><h5 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h5><p>​    <a href="https://www.nowcoder.com/questionTerminal/7b2152a85b9a4ebab6dfda7e995a8491" target="_blank" rel="noopener">牛客网优质答案</a></p><h1 id="7-Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"><a href="#7-Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？" class="headerlink" title="7. Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"></a>7. Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？</h1><p>答案:</p><h2 id="什么是构造方法？"><a href="#什么是构造方法？" class="headerlink" title="什么是构造方法？"></a>什么是构造方法？</h2><p>主要作用:** 完成对象的初始化工作(如果写的类里面没有构造函数,那么编译器会默认加上一个无参数且方法体为空的构造函数)</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>使用 new + 构造方法创建一个新的对象</li><li>构造函数是定义在 Java类中的一个用来 <strong>初始化对象</strong> 的函数</li><li>(new一个东西的时候，实际上你调用的是一个构造方法，构造方法就是把自己构造成一个新的对象，所以叫构造方法，构造一个新对象用的方法叫构造方法)</li><li>构造函数与类同名, 且没有返回值(构造方法的名字必须和类的名字完全一模一样，包括大小写,这个方法的名字和类名完全相同，并且没有返回值，也就是在这个方法前面不能写任何的方法的返回类型修饰符，连void都不可以写)</li></ul><h2 id="什么是构造方法重载？"><a href="#什么是构造方法重载？" class="headerlink" title="什么是构造方法重载？"></a>什么是构造方法重载？</h2><p>Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己 <strong>唯一的参数列表</strong> 。</p><h2 id="什么是复制构造方法？"><a href="#什么是复制构造方法？" class="headerlink" title="什么是复制构造方法？"></a>什么是复制构造方法？</h2><h4 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h4><h5 id="C-中的复制构造函数通常有三种作用"><a href="#C-中的复制构造函数通常有三种作用" class="headerlink" title="C++中的复制构造函数通常有三种作用:"></a>C++中的复制构造函数通常有三种作用:</h5><ol><li>对象作为函数参数   </li><li>对象作为函数返回值   </li><li>使用一个对象对另一个对象初始化。</li></ol><blockquote><p>C++语法允许用户定义自己的复制构造函数以实现自定义的复制，比如说进行深复制。Java并不支持这样的复制构造函数。但是这并不代表Java中没有这种机制，在Java中Object类的clone()方法就是这种机制的体现  </p></blockquote><p> java中不支持构造函数的复制。构造函数的复制属于C++的内容。</p><p>时间: 2019.3.12</p><h1 id="8-Java支持多继承么？"><a href="#8-Java支持多继承么？" class="headerlink" title="8. Java支持多继承么？"></a>8. Java支持多继承么？</h1><p>答案:</p><ol><li><strong>Java中类不支持多继承，只支持单继承（即一个类只有一个父类）.</strong></li><li>java中的 <strong>接口</strong> 支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）</li></ol><h1 id="9-接口和抽象类的区别是什么？"><a href="#9-接口和抽象类的区别是什么？" class="headerlink" title="9. 接口和抽象类的区别是什么？"></a>9. 接口和抽象类的区别是什么？</h1><p>答案:</p><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><ul><li>类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</li><li>接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。</li><li>抽象类可以在不提供接口方法实现的情况下实现接口。</li></ul><h4 id="语法层面上的区别"><a href="#语法层面上的区别" class="headerlink" title="语法层面上的区别"></a>语法层面上的区别</h4><ol><li>抽象类可以提供成员方法的实现细节(成员函数可以是private，protected或者是public)，而接口中只能存在public abstract 方法(默认是public的)</li><li>抽象类中的成员变量可以是各种类型的(包含非final的变量)，而接口中的成员变量只能是public static final类型的；</li><li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</li><li>接口中所有的方法默认的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ol><h4 id="设计层面上的区别"><a href="#设计层面上的区别" class="headerlink" title="设计层面上的区别"></a>设计层面上的区别</h4><blockquote><p>从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p></blockquote><ul><li>抽象类是对一种事物的抽象，即 <strong>对类抽象</strong> ，而接口是 <strong>对行为的抽象</strong> 。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。</li></ul><p>举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将飞行这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly(  )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，<strong>继承是一个  “是不是”的关系，而 接口 实现则是  “有没有”的关系</strong> 。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p><ul><li>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。</li></ul><p>什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt  B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt  B和ppt  C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.nowcoder.com/questionTerminal/bdb310cc6e384e78b2564dfd3ba4197c" target="_blank" rel="noopener">牛客网优质答案</a></p><p>​    <a href="http://www.importnew.com/12399.html" target="_blank" rel="noopener">Java抽象类与接口的区别</a></p><p>​    <a href="https://www.cnblogs.com/dolphin0520/p/3811437.html" target="_blank" rel="noopener">深入理解Java的接口和抽象类</a></p><p>时间: 2019.3.13</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;6-Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？&quot;&gt;&lt;a href=&quot;#6-Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？&quot; class=&quot;headerlink&quot; title=&quot;6. Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？&quot;&gt;&lt;/a&gt;6. Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？&lt;/h1&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
      <category term="java面试经典题目" scheme="http://yoursite.com/categories/java/java%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java面试经典题目" scheme="http://yoursite.com/tags/java%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/03/12/数据结构---顺序表的概念及实现/</id>
    <published>2019-03-12T12:50:53.000Z</published>
    <updated>2019-03-13T03:49:03.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>​    逻辑关系相邻的两个结点在 <strong>物理位置</strong> 上也相邻, 结点的逻辑次序和物理次序一致</p><a id="more"></a><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>​    <strong>数组</strong></p><h3 id="数组的优缺点"><a href="#数组的优缺点" class="headerlink" title="数组的优缺点"></a>数组的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>存取速度快</strong> O(1) 可以直接根据下标找到内存位置</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>浪费存储空间. 要求实现估计容量,比较困难,需要的空间过大,造成浪费,过小将导致溢出</li><li><strong>插入和删除</strong> 运算不方便,效率低,时间复杂度为O(n)</li><li>顺序表的存储空间不容易扩充.</li></ul><h3 id="基本操作的实现"><a href="#基本操作的实现" class="headerlink" title="基本操作的实现"></a>基本操作的实现</h3><ol><li>初始化数组</li><li>判断数组是否为空</li><li>判断数组是否满</li><li>显示数组内容</li><li>向数组中追加元素</li><li>向数组中指定的位置插入元素</li><li>删除指定元素</li><li>数组进行倒置</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先定义结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Arr</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> len; <span class="comment">// 数组能存取的最大元素个数</span></span><br><span class="line"><span class="keyword">int</span> currentNum;<span class="comment">// 当前元素的个数</span></span><br><span class="line"><span class="keyword">int</span> * pBase;<span class="comment">// 存储指向数组元素的指针 </span></span><br><span class="line">&#125; Arr;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 初始化数组</span></span><br><span class="line"><span class="comment">* 所需要的参数: 结构体, 数组长度 </span></span><br><span class="line"><span class="comment">* 让指针指向分配的数组</span></span><br><span class="line"><span class="comment">*  判断判断内存是否分配失败,如果没有失败,其他两个参数进行赋值 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initArr</span><span class="params">(Arr * pArr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 分配4*len字节长度的内存,这是pBase可以指向数组中的第一个元素，可以作为数组变量名称使用。</span></span><br><span class="line">pArr-&gt;pBase = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*len);</span><br><span class="line"><span class="comment">// 判断内存是否分配失败 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == pArr-&gt;pBase)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"动态内存分配失败!"</span>) ;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// pArray 中的值进行初始化</span></span><br><span class="line">pArr-&gt;len = len;</span><br><span class="line">pArr-&gt;currentNum = <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断数组是否为空</span></span><br><span class="line"><span class="comment">* 判断条件应该是当前数组中的元素是不是 0 个 </span></span><br><span class="line"><span class="comment">* 参数: 数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(Arr * pArr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == pArr-&gt;currentNum)&#123;</span><br><span class="line"><span class="comment">// 若数组为空,返回true </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断数组是否满了</span></span><br><span class="line"><span class="comment">* 判断条件应该是 len 和 currentNum 是否相等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(Arr * pArr)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果满了,返回 true </span></span><br><span class="line"><span class="keyword">if</span>(pArr-&gt;len == pArr-&gt;currentNum) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 显示数组内容</span></span><br><span class="line"><span class="comment">* 先判断数组是否为空,若为空,打印数组为空</span></span><br><span class="line"><span class="comment">* 若不为空,则利用指针循环遍历,全部打印出来 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showArr</span><span class="params">(Arr * pArr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isEmpty(pArr)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"数组为空!\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t\t此时数组中的所有元素为: \n"</span>); </span><br><span class="line"><span class="comment">// 注意应该是 i &lt; pArr-&gt;currentNum</span></span><br><span class="line"><span class="comment">// 不是  i &lt; pArr-&gt;len</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pArr-&gt;currentNum; i++) &#123;</span><br><span class="line"><span class="comment">// 是数组,所以是 pArr-&gt;pBase[i]</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d \t"</span>, pArr-&gt;pBase[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n------------------------------------------------\n"</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 向数组中追加元素</span></span><br><span class="line"><span class="comment">* 参数:数组, 追加的值 </span></span><br><span class="line"><span class="comment">* 先判断数组是否已经满了</span></span><br><span class="line"><span class="comment">* 如果满了,则不可以追加元素,打印追加失败</span></span><br><span class="line"><span class="comment">* 如果未满,进行追加 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(Arr * pArr, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>( isFull(pArr) ) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"数组已经满了,无法添加!\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"添加元素为 %d\t"</span>, val);</span><br><span class="line"></span><br><span class="line">pArr-&gt;pBase[pArr-&gt;currentNum] = val;</span><br><span class="line"><span class="comment">// 当前个数+1</span></span><br><span class="line">pArr-&gt;currentNum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 向数组中指定的位置插入元素</span></span><br><span class="line"><span class="comment">* 参数: 数组地址, 位置, 值</span></span><br><span class="line"><span class="comment">* 首先判断数组是否满 </span></span><br><span class="line"><span class="comment">* 再判断插入的位置是否合法 </span></span><br><span class="line"><span class="comment">* 将插入位置后面的元素向后移动一个 </span></span><br><span class="line"><span class="comment">* 再插入到相应的位置 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(Arr * pArr, <span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>( isFull(pArr) ) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"数组已经满了,无法插入!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 插入的位置不能小于1，同时不能比最后一个元素位置大一</span></span><br><span class="line"><span class="comment">// 注意是 pos &gt; pArr-&gt;len+1</span></span><br><span class="line"><span class="keyword">if</span>  (pos &lt; <span class="number">1</span> || pos &gt; pArr-&gt;len+<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 移动范围是从第pos个到底cnu个 </span></span><br><span class="line"><span class="comment">// 注意判断条件 i = pArr-&gt;currentlen</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = pArr-&gt;currentNum; i &gt; pos; i--) &#123;</span><br><span class="line"><span class="comment">// 若以i表示要移动元素的位置，从一开始的。右边都是i-1,若左移，左边是i-2,右移，左边是i</span></span><br><span class="line">pArr-&gt;pBase[<span class="number">1</span>] = pArr-&gt;pBase[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行插入的值的赋值</span></span><br><span class="line">pArr-&gt;pBase[pos<span class="number">-1</span>] = val;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"在第%d的位置插入元素: %d"</span>, pos, val);</span><br><span class="line">pArr-&gt;currentNum++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 向数组中指定的位置插入元素</span></span><br><span class="line"><span class="comment">* 参数: 数组地址, 位置, 值(地址,将返回去) </span></span><br><span class="line"><span class="comment">* 先判断位置是否合法</span></span><br><span class="line"><span class="comment">* 在进行删除 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">delete_</span><span class="params">(Arr * pArr, <span class="keyword">int</span> pos, <span class="keyword">int</span> *val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;<span class="number">1</span> || pos&gt;pArr-&gt;currentNum) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"删除失败，位置不合法\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 获取删除元素的值 </span></span><br><span class="line">*val = pArr-&gt;pBase[pos<span class="number">-1</span>];</span><br><span class="line"><span class="comment">// 注意循环条件 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=pos; i&lt;pArr-&gt;currentNum; i++)&#123;</span><br><span class="line">pArr-&gt;pBase[i<span class="number">-1</span>] = pArr-&gt;pBase[i];</span><br><span class="line">&#125; </span><br><span class="line">pArr-&gt;currentNum--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数组元素进行倒置</span></span><br><span class="line"><span class="comment">* 首先判断数组是否为空 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inverse</span><span class="params">(Arr * pArr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>( isEmpty(pArr) ) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"倒置失败，因数组为空"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;<span class="comment">// 数组的第一个元素</span></span><br><span class="line"><span class="keyword">int</span> end = pArr-&gt;currentNum<span class="number">-1</span>;<span class="comment">// 数组的最后一个元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"数组元素进行倒置"</span>); </span><br><span class="line"><span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line"><span class="comment">// 利用一个 temp 临时数据进行数据交换 </span></span><br><span class="line"><span class="keyword">int</span> temp = pArr-&gt;pBase[start];</span><br><span class="line">pArr-&gt;pBase[start] = pArr-&gt;pBase[end];</span><br><span class="line">pArr-&gt;pBase[end] = temp;</span><br><span class="line"><span class="comment">// 下一组 </span></span><br><span class="line">start++;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 代码测试 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Arr arr;</span><br><span class="line"><span class="comment">// 将结构体的地址作为实参，这样才能修改结构体中的值</span></span><br><span class="line"><span class="comment">// 如果传的是结构体变量，那么将进行拷贝，不会改变值</span></span><br><span class="line">initArr(&amp;arr, <span class="number">6</span>);</span><br><span class="line"><span class="comment">// 进行追加</span></span><br><span class="line">append(&amp;arr, <span class="number">1</span>);</span><br><span class="line">append(&amp;arr, <span class="number">2</span>);</span><br><span class="line">append(&amp;arr, <span class="number">3</span>);</span><br><span class="line">append(&amp;arr, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 进行显示 </span></span><br><span class="line">showArr(&amp;arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素 </span></span><br><span class="line">insert(&amp;arr, <span class="number">5</span>, <span class="number">88</span>);</span><br><span class="line">showArr(&amp;arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">delete_(&amp;arr, <span class="number">1</span>, &amp;val);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"删除了元素 %d"</span>, val);</span><br><span class="line">showArr(&amp;arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行倒置 </span></span><br><span class="line">inverse(&amp;arr);</span><br><span class="line">    showArr(&amp;arr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文:"></a>参考博文:</h5><p>​    <a href="https://blog.csdn.net/Davidluo001/article/details/46447817" target="_blank" rel="noopener">数据结构基础（1）–数组C语言实现–动态内存分配</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;顺序表&quot;&gt;&lt;a href=&quot;#顺序表&quot; class=&quot;headerlink&quot; title=&quot;顺序表&quot;&gt;&lt;/a&gt;顺序表&lt;/h1&gt;&lt;h3 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h3&gt;&lt;p&gt;​    逻辑关系相邻的两个结点在 &lt;strong&gt;物理位置&lt;/strong&gt; 上也相邻, 结点的逻辑次序和物理次序一致&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线性表" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
      <category term="顺序表" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>C语言---常用函数</title>
    <link href="http://yoursite.com/2019/03/12/C%E8%AF%AD%E8%A8%80---%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/03/12/C语言---常用函数/</id>
    <published>2019-03-12T10:23:51.000Z</published>
    <updated>2019-03-12T13:09:39.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言常用函数"><a href="#C语言常用函数" class="headerlink" title="C语言常用函数"></a>C语言常用函数</h1><h2 id="sizeof用法"><a href="#sizeof用法" class="headerlink" title="sizeof用法"></a>sizeof用法</h2><a id="more"></a><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C语言常用函数&quot;&gt;&lt;a href=&quot;#C语言常用函数&quot; class=&quot;headerlink&quot; title=&quot;C语言常用函数&quot;&gt;&lt;/a&gt;C语言常用函数&lt;/h1&gt;&lt;h2 id=&quot;sizeof用法&quot;&gt;&lt;a href=&quot;#sizeof用法&quot; class=&quot;headerlink&quot; title=&quot;sizeof用法&quot;&gt;&lt;/a&gt;sizeof用法&lt;/h2&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="常用函数" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---JDBC相关概念介绍</title>
    <link href="http://yoursite.com/2019/03/12/JavaWeb---JDBC(1)/"/>
    <id>http://yoursite.com/2019/03/12/JavaWeb---JDBC(1)/</id>
    <published>2019-03-12T09:23:51.000Z</published>
    <updated>2019-03-12T13:15:28.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JDBC相关概念介绍"><a href="#一、JDBC相关概念介绍" class="headerlink" title="一、JDBC相关概念介绍"></a>一、JDBC相关概念介绍</h2><h3 id="1-1、数据库驱动"><a href="#1-1、数据库驱动" class="headerlink" title="1.1、数据库驱动"></a>1.1、数据库驱动</h3><p>　　这里的驱动的概念和平时听到的那种驱动的概念是一样的，比如平时购买的声卡，网卡直接插到计算机上面是不能用的，必须要安装相应的驱动程序之后才能够使用声卡和网卡，同样道理，我们安装好数据库之后，我们的应用程序也是不能直接使用数据库的，必须要通过相应的数据库驱动程序，通过驱动程序去和数据库打交道</p><a id="more"></a><h3 id="1-2、JDBC介绍"><a href="#1-2、JDBC介绍" class="headerlink" title="1.2、JDBC介绍"></a>1.2、JDBC介绍</h3><p>　　SUN公司为了简化、统一对数据库的操作，定义了一套Java操作数据库的规范（接口），称之为<strong>JDBC</strong> 。这套接口由数据库厂商去实现，这样，开发人员只需要学习jdbc接口，并通过jdbc加载具体的驱动，就可以操作数据库。</p><p>JDBC全称为：<strong>Java Data Base Connectivity（java数据库连接）</strong>，它主要由接口组成。<br><strong>组成JDBC的２个包：</strong></p><ul><li><p>java.sql</p></li><li><p>javax.sql</p></li></ul><p>开发JDBC应用需要以上2个包的支持外，还需要 <strong>导入相应JDBC的数据库实现(即数据库驱动)</strong> 。</p><h2 id="二、编写JDBC程序"><a href="#二、编写JDBC程序" class="headerlink" title="二、编写JDBC程序"></a>二、编写JDBC程序</h2><h3 id="2-1-搭建实验环境"><a href="#2-1-搭建实验环境" class="headerlink" title="2.1. 搭建实验环境"></a>2.1. 搭建实验环境</h3><ol><li><p>在mysql中创建一个库，并 <strong>创建user表和插入表的数据</strong> 。</p></li><li><p>新建一个Java工程，并 <strong>导入数据驱动</strong></p></li><li><p>编写程序从user表中读取数据，并打印在命令行窗口中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConn</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//要连接的数据库URL</span></span><br><span class="line">        String url = <span class="string">"jdbc:mysql://localhost:3306/jdbcStudy"</span>;</span><br><span class="line">        <span class="comment">//连接的数据库时使用的用户名</span></span><br><span class="line">        String username = <span class="string">"root"</span>;</span><br><span class="line">        <span class="comment">//连接的数据库时使用的密码</span></span><br><span class="line">        String password = <span class="string">"XDP"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.加载驱动</span></span><br><span class="line">        <span class="comment">//DriverManager.registerDriver(new com.mysql.jdbc.Driver());不推荐使用这种方式来加载驱动</span></span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);<span class="comment">//推荐使用这种方式来加载驱动</span></span><br><span class="line">        <span class="comment">//2.获取与数据库的链接</span></span><br><span class="line">        Connection conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.获取用于向数据库发送sql语句的statement</span></span><br><span class="line">        Statement st = conn.createStatement();</span><br><span class="line">        </span><br><span class="line">        String sql = <span class="string">"select id,name,password,email,birthday from users"</span>;</span><br><span class="line">        <span class="comment">//4.向数据库发sql,并获取代表结果集的resultset</span></span><br><span class="line">        ResultSet rs = st.executeQuery(sql);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.取出结果集的数据</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">            System.out.println(<span class="string">"id="</span> + rs.getObject(<span class="string">"id"</span>));</span><br><span class="line">            System.out.println(<span class="string">"name="</span> + rs.getObject(<span class="string">"name"</span>));</span><br><span class="line">            System.out.println(<span class="string">"password="</span> + rs.getObject(<span class="string">"password"</span>));</span><br><span class="line">            System.out.println(<span class="string">"email="</span> + rs.getObject(<span class="string">"email"</span>));</span><br><span class="line">            System.out.println(<span class="string">"birthday="</span> + rs.getObject(<span class="string">"birthday"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.关闭链接，释放资源</span></span><br><span class="line">        rs.close();</span><br><span class="line">        st.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//详细解析见原博文</span></span><br></pre></td></tr></table></figure><h3 id="2-2-释放资源"><a href="#2-2-释放资源" class="headerlink" title="2.2 释放资源"></a>2.2 释放资源</h3><p>　　Jdbc程序运行完后，切记要释放程序在运行过程中，创建的那些与数据库进行交互的对象，这些对象通常是ResultSet,  Statement和Connection对象，特别是Connection对象，它是非常稀有的资源，用完后必须马上释放，如果Connection不能及时、正确的关闭，极易导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。<br>　　为确保资源释放代码能运行，资源释放代码也一定要放在finally语句中。</p></li></ol><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文:"></a>参考博文:</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3946207.html" target="_blank" rel="noopener">javaweb学习总结(三十二)——JDBC学习入门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、JDBC相关概念介绍&quot;&gt;&lt;a href=&quot;#一、JDBC相关概念介绍&quot; class=&quot;headerlink&quot; title=&quot;一、JDBC相关概念介绍&quot;&gt;&lt;/a&gt;一、JDBC相关概念介绍&lt;/h2&gt;&lt;h3 id=&quot;1-1、数据库驱动&quot;&gt;&lt;a href=&quot;#1-1、数据库驱动&quot; class=&quot;headerlink&quot; title=&quot;1.1、数据库驱动&quot;&gt;&lt;/a&gt;1.1、数据库驱动&lt;/h3&gt;&lt;p&gt;　　这里的驱动的概念和平时听到的那种驱动的概念是一样的，比如平时购买的声卡，网卡直接插到计算机上面是不能用的，必须要安装相应的驱动程序之后才能够使用声卡和网卡，同样道理，我们安装好数据库之后，我们的应用程序也是不能直接使用数据库的，必须要通过相应的数据库驱动程序，通过驱动程序去和数据库打交道&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/Java/JavaWeb/"/>
    
      <category term="JDBC相关概念介绍" scheme="http://yoursite.com/categories/Java/JavaWeb/JDBC%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb---JavaBean</title>
    <link href="http://yoursite.com/2019/03/12/JavaWeb---JavaBean/"/>
    <id>http://yoursite.com/2019/03/12/JavaWeb---JavaBean/</id>
    <published>2019-03-12T08:23:51.000Z</published>
    <updated>2019-03-13T13:06:43.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是JavaBean"><a href="#一、什么是JavaBean" class="headerlink" title="一、什么是JavaBean"></a>一、什么是JavaBean</h2><p>　　<strong>JavaBean是一个遵循特定写法的Java类</strong>，它通常具有如下特点：</p><ul><li>这个Java类<strong>必须具有一个无参的构造函数</strong></li><li>属性必须私有化。</li><li>私有化的属性必须通过public类型的方法暴露给其它程序，并且方法的命名也必须遵守一定的命名规范。</li></ul><a id="more"></a><p><strong>javaBean范例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gacl.javabean.study;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gacl</span></span><br><span class="line"><span class="comment"> * Person类就是一个最简单的JavaBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------Person类封装的私有属性-------------------------------------</span></span><br><span class="line">    <span class="comment">// 姓名 String类型</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 性别 String类型</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="comment">// 年龄 int类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//是否已婚 boolean类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> married;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//------------------Person类的无参数构造方法-----------------------------------</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参数构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//------------------Person类对外提供的用于访问私有属性的public方法----------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMarried</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> married;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMarried</span><span class="params">(<span class="keyword">boolean</span> married)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.married = married;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JavaBean在J2EE开发中，通常用于封装数据，对于遵循以上写法的JavaBean组件，其它程序可以通过反射技术实例化JavaBean对象，并且通过反射那些遵守命名规范的方法，从而获知JavaBean的属性，进而调用其属性保存数据</p></blockquote><h2 id="二、JavaBean的属性"><a href="#二、JavaBean的属性" class="headerlink" title="二、JavaBean的属性"></a>二、JavaBean的属性</h2><ul><li><strong>JavaBean的属性可以是任意类型，并且一个JavaBean可以有多个属性</strong>。每个属性通常都需要具有相应的setter、 getter方法，setter方法称为属性修改器，getter方法称为属性访问器。</li><li>属性修改器必须以小写的set前缀开始，后跟属性名，且属性名的第一个字母要改为大写，例如，name属性的修改器名称为setName，password属性的修改器名称为setPassword。 </li><li>属性访问器通常以小写的get前缀开始，后跟属性名，且属性名的第一个字母也要改为大写，例如，name属性的访问器名称为getName，password属性的访问器名称为getPassword。 </li><li>一个JavaBean的某个属性也可以只有set方法或get方法，这样的属性通常也称之为只写、只读属性。</li></ul><h4 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文:"></a>参考博文:</h4><p><a href="https://www.cnblogs.com/xdp-gacl/p/3871730.html" target="_blank" rel="noopener">javaweb学习总结(二十)——JavaBean总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是JavaBean&quot;&gt;&lt;a href=&quot;#一、什么是JavaBean&quot; class=&quot;headerlink&quot; title=&quot;一、什么是JavaBean&quot;&gt;&lt;/a&gt;一、什么是JavaBean&lt;/h2&gt;&lt;p&gt;　　&lt;strong&gt;JavaBean是一个遵循特定写法的Java类&lt;/strong&gt;，它通常具有如下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个Java类&lt;strong&gt;必须具有一个无参的构造函数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;属性必须私有化。&lt;/li&gt;
&lt;li&gt;私有化的属性必须通过public类型的方法暴露给其它程序，并且方法的命名也必须遵守一定的命名规范。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/Java/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>eclipse---快捷键</title>
    <link href="http://yoursite.com/2019/03/12/eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2019/03/12/eclipse快捷键/</id>
    <published>2019-03-12T04:23:51.000Z</published>
    <updated>2019-03-12T13:11:42.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="eclipse快捷键"><a href="#eclipse快捷键" class="headerlink" title="eclipse快捷键"></a>eclipse快捷键</h1><h4 id="eclipse配置折叠-展开代码快捷键"><a href="#eclipse配置折叠-展开代码快捷键" class="headerlink" title="eclipse配置折叠/展开代码快捷键"></a>eclipse配置折叠/展开代码快捷键</h4><p>​    <a href="https://blog.csdn.net/HFUTLXM/article/details/78916599" target="_blank" rel="noopener">https://blog.csdn.net/HFUTLXM/article/details/78916599</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;eclipse快捷键&quot;&gt;&lt;a href=&quot;#eclipse快捷键&quot; class=&quot;headerlink&quot; title=&quot;eclipse快捷键&quot;&gt;&lt;/a&gt;eclipse快捷键&lt;/h1&gt;&lt;h4 id=&quot;eclipse配置折叠-展开代码快捷键&quot;&gt;&lt;a href=&quot;#eclipse配置折叠-展开代码快捷键&quot; class=&quot;headerlink&quot; title=&quot;eclipse配置折叠/展开代码快捷键&quot;&gt;&lt;/a&gt;eclipse配置折叠/展开代码快捷键&lt;/h4&gt;&lt;p&gt;​    &lt;a href=&quot;https://blog.csdn.net/HFUTLXM/article/details/78916599&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/HFUTLXM/article/details/78916599&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="eclipse" scheme="http://yoursite.com/categories/eclipse/"/>
    
      <category term="快捷键" scheme="http://yoursite.com/categories/eclipse/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
    
      <category term="eclipse" scheme="http://yoursite.com/tags/eclipse/"/>
    
      <category term="快捷键" scheme="http://yoursite.com/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>how2J天猫整站---笔记</title>
    <link href="http://yoursite.com/2019/03/12/how2J%E5%A4%A9%E7%8C%AB%E6%95%B4%E7%AB%99J2EE---%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/03/12/how2J天猫整站J2EE---笔记/</id>
    <published>2019-03-12T04:23:51.000Z</published>
    <updated>2019-03-12T13:13:20.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-关于表"><a href="#一-关于表" class="headerlink" title="一.关于表"></a>一.关于表</h1><h4 id="表与表之间的关系，基本上是3种"><a href="#表与表之间的关系，基本上是3种" class="headerlink" title="表与表之间的关系，基本上是3种"></a>表与表之间的关系，基本上是3种</h4><ul><li>一对一</li><li>一对多</li><li>多对一</li></ul><h3 id="表的杂谈"><a href="#表的杂谈" class="headerlink" title="表的杂谈"></a>表的杂谈</h3><ul><li>修改表结构是代价最大的改动</li><li>在建表过程中，会设置外键约束，所以表和表之间有依赖关系。 因此会先建立被外键指向的表</li><li>一般说来，对于一个新项目，建表的时候，会把sql语句都准备好，一次性执行</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-关于表&quot;&gt;&lt;a href=&quot;#一-关于表&quot; class=&quot;headerlink&quot; title=&quot;一.关于表&quot;&gt;&lt;/a&gt;一.关于表&lt;/h1&gt;&lt;h4 id=&quot;表与表之间的关系，基本上是3种&quot;&gt;&lt;a href=&quot;#表与表之间的关系，基本上是3种&quot; class=&quot;headerlink&quot; title=&quot;表与表之间的关系，基本上是3种&quot;&gt;&lt;/a&gt;表与表之间的关系，基本上是3种&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;一对一&lt;/li&gt;
&lt;li&gt;一对多&lt;/li&gt;
&lt;li&gt;多对一&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;表的杂谈&quot;&gt;&lt;a href=&quot;#表的杂谈&quot; class=&quot;headerlink&quot; title=&quot;表的杂谈&quot;&gt;&lt;/a&gt;表的杂谈&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;修改表结构是代价最大的改动&lt;/li&gt;
&lt;li&gt;在建表过程中，会设置外键约束，所以表和表之间有依赖关系。 因此会先建立被外键指向的表&lt;/li&gt;
&lt;li&gt;一般说来，对于一个新项目，建表的时候，会把sql语句都准备好，一次性执行&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="how2J" scheme="http://yoursite.com/categories/how2J/"/>
    
    
      <category term="how2J" scheme="http://yoursite.com/tags/how2J/"/>
    
  </entry>
  
  <entry>
    <title>sql语句</title>
    <link href="http://yoursite.com/2019/03/11/sql%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2019/03/11/sql语句/</id>
    <published>2019-03-11T08:00:00.000Z</published>
    <updated>2019-03-12T13:17:23.177Z</updated>
    
    <content type="html"><![CDATA[<p>参考博文:</p><h1 id="一-基础"><a href="#一-基础" class="headerlink" title="一. 基础"></a>一. 基础</h1><ol><li>创建数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">database</span>-<span class="keyword">name</span></span><br></pre></td></tr></table></figure><a id="more"></a><ol start="2"><li>删除数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">database</span>-<span class="keyword">name</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建新表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CEEATE DATABASE database-name</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CEEATE DATABASE database-name</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CEEATE DATABASE database-name</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CEEATE DATABASE database-name</span><br></pre></td></tr></table></figure><p><strong>参考博文:</strong> </p><p><a href="https://www.cnblogs.com/1234abcd/p/5530314.html" target="_blank" rel="noopener">经典SQL语句大全(绝对的经典)</a></p><p><a href="http://how2j.cn/k/tmall-j2ee/tmall-j2ee-943/943.html" target="_blank" rel="noopener">how2J</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考博文:&lt;/p&gt;
&lt;h1 id=&quot;一-基础&quot;&gt;&lt;a href=&quot;#一-基础&quot; class=&quot;headerlink&quot; title=&quot;一. 基础&quot;&gt;&lt;/a&gt;一. 基础&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;创建数据库&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;DATABASE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;database&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="sql语句" scheme="http://yoursite.com/tags/sql%E8%AF%AD%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---方法的重载和覆盖</title>
    <link href="http://yoursite.com/2019/03/11/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E8%A6%86%E7%9B%96/"/>
    <id>http://yoursite.com/2019/03/11/Java基础知识---方法的重载和覆盖/</id>
    <published>2019-03-11T05:38:55.000Z</published>
    <updated>2019-03-11T07:56:12.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-方法的重载-overload"><a href="#一-方法的重载-overload" class="headerlink" title="一. 方法的重载(overload)"></a>一. 方法的重载(overload)</h1><p>指一个类中可以定义有 <strong>相同的名字</strong> ,但 <strong>参数不同</strong> 的多个方法. 调用时, 会根据 <strong>不同的参数表</strong> 选择对应的方法</p><a id="more"></a><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><ul><li>构造方法</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>方法名一样, 但参数不一样,就是重载(overload)</li><li>参数不一样 (1.参数的个数不一样  2. 参数的类型不一样, 只要有一个就可以)</li><li>方法名一样，参数类型一样，只有返回值不一样，这个不构成重载</li></ol><p><strong>理解:</strong> 多重加载，不同样式的加载</p><h1 id="二-方法的覆盖-override"><a href="#二-方法的覆盖-override" class="headerlink" title="二. 方法的覆盖(override)"></a>二. 方法的覆盖(override)</h1><p>指覆盖了一个方法并且对其重写，以求达到不同的作用,也可以叫做 <strong>重写</strong> </p><h3 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h3><ul><li><p>对 <strong>接口方法</strong> 的实现</p></li><li><p>在 <strong>继承</strong> 中也可能会在 <strong>子类覆盖父类</strong> 中的方法</p></li></ul><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ol><li>覆盖的方法的标志必须要和被覆盖的方法的 <strong>标志</strong> (相同的名字和相同的参数)完全匹配，才能达到覆盖的效果；</li><li>覆盖的方法的返回值必须和被覆盖的方法的返回一致；</li><li>覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；</li><li>被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖</li></ol><p><strong>参考博文</strong></p><p><a href="https://www.cnblogs.com/fanvfan/p/7563307.html" target="_blank" rel="noopener">java中的方法覆盖（Overriding）和方法重载（Overloading）是什么意思？重写跟重载的区别？</a></p><p><a href="https://zhidao.baidu.com/question/1996221.html" target="_blank" rel="noopener">对比Java语言中的覆盖和重载</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-方法的重载-overload&quot;&gt;&lt;a href=&quot;#一-方法的重载-overload&quot; class=&quot;headerlink&quot; title=&quot;一. 方法的重载(overload)&quot;&gt;&lt;/a&gt;一. 方法的重载(overload)&lt;/h1&gt;&lt;p&gt;指一个类中可以定义有 &lt;strong&gt;相同的名字&lt;/strong&gt; ,但 &lt;strong&gt;参数不同&lt;/strong&gt; 的多个方法. 调用时, 会根据 &lt;strong&gt;不同的参数表&lt;/strong&gt; 选择对应的方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---Java基础知识---访问修饰符</title>
    <link href="http://yoursite.com/2019/03/11/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <id>http://yoursite.com/2019/03/11/Java基础知识---访问修饰符/</id>
    <published>2019-03-11T05:38:55.000Z</published>
    <updated>2019-03-11T07:55:55.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ol><li>public：public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用</li><li>private：private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可以使用。</li><li>protected：protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private</li><li>不写时默认为friendly ，也即是“包访问权限”</li></ol><a id="more"></a><h3 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h3><table><thead><tr><th style="text-align:center">作用域</th><th style="text-align:center">自身</th><th style="text-align:center">同包子类</th><th style="text-align:center">不同包子类</th><th style="text-align:center">同包类</th><th>其他类</th></tr></thead><tbody><tr><td style="text-align:center">private</td><td style="text-align:center">访问(√)</td><td style="text-align:center">继承(×)</td><td style="text-align:center">继承(×)</td><td style="text-align:center">访问(×)</td><td>访问(×)</td></tr><tr><td style="text-align:center">package</td><td style="text-align:center">访问(√)</td><td style="text-align:center">继承(√)</td><td style="text-align:center">继承(×)</td><td style="text-align:center">访问(√)</td><td>访问(×)</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">访问(√)</td><td style="text-align:center">继承(√)</td><td style="text-align:center">继承(√)</td><td style="text-align:center">访问(√)</td><td>访问(×)</td></tr><tr><td style="text-align:center">public</td><td style="text-align:center">访问(√)</td><td style="text-align:center">继承(√)</td><td style="text-align:center">继承(√)</td><td style="text-align:center">访问(√)</td><td>访问(√)</td></tr></tbody></table><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><ol><li><strong>属性</strong> 通常使用private封装起来</li><li><strong>方法</strong> 一般使用public用于被调用</li><li>会 <strong>被子类继承</strong> 的方法，通常使用protected</li><li>package用的不多，一般新手会用package,因为还不知道有修饰符这个东西</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>如果一个成员需要被外部包所访问，则必须使用public修饰符；<br>如果一个成员需要被定义在不同包下的子类所访问，则可以使用public或protected修饰符；<br>如果一个成员需要被本包下的其他类所访问，则可以不用写任何的修饰符，使用public或者protected也行</p><p>若一个成员想使用同类中其他成员，则使用任意一个修饰符即可；若一个成员不想被任何一个外部的类所访问，则使用private关键字比较恰当。</p></blockquote><p>参考博客:</p><p><a href="https://blog.csdn.net/k_young1997/article/details/81109965" target="_blank" rel="noopener">Java中private、public、default、protected的区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;public：public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用&lt;/li&gt;
&lt;li&gt;private：private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可以使用。&lt;/li&gt;
&lt;li&gt;protected：protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private&lt;/li&gt;
&lt;li&gt;不写时默认为friendly ，也即是“包访问权限”&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>人间词话---送给自己</title>
    <link href="http://yoursite.com/2019/03/09/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E5%B7%B1/"/>
    <id>http://yoursite.com/2019/03/09/人间词话---自己/</id>
    <published>2019-03-09T14:57:13.000Z</published>
    <updated>2019-03-09T15:05:53.479Z</updated>
    
    <content type="html"><![CDATA[<ul><li>勇者愤怒, 抽刃向更强者.怯者愤怒, 却抽刀向更弱者</li><li>扬在脸上的微笑, 长在心里的善良,融进血液的骨气, 刻在生命里的坚强.</li><li>礼仪最重要的是在昭告自我,真正的宣誓是对自己说的话.   —陈果</li><li>对一切人,一切西乡都保持一种开放二友善的胸襟和气度的时候,才真正成为名副其实的大学生.   —陈果</li></ul><a id="more"></a><ul><li>挫折能使强者更强,弱者更弱,强者在面对中锻炼了自己,弱者在逃避中越发脆弱</li><li>最善言谈者就是最善于倾听的人</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;勇者愤怒, 抽刃向更强者.怯者愤怒, 却抽刀向更弱者&lt;/li&gt;
&lt;li&gt;扬在脸上的微笑, 长在心里的善良,融进血液的骨气, 刻在生命里的坚强.&lt;/li&gt;
&lt;li&gt;礼仪最重要的是在昭告自我,真正的宣誓是对自己说的话.   —陈果&lt;/li&gt;
&lt;li&gt;对一切人,一切西乡都保持一种开放二友善的胸襟和气度的时候,才真正成为名副其实的大学生.   —陈果&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="人间词话" scheme="http://yoursite.com/tags/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>人间词话---网易云评论</title>
    <link href="http://yoursite.com/2019/03/09/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%84%E8%AE%BA/"/>
    <id>http://yoursite.com/2019/03/09/人间词话---网易云评论/</id>
    <published>2019-03-09T14:57:13.000Z</published>
    <updated>2019-03-09T15:06:12.831Z</updated>
    
    <content type="html"><![CDATA[<h3 id="卿卿我我"><a href="#卿卿我我" class="headerlink" title="卿卿我我"></a>卿卿我我</h3><ul><li>写歌的人假正经, 听歌的人最无情.人要是桥请起来,听什么都像在唱自己.</li><li>校服是我和她唯一穿过的情侣装, 毕业照是我和她唯一的合影.</li></ul><a id="more"></a><h3 id="情怀"><a href="#情怀" class="headerlink" title="情怀"></a>情怀</h3><ul><li>愿走出半生, 归来仍是少年.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;卿卿我我&quot;&gt;&lt;a href=&quot;#卿卿我我&quot; class=&quot;headerlink&quot; title=&quot;卿卿我我&quot;&gt;&lt;/a&gt;卿卿我我&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;写歌的人假正经, 听歌的人最无情.人要是桥请起来,听什么都像在唱自己.&lt;/li&gt;
&lt;li&gt;校服是我和她唯一穿过的情侣装, 毕业照是我和她唯一的合影.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="人间词话" scheme="http://yoursite.com/tags/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
      <category term="网易云评论" scheme="http://yoursite.com/tags/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%84%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>人间词话---ZJ</title>
    <link href="http://yoursite.com/2019/03/09/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---ZJ/"/>
    <id>http://yoursite.com/2019/03/09/人间词话---ZJ/</id>
    <published>2019-03-09T14:57:13.000Z</published>
    <updated>2019-03-09T15:05:31.903Z</updated>
    
    <content type="html"><![CDATA[<ul><li>没有人会拒绝微笑, 也没有人会拒绝真诚.</li><li>逢山开路, 遇水架桥.</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;没有人会拒绝微笑, 也没有人会拒绝真诚.&lt;/li&gt;
&lt;li&gt;逢山开路, 遇水架桥.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="人间词话" scheme="http://yoursite.com/tags/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---Filter(一)</title>
    <link href="http://yoursite.com/2019/03/08/JavaWeb---Filter(%E4%B8%80)/"/>
    <id>http://yoursite.com/2019/03/08/JavaWeb---Filter(一)/</id>
    <published>2019-03-08T03:38:55.000Z</published>
    <updated>2019-03-13T13:56:20.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Filter简介"><a href="#一、Filter简介" class="headerlink" title="一、Filter简介"></a>一、Filter简介</h2><p>　　Filter也称之为<strong>过滤器</strong>，WEB开发人员通过Filter技术，对web服务器<strong>管理的所有web资源</strong>：例如Jsp,  Servlet, 静态图片文件或静态 html  文件等<strong>进行拦截</strong>，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。<br>　　Servlet  API中提供了一个<strong>Filter接口</strong>，开发web应用时，如果编写的Java类实现了这个接口，则<strong>把这个java类称之为过滤器Filter</strong>。通过Filter技术，开发人员可以实现用户在访问某个目标资源之前，对访问的请求和响应进行拦截.</p><h2 id="二、Filter是如何实现拦截的？"><a href="#二、Filter是如何实现拦截的？" class="headerlink" title="二、Filter是如何实现拦截的？"></a>二、Filter是如何实现拦截的？</h2><p>　　Filter接口中有一个doFilter方法，当我们编写好Filter，并配置对哪个web资源进行拦截后，WEB服务器每次在调用web资源的service方法之前，都会先调用一下filter的doFilter方法，因此，在该方法内编写代码可达到如下目的：</p><ol><li>调用目标资源之前，让一段代码执行。</li><li>是否调用目标资源（即是否让用户访问web资源）。</li><li>调用目标资源之后，让一段代码执行。</li></ol><p>　　web服务器在调用doFilter方法时，会传递一个filterChain对象进来，filterChain对象是filter接口中最重要的一个对  象，它也提供了一个doFilter方法，开发人员可以根据需求决定是否调用此方法，调用该方法，则web服务器就会调用web资源的service方  法，即web资源就会被访问，否则web资源不会被访问。</p><h2 id="三、Filter开发入门"><a href="#三、Filter开发入门" class="headerlink" title="三、Filter开发入门"></a>三、Filter开发入门</h2><h3 id="3-1、Filter开发步骤"><a href="#3-1、Filter开发步骤" class="headerlink" title="3.1、Filter开发步骤"></a>3.1、Filter开发步骤</h3><p>Filter开发分为二个步骤：</p><ol><li>编写java类实现Filter接口，并实现其doFilter方法。</li><li>在 web.xml 文件中使用<code>&lt;filter&gt;</code>和<code>&lt;filter-mapping&gt;</code>元素对编写的filter类进行注册，并设置它所能拦截的资源。</li></ol><h5 id="过滤器范例"><a href="#过滤器范例" class="headerlink" title="过滤器范例"></a>过滤器范例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>:filter的三种典型应用：</span></span><br><span class="line"><span class="comment">*  1、可以在filter中根据条件决定是否调用chain.doFilter(request, response)方法，即是否让目标资源执行</span></span><br><span class="line"><span class="comment">* 2、在让目标资源执行之前，可以对request\response作预处理，再让目标资源执行</span></span><br><span class="line"><span class="comment">* 3、在目标资源执行之后，可以捕获目标资源的执行结果，从而实现一些特殊的功能</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterDemo01</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----过滤器初始化----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">            FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对request和response进行一些预处理</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"FilterDemo01执行前！！！"</span>);</span><br><span class="line">        chain.doFilter(request, response);  <span class="comment">//让目标资源执行，放行</span></span><br><span class="line">        System.out.println(<span class="string">"FilterDemo01执行后！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----过滤器销毁----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在web-xml中配置过滤器"><a href="#在web-xml中配置过滤器" class="headerlink" title="在web. xml中配置过滤器"></a>在web. xml中配置过滤器</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterDemo01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>me.gacl.web.filter.FilterDemo01<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--映射过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterDemo01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--“/*”表示拦截所有的请求 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3948353.html" target="_blank" rel="noopener">javaweb学习总结(四十二)——Filter(过滤器)学习</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Filter简介&quot;&gt;&lt;a href=&quot;#一、Filter简介&quot; class=&quot;headerlink&quot; title=&quot;一、Filter简介&quot;&gt;&lt;/a&gt;一、Filter简介&lt;/h2&gt;&lt;p&gt;　　Filter也称之为&lt;strong&gt;过滤器&lt;/strong&gt;，WEB开发
      
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Filter" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Filter/"/>
    
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---面向对象(2)</title>
    <link href="http://yoursite.com/2019/03/08/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(2)/"/>
    <id>http://yoursite.com/2019/03/08/Java基础知识---面向对象(2)/</id>
    <published>2019-03-08T03:38:55.000Z</published>
    <updated>2019-03-13T13:39:31.680Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-Java类的定义"><a href="#一-Java类的定义" class="headerlink" title="一. Java类的定义"></a>一. Java类的定义</h3><blockquote><p>使用 <strong>class</strong> 关键字定义一个类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 成员变量(属性)定义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//方法定义</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        age = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="二-成员变量"><a href="#二-成员变量" class="headerlink" title="二. 成员变量"></a>二. 成员变量</h3><ul><li>成员变量的作用范围为 <strong>整个类体</strong></li><li>定义成员变量可以对其初始化, 如果 <strong>不对其初始化</strong> , Java <strong>使用默认的值</strong> 对其初始化(若不记得JAVA对成员变量默认的初始化是多少的话，定义一个成员变量，不给它初始化，然后直接打印这个成员变量,进行查看)</li></ul><blockquote><p>在 <strong>JAVA</strong> 里面的任何变量首先应该要声明，然后再赋值，然后再使用</p></blockquote><p> <strong>成员变量和局部变量的区别:</strong> </p><table><thead><tr><th style="text-align:center"></th><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td style="text-align:center">不进行初始化</td><td>默认给初始化</td><td>不默认给初始化, <strong>在方法里面声明一个局部变量如果不给它初始化时就会出错</strong></td></tr></tbody></table><h3 id="三-基本概念-—-引用"><a href="#三-基本概念-—-引用" class="headerlink" title="三. 基本概念 — 引用"></a>三. 基本概念 — 引用</h3><p>​    Java语言中 <strong>除基本类型之外</strong> 的变量类型都称之为引用类型</p><ul><li>Java中的对象是通过引用对其操作的</li></ul><h4 id="基本类型与引用类型的区别"><a href="#基本类型与引用类型的区别" class="headerlink" title="基本类型与引用类型的区别:"></a>基本类型与引用类型的区别:</h4><table><thead><tr><th></th><th>基本类型</th><th>引用类型</th></tr></thead><tbody><tr><td>实现</td><td>当声明一个int  i=0时，系统会马上给这个i分配一个内存空间（在 <strong>栈内存</strong> 里面分配一小块区域用来装数字0），里面装着一个值为0，以后使用i这个名字马上就可以访问这个内存空间里面的值</td><td>定义好这个类之后，需要使用new关键字把这个类的对象实例化出来，也就是真真正正造出一个对象出来才能使用这个对象</td></tr><tr><td>内存</td><td>占 <strong>一块</strong> 内存</td><td>占 <strong>两块</strong> 内存</td></tr><tr><td>存放位置</td><td>栈内存</td><td>栈内存: 引用对象   堆内存: 真正的内容(new出来的东西)</td></tr></tbody></table><blockquote><p>不论是基本数据类型还是引用类型，<strong>都会先在栈中分配一块内存</strong> ，对于基本类型来说，这块区域包含的是 <strong>基本类型的内容</strong>；而对于引用类型来说，这块区域包含的是 <strong>指向真正内容的指针(存放真正内容的地址)</strong> ，真正的内容被手动的分配在堆上。</p></blockquote><h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例:"></a>代码实例:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    String name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">float</span> hp; <span class="comment">//血量</span></span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代表创建了一个Hero对象</span></span><br><span class="line"><span class="comment">//但是也仅仅是创建了一个对象，没有办法访问它</span></span><br><span class="line"><span class="comment">//为了访问这个对象，会使用引用来代表这个对象</span></span><br><span class="line">        <span class="keyword">new</span> Hero();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//"h"这个变量是Hero类型，叫做引用(也叫 引用对象,对象的引用)</span></span><br><span class="line"><span class="comment">//"="的意思指的h这个引用代表右侧创建的对象</span></span><br><span class="line"><span class="comment">//“代表” 在面向对象里，又叫做“指向” </span></span><br><span class="line">        <span class="comment">//引用h指向了新建的Hero对象</span></span><br><span class="line">        Hero h = <span class="keyword">new</span> Hero();  </span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多个引用，一个对象，一个引用，多个对象区别："><a href="#多个引用，一个对象，一个引用，多个对象区别：" class="headerlink" title="多个引用，一个对象，一个引用，多个对象区别："></a>多个引用，一个对象，一个引用，多个对象<strong>区别：</strong></h4><ul><li>多个引用指向一个对象，操作的都是同一个对象</li><li>一个引用多个对象，之前的对象就没有办法访问了, 这个引用就指向了另一个对象</li></ul><h2 id="四-类和对象的关系"><a href="#四-类和对象的关系" class="headerlink" title="四. 类和对象的关系"></a>四. 类和对象的关系</h2><h4 id="如何在内存中区分类和对象"><a href="#如何在内存中区分类和对象" class="headerlink" title="如何在内存中区分类和对象"></a>如何在内存中区分类和对象</h4><ul><li><p>类是 <strong>静态</strong> 的概念, 在<strong>代码区</strong> </p></li><li><p>对象是new出来的, 位于 <strong>堆内存</strong> , <strong>类的每个成员变量在不同的对象中都有不同的值</strong> (除了静态变量,static),<strong>而方法只有一分,执行的时候才占用内存</strong> .</p></li></ul><p><img src="/2019/03/08/Java基础知识---面向对象(2)/blog\source\images\java基础知识\java面向对象__引用.png" alt="java面向对象__引用"></p><h2 id="五-构造方法-函数"><a href="#五-构造方法-函数" class="headerlink" title="五. 构造方法(函数)"></a>五. 构造方法(函数)</h2><blockquote><p><strong>主要作用</strong> :完成对象的初始化工作，(如果写的类里面没有构造函数,那么编译器会默认加上一个无参数且方法体为空的构造函数)</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>使用 new + 构造方法创建一个新的对象</li><li>构造函数是定义在 Java类中的一个用来 <strong>初始化对象</strong> 的函数,(new一个东西的时候，实际上你调用的是一个构造方法，构造方法就是把自己构造成一个新的对象，所以叫构造方法，构造一个新对象用的方法叫构造方法)</li><li>构造函数与类同名, 且没有返回值(构造方法的名字必须和类的名字完全一模一样，包括大小写,这个方法的名字和类名完全相同，并且没有返回值，也就是在这个方法前面不能写任何的方法的返回类型修饰符，连void都不可以写)</li></ul><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;  <span class="comment">//在person这类里面定义两个成员变量id和age,</span></span><br><span class="line">    <span class="keyword">int</span> age=<span class="number">20</span>;  <span class="comment">//给成员变量age赋了初值为20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**这里就是person这个类的一个构造方法</span></span><br><span class="line"><span class="comment">     * 构造方法的规则很简单，和类名要完全一样，一点都不能错，包括大小写。</span></span><br><span class="line"><span class="comment">     * 并且没有返回值，不能写void在它前面修饰</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> _id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> _age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> _id,<span class="keyword">int</span> _age )</span> </span>&#123;</span><br><span class="line">        id = _id;</span><br><span class="line">        age = _age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内存分析见 孤傲苍狼博客</span></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><p>如果类已经有了一个有参数有方法体的构造函数,这时编译器就不会再给它默认加上一个无参且方法体为空的构造函数.可以理解为无参的构造函数被覆盖了.这种情况称为没有默认构造函数</p></blockquote><h3 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h3><h4 id="数据区、代码区、栈区、堆区-区别"><a href="#数据区、代码区、栈区、堆区-区别" class="headerlink" title="数据区、代码区、栈区、堆区 区别:"></a>数据区、代码区、栈区、堆区 区别:</h4><ol><li><p>栈区(stack)：由系统的编译器自动的释放， <strong>主要用来存放方法中的参数，一些临时的局部变量等</strong> ，并且方法中的参数一般在操作完后，会由编译器自动的释放掉。</p></li><li><p>堆区(heap):由程序员决定，在Java中，如果程序员不释放的话，一般会由垃圾回收机制自动的清理掉。此区域主要用来 <strong>存放我们经常创建的对象、动态的申请的临时空间等</strong> 。</p></li><li><p>数据区(data seg):也称全局区或者静态区，根据名称我们就应该知道用来存放一些全局的东西，比如我们经常用到的 <strong>静态变量、全局变量等</strong> 都会存放到数据区，此区域上的东西都被全局所共享。比如我们可以采取类名.的方式就可以访问到方法，这就是所谓的静态方法，存放到数据区的。</p></li><li><p>代码区：存放 <strong>程序编译后可以执行代码的地方</strong> 。比如执行代码时写的While语句、if条件语句等，都会存放到此</p></li></ol><blockquote><p>理解了内存，就理解了一切，就理解了各种各样的语言。所有的语言无非都是这样：局部变量分配内存永远在栈里面，new出来的东西分配内存永远是在堆里，静态的东西分配内存永远是在数据区。剩下的代码肯定是在代码区</p></blockquote><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文:"></a>参考博文:</h5><p>how2J <a href="http://how2j.cn/k/class-object/class-object-reference/307.html" target="_blank" rel="noopener">类和对象</a></p><p>孤傲苍狼 <a href="https://www.cnblogs.com/xdp-gacl/p/3628880.html" target="_blank" rel="noopener">java基础学习总结——面向对象2</a></p><p><a href="https://blog.csdn.net/weixin_43896747/article/details/85105144" target="_blank" rel="noopener">Java基本数据类型与引用数据类型 及在堆栈中内存的存储原理</a></p><p><a href="https://blog.csdn.net/luckyzhoustar/article/details/42386629" target="_blank" rel="noopener">数据区、代码区、栈区、堆区</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-Java类的定义&quot;&gt;&lt;a href=&quot;#一-Java类的定义&quot; class=&quot;headerlink&quot; title=&quot;一. Java类的定义&quot;&gt;&lt;/a&gt;一. Java类的定义&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;使用 &lt;strong&gt;class&lt;/strong&gt; 关键字定义一个类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 成员变量(属性)定义&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; age = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//方法定义&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getAge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; age; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setAge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        age = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---static关键字</title>
    <link href="http://yoursite.com/2019/03/08/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/03/08/Java基础知识---static关键字/</id>
    <published>2019-03-08T03:29:27.000Z</published>
    <updated>2019-03-12T13:15:43.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Static-关键字"><a href="#Static-关键字" class="headerlink" title="Static 关键字"></a>Static 关键字</h1><blockquote><p>static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途</p></blockquote><p><strong>基本作用:</strong> 方便在 <strong>没有创建对象</strong> 的情况下来进行调用(方法/变量),被static修饰的变量和方法其<strong>随着类的加载而被加载</strong> . 只要类被加载了，就可以通过类名去进行访问.</p><a id="more"></a><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><ul><li><p>在类中用static声明的成员变量为 <strong>静态成员变量</strong> (也叫<strong>类变量</strong>),</p></li><li><p>其为该类的公共变量,  在第一次使用时被初始化, 这个成员变量 <strong>只有一份</strong> ，而且这一份是这个类 <strong>所有的对象</strong> 共享, 属于整个类的，它不属于专门的某个对象</p><blockquote><p>非静态成员专属于某一个对象，想访问非静态成员必须new一个对象出来才能访问</p></blockquote></li><li><p>static成员变量的初始化顺序按照定义的顺序进行初始化</p></li></ul><h5 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h5><ul><li>注意不能把 <strong>任何方法体内的变量声明为静态</strong> </li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul><li><p>用<strong>static</strong> 声明的方法为静态方法(也叫<strong>类方法</strong>)</p></li><li><p>在静态方法里只能直接调用同类中其他的静态成员（包括变量和方法），而<strong>不能直接访问类中的非静态成员</strong> 。这是因为，对于非静态的方法和变量，需要先创建类的实例对象后才可使用，而静态方法在使用前不用创建任何对象。</p><blockquote><p>对于非静态成员方法，它访问静态成员方法/变量显然是毫无限制的</p></blockquote></li><li><p>静态方法不能以任何方式引用this和super关键字</p><ul><li>因为静态方法在使用前不用创建任何实例对象，当静态方法调用时，this所引用的对象根本没有产生。</li><li>由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了</li></ul></li></ul><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><p>​    想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。</p><p>​    最常见的static方法就是main方法。因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。</p><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><blockquote><p>用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p></blockquote><h5 id="为什么说static块可以用来优化程序性能"><a href="#为什么说static块可以用来优化程序性能" class="headerlink" title="为什么说static块可以用来优化程序性能"></a>为什么说static块可以用来优化程序性能</h5><p>​    是因为它的特性:只会在类加载的时候执行一次。</p><h3 id="杂"><a href="#杂" class="headerlink" title="杂:"></a>杂:</h3><p>​    static可以修饰内部类，但是不能修饰普通类。静态内部类的话可以直接调用静态构造器（不用对象）。</p><p>参考博文:<br>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3637407.html" target="_blank" rel="noopener">java基础学习总结——static关键字</a></p><p>​    <a href="https://www.nowcoder.com/questionTerminal/6f66f55a1f844e21b580e73d36223cf7" target="_blank" rel="noopener">优质答案</a></p><p>​    <a href="https://www.cnblogs.com/tiantianxiangshangg/articles/5080112.html" target="_blank" rel="noopener">java中静态代码块的用法 static用法详解</a></p><p>​    <a href="https://www.cnblogs.com/dolphin0520/p/3799052.html" target="_blank" rel="noopener">Java中的static关键字解析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Static-关键字&quot;&gt;&lt;a href=&quot;#Static-关键字&quot; class=&quot;headerlink&quot; title=&quot;Static 关键字&quot;&gt;&lt;/a&gt;Static 关键字&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;基本作用:&lt;/strong&gt; 方便在 &lt;strong&gt;没有创建对象&lt;/strong&gt; 的情况下来进行调用(方法/变量),被static修饰的变量和方法其&lt;strong&gt;随着类的加载而被加载&lt;/strong&gt; . 只要类被加载了，就可以通过类名去进行访问.&lt;/p&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Static关键字" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识---面向对象(1)</title>
    <link href="http://yoursite.com/2019/03/08/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(1)/"/>
    <id>http://yoursite.com/2019/03/08/Java基础知识---面向对象(1)/</id>
    <published>2019-03-08T02:37:18.000Z</published>
    <updated>2019-03-13T14:51:13.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-面向过程的思想和面向对象的思想"><a href="#一-面向过程的思想和面向对象的思想" class="headerlink" title="一. 面向过程的思想和面向对象的思想"></a>一. 面向过程的思想和面向对象的思想</h1><h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><blockquote><p><strong>自顶向下,逐步细化</strong> </p></blockquote><p>​    <strong>面向解决问题的过程进行编程</strong><br>​    按照步骤化解决问题.(一个问题,分析这个问题如何去解决,第一步做什么, 第二步什么…), 当我们用面向过程的思想去编程或解决问题时，首先一定要把详细的实现过程弄清楚。一旦过程设计清楚，代码的实现简直轻而易举。</p><a id="more"></a><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><blockquote><p>Java 中万物皆对象，模拟真实的现实世界</p></blockquote><p>​    在编程的时候尽可能的去模拟真实的现实世界，按照现实世界中的逻辑去处理一个问题，分析问题中参与其中的有<strong>哪些实体</strong>，这些实体应该<strong>有什么属性和方法</strong>，我们<strong>如何通过调用这些实体的属性和方法</strong>去解决问题。<br>拿到一个问题,应该<strong>分析</strong>: </p><ol><li>这个问题里面有哪些类和对象</li><li>在分析这些类和对象应该具有哪些属性和方法</li><li>分析类和类之间具有什么关系<blockquote><p>设计思维: 合适的方法应该出现在合适的类里面</p></blockquote></li></ol><h1 id="二-类和对象"><a href="#二-类和对象" class="headerlink" title="二. 类和对象"></a>二. 类和对象</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h4 id="一类事物的抽象"><a href="#一类事物的抽象" class="headerlink" title="一类事物的抽象"></a>一类事物的抽象</h4><p>包括属性(静态)和方法(动态)</p><ul><li><strong>属性:</strong> 用来描述这一个对象（类）的<strong>特征</strong> ,比如一个人的属性有身高，肤色，体重等等，</li><li><strong>方法:</strong> 可以<strong>完成一个特定的功能</strong>，方法就像是动作, 比如人可以吃饭，跑步，学习，都可以是方法<blockquote><p>Java中属性就是成员变量,方法就是函数, 不同的叫法</p></blockquote><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h4 id="一类事物的具体的某一个东西-符合这类事物的具体特征"><a href="#一类事物的具体的某一个东西-符合这类事物的具体特征" class="headerlink" title="一类事物的具体的某一个东西(符合这类事物的具体特征)"></a>一类事物的具体的某一个东西(符合这类事物的具体特征)</h4><blockquote><p>在Java中, 对象就是类的实例化</p></blockquote></li></ul><h4 id="随笔"><a href="#随笔" class="headerlink" title="随笔:"></a>随笔:</h4><blockquote><p>对象和类是分不开的，必须首先定义类才能有对象<br>类和对象的关系，类就是<strong>模板</strong>，里面定义着属性和方法，而对象就是<strong>实例</strong>，通过类来创建（new）对象，叫类的实例化</p></blockquote><h1 id="三-面向过程与面向对象的比较"><a href="#三-面向过程与面向对象的比较" class="headerlink" title="三. 面向过程与面向对象的比较"></a>三. 面向过程与面向对象的比较</h1><ol><li>都可以实现代码重用和模块化编程，但是面对对象的模块化更深，数据更封闭，也更安全！因为面向对象的封装性更强！</li><li>面对对象的思维方式更加贴近于现实生活，更容易解决大型的复杂的业务逻辑</li><li>从前期开发角度上来看，面对对象远比面向过程要复杂，但是从维护和扩展功能的角度上来看，面对对象远比面向过程要简单！<blockquote><p>当我们的业务逻辑比较简单时，使用面向过程能更快的实现<br>当我们的业务逻辑比较复杂时，为了将来的维护和扩展，还是面向对象更为靠谱</p></blockquote></li></ol><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://www.cnblogs.com/BeiGuo-FengGuang/p/5935763.html" target="_blank" rel="noopener">编程思想：面向对象和面向过程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-面向过程的思想和面向对象的思想&quot;&gt;&lt;a href=&quot;#一-面向过程的思想和面向对象的思想&quot; class=&quot;headerlink&quot; title=&quot;一. 面向过程的思想和面向对象的思想&quot;&gt;&lt;/a&gt;一. 面向过程的思想和面向对象的思想&lt;/h1&gt;&lt;h2 id=&quot;面向过程&quot;&gt;&lt;a href=&quot;#面向过程&quot; class=&quot;headerlink&quot; title=&quot;面向过程&quot;&gt;&lt;/a&gt;面向过程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;自顶向下,逐步细化&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​    &lt;strong&gt;面向解决问题的过程进行编程&lt;/strong&gt;&lt;br&gt;​    按照步骤化解决问题.(一个问题,分析这个问题如何去解决,第一步做什么, 第二步什么…), 当我们用面向过程的思想去编程或解决问题时，首先一定要把详细的实现过程弄清楚。一旦过程设计清楚，代码的实现简直轻而易举。&lt;/p&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>C语言基础知识</title>
    <link href="http://yoursite.com/2019/03/08/C%E8%AF%AD%E8%A8%80---%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/03/08/C语言---基础知识/</id>
    <published>2019-03-08T02:23:51.000Z</published>
    <updated>2019-03-13T07:43:23.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言基础知识"><a href="#C语言基础知识" class="headerlink" title="C语言基础知识:"></a>C语言基础知识:</h1><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体:"></a>结构体:</h2><p><strong>定义:</strong> 将一些已知的数据类型放在一起来定义的一种数据类型</p><blockquote><p>结构体并没有创造出新的数据类型，这点要搞清楚。C语言的结构体和其他高级语言的类有点相似的概念，可以完成对一种事物的抽象。</p></blockquote><p><strong>代码中的定义:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构名 // 结构名是结构的标识符不是变量名</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    类型  变量名; </span><br><span class="line">    类型  变量名;</span><br><span class="line">&#125; 结构变量;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">8</span>]; </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">    <span class="keyword">char</span> sex[<span class="number">2</span>]; </span><br><span class="line">    <span class="keyword">char</span> depart[<span class="number">20</span>]; </span><br><span class="line">    <span class="keyword">float</span> wage1, wage2, wage3, wage4, wage5; </span><br><span class="line">&#125; Mike, Marry;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">John</span>;</span><span class="comment">// struct student:类型说明符, John 变量名</span></span><br><span class="line"><span class="comment">// 定义了两个 struct student 类型的变量 Mike, Marry</span></span><br></pre></td></tr></table></figure><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef:"></a>typedef:</h2><blockquote><p>使用 typedef 关键字来定义自己习惯的数据类型名称，来替代系统默认的基本类型名称、数组类型名称、指针类型名称与用户自定义的结构型名称、共用型名称、枚举型名称等。</p></blockquote><p>基本用法</p><h3 id="1-为基本类型数据定义新的类型名"><a href="#1-为基本类型数据定义新的类型名" class="headerlink" title="1. 为基本类型数据定义新的类型名"></a>1. 为基本类型数据定义新的类型名</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> COUNT; <span class="comment">// 为基本类型数据定义新的类型名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">COUNT a = <span class="number">88</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"结果为: %d"</span>, a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果: 结果为: 88</span></span><br></pre></td></tr></table></figure><h3 id="2-为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称"><a href="#2-为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称" class="headerlink" title="2. 为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称"></a>2. 为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以结构体为例，下面我们定义一个名为 Point 的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在调用这个结构体时，我们必须像下面的代码这样来调用这个结构体</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">oPoint2</span>;</span></span><br><span class="line">oPoint2.x = <span class="number">3.3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f"</span>, oPoint2.x); </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果: 3.300000</span></span><br></pre></td></tr></table></figure><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPoint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">&#125; Point;</span><br><span class="line"><span class="comment">// 1.相当于把 x = struct tagPoint &#123; …&#125;</span></span><br><span class="line"><span class="comment">// 2.typedef x Point;</span></span><br><span class="line"><span class="comment">// 可以看做是简写</span></span><br></pre></td></tr></table></figure><p><strong>参考文章:</strong> </p><p>​    <a href="http://c.biancheng.net/view/298.html" target="_blank" rel="noopener">typedef的用法，C语言typedef详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C语言基础知识&quot;&gt;&lt;a href=&quot;#C语言基础知识&quot; class=&quot;headerlink&quot; title=&quot;C语言基础知识:&quot;&gt;&lt;/a&gt;C语言基础知识:&lt;/h1&gt;&lt;h2 id=&quot;结构体&quot;&gt;&lt;a href=&quot;#结构体&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="C语言" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言---指针</title>
    <link href="http://yoursite.com/2019/03/08/C%E8%AF%AD%E8%A8%80---%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2019/03/08/C语言---指针/</id>
    <published>2019-03-08T02:23:51.000Z</published>
    <updated>2019-03-13T06:22:30.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="一-简单理解"><a href="#一-简单理解" class="headerlink" title="一. 简单理解"></a>一. 简单理解</h2><p><strong>指针变量:</strong> 专门用来存放地址的特殊变量</p><a id="more"></a><table><thead><tr><th></th><th>指针 ( = 变量的值)</th><th>指针变量 ( = 变量)</th></tr></thead><tbody><tr><td>含义</td><td>地址</td><td>存放另一个变量地址的变量</td></tr></tbody></table><blockquote><p>指针与指针变量的关系类似于变量的值与变量的区别.</p><p>指针变量习惯上简称为 <strong>指针</strong> </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, * p;</span><br><span class="line">p = &amp;a;<span class="comment">// "&amp;a" 代表a的地址的值 </span></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p的值为 %d\n"</span>, p); <span class="comment">// p中存放的是 a 的地址 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p的值为 %d"</span>, *p);<span class="comment">// * 号在 引用时表示"指向"操作, *p 代表 a,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "*"仅起到标志的作用, 表示该变量为指针变量, 不是变量名的一部分, 及指针变量名不包括 * </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-复杂类型说明"><a href="#二-复杂类型说明" class="headerlink" title="二. 复杂类型说明"></a>二. 复杂类型说明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> p; <span class="comment">//这是一个普通的整型变量  </span></span><br><span class="line"><span class="keyword">int</span> *p; <span class="comment">//首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针  </span></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组  </span></span><br><span class="line"><span class="keyword">int</span> *p[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组  </span></span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与"()"这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针  </span></span><br><span class="line"><span class="keyword">int</span> **p; <span class="comment">//首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据  </span></span><br><span class="line">Int (*p)(<span class="keyword">int</span>); <span class="comment">//从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针  </span></span><br><span class="line"><span class="keyword">int</span> *(*p(<span class="keyword">int</span>))[<span class="number">3</span>]; <span class="comment">//可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.</span></span><br></pre></td></tr></table></figure><h2 id="三-细说指针"><a href="#三-细说指针" class="headerlink" title="三. 细说指针"></a>三. 细说指针</h2><p>指针是一个 <strong>特殊的变量</strong> ，它里面 <strong>存储的数值</strong> 被解释成为 <strong>内存里的一个地址</strong> 。要搞清一个指针需要搞清指针的四方面的内容：</p><ul><li>指针的类型</li><li>指针所指向的类型</li><li>指针的值或者叫指针所指向的内存区</li><li>指针本身所占据的内存区。</li></ul><h2 id="3-1-指针的类型"><a href="#3-1-指针的类型" class="headerlink" title="3.1 指针的类型"></a>3.1 指针的类型</h2><p>从语法的角度看，你只要<strong>把指针声明语句里的指针名字去掉</strong>，<strong>剩下的部分就是这个指针的类型</strong>。这是指针本身所具有的类型。例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ptr;<span class="comment">//指针的类型是int*</span></span><br><span class="line"><span class="keyword">char</span> * ptr;<span class="comment">//指针的类型是char*</span></span><br><span class="line"><span class="keyword">int</span> ** ptr;<span class="comment">//指针的类型是int**</span></span><br><span class="line"><span class="keyword">int</span> (* ptr)[<span class="number">3</span>];<span class="comment">//指针的类型是int(*)[3]</span></span><br><span class="line"><span class="keyword">int</span> * (* ptr)[<span class="number">4</span>];<span class="comment">//指针的类型是int*(*)[4]</span></span><br></pre></td></tr></table></figure><h2 id="3-2-指针所指向的类型"><a href="#3-2-指针所指向的类型" class="headerlink" title="3.2 指针所指向的类型"></a>3.2 指针所指向的类型</h2><p>当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把<strong>那片内存区里的内容当做什么来看待</strong>。<br>从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符去掉，剩下的就是指针所指向的类型。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ptr; <span class="comment">//指针所指向的类型是int</span></span><br><span class="line"><span class="keyword">char</span> * ptr; <span class="comment">//指针所指向的的类型是char</span></span><br><span class="line"><span class="keyword">int</span> ** ptr; <span class="comment">//指针所指向的的类型是int</span></span><br><span class="line"><span class="keyword">int</span> (*ptr)[<span class="number">3</span>]; <span class="comment">//指针所指向的的类型是int()[3]</span></span><br><span class="line"><span class="keyword">int</span> (ptr)[<span class="number">4</span>]; <span class="comment">//指针所指向的的类型是int*()[4]</span></span><br></pre></td></tr></table></figure><blockquote><p>指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C 越来越熟悉时，你会发现，把与指针搅和在一起的”类型”这个概念分成”指针的类型”和”指针所指向的类型”两个概念，是精通指针的关键点之一。</p></blockquote><h2 id="3-3-指针的值—-或者叫指针所指向的内存区或地址"><a href="#3-3-指针的值—-或者叫指针所指向的内存区或地址" class="headerlink" title="3.3 指针的值—-或者叫指针所指向的内存区或地址"></a>3.3 指针的值—-或者叫指针所指向的内存区或地址</h2><blockquote><p>指针的值是指针本身存储的数值，这个值将被编译器<strong>当作一个地址</strong>，而不是一个一般的数值。</p></blockquote><ul><li><p>在32 位程序里，所有类型的指针的值都是一个32 位整数，因为32 位程序里内存地址全都是32 位长。<strong>指针所指向的内存区就是从指针的值所代表的那个内存地址开始</strong>，长度为sizeof(指针所指向的类型)的一片内存区</p></li><li><p>我们<strong>说一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域</strong>；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。<strong>指针所指向的内存区和指针所指向的类型是两个完全不同的概念</strong>。在3.2例子中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。</p></li></ul><blockquote><h5 id="以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？"><a href="#以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？" class="headerlink" title="以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？"></a>以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？</h5></blockquote><h3 id="3-4-指针本身所占据的内存区"><a href="#3-4-指针本身所占据的内存区" class="headerlink" title="3.4 指针本身所占据的内存区"></a>3.4 指针本身所占据的内存区</h3><p>指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32 位平台里，指针本身占据了4 个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式（后面会解释）是否是左值时很有用</p><h2 id="四-指针的算术运算"><a href="#四-指针的算术运算" class="headerlink" title="四. 指针的算术运算"></a>四. 指针的算术运算</h2><h2 id="五-运算符-amp-和"><a href="#五-运算符-amp-和" class="headerlink" title="五. 运算符 &amp; 和 *"></a>五. 运算符 <code>&amp;</code> 和 <code>*</code></h2><p>这里 <code>&amp;</code> 是取地址运算符，<code>*</code> 是间接运算符。<br><code>&amp;a</code> 的运算结果是<strong>一个指针</strong>，指针的类型是a 的类型加个<code>*</code> ，指针所指向的类型是a 的类型，指针所指向的地址嘛，<strong>那就是a 的地址</strong>。</p><p><code>*p</code> 的运算结果就五花八门了。总之<code>*p</code> 的结果是 <strong>p 所指向的东西</strong>，这个东西有这些特点：它的类型是p 指向的类型，它所占用的地址是p所指向的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">12</span>; <span class="keyword">int</span> b; </span><br><span class="line"><span class="keyword">int</span> *p; <span class="keyword">int</span> **ptr;  </span><br><span class="line">p=&amp;a; <span class="comment">//&amp;a 的结果是一个指针，类型是int*，指向的类型是int，指向的地址是a的地址。  </span></span><br><span class="line">*p=<span class="number">24</span>; <span class="comment">//*p 的结果，在这里它的类型是int，它所占用的地址是p所指向的地址，*p就是变量a。  </span></span><br><span class="line"><span class="comment">// 下面的还有有看懂</span></span><br><span class="line">ptr=&amp;p; <span class="comment">//&amp;p 的结果是个指针，该指针的类型是p 的类型加个*, 在这里是int **。该指针所指向的类</span></span><br><span class="line"><span class="comment">//型是p的类型，这里是int*。该指针所指向的地址就是指针p 自己的地址。  </span></span><br><span class="line">*ptr=&amp;b; <span class="comment">//*ptr 是个指针，&amp;b 的结果也是个指针，且这两个指针  </span></span><br><span class="line"><span class="comment">//的类型和所指向的类型是一样的，所以用&amp;b 来给*ptr 赋  </span></span><br><span class="line"><span class="comment">//值就是毫无问题的了。  </span></span><br><span class="line">**ptr=<span class="number">34</span>; <span class="comment">//*ptr 的结果是ptr 所指向的东西，在这里是一个指针，  </span></span><br><span class="line"><span class="comment">//对这个指针再做一次*运算，结果是一个int 类型的变量。</span></span><br></pre></td></tr></table></figure><h2 id="六-指针表达式"><a href="#六-指针表达式" class="headerlink" title="六. 指针表达式"></a>六. 指针表达式</h2><p>一个表达式的结果如果是一个指针，那么这个表达式就叫指针表式。</p><h2 id="七-数组和指针的关系"><a href="#七-数组和指针的关系" class="headerlink" title="七. 数组和指针的关系"></a>七. 数组和指针的关系</h2><h2 id="八-指针和结构类型的关系"><a href="#八-指针和结构类型的关系" class="headerlink" title="八. 指针和结构类型的关系"></a>八. 指针和结构类型的关系</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> a;  </span><br><span class="line">    <span class="keyword">int</span> b;  </span><br><span class="line">    <span class="keyword">int</span> c;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">// 声明了结构对象ss，并把ss 的成员初始化为20，30 和40。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> <span class="title">ss</span> = &#123;</span><span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明了一个指向结构对象 ss 的指针。它的类型是MyStruct *,它指向的类型是MyStruct。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> *<span class="title">ptr</span> = &amp;<span class="title">ss</span>;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明了一个指向结构对象ss 的指针。但是pstr 和它被指向的类型ptr 是不同的。</span></span><br><span class="line"><span class="keyword">int</span> *pstr = (<span class="keyword">int</span>*)&amp;ss;</span><br></pre></td></tr></table></figure><h4 id="请问怎样通过指针ptr-来访问ss-的三个成员变量？"><a href="#请问怎样通过指针ptr-来访问ss-的三个成员变量？" class="headerlink" title="请问怎样通过指针ptr 来访问ss 的三个成员变量？"></a>请问怎样通过指针ptr 来访问ss 的三个成员变量？</h4><p>答案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;a; <span class="comment">//指向运算符，或者可以这们(*ptr).a,建议使用前者</span></span><br><span class="line">ptr-&gt;b;</span><br><span class="line">ptr-&gt;c;</span><br></pre></td></tr></table></figure><h2 id="九-指针和函数的关系"><a href="#九-指针和函数的关系" class="headerlink" title="九. 指针和函数的关系"></a>九. 指针和函数的关系</h2><p>可以把一个指针声明成为一个指向函数的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">char</span> *,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*pfun1)(<span class="keyword">char</span> ,<span class="keyword">int</span>);</span><br><span class="line">pfun1 = fun1;</span><br><span class="line"><span class="keyword">int</span> a = (*pfun1)(<span class="string">"abcdefg"</span>,<span class="number">7</span>); <span class="comment">//通过函数指针调用函数。</span></span><br></pre></td></tr></table></figure><p>可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *)</span></span>;  </span><br><span class="line"><span class="keyword">int</span> a;  </span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"abcdefghijklmn"</span>;  </span><br><span class="line">a = fun(str);  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *s)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;;)  </span><br><span class="line">    &#123;  </span><br><span class="line">        num+=*s;s++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> num;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中的函数fun 统计一个字符串中各个字符的ASCII 码值之和。前面说了，数组的名字也是一个指针。在函数调用中，当把str作为实参传递给形参s 后，实际是把str 的值传递给了s，s 所指向的地址就和str 所指向的地址一致，但是str 和s 各自占用各自的存储空间。在函数体内对s 进行自加1 运算，并不意味着同时对str 进行了自加1 运算。</p><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h5><p>​    <a href="https://blog.csdn.net/constantin_/article/details/79575638" target="_blank" rel="noopener">C语言指针详解(经典,非常详细)</a></p><p>​    <a href="https://blog.csdn.net/qq_33757398/article/details/81265884" target="_blank" rel="noopener">指针与函数</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;指针&quot;&gt;&lt;a href=&quot;#指针&quot; class=&quot;headerlink&quot; title=&quot;指针&quot;&gt;&lt;/a&gt;指针&lt;/h1&gt;&lt;h2 id=&quot;一-简单理解&quot;&gt;&lt;a href=&quot;#一-简单理解&quot; class=&quot;headerlink&quot; title=&quot;一. 简单理解&quot;&gt;&lt;/a&gt;一. 简单理解&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;指针变量:&lt;/strong&gt; 专门用来存放地址的特殊变量&lt;/p&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="指针" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/%E6%8C%87%E9%92%88/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>数据结构---链表的概念及实现</title>
    <link href="http://yoursite.com/2019/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/03/08/数据结构---单链表的概念及实现/</id>
    <published>2019-03-08T00:24:53.000Z</published>
    <updated>2019-03-13T03:44:55.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>线性表的<strong>链接存储结构</strong>成为链表</p><p>常见的链表: </p><ol><li>单链表(每个节点有一个指针域的链表)</li><li>循环链表</li><li>双链表(每个节点有两个指针域的链表)</li></ol><p>特点: </p><ul><li>用一组任意的存储单元存储线性表的数据结构(存储单元可以是连续的,也可以是不连续的</li><li>数据元素的逻辑次序和物理次序 <strong>==不一定一致==</strong></li></ul><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li><p><strong>结点:</strong> 基本单元,由两部分组成</p><ul><li>数据域: 用来存放节点本身的信息</li><li>指针域:用来存放本节点的直接后继节点的地址</li></ul></li><li><p><strong>空指针:</strong> 链表中最后一个节点的指针域不指向任何节点(通常用”∧”或者”NULL”表示</p></li><li><p><strong>头指针:</strong> 指向单链表第一个节点的指针(head)</p></li><li><p><strong>空表:</strong> 之神 head 为空指针,即 head=NULL</p></li><li><p><strong>表头结点:</strong> 第一个节点之前再增加一个类型相同的结点(为了便于实现链表的各种运算, 其他节点成为表结点)</p></li><li><p><strong>表结点:</strong>  除了表头结点其他的结点</p><blockquote><p>在表结点中,第一个节点称为<strong>首结点</strong> ,最后一个节点称为 <strong>尾节点</strong></p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h1&gt;&lt;p&gt;线性表的&lt;strong&gt;链接存储结构&lt;/strong&gt;成为链表&lt;/p&gt;
&lt;p&gt;常见的链表: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单链表(每个节点有一
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="单链表" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构---线性表</title>
    <link href="http://yoursite.com/2019/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/03/08/数据结构---线性表/</id>
    <published>2019-03-08T00:24:53.000Z</published>
    <updated>2019-03-13T02:49:19.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性表："><a href="#线性表：" class="headerlink" title="线性表："></a>线性表：</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h3><p>​    由 n(n≥0) 个数据特性相同的元素构成的 <strong>有限序列</strong> </p><a id="more"></a><h4 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h4><ul><li>存在唯一的一个被称为”第一个”的数据元素</li><li>存在唯一的一个被称为”最后一个”的数据元素</li><li>除第一个之外, 结构中的每个数据元素均只有一个前驱元素</li><li>除最后一个之外, 结构中的每个数据元素均只有一个后继元素</li></ul><h4 id="存储结构及运算"><a href="#存储结构及运算" class="headerlink" title="存储结构及运算:"></a>存储结构及运算:</h4><ul><li><strong>存储结构方式:</strong>  顺序存储方式(顺序表), 链接存储方式(链表)</li><li><strong>运算:</strong> <ol><li>线性表的初始化 </li><li>求表的长度 </li><li>取出表的元素 </li><li>查找运算</li></ol></li></ul><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul><li>空表: 线性表的长度 n=0</li><li>前驱元素: 如果 a~i~ 和a~i+1~ 是相邻的具有前后关系的两个元素, 则 a~i~ 称为 a~i+1~ 的前驱元素</li><li>后继元素: 如果 a~i~ 和a~i+1~ 是相邻的具有前后关系的两个元素, 则 a~i+1~ 称为 a~i~ 的前驱元素</li></ul><h4 id="随笔"><a href="#随笔" class="headerlink" title="随笔:"></a>随笔:</h4><ul><li>线性表中的数据元素之间的逻辑关系就是其相互位置上的 <strong>邻接关系</strong> ,该关系是线性的,因此,线性表是一种<strong>线性结构</strong> </li><li><strong>常见例子:</strong> 学生成绩表, 列车时刻表, 英文字母表</li></ul><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线性表：&quot;&gt;&lt;a href=&quot;#线性表：&quot; class=&quot;headerlink&quot; title=&quot;线性表：&quot;&gt;&lt;/a&gt;线性表：&lt;/h1&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义:&quot;&gt;&lt;/a&gt;定义:&lt;/h3&gt;&lt;p&gt;​    由 n(n≥0) 个数据特性相同的元素构成的 &lt;strong&gt;有限序列&lt;/strong&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线性表" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>涂磊老师语录</title>
    <link href="http://yoursite.com/2019/03/07/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E6%88%91%E6%88%90%E9%95%BF---%E6%B6%82%E7%A3%8A/"/>
    <id>http://yoursite.com/2019/03/07/人间词话---自我成长---涂磊/</id>
    <published>2019-03-07T14:54:18.000Z</published>
    <updated>2019-03-08T05:25:49.954Z</updated>
    
    <content type="html"><![CDATA[<ul><li>我们总是善于去伤害那些爱我们的人， 因为我们根本伤害不了那些不爱我们的人;我们总是甘愿被那些我们爱的人伤害，那是因为我爱他们</li><li>喜欢可以心动，而爱一定会心痛；喜欢可以舍得，但爱一定舍不得；喜欢一个人，冬天不过是冬天，不过是漂亮一点而已；但是爱一个人，冬天可以变成春天；爱一个人，她落泪你就会跟着她一起落泪；而喜欢一个人，她落泪你只不过是安慰；喜欢是可以变成爱的，但如果爱了就说不出喜欢；喜欢是不排她的，而爱一定是排她的，唯一的；喜欢与责任无关，而爱一定要负责任，这就是喜欢和爱的区别</li></ul><a id="more"></a><ul><li>春风得意的浪子回头最珍贵，穷途末路的认错悔改最虚伪</li><li>你曾经买了一件很喜欢的衣裳却舍不得穿，郑重地供奉在衣柜里；许久之后，当你再看见它的时候，却发现它已经过时了。所以，你就这样与它错过了。你也曾经买了一块漂亮的蛋糕却舍不得吃，郑重地供奉在冰箱里；许久之后，当你再看见它的时候，却发现它已经过期了。所以，你也这样与它错过了。没有在最喜欢的时候上身的衣裳，没有在最可口的时候品尝的蛋糕，就像没有在最想做的时候去做的事情，都是遗憾。生命也有保存期限，想做的事该趁早去做。如果你只是把你的心愿郑重地供奉在心里，却未曾去实行，那么唯一的结果，就是与它错过，一如那件过时的衣裳，一如那块过期的蛋糕</li><li>有些人注定是你生命中的过客，却总是成为你记忆中的常客，但永远也仅止于做客</li><li>你以为责任是什么？你以为责任就是终身相守，扔几个钱在家里。真正的责任是要在乎你所爱的人的每一分每一秒的感受</li><li>男人无事献殷勤非奸即盗，女人对爱来者不拒不是欺就是爱</li><li>人最伟大的力量不是创造，而是自省！如果不能自我反省，不能看到自身的错误和不足，即使有非凡的力量，创造出的一切都只是埋没自己的坟墓！</li><li>越是嘴上说自己有原则的人，越是圆滑，因为他们的原则便是永远不说负责任的话，永远模棱两可！狡猾的眼神中永远透露的是欺骗，向下的嘴角代表的永远是严肃。</li><li>在我看来，绝大多数现代人的虚荣来自于虚伪，虚伪来自于自卑！在日常生活中衣着光鲜、牛逼哄哄的家伙其实内心很恐慌！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;我们总是善于去伤害那些爱我们的人， 因为我们根本伤害不了那些不爱我们的人;我们总是甘愿被那些我们爱的人伤害，那是因为我爱他们&lt;/li&gt;
&lt;li&gt;喜欢可以心动，而爱一定会心痛；喜欢可以舍得，但爱一定舍不得；喜欢一个人，冬天不过是冬天，不过是漂亮一点而已；但是爱一个人，冬天可以变成春天；爱一个人，她落泪你就会跟着她一起落泪；而喜欢一个人，她落泪你只不过是安慰；喜欢是可以变成爱的，但如果爱了就说不出喜欢；喜欢是不排她的，而爱一定是排她的，唯一的；喜欢与责任无关，而爱一定要负责任，这就是喜欢和爱的区别&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="感悟" scheme="http://yoursite.com/categories/%E6%84%9F%E6%82%9F/"/>
    
      <category term="涂磊老师" scheme="http://yoursite.com/categories/%E6%84%9F%E6%82%9F/%E6%B6%82%E7%A3%8A%E8%80%81%E5%B8%88/"/>
    
    
      <category term="感悟" scheme="http://yoursite.com/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="人生方向" scheme="http://yoursite.com/tags/%E4%BA%BA%E7%94%9F%E6%96%B9%E5%90%91/"/>
    
      <category term="智慧" scheme="http://yoursite.com/tags/%E6%99%BA%E6%85%A7/"/>
    
      <category term="成长" scheme="http://yoursite.com/tags/%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>陈果老师语录</title>
    <link href="http://yoursite.com/2019/03/07/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E6%88%91%E6%88%90%E9%95%BF---%E9%99%88%E6%9E%9C/"/>
    <id>http://yoursite.com/2019/03/07/人间词话---自我成长---陈果/</id>
    <published>2019-03-07T14:54:18.000Z</published>
    <updated>2019-03-09T15:06:00.612Z</updated>
    
    <content type="html"><![CDATA[<ul><li>只有心灵才能洞察一切，世界上真正重要的东西要用心去看</li><li>你使用什么样的双眼观世界，就印证了你有怎样的心眼，如果心眼大，你所见的世界宽广无边，如果你心眼小，充满羡慕嫉妒恨，所见的世界也是偏狭丑陋</li><li>选择之所以称之为选择，一定是痛苦的，因为选项是不相上下的，能轻松做决定的，都不叫选择，选择意味着舍弃一种美好，承受一种痛苦，不安</li><li>回忆是一种重逢, 忘记是一份自由.</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;只有心灵才能洞察一切，世界上真正重要的东西要用心去看&lt;/li&gt;
&lt;li&gt;你使用什么样的双眼观世界，就印证了你有怎样的心眼，如果心眼大，你所见的世界宽广无边，如果你心眼小，充满羡慕嫉妒恨，所见的世界也是偏狭丑陋&lt;/li&gt;
&lt;li&gt;选择之所以称之为选择，一定是痛苦的，因为选项是不相上下的，能轻松做决定的，都不叫选择，选择意味着舍弃一种美好，承受一种痛苦，不安&lt;/li&gt;
&lt;li&gt;回忆是一种重逢, 忘记是一份自由.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="感悟" scheme="http://yoursite.com/categories/%E6%84%9F%E6%82%9F/"/>
    
      <category term="陈果老师" scheme="http://yoursite.com/categories/%E6%84%9F%E6%82%9F/%E9%99%88%E6%9E%9C%E8%80%81%E5%B8%88/"/>
    
    
      <category term="感悟" scheme="http://yoursite.com/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="人生方向" scheme="http://yoursite.com/tags/%E4%BA%BA%E7%94%9F%E6%96%B9%E5%90%91/"/>
    
      <category term="成长" scheme="http://yoursite.com/tags/%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(1)---基础语法(1)</title>
    <link href="http://yoursite.com/2019/03/07/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(1)---%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95(1)/"/>
    <id>http://yoursite.com/2019/03/07/Java基础知识(1)---基础语法(1)/</id>
    <published>2019-03-07T14:27:03.000Z</published>
    <updated>2019-03-14T00:10:18.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-标识符"><a href="#一-标识符" class="headerlink" title="一.标识符"></a>一.标识符</h1><p>​    对于各种变量, 方法和类等要素 <strong>命名时使用的字符序列</strong> 称为标识符</p><blockquote><p>凡是自己可以命名的地方都叫标识符, 都遵循标识符的规则</p></blockquote><h1 id="二-关键字"><a href="#二-关键字" class="headerlink" title="二.关键字"></a>二.关键字</h1><p>​    一些赋以特定的含义, <strong>用作专门用途的字符串</strong> 成为关键字</p><blockquote><p>大部分编辑会将关键字用特殊方式标出<br>所有Java关键字都是小写英文</p></blockquote><h1 id="三-java基础数据类型"><a href="#三-java基础数据类型" class="headerlink" title="三.  java基础数据类型"></a>三.  java基础数据类型</h1><h2 id="3-1-Java常量"><a href="#3-1-Java常量" class="headerlink" title="3.1 Java常量"></a>3.1 Java常量</h2><p>​    eg: 整型常量: 123, 字符常量: ‘a’</p><blockquote><p>注意: 区分字符常量和字符串常量<br>注意: “常量”这个名词还会用在另外其它语境中表示 <strong>值不可变的变量</strong> </p></blockquote><h2 id="3-2-Java变量"><a href="#3-2-Java变量" class="headerlink" title="3.2 Java变量"></a>3.2 Java变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量i(变量的名字)中存放常量100(变量的值)</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>; </span><br><span class="line"><span class="keyword">float</span> f = <span class="number">3.14</span>;</span><br><span class="line">String s = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><blockquote><p>变量是 <strong>内存</strong> 中的一小块区域, 使用 <strong>变量名</strong> 来访问这块区域<br>因此,每一个变量使用前必须要先 <strong>声明</strong>, 然后必须进行 <strong>赋值</strong> (填充内容), 才能使用</p></blockquote><h3 id="补充-本质上理解"><a href="#补充-本质上理解" class="headerlink" title="补充(本质上理解):"></a>补充(本质上理解):</h3><blockquote><ul><li>一个程序在运行的时候，实际上这个程序是位于内存里面，然后才开始运行。一个.exe文件 <strong>存放在硬盘上是无法运行的</strong> ，在硬盘上看到的.exe文件无非就是一个文件而已，当我们双击这个.exe文件时，运行起来的时候实际上是 <strong>整个.exe文件被放在了在内存里面</strong> ，然后操作系统找到main方法，也就是程序的入口，然后就开始执行了。执行的过程之中，<strong>会不断地在内存里面分配一些区域</strong> </li><li>变量在内存里面就是一小块区域，变量有两个概念，一个是变量的名字，另一个是变量的值<br>即这一小块区域是有名字的，里面装着一个值，因此以后要想访问这小块区域里面的内容就可以根据这小块区域的名字来访问了。因此，<strong>变量的本质就是一小块内存区域</strong> 。<br><strong>变量在内存里面分配多大的存储空间呢？</strong> 答: 不同的变量类型分配不同大小的存储空间，每一个变量都是属于特定的数据类型的，声明成不同的数据类型，它就在内存里面分配不同的存储空间。</li></ul></blockquote><h3 id="Java变量的分类"><a href="#Java变量的分类" class="headerlink" title="Java变量的分类:"></a>Java变量的分类:</h3><p>按被声明的 <strong>位置</strong> 划分:</p><ul><li>局部变量: <strong>方法或语句块内部</strong>定义的变量</li><li>成员变量: <strong>方法外部, 类的内部</strong>定义的变量</li></ul><blockquote><p>类外面不能有变量的声明</p></blockquote><p>按所属数据的 <strong>数据类型</strong> 划分:</p><ul><li><strong>基本</strong>数据类型变量</li><li><strong>引用</strong>数据类型变量</li></ul><h2 id="3-3-Java数据类型"><a href="#3-3-Java数据类型" class="headerlink" title="3.3 Java数据类型"></a>3.3 Java数据类型</h2><h3 id="3-3-1-基本数据类型"><a href="#3-3-1-基本数据类型" class="headerlink" title="3.3.1 基本数据类型"></a>3.3.1 基本数据类型</h3><ul><li><strong>整数型:</strong> byte, short, int, long,</li><li><strong>浮动型:</strong> float, double</li><li><strong>布尔型:</strong> bool</li><li><strong>字符型:</strong> char</li></ul><h3 id="3-3-2-基本数据类型的转换"><a href="#3-3-2-基本数据类型的转换" class="headerlink" title="3.3.2 基本数据类型的转换"></a>3.3.2 基本数据类型的转换</h3><ul><li>boolean 类型不可以转换为其他的数据类型</li><li>容量小的类型自动转换为容量大的数据类型</li><li>容量大的类型转换为容量小的数据类型时, 要加上强制转换符,可能造成精度降低或溢出</li><li>有多种类型的数据混合运算时,系统首先自动的将所有数据类型转换成 <strong>容量最大</strong> 的那一种数据类型,然后在进行计算</li></ul><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConvert</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">123</span>; </span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">456</span>;</span><br><span class="line">        <span class="keyword">double</span> d1 = (i1+i2)*<span class="number">1.2</span>;<span class="comment">//系统将转换为double型运算</span></span><br><span class="line">        <span class="keyword">float</span> f1 = (<span class="keyword">float</span>)((i1+i2)*<span class="number">1.2</span>);<span class="comment">//需要加强制转换符</span></span><br><span class="line">        <span class="keyword">byte</span> b1 = <span class="number">67</span>; </span><br><span class="line">        <span class="keyword">byte</span> b2 = <span class="number">89</span>;</span><br><span class="line">        <span class="keyword">byte</span> b3 = (<span class="keyword">byte</span>)(b1+b2);<span class="comment">//系统将转换为int型运算，需要强制转换符</span></span><br><span class="line">        System.out.println(b3);</span><br><span class="line">        <span class="keyword">double</span> d2 = <span class="number">1e200</span>;</span><br><span class="line">        <span class="keyword">float</span> f2 = (<span class="keyword">float</span>)d2;<span class="comment">//会产生溢出</span></span><br><span class="line">        System.out.println(f2);</span><br><span class="line">        <span class="keyword">float</span> f3 = <span class="number">1.23f</span>;<span class="comment">//必须加f</span></span><br><span class="line">        <span class="keyword">long</span> l1 = <span class="number">123</span>;</span><br><span class="line">        <span class="keyword">long</span> l2 = <span class="number">30000000000L</span>;<span class="comment">//必须加l</span></span><br><span class="line">        <span class="keyword">float</span> f = l1+l2+f3;<span class="comment">//系统将转换为float型计算</span></span><br><span class="line">        <span class="keyword">long</span> l = (<span class="keyword">long</span>)f;<span class="comment">//强制转换会舍去小数部分（不是四舍五入）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-3-引用数据类型"><a href="#3-3-3-引用数据类型" class="headerlink" title="3.3.3 引用数据类型"></a>3.3.3 引用数据类型</h3><ul><li>类(class)</li><li>接口(interface)</li><li>数组</li></ul><p>参考博文:<br>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3624567.html" target="_blank" rel="noopener">java基础学习总结——基础语法1</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-标识符&quot;&gt;&lt;a href=&quot;#一-标识符&quot; class=&quot;headerlink&quot; title=&quot;一.标识符&quot;&gt;&lt;/a&gt;一.标识符&lt;/h1&gt;&lt;p&gt;​    对于各种变量, 方法和类等要素 &lt;strong&gt;命名时使用的字符序列&lt;/strong&gt; 称为标识符&lt;/p&gt;
      
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="基础语法" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识(1)---基础语法(1)</title>
    <link href="http://yoursite.com/2019/03/07/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95(1)/"/>
    <id>http://yoursite.com/2019/03/07/Java基础知识---基础语法(1)/</id>
    <published>2019-03-07T14:27:03.000Z</published>
    <updated>2019-03-14T00:52:56.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-标识符"><a href="#一-标识符" class="headerlink" title="一.标识符"></a>一.标识符</h1><p>​    对于各种变量, 方法和类等要素 <strong>命名时使用的字符序列</strong> 称为标识符</p><blockquote><p>凡是自己可以命名的地方都叫标识符, 都遵循标识符的规则</p></blockquote><h1 id="二-关键字"><a href="#二-关键字" class="headerlink" title="二.关键字"></a>二.关键字</h1><p>​    一些赋以特定的含义, <strong>用作专门用途的字符串</strong> 成为关键字</p><blockquote><p>大部分编辑会将关键字用特殊方式标出<br>所有Java关键字都是小写英文</p></blockquote><h1 id="三-java基础数据类型"><a href="#三-java基础数据类型" class="headerlink" title="三.  java基础数据类型"></a>三.  java基础数据类型</h1><h2 id="3-1-Java常量"><a href="#3-1-Java常量" class="headerlink" title="3.1 Java常量"></a>3.1 Java常量</h2><p>​    eg: 整型常量: 123, 字符常量: ‘a’</p><blockquote><p>注意: 区分字符常量和字符串常量<br>注意: “常量”这个名词还会用在另外其它语境中表示 <strong>值不可变的变量</strong> </p></blockquote><h2 id="3-2-Java变量"><a href="#3-2-Java变量" class="headerlink" title="3.2 Java变量"></a>3.2 Java变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量i(变量的名字)中存放常量100(变量的值)</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>; </span><br><span class="line"><span class="keyword">float</span> f = <span class="number">3.14</span>;</span><br><span class="line">String s = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><blockquote><p>变量是 <strong>内存</strong> 中的一小块区域, 使用 <strong>变量名</strong> 来访问这块区域<br>因此,每一个变量使用前必须要先 <strong>声明</strong>, 然后必须进行 <strong>赋值</strong> (填充内容), 才能使用</p></blockquote><h3 id="补充-本质上理解"><a href="#补充-本质上理解" class="headerlink" title="补充(本质上理解):"></a>补充(本质上理解):</h3><blockquote><ul><li>一个程序在运行的时候，实际上这个程序是位于内存里面，然后才开始运行。一个.exe文件 <strong>存放在硬盘上是无法运行的</strong> ，在硬盘上看到的.exe文件无非就是一个文件而已，当我们双击这个.exe文件时，运行起来的时候实际上是 <strong>整个.exe文件被放在了在内存里面</strong> ，然后操作系统找到main方法，也就是程序的入口，然后就开始执行了。执行的过程之中，<strong>会不断地在内存里面分配一些区域</strong> </li><li>变量在内存里面就是一小块区域，变量有两个概念，一个是变量的名字，另一个是变量的值<br>即这一小块区域是有名字的，里面装着一个值，因此以后要想访问这小块区域里面的内容就可以根据这小块区域的名字来访问了。因此，<strong>变量的本质就是一小块内存区域</strong> 。<br><strong>变量在内存里面分配多大的存储空间呢？</strong> 答: 不同的变量类型分配不同大小的存储空间，每一个变量都是属于特定的数据类型的，声明成不同的数据类型，它就在内存里面分配不同的存储空间。</li></ul></blockquote><h3 id="Java变量的分类"><a href="#Java变量的分类" class="headerlink" title="Java变量的分类:"></a>Java变量的分类:</h3><p>按被声明的 <strong>位置</strong> 划分:</p><ul><li>局部变量: <strong>方法或语句块内部</strong>定义的变量</li><li>成员变量: <strong>方法外部, 类的内部</strong>定义的变量</li></ul><blockquote><p>类外面不能有变量的声明</p></blockquote><p>按所属数据的 <strong>数据类型</strong> 划分:</p><ul><li><strong>基本</strong>数据类型变量</li><li><strong>引用</strong>数据类型变量</li></ul><h2 id="3-3-Java数据类型"><a href="#3-3-Java数据类型" class="headerlink" title="3.3 Java数据类型"></a>3.3 Java数据类型</h2><h3 id="3-3-1-基本数据类型"><a href="#3-3-1-基本数据类型" class="headerlink" title="3.3.1 基本数据类型"></a>3.3.1 基本数据类型</h3><ul><li><strong>整数型:</strong> byte, short, int, long,</li><li><strong>浮动型:</strong> float, double</li><li><strong>布尔型:</strong> bool</li><li><strong>字符型:</strong> char</li></ul><h3 id="3-3-2-基本数据类型的转换"><a href="#3-3-2-基本数据类型的转换" class="headerlink" title="3.3.2 基本数据类型的转换"></a>3.3.2 基本数据类型的转换</h3><ul><li>boolean 类型不可以转换为其他的数据类型</li><li>容量小的类型自动转换为容量大的数据类型</li><li>容量大的类型转换为容量小的数据类型时, 要加上强制转换符,可能造成精度降低或溢出</li><li>有多种类型的数据混合运算时,系统首先自动的将所有数据类型转换成 <strong>容量最大</strong> 的那一种数据类型,然后在进行计算</li></ul><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConvert</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">123</span>; </span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">456</span>;</span><br><span class="line">        <span class="keyword">double</span> d1 = (i1+i2)*<span class="number">1.2</span>;<span class="comment">//系统将转换为double型运算</span></span><br><span class="line">        <span class="keyword">float</span> f1 = (<span class="keyword">float</span>)((i1+i2)*<span class="number">1.2</span>);<span class="comment">//需要加强制转换符</span></span><br><span class="line">        <span class="keyword">byte</span> b1 = <span class="number">67</span>; </span><br><span class="line">        <span class="keyword">byte</span> b2 = <span class="number">89</span>;</span><br><span class="line">        <span class="keyword">byte</span> b3 = (<span class="keyword">byte</span>)(b1+b2);<span class="comment">//系统将转换为int型运算，需要强制转换符</span></span><br><span class="line">        System.out.println(b3);</span><br><span class="line">        <span class="keyword">double</span> d2 = <span class="number">1e200</span>;</span><br><span class="line">        <span class="keyword">float</span> f2 = (<span class="keyword">float</span>)d2;<span class="comment">//会产生溢出</span></span><br><span class="line">        System.out.println(f2);</span><br><span class="line">        <span class="keyword">float</span> f3 = <span class="number">1.23f</span>;<span class="comment">//必须加f</span></span><br><span class="line">        <span class="keyword">long</span> l1 = <span class="number">123</span>;</span><br><span class="line">        <span class="keyword">long</span> l2 = <span class="number">30000000000L</span>;<span class="comment">//必须加l</span></span><br><span class="line">        <span class="keyword">float</span> f = l1+l2+f3;<span class="comment">//系统将转换为float型计算</span></span><br><span class="line">        <span class="keyword">long</span> l = (<span class="keyword">long</span>)f;<span class="comment">//强制转换会舍去小数部分（不是四舍五入）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-3-引用数据类型"><a href="#3-3-3-引用数据类型" class="headerlink" title="3.3.3 引用数据类型"></a>3.3.3 引用数据类型</h3><ul><li>类(class)</li><li>接口(interface)</li><li>数组</li></ul><p>参考博文:<br>​    <a href="https://www.cnblogs.com/xdp-gacl/p/3624567.html" target="_blank" rel="noopener">java基础学习总结——基础语法1</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-标识符&quot;&gt;&lt;a href=&quot;#一-标识符&quot; class=&quot;headerlink&quot; title=&quot;一.标识符&quot;&gt;&lt;/a&gt;一.标识符&lt;/h1&gt;&lt;p&gt;​    对于各种变量, 方法和类等要素 &lt;strong&gt;命名时使用的字符序列&lt;/strong&gt; 称为标识符&lt;/p&gt;
      
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="基础语法" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 常用命令</title>
    <link href="http://yoursite.com/2019/03/07/Hexo---%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/03/07/Hexo---常用命令/</id>
    <published>2019-03-07T02:59:05.000Z</published>
    <updated>2019-03-08T05:25:14.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-写文章"><a href="#1-写文章" class="headerlink" title="1. 写文章"></a>1. 写文章</h2><ul><li>写文章<br> 你可以执行下列命令来创建一篇新文章。</li></ul><blockquote><p>hexo new  <title>    #新建文章，可以改成中文的，如“新文章”，如果标题包含空格的话，请使用引号括起来。</title></p></blockquote><ul><li>删除文章<br> 先删除目标文章，然后重新运行</li></ul><blockquote><p>hexo clean # 清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)<br> hexo g -d # 文件生成后立即部署网站</p></blockquote><a id="more"></a><ul><li>写完文章后，你可以使用</li></ul><blockquote><p>hexo g  # 全称<code>hexo generate</code> , 生成静态文件（generate：产生）<br> hexo s  # 全称<code>hexo server</code> , 启动服务器，默认情况下，访问网址为<code>http://localhost:4000/</code>在本地预览效果<br> hexo d  # 全称<code>hexo deploy</code>, 部署网站，同步到github上（deploy：部署）</p></blockquote><h2 id="2-分类和标签"><a href="#2-分类和标签" class="headerlink" title="2. 分类和标签"></a>2. 分类和标签</h2><ul><li>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title: Hello World</span><br><span class="line">date: <span class="number">2013</span>/<span class="number">7</span>/<span class="number">13</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">25</span></span><br></pre></td></tr></table></figure><ul><li>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用</li></ul><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>layout</code></td><td>布局</td><td></td></tr><tr><td><code>title</code></td><td>标题</td><td></td></tr><tr><td><code>date</code></td><td>建立日期</td><td>文件建立日期</td></tr><tr><td><code>updated</code></td><td>更新日期</td><td>文件更新日期</td></tr><tr><td><code>comments</code></td><td>开启文章的评论功能</td><td>true</td></tr><tr><td><code>tags</code></td><td>标签（不适用于分页）</td><td></td></tr><tr><td><code>categories</code></td><td>分类（不适用于分页）</td><td></td></tr><tr><td><code>permalink</code></td><td>覆盖文章网址</td></tr></tbody></table><ul><li><p>分类和标签</p><p>只有文章支持分类和标签，您可以在 <code>Front-matter</code> 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：<strong>分类具有顺序性和层次性</strong>，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br><span class="line"><span class="comment"># 会使分类Games成为PS3的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-写文章&quot;&gt;&lt;a href=&quot;#1-写文章&quot; class=&quot;headerlink&quot; title=&quot;1. 写文章&quot;&gt;&lt;/a&gt;1. 写文章&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;写文章&lt;br&gt; 你可以执行下列命令来创建一篇新文章。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;hexo new  &lt;title&gt;    #新建文章，可以改成中文的，如“新文章”，如果标题包含空格的话，请使用引号括起来。&lt;/title&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;删除文章&lt;br&gt; 先删除目标文章，然后重新运行&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;hexo clean # 清除缓存文件 (&lt;code&gt;db.json&lt;/code&gt;) 和已生成的静态文件 (&lt;code&gt;public&lt;/code&gt;)&lt;br&gt; hexo g -d # 文件生成后立即部署网站&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
      <category term="基本操作" scheme="http://yoursite.com/categories/hexo/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="写作常用命令" scheme="http://yoursite.com/tags/%E5%86%99%E4%BD%9C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>java面试经典题目（1-5题）</title>
    <link href="http://yoursite.com/2019/03/07/java%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE(1-5%E9%A2%98)/"/>
    <id>http://yoursite.com/2019/03/07/java面试经典题目(1-5题)/</id>
    <published>2019-03-07T02:00:00.000Z</published>
    <updated>2019-03-12T14:12:18.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h1><p>答案：</p><blockquote><p>运行原理：java源程序经过<code>javac</code> 编译器编译成二进制的<code>xx.class</code> 字节码文件, <code>xx.class</code> 在<strong>jvm</strong>（各平台装有不同的jvm）上运行，java解释器（jvm的一部分）会将<strong>相同的字节码</strong>解释成对应平台的机器码，进而执行。</p></blockquote><a id="more"></a><p>知识：</p><blockquote><p>一份 <code>xx.class</code> 文件(不会变化）被 <strong>不同的jvm</strong> 解释成 <strong>相对应的机器码</strong> </p><p><strong>机器码:</strong> 依附于硬件，根本不存在跨平台行，不同型号的CPU给相同的指令（eg：10011110）,解析成不同的结果</p></blockquote><p>题外知识：</p><blockquote><p><strong>JDK</strong> (Java Development Kit): Java开发工具包，针对于<strong>Java开发员的产品</strong>，JDK是整个Java的核心，包括了JRE, Java工具（javac【编译java源码的编译器】，java程序调试和分析的工具）和Java基础的类库（即Java API)</p><p><strong>JRE</strong> (Java runtime environment)：Java运行环境 ,针对于<strong>使用Java程序的用户</strong>，java程序运行做需要的软件环境，不是一个开发环境, 包含jvm，java基础类库, 不包含任何开发工具（如编译器和调试器）。</p><p><strong>JVM</strong> (Java Virtual Machine): Java虚拟机，实现java跨平台的最核心的部分，JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行</p></blockquote><h1 id="2-JDK和JRE的区别是什么？"><a href="#2-JDK和JRE的区别是什么？" class="headerlink" title="2. JDK和JRE的区别是什么？"></a>2. JDK和JRE的区别是什么？</h1><p>答案：</p><blockquote><p>详细区别见第一题</p><p>如果需要运行Java程序，只需要安装JRE（JRE根据不同操作系统有很多不同的版本）</p><p>如果需要编写Java程序，需要安装JDK</p></blockquote><p>补充知识：</p><blockquote><p>JRE和JVM的区别是什么？</p><p>JRE包括JVM和lib（Jvm所需要的类库），JRE里有运行<code>xx.class</code> 的<code>java.exe</code> </p><p>只有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库</p></blockquote><p>时间：2019.3.7</p><h1 id="3-”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？"><a href="#3-”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？" class="headerlink" title="3. ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？"></a>3. ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</h1><p>答案:</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p> 表示静态的意思, 可用于修饰 <strong>成员变量</strong>和 <strong>方法</strong> , 静态是随着类的加载而加载, 因此可以直接用类进行访问</p><h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>私有的方法不能被继承，子类就没有访问权限</p><h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><ul><li><p>覆盖基于运动时动态绑定的</p></li><li><p>指覆盖了一个方法并且对其重写，以求达到不同的作用,，但是子类中的访问权限要不低于父类中的访问权限,重写的前提是必须要继承.</p></li></ul><p>Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。 </p><p>私有的方法不能被继承，子类就没有访问权限，肯定也是不能别覆盖的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span>&#123;</span><br><span class="line">   <span class="comment">// 静态方法</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> String <span class="title">greeting</span><span class="params">()</span></span>&#123;   </span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Good night"</span>;   </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function">String <span class="title">name</span><span class="params">()</span></span>&#123;   </span><br><span class="line">     <span class="keyword">return</span> <span class="string">"Richard"</span>;   </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span></span>&#123;   <span class="comment">//子方法,继承Super</span></span><br><span class="line">   <span class="comment">//重写(覆盖)父类当中的静态方法</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> String <span class="title">greeting</span><span class="params">()</span></span>&#123;   </span><br><span class="line">     <span class="keyword">return</span> <span class="string">"Hello"</span>;   </span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="function">String <span class="title">name</span><span class="params">()</span></span>&#123;   </span><br><span class="line">     <span class="keyword">return</span> <span class="string">"Dick"</span>;   </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;   </span><br><span class="line">    Super s = <span class="keyword">new</span> Sub();   </span><br><span class="line">    System.out.println(s.greeting()+<span class="string">","</span>+s.name());   </span><br><span class="line"></span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：Good night,Dick (静态方法打印的是父类中的)</span></span><br><span class="line"><span class="comment">//这个例子说明“实例方法被覆盖，静态方法被隐藏”</span></span><br></pre></td></tr></table></figure><h1 id="4-是否可以在static环境中访问非static变量？"><a href="#4-是否可以在static环境中访问非static变量？" class="headerlink" title="4. 是否可以在static环境中访问非static变量？"></a>4. 是否可以在static环境中访问非static变量？</h1><p>答案:</p><p>不可以</p><blockquote><p><strong>因为静态的成员属于类，随着类的加载而加载到静态方法区内存，当类加载时，此时不一定有实例创建，没有实例，就不可以访问非静态的成员。</strong></p><p>静态变量属于类变量，随着类的加载而加载，当调用类变量时java虚拟机会对类的静态变量，静态方法进行初始化，此时如果静态方法中有非静态变量，由于非静态变量是随着实例的创建而创建，此时还没有实例创建，所以非静态变量还没有创建，所以会出现编译错误。  </p></blockquote><h5 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文:"></a>参考博文:</h5><p>​    <a href="https://www.nowcoder.com/questionTerminal/129a7ff6cfeb45ae9d456d9efed69acd" target="_blank" rel="noopener">牛客网优质答案</a></p><p>时间: 2019.3.11</p><h1 id="5-Java支持的数据类型有哪些？什么是自动拆装箱？"><a href="#5-Java支持的数据类型有哪些？什么是自动拆装箱？" class="headerlink" title="5. Java支持的数据类型有哪些？什么是自动拆装箱？"></a>5. Java支持的数据类型有哪些？什么是自动拆装箱？</h1><p>答案:</p><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul><li><strong>整数型:</strong> byte, short, int, long,</li><li><strong>浮动型:</strong> float, double</li><li><strong>布尔型:</strong> bool</li><li><strong>字符型:</strong> char</li></ul><blockquote><p>整数默认int型，小数默认是double型。Float和long类型的必须加后缀。</p></blockquote><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul><li>引用类型也就是我们常说的对象，在java中每个基础类型的数据都有其包装类，对应上面分别是：<br><strong>Byte, Short, Int, Long, Float, Double, Char, Boolean</strong></li><li>引用类型包括类、数组、接口, String等</li></ul><h4 id="自动装箱和拆箱就是基本类型和引用类型之间的转换"><a href="#自动装箱和拆箱就是基本类型和引用类型之间的转换" class="headerlink" title="自动装箱和拆箱就是基本类型和引用类型之间的转换"></a>自动装箱和拆箱就是基本类型和引用类型之间的转换</h4><ul><li><p>装箱：将基本类型转换成引用类型，如 <code>Integer i = 10;</code></p></li><li><p>拆箱：将引用类型转换成基础类型，如 <code>Integer i = 10;  int j = i;</code></p></li></ul><blockquote><p>转化为引用类型之后，就可以new一个对象，从而就可以调用包装类型中的封装好的方法，方便使用</p></blockquote><h5 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h5><p>​    <a href="https://www.nowcoder.com/questionTerminal/a5eb239111024d1b90cf00f24cfee36f" target="_blank" rel="noopener">牛客网优质答案</a></p><p>时间: 2019.3.12</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？&quot;&gt;&lt;a href=&quot;#1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？&quot;&gt;&lt;/a&gt;1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？&lt;/h1&gt;&lt;p&gt;答案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;运行原理：java源程序经过&lt;code&gt;javac&lt;/code&gt; 编译器编译成二进制的&lt;code&gt;xx.class&lt;/code&gt; 字节码文件, &lt;code&gt;xx.class&lt;/code&gt; 在&lt;strong&gt;jvm&lt;/strong&gt;（各平台装有不同的jvm）上运行，java解释器（jvm的一部分）会将&lt;strong&gt;相同的字节码&lt;/strong&gt;解释成对应平台的机器码，进而执行。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
      <category term="java面试经典题目" scheme="http://yoursite.com/categories/java/java%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java面试经典题目" scheme="http://yoursite.com/tags/java%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>人间词话---文章</title>
    <link href="http://yoursite.com/2019/03/06/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E6%96%87%E7%AB%A0/"/>
    <id>http://yoursite.com/2019/03/06/人间词话---文章/</id>
    <published>2019-03-06T13:57:13.000Z</published>
    <updated>2019-03-09T15:03:44.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="感谢困难"><a href="#感谢困难" class="headerlink" title="感谢困难"></a>感谢困难</h1><p>​                                                                                林清玄<br>​    我做了一个梦。</p><p>　　梦见我在街上问人：“请问您可不可以给我一些困难、一些挫折，一些痛苦?”</p><p>　　所有的人都拒绝我，我着急地恳求别人：“那么，我雇用您，每小时五百元，请您给我一些折磨!”</p><p>　　那些陌生人摇摇头，沉默地离开，我因找不到愿意折磨我的人而惊醒。</p><p>　　我坐在床上发呆，是呀!困难，折磨，痛苦是多么珍贵!如果一切平顺，谁会静下来沉思，谁会生起智慧，谁又能在平凡安逸的日子中超越自我、登上高峰呢?</p><p>　　如果没有困难，谁又会谦卑地跪下来祈祷?谁又能相信有无边的宇宙?谁又能寄情于来生呢?</p><p>　　我深深地感谢着困难、挫折与痛苦。</p><p>　　也深深地感恩那些曾经折磨过我的人，他们是多么慈悲呀!我并未花钱聘雇他们，他们却以宝贵的时间来考验我、提升我，为了增长我的智慧。</p><a id="more"></a><h1 id="真正的高贵"><a href="#真正的高贵" class="headerlink" title="真正的高贵"></a>真正的高贵</h1><p>​                                                                                海明威</p><p>​    在风平浪静的大海，每个人都是领航员。</p><p>​    但是，只有阳光而无阴影，只有欢乐而无痛苦，那就不是人生。以最幸福的人的生活为例.他的生活也是一团缠结在一起的乱麻。痛苦与幸福交替出现,使得我们一会悲伤，一会高兴，甚至死亡本身也会使生命更加可爱。在人生的清醒的时刻，在悲伤与失落的阴影之下，人们与真实的自我最接近。</p><p>​    在生活和事业的种种事物中，性格比才智更能指导我们, 心灵比头脑更能引导我们,而由判断获得的克制, 耐心和教养比天分更能让我们受益。</p><p>​    我始终相信，内心生活开始更为严谨的人，他的外在生活也会变得更为简朴。在一个物欲横流的年代，但愿我能向世人表明，人类真正需求少得多么可怜。</p><p>​    反思自己的过错不至于重蹈覆辙才是真正的悔悟, 高人一等并没有什么值得夸耀的。真正的高贵是优于过去的自己。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;感谢困难&quot;&gt;&lt;a href=&quot;#感谢困难&quot; class=&quot;headerlink&quot; title=&quot;感谢困难&quot;&gt;&lt;/a&gt;感谢困难&lt;/h1&gt;&lt;p&gt;​                                                                                林清玄&lt;br&gt;​    我做了一个梦。&lt;/p&gt;
&lt;p&gt;　　梦见我在街上问人：“请问您可不可以给我一些困难、一些挫折，一些痛苦?”&lt;/p&gt;
&lt;p&gt;　　所有的人都拒绝我，我着急地恳求别人：“那么，我雇用您，每小时五百元，请您给我一些折磨!”&lt;/p&gt;
&lt;p&gt;　　那些陌生人摇摇头，沉默地离开，我因找不到愿意折磨我的人而惊醒。&lt;/p&gt;
&lt;p&gt;　　我坐在床上发呆，是呀!困难，折磨，痛苦是多么珍贵!如果一切平顺，谁会静下来沉思，谁会生起智慧，谁又能在平凡安逸的日子中超越自我、登上高峰呢?&lt;/p&gt;
&lt;p&gt;　　如果没有困难，谁又会谦卑地跪下来祈祷?谁又能相信有无边的宇宙?谁又能寄情于来生呢?&lt;/p&gt;
&lt;p&gt;　　我深深地感谢着困难、挫折与痛苦。&lt;/p&gt;
&lt;p&gt;　　也深深地感恩那些曾经折磨过我的人，他们是多么慈悲呀!我并未花钱聘雇他们，他们却以宝贵的时间来考验我、提升我，为了增长我的智慧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="人间词话" scheme="http://yoursite.com/tags/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>人间词话---惊艳的文字</title>
    <link href="http://yoursite.com/2019/03/06/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E6%83%8A%E8%89%B3%E7%9A%84%E6%96%87%E5%AD%97/"/>
    <id>http://yoursite.com/2019/03/06/人间词话---惊艳的文字/</id>
    <published>2019-03-06T13:57:13.000Z</published>
    <updated>2019-03-09T15:05:04.393Z</updated>
    
    <content type="html"><![CDATA[<h3 id="现代诗"><a href="#现代诗" class="headerlink" title="现代诗"></a>现代诗</h3><ul><li>酒入豪肠，七分酿成了月光，余下的三分啸成剑气，绣口一吐，就半个盛唐。   —余光中《寻李白》</li></ul><a id="more"></a><h3 id="古诗"><a href="#古诗" class="headerlink" title="古诗"></a>古诗</h3><ul><li>少年不知愁滋味,爱上层楼,爱上层楼.为赋新词强说愁.而今识尽愁滋味,欲说还休,欲说还休,却道天凉好个秋.  —辛弃疾《丑奴儿》</li><li>十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。料得年年肠断处，明月夜，短松冈。    —苏轼</li></ul><h3 id="古文"><a href="#古文" class="headerlink" title="古文"></a>古文</h3><ul><li>斯是陋室,惟吾德馨.   —刘禹锡《陋室铭》</li><li>夏虫不可语冰   —孔子</li></ul><h3 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h3><ul><li>我知道我很大胆冒昧, 听说你朋友很多, 我不配高攀, 可是很想在你的朋友里凑个数目.   —钱钟书《围城》</li><li>别客气,我求你明天来.我想去吃,对自己没有好借口,借你的名义,自己享受一下,你就体贴下情,答应了吧.   —钱钟书《围城》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;现代诗&quot;&gt;&lt;a href=&quot;#现代诗&quot; class=&quot;headerlink&quot; title=&quot;现代诗&quot;&gt;&lt;/a&gt;现代诗&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;酒入豪肠，七分酿成了月光，余下的三分啸成剑气，绣口一吐，就半个盛唐。   —余光中《寻李白》&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="人间词话" scheme="http://yoursite.com/tags/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D/"/>
    
      <category term="现代诗" scheme="http://yoursite.com/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"/>
    
      <category term="古诗" scheme="http://yoursite.com/tags/%E5%8F%A4%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>Java常见简写</title>
    <link href="http://yoursite.com/2019/02/28/Java%E5%B8%B8%E8%A7%81%E7%AE%80%E5%86%99/"/>
    <id>http://yoursite.com/2019/02/28/Java常见简写/</id>
    <published>2019-02-28T07:29:27.000Z</published>
    <updated>2019-03-12T13:16:43.930Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h4><p> <strong>Object Relational Mapping</strong>  对象关系映射</p><blockquote><p>对象和关系数据库的映射<br>简单说，一个对象，对应数据库里的一条记录</p></blockquote><a id="more"></a><h4 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h4><p>Data Access Object的缩写，这些类专门用于进行数据库访问的操作</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;ORM&quot;&gt;&lt;a href=&quot;#ORM&quot; class=&quot;headerlink&quot; title=&quot;ORM&quot;&gt;&lt;/a&gt;ORM&lt;/h4&gt;&lt;p&gt; &lt;strong&gt;Object Relational Mapping&lt;/strong&gt;  对象关系映射&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对象和关系数据库的映射&lt;br&gt;简单说，一个对象，对应数据库里的一条记录&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java基础知识" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>曾仕强教授语录</title>
    <link href="http://yoursite.com/2019/01/10/%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E6%88%91%E6%88%90%E9%95%BF---%E6%9B%BE%E4%BB%95%E5%BC%BA/"/>
    <id>http://yoursite.com/2019/01/10/人间词话---自我成长---曾仕强/</id>
    <published>2019-01-10T14:19:18.000Z</published>
    <updated>2019-03-07T15:05:27.788Z</updated>
    
    <content type="html"><![CDATA[<ul><li>很多事情，从不同的角度看，才能体会到其中的奥妙</li><li>做一个领导者，一定要充分了解下属的特性是什么，及时的下达合理的命令，而且效果要非常的良好，此为将才</li><li>事事都透露着一个人的能力</li><li>顾全大局，大局的前提底下，很多细小的事情，不用太过于考虑</li></ul><a id="more"></a><ul><li>一件事，从不同的角度看，都有道理，怎么讲都对，不是对不对的事，是价值观的体现</li><li>得意勿忘形，人在得意时，千万不能忘形，做事情随他爱怎样怎样，变为得意忘形，当一个人处于逆境的时候，他还会谨慎一点，当一个人处顺境的时候，他就开始沉不住气</li><li>形势比人强</li><li>人生的理想在于不断提升自己的层次</li><li>有智慧没知识容易陷入空想，一事无成。有知识没智慧，就不要埋怨被人当做工具使用，用毕即弃。要善用智慧来运用知识，以求合理的表现</li><li>处逆境容易，正因留意，处顺境很难，正因大意</li><li>你要很谨慎地去保留你独特的地方，这个独特之处就是你之所以为人的地方。能够自我成全，才是人最伟大的地方</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;很多事情，从不同的角度看，才能体会到其中的奥妙&lt;/li&gt;
&lt;li&gt;做一个领导者，一定要充分了解下属的特性是什么，及时的下达合理的命令，而且效果要非常的良好，此为将才&lt;/li&gt;
&lt;li&gt;事事都透露着一个人的能力&lt;/li&gt;
&lt;li&gt;顾全大局，大局的前提底下，很多细小的事情，不用太过于考虑&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="感悟" scheme="http://yoursite.com/categories/%E6%84%9F%E6%82%9F/"/>
    
      <category term="曾仕强教授" scheme="http://yoursite.com/categories/%E6%84%9F%E6%82%9F/%E6%9B%BE%E4%BB%95%E5%BC%BA%E6%95%99%E6%8E%88/"/>
    
    
      <category term="感悟" scheme="http://yoursite.com/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="人生方向" scheme="http://yoursite.com/tags/%E4%BA%BA%E7%94%9F%E6%96%B9%E5%90%91/"/>
    
      <category term="智慧" scheme="http://yoursite.com/tags/%E6%99%BA%E6%85%A7/"/>
    
      <category term="成长" scheme="http://yoursite.com/tags/%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
</feed>
