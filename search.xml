<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java基础知识---线程(1)]]></title>
    <url>%2F2019%2F03%2F18%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E7%BA%BF%E7%A8%8B(1)%2F</url>
    <content type="text"><![CDATA[一. 线程的基本概念线程是一个程序里面不同的执行路径 每一个分支都叫做一个线程，main()叫做主分支，也叫主线程 程序的执行过程都是这样的​ 首先把程序的代码放到内存的代码区里面，代码放到代码区后并没有马上开始执行，但这时候说明了一个进程准备开始，进程已经产生了，但还没有开始执行，这就是进程，所以进程其实是一个静态的概念，它本身就不能动。 进程: 机器上的一个.class文件，机器上的一个.exe文件，这个叫做一个进程 平常所说的进程的执行指的是进程里面主线程开始执行了，也就是main()方法开始执行了。 ==进程是一个静态的概念，在我们机器里面实际上运行的都是线程。== 知识补充: CPU难道真的很神通广大，能够同时执行那么多程序吗？ 不是的，CPU的执行是这样的：CPU的速度很快，一秒钟可以算好几亿次，因此CPU把自己的时间分成一个个小时间片，我这个时间片执行你一会，下一个时间片执行他一会，再下一个时间片又执行其他人一会，虽然有几十个线程，但一样可以在很短的时间内把他们通通都执行一遍，但对我们人来说，CPU的执行速度太快了，因此看起来就像是在同时执行一样，但实际上在一个时间点上，CPU只有一个线程在运行。 小总结(学习线程首先要理清楚三个概念): 进程：进程是一个静态的概念 线程：一个进程里面有一个主线程叫main()方法，是一个程序里面的，一个进程里面不同的执行路径。 在同一个时间点上，一个CPU只能支持一个线程在执行。因为CPU运行的速度很快，因此我们看起来的感觉就像是多线程一样。 什么才是真正的多线程？如果你的机器是双CPU，或者是双核，这确确实实是多线程。 二. 线程的创建和启动在 JAVA 里面，JAVA的线程是通过java.lang.Thread类来实现的，每一个Thread对象代表一个新的线程。 创建一个新线程出来有两种方法： 从Thread类继承 实现接口 2.1 使用实现Runnable接口创建和启动新线程123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @Description: 开辟一个新的线程来调用run方法 * 程序执行到 t.start() 后开辟了一条新的线程,主线程继续向下执行 * t.start() 这条线程是 run() 方法执行的线程, * run() 方法和 main() 方法再在交替进行,或者说叫并行执行 * @author zn * */public class TestThread1 &#123; public static void main(String args[]) &#123; // 这里new了一个线程类的对象出来 Runner1 r1 = new Runner1(); // r1.run(); // 这里使用的是Thread(Runnable target) 这构造方法 Thread t = new Thread(r1); // 要启动一个新的线程就必须new一个Thread对象出来 // 启动新开辟的线程，新线程执行的是run()方法，新线程与主线程会一起并行执行 t.start(); for (int i = 0; i &lt; 4; i++) &#123; System.out.println("maintheod：" + i); &#125; &#125;&#125;// 定义一个类用来实现 Runnable 接口，实现Runnable接口就表示这个类是一个线程类 class Runner1 implements Runnable &#123; // 每个线程都是方法run()来完成其操作的，方法run()称为线程体 public void run() &#123; for (int i = 0; i &lt; 4; i++) &#123; System.out.println("Runner1：" + i); &#125; &#125;&#125;/*打印结果: maintheod：0 maintheod：1 Runner1：0 maintheod：2 Runner1：1 maintheod：3 Runner1：2 Runner1：3*/ 不开辟新线程直接调用run方法123456789101112131415161718192021222324252627282930313233343536373839404142/** * @Description: 不开辟新线程直接调用run方法 * 首先进入主程序, 子程序 r2 执行完之后主程序 main() 在继续执行 * @author zn * */public class TestThread2 &#123; public static void main(String args[]) &#123; // 这里new了一个线程类的对象出来 Runner2 r2 = new Runner2(); // 这个称为方法调用，方法调用的执行是等run()方法执行完之后才会继续执行main()方法 r2.run(); // Thread t = new Thread(r2); // t.start(); for (int i = 0; i &lt; 4; i++) &#123; System.out.println("maintheod：" + i); &#125; &#125;&#125;// 定义一个类用来实现 Runnable 接口，实现Runnable接口就表示这个类是一个线程类class Runner2 implements Runnable &#123; // 每个线程都是方法run()来完成其操作的，方法run()称为线程体 public void run() &#123; for (int i = 0; i &lt; 4; i++) &#123; System.out.println("Runner2：" + i); &#125; &#125;&#125;/*打印结果: Runner2：0 Runner2：1 Runner2：2 Runner2：3 maintheod：0 maintheod：1 maintheod：2 maintheod：3*/ 2.2 继承Thread类，并重写其run()方法创建和启动新的线程123456789101112131415161718192021222324252627282930313233343536373839404142/** * @Description: 线程创建与启动的第二种方法：定义Thread的子类并实现run()方法 * 这里也是并发进行 * @author zn * */public class TestThread3 &#123; public static void main(String args[]) &#123; Runner3 r3 = new Runner3(); // 调用start()方法启动新开辟的线程 r3.start(); for (int i = 0; i &lt;= 4; i++) &#123; System.out.println("mainMethod：" + i); &#125; &#125;&#125;/* * Runner2类从Thread类继承 通过实例化Runner2类的一个对象就可以开辟一个新的线程 * 调用从Thread类继承来的start()方法就可以启动新开辟的线程 */class Runner3 extends Thread &#123; // 重写run()方法的实现 public void run() &#123; for (int i = 0; i &lt;= 4; i++) &#123; System.out.println("Runner3：" + i); &#125; &#125;&#125;/*打印结果: mainMethod：0 Runner3：0 mainMethod：1 Runner3：1 Runner3：2 Runner3：3 Runner3：4 mainMethod：2 mainMethod：3 mainMethod：4*/ 2.3 两种方法的选择优先选择实现Runnable接口 的这种方式去开辟一个新的线程。 因为接口的实现可以实现多个，而类的继承只能是单继承。因此在开辟新线程时能够使用Runnable接口就尽量不要使用从Thread类继承的方式来开辟新的线程。 三. 线程状态转换参考博文​ java基础学习总结——线程(一)]]></content>
      <categories>
        <category>java基础知识</category>
        <category>基础语法</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---框架图解]]></title>
    <url>%2F2019%2F03%2F14%2FJavaWeb-%E6%A1%86%E6%9E%B6%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. MVC 模式 2. sevlet]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Java</tag>
        <tag>图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JSP指令]]></title>
    <url>%2F2019%2F03%2F14%2FJavaWeb---JSP%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一、JSP指令简介 JSP指令（directive）是为JSP引擎而设计的，它们并不直接产生任何可见输出，而只是告诉引擎如何处理JSP页面中的其余部分。 在JSP 2.0规范中共定义了三个指令： page指令 Include指令 taglib指令 JSP指令的基本语法格式：&lt;%@ 指令 属性名=”值” %&gt; 例如12345678&lt;%@ page contentType="text/html;charset=gb2312"%&gt;&lt;!--如果一个指令有多个属性，这多个属性可以写在一个指令中，也可以分开写--&gt;&lt;%@ page contentType="text/html;charset=gb2312"%&gt;&lt;%@ page import="java.util.Date"%&gt;&lt;!--也可以写作--&gt;&lt;%@ page contentType="text/html;charset=gb2312" import="java.util.Date"%&gt; 二、Page指令​ page指令 用于定义 JSP 页面的==各种属性== ，无论page指令出现在JSP页面中的什么地方，它作用的都是整个JSP页面，为了保持程序的可读性和遵循良好的编程习惯，page指令最好是放在整个JSP页面的起始位置。 范例123456789101112131415161718&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!--指令完整语法--&gt;&lt;%@ page [ language="java" ] [ extends="package.class" ] [ import="&#123;package.class | package.*&#125;, ..." ] [ session="true | false" ] [ buffer="none | 8kb | sizekb" ] [ autoFlush="true | false" ] [ isThreadSafe="true | false" ] [ info="text" ] [ errorPage="relative_url" ] [ isErrorPage="true | false" ] [ contentType="mimeType [ ;charset=characterSet ]" | "text/html ; charset=ISO-8859-1" ] [ pageEncoding="characterSet | ISO-8859-1" ] [ isELIgnored="true | false" ] %&gt; 三. include指令在JSP中对于包含有两种语句形式： @include 指令 &lt;jsp:include&gt; 指令 3.1 @include指令 @include可以包含任意的文件，当然，只是把文件的内容包含进来。 include指令用于引入其它JSP页面，如果使用include指令引入了其它JSP页面，那么JSP引擎将把这两个JSP翻译成一个servlet。所以include指令引入通常也称之为静态引入。 语法： 12&lt;!--其中的file属性用于指定被引入文件的路径。路径以“/”开头，表示代表当前web应用。--&gt;&lt;%@ include file="relativeURL"%&gt; include指令细节注意问题： 被引入的文件必须遵循 JSP 语法。 被引入的文件可以使用任意的扩展名，即使其扩展名是html，JSP引擎也会按照处理jsp页面的方式处理它里面的内容，为了见明知意，JSP规范建议使用 .jspf（JSP fragments(片段)）作为静态引入文件的扩展名。 由于使用include指令将会涉及到2个JSP页面，并会把2个JSP翻译成一个servlet，所以这2个JSP页面的指令不能冲突(除了pageEncoding和导包除外)。 范例 新建head.jspf页面和foot.jspf页面，分别作为jsp页面的头部和尾部，存放于WebRoot下的jspfragments文件夹中，代码如下： head.jspf代码： 12&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;h1 style="color:red;"&gt;网页头部&lt;/h1&gt; foot.jspf代码： 12&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;h1 style="color:blue;"&gt;网页尾部&lt;/h1&gt; 在WebRoot文件夹下创建一个IncludeTagTest.jsp页面，在IncludeTagTest.jsp页面中使用@include指令引入head.jspf页面和foot.jspf页面，代码如下： 1234567891011121314&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;jsp的Include指令测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%--使用include标签引入引入其它JSP页面--%&gt; &lt;%@include file="/jspfragments/head.jspf" %&gt; &lt;h1&gt;网页主体内容&lt;/h1&gt; &lt;%@include file="/jspfragments/foot.jspf" %&gt; &lt;/body&gt;&lt;/html&gt; 3.2 总结@include指令 使用@include可以包含任意的内容，文件的后缀是什么都无所谓。这种把别的文件内容包含到自身页面的@include语句就叫作静态包含，作用只是把别的页面内容包含进来，属于静态包含 3.3 jsp:include指令 jsp:include指令为动态包含，如果被包含的页面是JSP，则先处理之后再将结果包含，而如果包含的是非*.jsp文件，则只是把文件内容静态包含进来，功能与@include类似。后面再具体介绍 参考博文​ javaweb学习总结(十六)——JSP指令]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JSP基础语法]]></title>
    <url>%2F2019%2F03%2F14%2FJavaWeb---JSP%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[​ 任何语言都有自己的语法，JAVA 中有，JS P虽然是在JAVA上的一种应用，但是依然有其自己扩充的语法，而且在 JSP 中，所有的 JAVA 语句都可以使用。 一. JSP 模版元素 JSP 页面中的 HTML 内容 称之为 JSP 模版元素 。 JSP 模版元素定义了网页的 基本骨架 ，即定义了页面的结构和外观。 二、JSP表达式 JSP 脚本表达式（expression）用于将程序数据输出到客户端 ​ 语法：&lt;%= 变量或表达式 %&gt; 举例：输出当前系统时间: 1&lt;%= new java.util.Date() %&gt; JSP引擎在翻译脚本表达式时，会将程序数据转成字符串，然后在相应位置用out.print(…) 将数据输给客户端。 JSP脚本表达式中的变量或表达式后面不能有分号（;）。 三、JSP脚本片断 JSP脚本片断(scriptlet)用于在JSP页面中编写多行Java代码。 语法1234&lt;!-- 在&lt;% %&gt;中可以定义变量、编写语句，不能定义方法--&gt;&lt;% 多行java代码 %&gt; 范例: 在Scriptlet中定义变量、编写语句 123456789&lt;% int sum=0;//声明变量 /*编写语句*/ for (int i=1;i&lt;=100;i++)&#123; sum+=i; &#125; out.println("&lt;h1&gt;Sum="+sum+"&lt;/h1&gt;");%&gt; 注意事项 JSP脚本片断中只能出现java代码，不能出现其它模板元素， JSP引擎在翻译JSP页面中，会将JSP脚本片断中的Java代码将被原封不动地放到Servlet的_jspService方法中。 JSP脚本片断中的Java代码必须严格遵循Java语法，例如，每执行语句后面必须用分号（;）结束。 在一个 JSP 页面中可以有多个脚本片断，在两个或多个脚本片断之间可以嵌入文本、HTML标记和其他JSP元素。 四、JSP声明JSP页面中编写的所有代码，默认会翻译到 servlet 的 service 方法中， 而 JSP 声明中的 java代码 被翻译到 _jspService方法的外面。 语法123&lt;%！ java代码%&gt; ​ 所以，JSP声明可用于定义JSP页面转换成的Servlet程序的静态代码块、成员变量和方法 。 多个静态代码块、变量和函数可以定义在一个JSP声明中，也可以分别单独定义在多个JSP声明中。JSP隐式对象的作用范围仅限于Servlet的 _jspService 方法，所以在 JSP 声明中不能使用这些隐式对象。 范例1234567891011121314151617&lt;%! static &#123; System.out.println("loading Servlet!"); &#125; private int globalVar = 0; public void jspInit()&#123; System.out.println("initializing jsp!"); &#125;%&gt;&lt;%! public void jspDestroy()&#123; System.out.println("destroying jsp!"); &#125;%&gt; 五. JSP注释在 JSP 中，注释有两大类： 显式注释：直接使用HTML风格的注释：&lt;!- - 注释内容**- -&gt; 隐式注释：直接使用JAVA的注释：//、/*……***/** JSP自己的注释：&lt;%- -注释内容- -%&gt; 范例1234567891011&lt;!--这个注释可以看见--&gt;&lt;% //JAVA中的单行注释 /* JAVA中的多行注释 */%&gt;&lt;%--JSP自己的注释--%&gt; 区别 ​ HTML的注释在浏览器中查看源文件的时候是可以看得到的，而JAVA注释和JSP注释在浏览器中查看源文件时是看不到注释的内容 参考博文​ javaweb学习总结(十五)——JSP基础语法]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JavaWeb开发入门]]></title>
    <url>%2F2019%2F03%2F14%2FJavaWeb---JavaWeb%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[一. 基本概念1.1 WEB 开发的相关知识 WEB，在英语中web即表示网页的意思，它用于表示Internet主机上供外界访问的资源。 Internet上供外界访问的Web资源分为： 静态web资源（如html 页面）：指web页面中供人们浏览的数据始终是不变的。 动态web资源：指web页面中供人们浏览的数据是由程序产生的，不同时间点访问web页面看到的内容各不相同。 静态web资源开发技术：Html 常用动态web资源开发技术：JSP/Servlet、ASP、PHP等 在 Java 中，动态web资源开发技术统称为 ==Javaweb==。 1.2 WEB应用程序 WEB应用程序指供浏览器访问的程序，通常也简称为web应用。例如有a.html 、b.html…..多个web资源，这多个web资源用于对外提供服务，此时应把这多个web资源放在一个目录中，以组成一个web应用（或web应用程序） 一个web应用由多个静态web资源和动态web资源组成，如:html、css、js文件，Jsp文件、java程序、支持jar包、配置文件等等。 Web应用开发好后，若想供外界访问，需要把web应用所在目录交给web服务器管理，这个过程称之为虚似目录的映射 二. WEB服务器2.1 WEB服务器简介 1. Web服务器是指驻留于因特网上某种类型计算机的程序，是可以向发出请求的浏览器提供文档的程序。当Web浏览器（客户端）连到服务器上并请求文件时，服务器将处理该请求并将文件反馈到该浏览器上，附带的信息会告诉浏览器如何查看该文件（即文件类型）。 2、服务器是一种被动程序：只有当Internet上运行在其他计算机中的浏览器发出请求时，服务器才会响应。 2.2、常见的Web服务器介绍1. WebLogic2. WebSphere3. Tomcat TomcatTomcat是一个实现了JAVA EE标准的最小的WEB服务器，是Apache 软件基金会的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。因为Tomcat 技术先进、性能稳定，而且开源免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。学习JavaWeb开发一般都使用Tomcat服务器，该服务器支持全部JSP以及Servlet规范，启动界面如图： 4. IIS 学习web开发，需要先安装一台web服务器，然后再在web服务器中开发相应的web资源，供用户使用浏览器访问。 三. 搭建JavaWeb应用开发环境——Tomcat服务器3.1 疑问：学习web开发，为什么必须要先装一个WEB服务器？ 在本地计算机上随便创建一个 web 页面，用户是无法访问到的，但是如果启动 tomcat 服务器，把 web 页面放在 tomcat 服务器中，用户就可以访问了。这说明什么问题？ 1. 不管什么 web 资源，想被远程计算机访问，都必须有一个与之对应的网络通信程序，当用户来访问时，这个网络通信程序读取 web 资源数据，并把数据发送给来访者。 2. WEB 服务器就是这样一个程序，它用于完成底层网络通迅。使用这些服务器，We应用的开发者只需要关注web资源怎么编写，而不需要关心资源如何发送到客户端手中，从而极大的减轻了开发者的开发工作量。 3.2、下载和安装Tomcat服务器见参考博客参考博文​ JavaWeb学习总结(一)——JavaWeb开发入门]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JSP原理]]></title>
    <url>%2F2019%2F03%2F14%2FJavaWeb---JSP%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[一. 什么是 JSP？ JSP全称是 Java Server Pages ，它和 servle 技术一样，都是SUN公司定义的一种用于开发动态web资源的技术。 JSP 这门技术的最大的特点在于，写 jsp 就像在写 html ，但它相比 html 而言，html 只能为用户提供静态数据，而 Jsp 技术允许在页面中嵌套java代码，为用户提供动态数据。 二. JSP原理2.1 Web服务器是如何调用并执行一个jsp页面的？ 浏览器向服务器发请求，不管访问的是什么资源，其实都是在访问Servlet，所以当访问一个jsp页面时，其实也是在访问一个Servlet ​ 服务器在执行jsp的时候，首先==把jsp翻译成一个Servlet==，所以我们访问 jsp 时，其实不是在访问 jsp，而是在访问 jsp 翻译过后的那个Servlet 当我们通过浏览器访问index.jsp时，服务器首先将 index.jsp 翻译成一个index_jsp.class index_jsp 这个类是继承 org.apache.jasper.runtime.HttpJspBase 这个类的 HttpJspBase 类是继承 HttpServlet 的，所以index_jsp类也是一个Servlet，所以当浏览器访问服务器上的 index.jsp 页面时，其实就是在访问index_jsp 这个Servlet，index_jsp 这个 Servlet 使用_jspService 这个方法处理请求。 2.2 Jsp页面中的java代码服务器是如何执行的？ 在 jsp 中编写的 java 代码会被翻译到 _jspService 方法中去，当执行 _jspService方法处理请求时，就会执行在jsp编写的java代码了，所以Jsp页面中的java代码服务器是通过调用_jspService方法处理请求时执行的。 参考博文​ javaweb学习总结(十四)——JSP原理]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试经典题目(11-15题)]]></title>
    <url>%2F2019%2F03%2F14%2Fjava%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE(11-15%E9%A2%98)%2F</url>
    <content type="text"><![CDATA[11. 进程和线程的区别是什么？答案: 通俗解释什么是进程和线程: 开个QQ，开了一个进程；开了迅雷，开了一个进程。 在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。 所以运行某个软件，相当于开了一个进程。在这个软件运行的过程里（在这个进程里），多个工作支撑的完成QQ的运行，那么这“多个工作”就是多个线程。 所以一个进程管着多个线程。 专业解释1. 进程是执行着的应用程序 2. 线程是进程内部的一个执行序列。 3. 一个进程可以有多个线程。线程又叫做轻量级进程。 线程与进程的区别归纳优质答案一 进程是运行中的程序，线程是进程的内部的一个执行序列 进程是资源分配的单元，线程是执行行单元(进程是资源分配的基本单位, 线程是调度的基本单位) 进程间切换代价大，线程间切换代价小 进程拥有资源多，线程拥有资源少 多个线程共享进程的资源 优质答案二 a.地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。 b.通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。 c.调度和切换：线程上下文切换比进程上下文切换要快得多。 d.在多线程OS中，进程不是一个可执行的实体。 知识补充 进程是什么？程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。 进程和线程的并发层次不同：进程属于在处理器这一层上提供的抽象；线程则属于在进程这个层次上再提供了一层并发的抽象。 参考博文​ 进程与线程的一个简单解释 ​ 进程篇：进程和线程的本质和区别 ​ 深入理解进程和线程 ​ 线程与进程的区别 12. 创建线程有几种不同的方式？你喜欢哪一种？为什么？1. 方式 继承Thread类，重写run方法； 实现Runnable接口，重写run方法，但是比继承Thread类好用，实现接口还可以继承类，避免了单继承带来的局限性； 实现callable接口，重写call方法，有返回值。 使用实现了Executor接口的ThreadPoolExecutor来创建线程池。 2. 选择 一般情况下，常见的是第二种。 Runnable接口有如下好处： 避免点继承的局限，一个类可以继承多个接口。 适合于资源的共享 线程详细见: xxxxxx 参考博文​ 牛客网优质答案 时间: 2019.3.14]]></content>
      <categories>
        <category>java面试经典题目</category>
      </categories>
      <tags>
        <tag>java面试经典题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---Servlet开发(二)]]></title>
    <url>%2F2019%2F03%2F13%2FJavaWeb---Servlet%E5%BC%80%E5%8F%91(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[一. ServletConfig讲解1.1. 配置Servlet初始化参数 在Servlet的配置文件web.xml中，可以使用一个或多个标签为servlet配置一些初始化参数。 参考博文: ​ javaweb学习总结(六)——Servlet开发(二)]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---Servlet开发(一)]]></title>
    <url>%2F2019%2F03%2F13%2FJavaWeb---Servlet%E5%BC%80%E5%8F%91(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[一. Servlet简介Servlet是sun公司提供的一门用于 开发动态web资源的技术 若想开发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤： 编写一个 Java 类，实现 servlet 接口。 把开发好的 Java类部署到 web 服务器中。 按照一种约定俗成的称呼习惯，通常我们也把实现了servlet接口的java程序，称之为Servlet 二. Servlet的运行过程Servlet程序是由 WEB服务器 调用，web服务器 收到客户端的 Servlet 访问请求后: ​ ① Web服务器首先 检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第②步。 ​ ② 装载并创建该Servlet的一个实例对象。 ​ ③ 调用Servlet实例对象的 init()方法。 ​ ④ 创建一个用于封装 HTTP请求消息的 HttpServletRequest 对象 和一个 代表HTTP响应消息的 HttpServletResponse 对象 ，然后调用Servlet的service()方法并将 请求和响应对象 作为参数传递进去 ​ ⑤ WEB应用程序被 停止或重新启动之前，Servlet引擎将 卸载Servlet ，并在卸载之前调用Servlet的destroy()方法。 三. Servlet调用图 四. Servlet接口实现类 Servlet接口SUN公司定义了两个默认实现类，分别为：GenericServlet、HttpServlet。 ==HttpServlet== 指能够处理HTTP请求的servlet，它在原有Servlet接口上添加了一些与HTTP协议处理方法，它比Servlet接口的功能更为强大。因此开发人员在编写Servlet时，通常应继承这个类，而避免直接去实现Servlet接口。 HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。因此，开发人员在编写Servlet时，通常只需要覆写doGet或doPost方法，而不要去覆写service方法 五. Servlet开发注意细节4.1 Servlet访问URL映射配置 由于客户端是通过URL地址访问web服务器中的资源，所以Servlet程序若想被外界访问，必须把servlet程序映射到一个URL地址上，这个工作在==web.xml文件==中使用&lt;servlet&gt;元素和&lt;servlet-mapping&gt;元素完成。 &lt;servlet&gt;元素用于注册Servlet，它包含有两个主要的子元素：&lt;servlet-name&gt;和&lt;servlet-class&gt;，分别用于设置Servlet的注册名称和Servlet的完整类名。 &lt;servlet-mapping&gt;元素用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：&lt;servlet-name&gt;和&lt;url-pattern&gt;，分别用于指定Servlet的注册名称和Servlet的对外访问路径。 都是成对出现的 有注册,有映射 web.xml 是什么 web.xml文件用来初始化配置信息：比如Welcome页面、servlet、servlet-mapping、filter、listener、启动加载级别等 每个xml文件都有定义它书写规则的Schema文件，也就是说javaEE的定义 web.xml 所对应的 xml Schema 文件中定义了多少种标签元素，web.xml中就可以出现它所定义的标签元素，也就具备哪些特定的功能。 范例123456789&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;gacl.servlet.study.ServletDemo1&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/ServletDemo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 同一个Servlet可以被映射到多个URL上，即多个元素的子元素的设置值可以是同一个Servlet的注册名。 4.2 Servlet与普通Java类的区别 Servlet是一个供其他Java程序（Servlet引擎）调用的Java类，不能独立运行，它的运行完全由Servlet引擎来控制和调度。 针对客户端的多次Servlet请求，通常情况下，服务器只会创建一个Servlet实例对象，也就是说Servlet实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至web容器退出，servlet实例对象才会销毁。 在Servlet的整个生命周期内，Servlet的init()方法只被调用一次。而对一个Servlet的每次访问请求都导致Servlet引擎调用一次servlet的service()方法。对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。 参考博文​ javaweb学习总结(五)——Servlet开发(一) ​ web.xml文件的作用]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---抽象类]]></title>
    <url>%2F2019%2F03%2F13%2Fjava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java 抽象类1. 抽象方法​ 一种特殊的方法：它只有声明，而没有具体的实现 123// 声明格式// 抽象方法必须用abstract关键字进行修饰abstract void fun(); 抽象方法必须定义在抽象类中。 2. 抽象类概念​ 抽象方法的类(一个类含有抽象方法，则称这个类为抽象类), 抽象类必须在类前用 abstract关键字 修饰。 一个类不包含抽象方法，只是用abstract修饰的话也是抽象类。也就是说抽象类不一定必须含有抽象方法。 特点 子类继承父类时，如果这个父类里面有抽象方法，并且子类觉得可以去实现父类的所有抽象方法，那么子类必须去实现父类的所有抽象方法, 父类里面的抽象方法，子类如果觉得实现不了，那么把就子类也声明成一个抽象类 因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。父类里面的方法是抽象的，那么对于整个类来说，它就有一个没有实现的方法，这个方法不知道怎么去实现，那么这个类是就是残缺不全的，因此这个类应该被定义为一个抽象类 含有抽象方法的类必须被声明为抽象类 不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法 抽象类必须被继承 抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情 抽象方法必须被重写 从某种意义上来说，抽象方法就是被用来重写的，所以在父类声明的抽象方法一定要在子类里面重写 范例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package javastudy.summary;/** * 父类Animal * 在class的前面加上abstract，即声明成这样：abstract class Animal * 这样Animal类就成了一个抽象类了 */abstract class Animal &#123; public String name; public Animal(String name) &#123; this.name = name; &#125; /** * 抽象方法 * 这里只有方法的定义，没有方法的实现。 */ public abstract void enjoy(); &#125;/** * 这里的子类Cat从抽象类Animal继承下来，自然也继承了Animal类里面声明的抽象方法enjoy()， * 但子类Cat觉得自己去实现这个enjoy()方法也不合适，因此它把它自己也声明成一个抽象的类， * 那么，谁去实现这个抽象的enjoy方法，谁继承了子类，那谁就去实现这个抽象方法enjoy()。 */abstract class Cat extends Animal &#123; // Cat添加自己独有的属性 public String eyeColor; public Cat(String n, String c) &#123; super(n);//调用父类Animal的构造方法 this.eyeColor = c; &#125;&#125;/** * 子类BlueCat继承抽象类Cat，并且实现了从父类Cat继承下来的抽象方法enjoy */class BlueCat extends Cat &#123; public BlueCat(String n, String c) &#123; super(n, c); &#125; // 实现了抽象方法enjoy @Override public void enjoy() &#123; System.out.println("蓝猫叫..."); &#125; &#125;/** * 子类Dog继承抽象类Animal，并且实现了抽象方法enjoy */class Dog extends Animal &#123; // Dog类添加自己特有的属性 public String furColor; public Dog(String n, String c) &#123; super(n);//调用父类Animal的构造方法 this.furColor = c; &#125; @Override public void enjoy() &#123; System.out.println("狗叫...."); &#125;&#125;public class TestAbstract &#123; public static void main(String[] args) &#123; /** * 把Cat类声明成一个抽象类以后，就不能再对Cat类进行实例化了， * 因为抽象类是残缺不全的，缺胳膊少腿的，因此抽象类不能被实例化。 */ //Cat c = new Cat("Catname","blue"); Dog d = new Dog("dogname","black"); d.enjoy();//调用自己实现了的enjoy方法 BlueCat c = new BlueCat("BlueCatname","blue"); c.enjoy();//调用自己实现了的enjoy方法 &#125;&#125; 杂抽象类和普通类的主要有三点区别： 抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。 抽象类不能用来创建对象。 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。 参考博文​ Java抽象类与接口的区别 ​ java基础学习总结——抽象类 ​ 深入理解Java的接口和抽象类]]></content>
      <categories>
        <category>java基础知识</category>
        <category>抽象类</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---继承]]></title>
    <url>%2F2019%2F03%2F13%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[Java 继承概念 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的 一些属性或方法 类的继承格式123456// Java继承的关键字是：extendsclass 父类 &#123;&#125; class 子类 extends 父类 &#123;&#125; 需要注意的是 Java 不支持多继承，但支持多重继承。 继承的特性 子类拥有父类非 private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。 为什么需要继承 提高代码的 复用性 (复用性主要是可以多次使用，不用再多次写同样的代码）)。 提高程序的扩展性。 参考博文​ JAVA继承总结 ​ 菜鸟教程]]></content>
      <categories>
        <category>java基础知识</category>
        <category>继承</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---接口]]></title>
    <url>%2F2019%2F03%2F13%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[Java基础知识—接口一. 概念 官方解释: Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能） 通俗理解: 接口可以理解为一种特殊的抽象类(100%的抽象类, 所有的方法都是抽象方法)，里面全部是由全局常量和公共的抽象方法(方法的定义)所组成,而没有变量和方法的实现 范例123456789101112131415/** * java中定义接口 * 把一个类定义成一个接口的格式是把声明类的关键字class用声明接口的关键字interface替换掉即可 */public interface JavaInterfaces &#123; // 常量的声明格式, 都是公共的、静态的，不能改变的 // 下面两种都可以,因为在接口里面默认的属性声明都是“public static final”的 public static final int id=10; int id=10; //方法的声明 // 在接口里面的声明的方法都是抽象方法,默认是抽象的，因此在接口里面的抽象方法都会把abstract关键字省略掉 // 在接口里面声明的抽象方法默认是“public(公共的) public void start();&#125; 二. 特点 接口指明了一个类必须要做什么和不能做什么，相当于类的蓝图 接口可以继承其他的接口,并添加新的属性和抽象方法. 抽象方法只能存在于抽象类或者接口中，但抽象类中却能存在非抽象方法，即有方法体的方法。接口是百分之百的抽象类 接口是解决Java无法使用多继承的一种手段,, 实际中更多的作用是制定标准的。 一个类可以实现多个接口, 接口里面的成员变量不专属于某个对象，都是静态的成员变量，是属于整个类的,不会存在对象之间互相冲突的问题。实现多个接口，也就实现了多重继承 见范例 接口和接口之间可以相互继承，类和类之间可以相互继承，类和接口之间，只能是类来实现接口 三. 重点 一个类如果要实现某个接口的话，那么它必须要实现这个接口中的所有方法。 不能直接去实例化一个接口，因为接口中的方法都是抽象的，是没有方法体的. 但是，我们可以使用接口类型的引用指向一个实现了该接口的对象，并且可以调用这个接口中的方法(Java多态的特性). 四. 接口的进一步理解​ 如果某个设备需要向电脑中读取或者写入某些东西，这些设备一般都是采用USB方式与电脑连接的，我们发现，只要带有USB功能的设备就可以插入电脑中使用了，那么我们可以认为USB就是一种功能，这种功能能够做出很多的事情（实现很多的方法），其实USB就可以看做是一种标准，一种接口，只要实现了USB标准的设备我就认为你已经拥有了USB这种功能。（因为你实现了我USB标准中规定的方法） 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344// 先声明USB接口：其中规定了要实现USB接口就必须实现接口规定实现的read( )和write( )这两个方法。interface USB &#123; void read(); void write();&#125;// 一个USB类实现USB接口。（实现其中的方法）class YouPan implements USB &#123; @Override public void read() &#123; System.out.println("U盘正在通过USB功能读取数据"); &#125; @Override public void write() &#123; System.out.println("U盘正在通过USB功能写入数据"); &#125;&#125;// 一个键盘类实现USB接口。（实现其中的方法）class JianPan implements USB &#123; @Override public void read() &#123; System.out.println("键盘正在通过USB功能读取数据"); &#125; @Override public void write() &#123; System.out.println("键盘正在通过USB功能写入数据"); &#125;&#125;// 测试public class Main &#123; public static void main(String[] args) &#123; // 生成一个实现可USB接口（标准）的U盘对象 YouPan youPan = new YouPan(); // 调用U盘的read( )方法读取数据 youPan.read(); // 调用U盘的write( )方法写入数据 youPan.write(); // 生成一个实现可USB接口（标准）的键盘对象 JianPan jianPan = new JianPan(); // 调用键盘的read( )方法读取数据 jianPan.read(); // 调用键盘的write( )方法写入数据 jianPan.write(); &#125;&#125; 参考博文​ java基础学习总结——接口 ​ JAVA基础——接口（全网最详细教程）]]></content>
      <categories>
        <category>java基础知识</category>
        <category>接口</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试经典题目(6-10题)]]></title>
    <url>%2F2019%2F03%2F12%2Fjava%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE(6-10%E9%A2%98)%2F</url>
    <content type="text"><![CDATA[6. Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？ 答案: 方法覆盖(重写)的原则： 重写方法的方法名称、参数列表必须与原方法的相同，返回类型可以相同也可以是原类型的子类型(从Java SE5开始支持)。 重写方法不能比原方法访问性差（即访问权限不允许缩小）。 重写方法不能比原方法抛出更多的异常。 被重写的方法 不能为final类型 ，因为final修饰的方法是无法重写的。 被重写的方法 不能为private ，否则在其子类中只是新定义了一个方法，并没有对其进行重写。 被重写的方法 不能为static 。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足重写条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足重写条件，但是仍然不会发生重写，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。 重写是 发生在运行时的 ，因为编译期编译器不知道并且没办法确定该去调用哪个方法，JVM会在代码运行的时候作出决定。 方法重载的原则： 方法名称必须相同。 参数列表必须不同（个数不同、或类型不同、参数类型排列顺序不同等）。 方法的返回类型可以相同也可以不相同。 仅仅返回类型不同不足以成为方法的重载。 重载是 发生在编译时的 ，因为编译器可以根据参数的类型来选择使用哪个方法。 重写和重载的不同： 方法重写要求参数列表必须一致，而方法重载要求参数列表必须不一致。 方法重写要求返回类型必须一致(或为其子类型)，方法重载对此没有要求。 方法重写只能用于子类重写父类的方法(覆盖者可能不会限制它所覆盖的方法的访问)，方法重载用于同一个类中的所有方法。 方法重写对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。 父类的一个方法只能被子类重写一次，而一个方法可以在所有的类中可以被重载多次。 重载是编译时多态，重写是运行时多态。 参考博客​ 牛客网优质答案 7. Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？答案: 什么是构造方法？主要作用:** 完成对象的初始化工作(如果写的类里面没有构造函数,那么编译器会默认加上一个无参数且方法体为空的构造函数) 特点 使用 new + 构造方法创建一个新的对象 构造函数是定义在 Java类中的一个用来 初始化对象 的函数 (new一个东西的时候，实际上你调用的是一个构造方法，构造方法就是把自己构造成一个新的对象，所以叫构造方法，构造一个新对象用的方法叫构造方法) 构造函数与类同名, 且没有返回值(构造方法的名字必须和类的名字完全一模一样，包括大小写,这个方法的名字和类名完全相同，并且没有返回值，也就是在这个方法前面不能写任何的方法的返回类型修饰符，连void都不可以写) 什么是构造方法重载？Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己 唯一的参数列表 。 什么是复制构造方法？复制构造函数C++中的复制构造函数通常有三种作用: 对象作为函数参数 对象作为函数返回值 使用一个对象对另一个对象初始化。 C++语法允许用户定义自己的复制构造函数以实现自定义的复制，比如说进行深复制。Java并不支持这样的复制构造函数。但是这并不代表Java中没有这种机制，在Java中Object类的clone()方法就是这种机制的体现 java中不支持构造函数的复制。构造函数的复制属于C++的内容。 时间: 2019.3.12 8. Java支持多继承么？答案: Java中类不支持多继承，只支持单继承（即一个类只有一个父类）. java中的 接口 支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能） 9. 接口和抽象类的区别是什么？答案: 相同点 类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。 接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。 抽象类可以在不提供接口方法实现的情况下实现接口。 语法层面上的区别 抽象类可以提供成员方法的实现细节(成员函数可以是private，protected或者是public)，而接口中只能存在public abstract 方法(默认是public的) 抽象类中的成员变量可以是各种类型的(包含非final的变量)，而接口中的成员变量只能是public static final类型的； 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法； 接口中所有的方法默认的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 设计层面上的区别 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 抽象类是对一种事物的抽象，即 对类抽象 ，而接口是 对行为的抽象 。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。 举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将飞行这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系 。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。 什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。 参考博文​ 牛客网优质答案 ​ Java抽象类与接口的区别 ​ 深入理解Java的接口和抽象类 时间: 2019.3.13 10. 什么是值传递和引用传递？答案: 一般认为,java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递 值传递，顾名思义传递的是其值，也可以理解为副本给你，任意修改，原本不变。 引用传递，顾名思义传递本身，或者说传递的是地址，修改的是本身或者是原本地址里的内容。 值传递，原本不改变，引用传递，原本改变 详细解析见：知乎答案参考博文: ​ 牛客网答案 时间: 2019.3.14]]></content>
      <categories>
        <category>java面试经典题目</category>
      </categories>
      <tags>
        <tag>java面试经典题目</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[顺序表特点​ 逻辑关系相邻的两个结点在 物理位置 上也相邻, 结点的逻辑次序和物理次序一致 实现方式​ 数组 数组的优缺点优点 存取速度快 O(1) 可以直接根据下标找到内存位置 缺点 浪费存储空间. 要求实现估计容量,比较困难,需要的空间过大,造成浪费,过小将导致溢出 插入和删除 运算不方便,效率低,时间复杂度为O(n) 顺序表的存储空间不容易扩充. 基本操作的实现 初始化数组 判断数组是否为空 判断数组是否满 显示数组内容 向数组中追加元素 向数组中指定的位置插入元素 删除指定元素 数组进行倒置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include&lt;stdbool.h&gt;// 首先定义结构体typedef struct Arr&#123; int len; // 数组能存取的最大元素个数 int currentNum; // 当前元素的个数 int * pBase; // 存储指向数组元素的指针 &#125; Arr;/** * 初始化数组* 所需要的参数: 结构体, 数组长度 * 让指针指向分配的数组* 判断判断内存是否分配失败,如果没有失败,其他两个参数进行赋值 */void initArr(Arr * pArr, int len) &#123; // 分配4*len字节长度的内存,这是pBase可以指向数组中的第一个元素，可以作为数组变量名称使用。 pArr-&gt;pBase = (int *)malloc(sizeof(int)*len); // 判断内存是否分配失败 if(NULL == pArr-&gt;pBase)&#123; printf("动态内存分配失败!") ; &#125; else &#123; // pArray 中的值进行初始化 pArr-&gt;len = len; pArr-&gt;currentNum = 0; &#125; &#125;/*** 判断数组是否为空* 判断条件应该是当前数组中的元素是不是 0 个 * 参数: 数组*/bool isEmpty(Arr * pArr) &#123; if(0 == pArr-&gt;currentNum)&#123; // 若数组为空,返回true return true; &#125; else &#123; return false; &#125;&#125;/*** 判断数组是否满了* 判断条件应该是 len 和 currentNum 是否相等*/bool isFull(Arr * pArr) &#123; // 如果满了,返回 true if(pArr-&gt;len == pArr-&gt;currentNum) &#123; return true; &#125; else &#123; return false; &#125;&#125;/*** 显示数组内容* 先判断数组是否为空,若为空,打印数组为空* 若不为空,则利用指针循环遍历,全部打印出来 */void showArr(Arr * pArr) &#123; if(isEmpty(pArr)) &#123; printf("数组为空!\n"); &#125; else &#123; printf("\t\t此时数组中的所有元素为: \n"); // 注意应该是 i &lt; pArr-&gt;currentNum // 不是 i &lt; pArr-&gt;len for(int i = 0; i &lt; pArr-&gt;currentNum; i++) &#123; // 是数组,所以是 pArr-&gt;pBase[i] printf("%d \t", pArr-&gt;pBase[i]); &#125; printf("\n------------------------------------------------\n"); &#125;&#125; /*** 向数组中追加元素* 参数:数组, 追加的值 * 先判断数组是否已经满了* 如果满了,则不可以追加元素,打印追加失败* 如果未满,进行追加 */void append(Arr * pArr, int val) &#123; if( isFull(pArr) ) &#123; printf("数组已经满了,无法添加!\n"); &#125; else &#123; printf("添加元素为 %d\t", val); pArr-&gt;pBase[pArr-&gt;currentNum] = val; // 当前个数+1 pArr-&gt;currentNum++; &#125;&#125;/*** 向数组中指定的位置插入元素* 参数: 数组地址, 位置, 值* 首先判断数组是否满 * 再判断插入的位置是否合法 * 将插入位置后面的元素向后移动一个 * 再插入到相应的位置 */ bool insert(Arr * pArr, int pos, int val) &#123; if( isFull(pArr) ) &#123; printf("数组已经满了,无法插入!\n"); return false; &#125; // 插入的位置不能小于1，同时不能比最后一个元素位置大一 // 注意是 pos &gt; pArr-&gt;len+1 if (pos &lt; 1 || pos &gt; pArr-&gt;len+1) &#123; return false; &#125; else &#123; // 移动范围是从第pos个到底cnu个 // 注意判断条件 i = pArr-&gt;currentlen for(int i = pArr-&gt;currentNum; i &gt; pos; i--) &#123; // 若以i表示要移动元素的位置，从一开始的。右边都是i-1,若左移，左边是i-2,右移，左边是i pArr-&gt;pBase[1] = pArr-&gt;pBase[i-1]; &#125; //进行插入的值的赋值 pArr-&gt;pBase[pos-1] = val; printf("在第%d的位置插入元素: %d", pos, val); pArr-&gt;currentNum++; return true; &#125; &#125;/*** 向数组中指定的位置插入元素* 参数: 数组地址, 位置, 值(地址,将返回去) * 先判断位置是否合法* 在进行删除 */ bool delete_(Arr * pArr, int pos, int *val) &#123; if(pos&lt;1 || pos&gt;pArr-&gt;currentNum) &#123; printf("删除失败，位置不合法\n"); return false; &#125; else &#123; // 获取删除元素的值 *val = pArr-&gt;pBase[pos-1]; // 注意循环条件 for(int i=pos; i&lt;pArr-&gt;currentNum; i++)&#123; pArr-&gt;pBase[i-1] = pArr-&gt;pBase[i]; &#125; pArr-&gt;currentNum--; return true; &#125;&#125;/*** 数组元素进行倒置* 首先判断数组是否为空 */bool inverse(Arr * pArr) &#123; if( isEmpty(pArr) ) &#123; printf("倒置失败，因数组为空"); return false; &#125; int start = 0; // 数组的第一个元素 int end = pArr-&gt;currentNum-1; // 数组的最后一个元素 printf("数组元素进行倒置"); while(start &lt; end)&#123; // 利用一个 temp 临时数据进行数据交换 int temp = pArr-&gt;pBase[start]; pArr-&gt;pBase[start] = pArr-&gt;pBase[end]; pArr-&gt;pBase[end] = temp; // 下一组 start++; end--; &#125; return true; &#125;/*** 代码测试 */ int main() &#123; Arr arr; // 将结构体的地址作为实参，这样才能修改结构体中的值 // 如果传的是结构体变量，那么将进行拷贝，不会改变值 initArr(&amp;arr, 6); // 进行追加 append(&amp;arr, 1); append(&amp;arr, 2); append(&amp;arr, 3); append(&amp;arr, 4); // 进行显示 showArr(&amp;arr); // 插入元素 insert(&amp;arr, 5, 88); showArr(&amp;arr); // 删除元素 int val; delete_(&amp;arr, 1, &amp;val); printf("删除了元素 %d", val); showArr(&amp;arr); // 进行倒置 inverse(&amp;arr); showArr(&amp;arr); return 0;&#125; 参考博文:​ 数据结构基础（1）–数组C语言实现–动态内存分配]]></content>
      <categories>
        <category>数据结构</category>
        <category>线性表</category>
        <category>顺序表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言---常用函数]]></title>
    <url>%2F2019%2F03%2F12%2FC%E8%AF%AD%E8%A8%80---%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[C语言常用函数sizeof用法 如何使用]]></content>
      <categories>
        <category>C语言</category>
        <category>常用函数</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JDBC相关概念介绍]]></title>
    <url>%2F2019%2F03%2F12%2FJavaWeb---JDBC(1)%2F</url>
    <content type="text"><![CDATA[一、JDBC相关概念介绍1.1、数据库驱动 这里的驱动的概念和平时听到的那种驱动的概念是一样的，比如平时购买的声卡，网卡直接插到计算机上面是不能用的，必须要安装相应的驱动程序之后才能够使用声卡和网卡，同样道理，我们安装好数据库之后，我们的应用程序也是不能直接使用数据库的，必须要通过相应的数据库驱动程序，通过驱动程序去和数据库打交道 1.2、JDBC介绍 SUN公司为了简化、统一对数据库的操作，定义了一套Java操作数据库的规范（接口），称之为JDBC 。这套接口由数据库厂商去实现，这样，开发人员只需要学习jdbc接口，并通过jdbc加载具体的驱动，就可以操作数据库。 JDBC全称为：Java Data Base Connectivity（java数据库连接），它主要由接口组成。组成JDBC的２个包： java.sql javax.sql 开发JDBC应用需要以上2个包的支持外，还需要 导入相应JDBC的数据库实现(即数据库驱动) 。 二、编写JDBC程序2.1. 搭建实验环境 在mysql中创建一个库，并 创建user表和插入表的数据 。 新建一个Java工程，并 导入数据驱动 编写程序从user表中读取数据，并打印在命令行窗口中 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Statement;public class JdbcConn &#123; public static void main(String[] args) throws Exception &#123; //要连接的数据库URL String url = "jdbc:mysql://localhost:3306/jdbcStudy"; //连接的数据库时使用的用户名 String username = "root"; //连接的数据库时使用的密码 String password = "XDP"; //1.加载驱动 //DriverManager.registerDriver(new com.mysql.jdbc.Driver());不推荐使用这种方式来加载驱动 Class.forName("com.mysql.jdbc.Driver");//推荐使用这种方式来加载驱动 //2.获取与数据库的链接 Connection conn = DriverManager.getConnection(url, username, password); //3.获取用于向数据库发送sql语句的statement Statement st = conn.createStatement(); String sql = "select id,name,password,email,birthday from users"; //4.向数据库发sql,并获取代表结果集的resultset ResultSet rs = st.executeQuery(sql); //5.取出结果集的数据 while(rs.next())&#123; System.out.println("id=" + rs.getObject("id")); System.out.println("name=" + rs.getObject("name")); System.out.println("password=" + rs.getObject("password")); System.out.println("email=" + rs.getObject("email")); System.out.println("birthday=" + rs.getObject("birthday")); &#125; //6.关闭链接，释放资源 rs.close(); st.close(); conn.close(); &#125;&#125;//详细解析见原博文 2.2 释放资源 Jdbc程序运行完后，切记要释放程序在运行过程中，创建的那些与数据库进行交互的对象，这些对象通常是ResultSet, Statement和Connection对象，特别是Connection对象，它是非常稀有的资源，用完后必须马上释放，如果Connection不能及时、正确的关闭，极易导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。 为确保资源释放代码能运行，资源释放代码也一定要放在finally语句中。 参考博文:​ javaweb学习总结(三十二)——JDBC学习入门]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
        <category>JDBC相关概念介绍</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JavaBean]]></title>
    <url>%2F2019%2F03%2F12%2FJavaWeb---JavaBean%2F</url>
    <content type="text"><![CDATA[一、什么是JavaBean JavaBean是一个遵循特定写法的Java类，它通常具有如下特点： 这个Java类必须具有一个无参的构造函数 属性必须私有化。 私有化的属性必须通过public类型的方法暴露给其它程序，并且方法的命名也必须遵守一定的命名规范。 javaBean范例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package gacl.javabean.study;/** * @author gacl * Person类就是一个最简单的JavaBean */public class Person &#123; //------------------Person类封装的私有属性------------------------------------- // 姓名 String类型 private String name; // 性别 String类型 private String sex; // 年龄 int类型 private int age; //是否已婚 boolean类型 private boolean married; //------------------Person类的无参数构造方法----------------------------------- /** * 无参数构造方法 */ public Person() &#123; &#125; //------------------Person类对外提供的用于访问私有属性的public方法---------------- public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public boolean isMarried() &#123; return married; &#125; public void setMarried(boolean married) &#123; this.married = married; &#125;&#125; JavaBean在J2EE开发中，通常用于封装数据，对于遵循以上写法的JavaBean组件，其它程序可以通过反射技术实例化JavaBean对象，并且通过反射那些遵守命名规范的方法，从而获知JavaBean的属性，进而调用其属性保存数据 二、JavaBean的属性 JavaBean的属性可以是任意类型，并且一个JavaBean可以有多个属性。每个属性通常都需要具有相应的setter、 getter方法，setter方法称为属性修改器，getter方法称为属性访问器。 属性修改器必须以小写的set前缀开始，后跟属性名，且属性名的第一个字母要改为大写，例如，name属性的修改器名称为setName，password属性的修改器名称为setPassword。 属性访问器通常以小写的get前缀开始，后跟属性名，且属性名的第一个字母也要改为大写，例如，name属性的访问器名称为getName，password属性的访问器名称为getPassword。 一个JavaBean的某个属性也可以只有set方法或get方法，这样的属性通常也称之为只写、只读属性。 参考博文:javaweb学习总结(二十)——JavaBean总结]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how2J天猫整站---笔记]]></title>
    <url>%2F2019%2F03%2F12%2Fhow2J%E5%A4%A9%E7%8C%AB%E6%95%B4%E7%AB%99J2EE---%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一.关于表表与表之间的关系，基本上是3种 一对一 一对多 多对一 表的杂谈 修改表结构是代价最大的改动 在建表过程中，会设置外键约束，所以表和表之间有依赖关系。 因此会先建立被外键指向的表 一般说来，对于一个新项目，建表的时候，会把sql语句都准备好，一次性执行]]></content>
      <categories>
        <category>how2J</category>
      </categories>
      <tags>
        <tag>how2J</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse---快捷键]]></title>
    <url>%2F2019%2F03%2F12%2Feclipse%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[eclipse快捷键eclipse配置折叠/展开代码快捷键​ https://blog.csdn.net/HFUTLXM/article/details/78916599]]></content>
      <categories>
        <category>eclipse</category>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql语句]]></title>
    <url>%2F2019%2F03%2F11%2Fsql%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[参考博文: 一. 基础 创建数据库 1CREATE DATABASE database-name 删除数据库 1DROP DATABASE database-name 创建新表 1CEEATE DATABASE database-name 1CEEATE DATABASE database-name 1CEEATE DATABASE database-name 1CEEATE DATABASE database-name 参考博文: 经典SQL语句大全(绝对的经典) how2J]]></content>
      <tags>
        <tag>sql语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---Java基础知识---访问修饰符]]></title>
    <url>%2F2019%2F03%2F11%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[区别 public：public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用 private：private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可以使用。 protected：protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private 不写时默认为friendly ，也即是“包访问权限” 详细 作用域 自身 同包子类 不同包子类 同包类 其他类 private 访问(√) 继承(×) 继承(×) 访问(×) 访问(×) package 访问(√) 继承(√) 继承(×) 访问(√) 访问(×) protected 访问(√) 继承(√) 继承(√) 访问(√) 访问(×) public 访问(√) 继承(√) 继承(√) 访问(√) 访问(√) 如何使用 属性 通常使用private封装起来 方法 一般使用public用于被调用 会 被子类继承 的方法，通常使用protected package用的不多，一般新手会用package,因为还不知道有修饰符这个东西 总结 如果一个成员需要被外部包所访问，则必须使用public修饰符；如果一个成员需要被定义在不同包下的子类所访问，则可以使用public或protected修饰符；如果一个成员需要被本包下的其他类所访问，则可以不用写任何的修饰符，使用public或者protected也行 若一个成员想使用同类中其他成员，则使用任意一个修饰符即可；若一个成员不想被任何一个外部的类所访问，则使用private关键字比较恰当。 参考博客: Java中private、public、default、protected的区别]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---方法的重载和覆盖]]></title>
    <url>%2F2019%2F03%2F11%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[一. 方法的重载(overload)指一个类中可以定义有 相同的名字 ,但 参数不同 的多个方法. 调用时, 会根据 不同的参数表 选择对应的方法 范例 构造方法 注意 方法名一样, 但参数不一样,就是重载(overload) 参数不一样 (1.参数的个数不一样 2. 参数的类型不一样, 只要有一个就可以) 方法名一样，参数类型一样，只有返回值不一样，这个不构成重载 理解: 多重加载，不同样式的加载 二. 方法的覆盖(override)指覆盖了一个方法并且对其重写，以求达到不同的作用,也可以叫做 重写 范例 对 接口方法 的实现 在 继承 中也可能会在 子类覆盖父类 中的方法 注意 覆盖的方法的标志必须要和被覆盖的方法的 标志 (相同的名字和相同的参数)完全匹配，才能达到覆盖的效果； 覆盖的方法的返回值必须和被覆盖的方法的返回一致； 覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类； 被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖 参考博文 java中的方法覆盖（Overriding）和方法重载（Overloading）是什么意思？重写跟重载的区别？ 对比Java语言中的覆盖和重载]]></content>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间词话---网易云评论]]></title>
    <url>%2F2019%2F03%2F09%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%84%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[卿卿我我 写歌的人假正经, 听歌的人最无情.人要是桥请起来,听什么都像在唱自己. 校服是我和她唯一穿过的情侣装, 毕业照是我和她唯一的合影. 情怀 愿走出半生, 归来仍是少年.]]></content>
      <tags>
        <tag>人间词话</tag>
        <tag>网易云评论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间词话---送给自己]]></title>
    <url>%2F2019%2F03%2F09%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[勇者愤怒, 抽刃向更强者.怯者愤怒, 却抽刀向更弱者 扬在脸上的微笑, 长在心里的善良,融进血液的骨气, 刻在生命里的坚强. 礼仪最重要的是在昭告自我,真正的宣誓是对自己说的话. —陈果 对一切人,一切西乡都保持一种开放二友善的胸襟和气度的时候,才真正成为名副其实的大学生. —陈果 挫折能使强者更强,弱者更弱,强者在面对中锻炼了自己,弱者在逃避中越发脆弱 最善言谈者就是最善于倾听的人]]></content>
      <tags>
        <tag>人间词话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间词话---ZJ]]></title>
    <url>%2F2019%2F03%2F09%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---ZJ%2F</url>
    <content type="text"><![CDATA[没有人会拒绝微笑, 也没有人会拒绝真诚. 逢山开路, 遇水架桥.]]></content>
      <tags>
        <tag>人间词话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---面向对象(2)]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(2)%2F</url>
    <content type="text"><![CDATA[一. Java类的定义 使用 class 关键字定义一个类 12345678910class Person &#123; // 成员变量(属性)定义 private int id; private int age = 10; //方法定义 public int getAge() &#123; return age; &#125; public void setAge(int i) &#123; age = i; &#125;&#125; 二. 成员变量 成员变量的作用范围为 整个类体 定义成员变量可以对其初始化, 如果 不对其初始化 , Java 使用默认的值 对其初始化(若不记得JAVA对成员变量默认的初始化是多少的话，定义一个成员变量，不给它初始化，然后直接打印这个成员变量,进行查看) 在 JAVA 里面的任何变量首先应该要声明，然后再赋值，然后再使用 成员变量和局部变量的区别: 成员变量 局部变量 不进行初始化 默认给初始化 不默认给初始化, 在方法里面声明一个局部变量如果不给它初始化时就会出错 三. 基本概念 — 引用​ Java语言中 除基本类型之外 的变量类型都称之为引用类型 Java中的对象是通过引用对其操作的 基本类型与引用类型的区别: 基本类型 引用类型 实现 当声明一个int i=0时，系统会马上给这个i分配一个内存空间（在 栈内存 里面分配一小块区域用来装数字0），里面装着一个值为0，以后使用i这个名字马上就可以访问这个内存空间里面的值 定义好这个类之后，需要使用new关键字把这个类的对象实例化出来，也就是真真正正造出一个对象出来才能使用这个对象 内存 占 一块 内存 占 两块 内存 存放位置 栈内存 栈内存: 引用对象 堆内存: 真正的内容(new出来的东西) 不论是基本数据类型还是引用类型，都会先在栈中分配一块内存 ，对于基本类型来说，这块区域包含的是 基本类型的内容；而对于引用类型来说，这块区域包含的是 指向真正内容的指针(存放真正内容的地址) ，真正的内容被手动的分配在堆上。 代码实例:123456789101112131415161718public class Hero &#123; String name; //姓名 float hp; //血量 public static void main(String[] args) &#123; //代表创建了一个Hero对象 //但是也仅仅是创建了一个对象，没有办法访问它 //为了访问这个对象，会使用引用来代表这个对象 new Hero(); //"h"这个变量是Hero类型，叫做引用(也叫 引用对象,对象的引用) //"="的意思指的h这个引用代表右侧创建的对象 //“代表” 在面向对象里，又叫做“指向” //引用h指向了新建的Hero对象 Hero h = new Hero(); &#125; &#125; 多个引用，一个对象，一个引用，多个对象区别： 多个引用指向一个对象，操作的都是同一个对象 一个引用多个对象，之前的对象就没有办法访问了, 这个引用就指向了另一个对象 四. 类和对象的关系如何在内存中区分类和对象 类是 静态 的概念, 在代码区 对象是new出来的, 位于 堆内存 , 类的每个成员变量在不同的对象中都有不同的值 (除了静态变量,static),而方法只有一分,执行的时候才占用内存 . 五. 构造方法(函数) 主要作用 :完成对象的初始化工作，(如果写的类里面没有构造函数,那么编译器会默认加上一个无参数且方法体为空的构造函数) 特点 使用 new + 构造方法创建一个新的对象 构造函数是定义在 Java类中的一个用来 初始化对象 的函数,(new一个东西的时候，实际上你调用的是一个构造方法，构造方法就是把自己构造成一个新的对象，所以叫构造方法，构造一个新对象用的方法叫构造方法) 构造函数与类同名, 且没有返回值(构造方法的名字必须和类的名字完全一模一样，包括大小写,这个方法的名字和类名完全相同，并且没有返回值，也就是在这个方法前面不能写任何的方法的返回类型修饰符，连void都不可以写) 范例12345678910111213141516public class Person &#123; int id; //在person这类里面定义两个成员变量id和age, int age=20; //给成员变量age赋了初值为20 /**这里就是person这个类的一个构造方法 * 构造方法的规则很简单，和类名要完全一样，一点都不能错，包括大小写。 * 并且没有返回值，不能写void在它前面修饰 * @param _id * @param _age */ public Person(int _id,int _age ) &#123; id = _id; age = _age; &#125;&#125;//内存分析见 孤傲苍狼博客 注意 如果类已经有了一个有参数有方法体的构造函数,这时编译器就不会再给它默认加上一个无参且方法体为空的构造函数.可以理解为无参的构造函数被覆盖了.这种情况称为没有默认构造函数 随笔数据区、代码区、栈区、堆区 区别: 栈区(stack)：由系统的编译器自动的释放， 主要用来存放方法中的参数，一些临时的局部变量等 ，并且方法中的参数一般在操作完后，会由编译器自动的释放掉。 堆区(heap):由程序员决定，在Java中，如果程序员不释放的话，一般会由垃圾回收机制自动的清理掉。此区域主要用来 存放我们经常创建的对象、动态的申请的临时空间等 。 数据区(data seg):也称全局区或者静态区，根据名称我们就应该知道用来存放一些全局的东西，比如我们经常用到的 静态变量、全局变量等 都会存放到数据区，此区域上的东西都被全局所共享。比如我们可以采取类名.的方式就可以访问到方法，这就是所谓的静态方法，存放到数据区的。 代码区：存放 程序编译后可以执行代码的地方 。比如执行代码时写的While语句、if条件语句等，都会存放到此 理解了内存，就理解了一切，就理解了各种各样的语言。所有的语言无非都是这样：局部变量分配内存永远在栈里面，new出来的东西分配内存永远是在堆里，静态的东西分配内存永远是在数据区。剩下的代码肯定是在代码区 参考博文:how2J 类和对象 孤傲苍狼 java基础学习总结——面向对象2 Java基本数据类型与引用数据类型 及在堆栈中内存的存储原理 数据区、代码区、栈区、堆区]]></content>
      <categories>
        <category>java基础知识</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---Filter(一)]]></title>
    <url>%2F2019%2F03%2F08%2FJavaWeb---Filter(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[一、Filter简介 Filter也称之为过滤器，WEB开发人员通过Filter技术，对web服务器管理的所有web资源：例如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。 Servlet API中提供了一个Filter接口，开发web应用时，如果编写的Java类实现了这个接口，则把这个java类称之为过滤器Filter。通过Filter技术，开发人员可以实现用户在访问某个目标资源之前，对访问的请求和响应进行拦截. 二、Filter是如何实现拦截的？ Filter接口中有一个doFilter方法，当我们编写好Filter，并配置对哪个web资源进行拦截后，WEB服务器每次在调用web资源的service方法之前，都会先调用一下filter的doFilter方法，因此，在该方法内编写代码可达到如下目的： 调用目标资源之前，让一段代码执行。 是否调用目标资源（即是否让用户访问web资源）。 调用目标资源之后，让一段代码执行。 web服务器在调用doFilter方法时，会传递一个filterChain对象进来，filterChain对象是filter接口中最重要的一个对 象，它也提供了一个doFilter方法，开发人员可以根据需求决定是否调用此方法，调用该方法，则web服务器就会调用web资源的service方 法，即web资源就会被访问，否则web资源不会被访问。 三、Filter开发入门3.1、Filter开发步骤Filter开发分为二个步骤： 编写java类实现Filter接口，并实现其doFilter方法。 在 web.xml 文件中使用&lt;filter&gt;和&lt;filter-mapping&gt;元素对编写的filter类进行注册，并设置它所能拦截的资源。 过滤器范例123456789101112131415161718192021222324252627282930313233/*** @Description:filter的三种典型应用：* 1、可以在filter中根据条件决定是否调用chain.doFilter(request, response)方法，即是否让目标资源执行* 2、在让目标资源执行之前，可以对request\response作预处理，再让目标资源执行* 3、在目标资源执行之后，可以捕获目标资源的执行结果，从而实现一些特殊的功能*/ public class FilterDemo01 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println("----过滤器初始化----"); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; //对request和response进行一些预处理 request.setCharacterEncoding("UTF-8"); response.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); System.out.println("FilterDemo01执行前！！！"); chain.doFilter(request, response); //让目标资源执行，放行 System.out.println("FilterDemo01执行后！！！"); &#125; @Override public void destroy() &#123; System.out.println("----过滤器销毁----"); &#125;&#125; 在web. xml中配置过滤器123456789101112&lt;!--配置过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;FilterDemo01&lt;/filter-name&gt; &lt;filter-class&gt;me.gacl.web.filter.FilterDemo01&lt;/filter-class&gt;&lt;/filter&gt;&lt;!--映射过滤器--&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;FilterDemo01&lt;/filter-name&gt; &lt;!--“/*”表示拦截所有的请求 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 参考博文​ javaweb学习总结(四十二)——Filter(过滤器)学习]]></content>
      <categories>
        <category>java基础知识</category>
        <category>Filter</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---static关键字]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---static%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Static 关键字 static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途 基本作用: 方便在 没有创建对象 的情况下来进行调用(方法/变量),被static修饰的变量和方法其随着类的加载而被加载 . 只要类被加载了，就可以通过类名去进行访问. 静态变量 在类中用static声明的成员变量为 静态成员变量 (也叫类变量), 其为该类的公共变量, 在第一次使用时被初始化, 这个成员变量 只有一份 ，而且这一份是这个类 所有的对象 共享, 属于整个类的，它不属于专门的某个对象 非静态成员专属于某一个对象，想访问非静态成员必须new一个对象出来才能访问 static成员变量的初始化顺序按照定义的顺序进行初始化 注意: 注意不能把 任何方法体内的变量声明为静态 静态方法 用static 声明的方法为静态方法(也叫类方法) 在静态方法里只能直接调用同类中其他的静态成员（包括变量和方法），而不能直接访问类中的非静态成员 。这是因为，对于非静态的方法和变量，需要先创建类的实例对象后才可使用，而静态方法在使用前不用创建任何对象。 对于非静态成员方法，它访问静态成员方法/变量显然是毫无限制的 静态方法不能以任何方式引用this和super关键字 因为静态方法在使用前不用创建任何实例对象，当静态方法调用时，this所引用的对象根本没有产生。 由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了 范例​ 想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。 ​ 最常见的static方法就是main方法。因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。 静态代码块 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。 为什么说static块可以用来优化程序性能​ 是因为它的特性:只会在类加载的时候执行一次。 杂:​ static可以修饰内部类，但是不能修饰普通类。静态内部类的话可以直接调用静态构造器（不用对象）。 参考博文:​ java基础学习总结——static关键字 ​ 优质答案 ​ java中静态代码块的用法 static用法详解 ​ Java中的static关键字解析]]></content>
      <categories>
        <category>java基础知识</category>
        <category>Static关键字</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---面向对象(1)]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(1)%2F</url>
    <content type="text"><![CDATA[一. 面向过程的思想和面向对象的思想面向过程 自顶向下,逐步细化 ​ 面向解决问题的过程进行编程​ 按照步骤化解决问题.(一个问题,分析这个问题如何去解决,第一步做什么, 第二步什么…), 当我们用面向过程的思想去编程或解决问题时，首先一定要把详细的实现过程弄清楚。一旦过程设计清楚，代码的实现简直轻而易举。 面向对象 Java 中万物皆对象，模拟真实的现实世界 ​ 在编程的时候尽可能的去模拟真实的现实世界，按照现实世界中的逻辑去处理一个问题，分析问题中参与其中的有哪些实体，这些实体应该有什么属性和方法，我们如何通过调用这些实体的属性和方法去解决问题。拿到一个问题,应该分析: 这个问题里面有哪些类和对象 在分析这些类和对象应该具有哪些属性和方法 分析类和类之间具有什么关系 设计思维: 合适的方法应该出现在合适的类里面 二. 类和对象类一类事物的抽象包括属性(静态)和方法(动态) 属性: 用来描述这一个对象（类）的特征 ,比如一个人的属性有身高，肤色，体重等等， 方法: 可以完成一个特定的功能，方法就像是动作, 比如人可以吃饭，跑步，学习，都可以是方法 Java中属性就是成员变量,方法就是函数, 不同的叫法 对象一类事物的具体的某一个东西(符合这类事物的具体特征) 在Java中, 对象就是类的实例化 随笔: 对象和类是分不开的，必须首先定义类才能有对象类和对象的关系，类就是模板，里面定义着属性和方法，而对象就是实例，通过类来创建（new）对象，叫类的实例化 三. 面向过程与面向对象的比较 都可以实现代码重用和模块化编程，但是面对对象的模块化更深，数据更封闭，也更安全！因为面向对象的封装性更强！ 面对对象的思维方式更加贴近于现实生活，更容易解决大型的复杂的业务逻辑 从前期开发角度上来看，面对对象远比面向过程要复杂，但是从维护和扩展功能的角度上来看，面对对象远比面向过程要简单！ 当我们的业务逻辑比较简单时，使用面向过程能更快的实现当我们的业务逻辑比较复杂时，为了将来的维护和扩展，还是面向对象更为靠谱 参考博文​ 编程思想：面向对象和面向过程]]></content>
      <categories>
        <category>java基础知识</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言基础知识]]></title>
    <url>%2F2019%2F03%2F08%2FC%E8%AF%AD%E8%A8%80---%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[C语言基础知识:结构体:定义: 将一些已知的数据类型放在一起来定义的一种数据类型 结构体并没有创造出新的数据类型，这点要搞清楚。C语言的结构体和其他高级语言的类有点相似的概念，可以完成对一种事物的抽象。 代码中的定义: 1234567891011121314151617struct 结构名 // 结构名是结构的标识符不是变量名&#123; 类型 变量名; 类型 变量名;&#125; 结构变量;// 例子:struct student &#123; char name[8]; int age; char sex[2]; char depart[20]; float wage1, wage2, wage3, wage4, wage5; &#125; Mike, Marry;struct student John; // struct student:类型说明符, John 变量名// 定义了两个 struct student 类型的变量 Mike, Marry typedef: 使用 typedef 关键字来定义自己习惯的数据类型名称，来替代系统默认的基本类型名称、数组类型名称、指针类型名称与用户自定义的结构型名称、共用型名称、枚举型名称等。 基本用法 1. 为基本类型数据定义新的类型名1234567typedef int COUNT; // 为基本类型数据定义新的类型名int main() &#123; COUNT a = 88; printf("结果为: %d", a); return 0;&#125;// 打印结果: 结果为: 88 2. 为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称12345678910111213141516// 以结构体为例，下面我们定义一个名为 Point 的结构体struct Point&#123; double x; double y; double z;&#125;;// 在调用这个结构体时，我们必须像下面的代码这样来调用这个结构体int main() &#123; struct Point oPoint2; oPoint2.x = 3.3; printf("%f", oPoint2.x); return 0;&#125;// 打印结果: 3.300000 解析123456789typedef struct tagPoint&#123; double x; double y; double z;&#125; Point;// 1.相当于把 x = struct tagPoint &#123; …&#125;// 2.typedef x Point;// 可以看做是简写 参考文章: ​ typedef的用法，C语言typedef详解]]></content>
      <categories>
        <category>C语言</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言---指针]]></title>
    <url>%2F2019%2F03%2F08%2FC%E8%AF%AD%E8%A8%80---%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[指针一. 简单理解指针变量: 专门用来存放地址的特殊变量 指针 ( = 变量的值) 指针变量 ( = 变量) 含义 地址 存放另一个变量地址的变量 指针与指针变量的关系类似于变量的值与变量的区别. 指针变量习惯上简称为 指针 1234567891011int main()&#123; int a, * p; p = &amp;a; // "&amp;a" 代表a的地址的值 a = 3; printf("p的值为 %d\n", p); // p中存放的是 a 的地址 printf("*p的值为 %d", *p); // * 号在 引用时表示"指向"操作, *p 代表 a, // "*"仅起到标志的作用, 表示该变量为指针变量, 不是变量名的一部分, 及指针变量名不包括 * return 0 ;&#125; 二. 复杂类型说明123456789int p; //这是一个普通的整型变量 int *p; //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针 int p[3]; //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组 int *p[3]; //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组 int (*p)[3]; //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与"()"这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针 int **p; //首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针. int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据 Int (*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针 int *(*p(int))[3]; //可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数. 三. 细说指针指针是一个 特殊的变量 ，它里面 存储的数值 被解释成为 内存里的一个地址 。要搞清一个指针需要搞清指针的四方面的内容： 指针的类型 指针所指向的类型 指针的值或者叫指针所指向的内存区 指针本身所占据的内存区。 3.1 指针的类型从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。例如: 12345int * ptr; //指针的类型是int*char * ptr; //指针的类型是char*int ** ptr; //指针的类型是int**int (* ptr)[3]; //指针的类型是int(*)[3]int * (* ptr)[4]; //指针的类型是int*(*)[4] 3.2 指针所指向的类型当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符去掉，剩下的就是指针所指向的类型。例如： 12345int * ptr; //指针所指向的类型是intchar * ptr; //指针所指向的的类型是charint ** ptr; //指针所指向的的类型是intint (*ptr)[3]; //指针所指向的的类型是int()[3]int (ptr)[4]; //指针所指向的的类型是int*()[4] 指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C 越来越熟悉时，你会发现，把与指针搅和在一起的”类型”这个概念分成”指针的类型”和”指针所指向的类型”两个概念，是精通指针的关键点之一。 3.3 指针的值—-或者叫指针所指向的内存区或地址 指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。 在32 位程序里，所有类型的指针的值都是一个32 位整数，因为32 位程序里内存地址全都是32 位长。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区 我们说一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在3.2例子中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。 以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？ 3.4 指针本身所占据的内存区指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32 位平台里，指针本身占据了4 个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式（后面会解释）是否是左值时很有用 四. 指针的算术运算五. 运算符 &amp; 和 *这里 &amp; 是取地址运算符，* 是间接运算符。&amp;a 的运算结果是一个指针，指针的类型是a 的类型加个* ，指针所指向的类型是a 的类型，指针所指向的地址嘛，那就是a 的地址。 *p 的运算结果就五花八门了。总之*p 的结果是 p 所指向的东西，这个东西有这些特点：它的类型是p 指向的类型，它所占用的地址是p所指向的地址。 123456789101112int a=12; int b; int *p; int **ptr; p=&amp;a; //&amp;a 的结果是一个指针，类型是int*，指向的类型是int，指向的地址是a的地址。 *p=24; //*p 的结果，在这里它的类型是int，它所占用的地址是p所指向的地址，*p就是变量a。 // 下面的还有有看懂ptr=&amp;p; //&amp;p 的结果是个指针，该指针的类型是p 的类型加个*, 在这里是int **。该指针所指向的类 //型是p的类型，这里是int*。该指针所指向的地址就是指针p 自己的地址。 *ptr=&amp;b; //*ptr 是个指针，&amp;b 的结果也是个指针，且这两个指针 //的类型和所指向的类型是一样的，所以用&amp;b 来给*ptr 赋 //值就是毫无问题的了。 **ptr=34; //*ptr 的结果是ptr 所指向的东西，在这里是一个指针， //对这个指针再做一次*运算，结果是一个int 类型的变量。 六. 指针表达式一个表达式的结果如果是一个指针，那么这个表达式就叫指针表式。 七. 数组和指针的关系八. 指针和结构类型的关系12345678910111213struct MyStruct &#123; int a; int b; int c; &#125;; // 声明了结构对象ss，并把ss 的成员初始化为20，30 和40。struct MyStruct ss = &#123;20,30,40&#125;; // 声明了一个指向结构对象 ss 的指针。它的类型是MyStruct *,它指向的类型是MyStruct。struct MyStruct *ptr = &amp;ss; // 声明了一个指向结构对象ss 的指针。但是pstr 和它被指向的类型ptr 是不同的。int *pstr = (int*)&amp;ss; 请问怎样通过指针ptr 来访问ss 的三个成员变量？答案： 123ptr-&gt;a; //指向运算符，或者可以这们(*ptr).a,建议使用前者ptr-&gt;b;ptr-&gt;c; 九. 指针和函数的关系可以把一个指针声明成为一个指向函数的指针。 1234int fun1(char *,int);int (*pfun1)(char ,int);pfun1 = fun1;int a = (*pfun1)("abcdefg",7); //通过函数指针调用函数。 可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。 12345678910111213int fun(char *); int a; char str[] = "abcdefghijklmn"; a = fun(str); int fun(char *s) &#123; int num=0; for(int i=0;;) &#123; num+=*s;s++; &#125; return num; &#125; 这个例子中的函数fun 统计一个字符串中各个字符的ASCII 码值之和。前面说了，数组的名字也是一个指针。在函数调用中，当把str作为实参传递给形参s 后，实际是把str 的值传递给了s，s 所指向的地址就和str 所指向的地址一致，但是str 和s 各自占用各自的存储空间。在函数体内对s 进行自加1 运算，并不意味着同时对str 进行了自加1 运算。 参考博文​ C语言指针详解(经典,非常详细) ​ 指针与函数]]></content>
      <categories>
        <category>C语言</category>
        <category>指针</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---基础语法(2)]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%952%2F</url>
    <content type="text"><![CDATA[一. 语句1.1 条件语句 if 语句 switch 语句 1.2 循环语句 for 循环语句 while 循环与do while 循环 1.3 break 和 continue 语句 二. 方法​ 一段用来完成特定功能的代码片段 1234[修饰符1 修饰符2 ...] 返回值类型 方法名(形式参数列表) &#123; java 语句; ...&#125; 方法可以有返回值，但可以不用这个返回值。方法首先要定义，然后才能调用 三、变量的作用域​ 变量的作用域只在“{ }”有效，出了这个“{ }”就没有作用了 四、递归调用 递归：在一个方法内部对自身的调用就称为递归 具体的参考 孤傲苍狼 博客 五、程序的执行过程 参考博文:​ java基础学习总结——基础语法2]]></content>
      <categories>
        <category>java基础知识</category>
        <category>基础语法</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构---线性表]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[线性表：定义:​ 由 n(n≥0) 个数据特性相同的元素构成的 有限序列 特点: 存在唯一的一个被称为”第一个”的数据元素 存在唯一的一个被称为”最后一个”的数据元素 除第一个之外, 结构中的每个数据元素均只有一个前驱元素 除最后一个之外, 结构中的每个数据元素均只有一个后继元素 存储结构及运算: 存储结构方式: 顺序存储方式(顺序表), 链接存储方式(链表) 运算: 线性表的初始化 求表的长度 取出表的元素 查找运算 相关概念 空表: 线性表的长度 n=0 前驱元素: 如果 a~i~ 和a~i+1~ 是相邻的具有前后关系的两个元素, 则 a~i~ 称为 a~i+1~ 的前驱元素 后继元素: 如果 a~i~ 和a~i+1~ 是相邻的具有前后关系的两个元素, 则 a~i+1~ 称为 a~i~ 的前驱元素 随笔: 线性表中的数据元素之间的逻辑关系就是其相互位置上的 邻接关系 ,该关系是线性的,因此,线性表是一种线性结构 常见例子: 学生成绩表, 列车时刻表, 英文字母表 ​]]></content>
      <categories>
        <category>数据结构</category>
        <category>线性表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构---链表的概念及实现]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[链表线性表的链接存储结构成为链表 常见的链表: 单链表(每个节点有一个指针域的链表) 循环链表 双链表(每个节点有两个指针域的链表) 特点: 用一组任意的存储单元存储线性表的数据结构(存储单元可以是连续的,也可以是不连续的 数据元素的逻辑次序和物理次序 ==不一定一致== 相关概念 结点: 基本单元,由两部分组成 数据域: 用来存放节点本身的信息 指针域:用来存放本节点的直接后继节点的地址 空指针: 链表中最后一个节点的指针域不指向任何节点(通常用”∧”或者”NULL”表示 头指针: 指向单链表第一个节点的指针(head) 空表: 之神 head 为空指针,即 head=NULL 表头结点: 第一个节点之前再增加一个类型相同的结点(为了便于实现链表的各种运算, 其他节点成为表结点) 表结点: 除了表头结点其他的结点 在表结点中,第一个节点称为首结点 ,最后一个节点称为 尾节点]]></content>
      <categories>
        <category>数据结构</category>
        <category>单链表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[陈果老师语录]]></title>
    <url>%2F2019%2F03%2F07%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E6%88%91%E6%88%90%E9%95%BF---%E9%99%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[只有心灵才能洞察一切，世界上真正重要的东西要用心去看 你使用什么样的双眼观世界，就印证了你有怎样的心眼，如果心眼大，你所见的世界宽广无边，如果你心眼小，充满羡慕嫉妒恨，所见的世界也是偏狭丑陋 选择之所以称之为选择，一定是痛苦的，因为选项是不相上下的，能轻松做决定的，都不叫选择，选择意味着舍弃一种美好，承受一种痛苦，不安 回忆是一种重逢, 忘记是一份自由.]]></content>
      <categories>
        <category>感悟</category>
        <category>陈果老师</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>人生方向</tag>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[涂磊老师语录]]></title>
    <url>%2F2019%2F03%2F07%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E6%88%91%E6%88%90%E9%95%BF---%E6%B6%82%E7%A3%8A%2F</url>
    <content type="text"><![CDATA[我们总是善于去伤害那些爱我们的人， 因为我们根本伤害不了那些不爱我们的人;我们总是甘愿被那些我们爱的人伤害，那是因为我爱他们 喜欢可以心动，而爱一定会心痛；喜欢可以舍得，但爱一定舍不得；喜欢一个人，冬天不过是冬天，不过是漂亮一点而已；但是爱一个人，冬天可以变成春天；爱一个人，她落泪你就会跟着她一起落泪；而喜欢一个人，她落泪你只不过是安慰；喜欢是可以变成爱的，但如果爱了就说不出喜欢；喜欢是不排她的，而爱一定是排她的，唯一的；喜欢与责任无关，而爱一定要负责任，这就是喜欢和爱的区别 春风得意的浪子回头最珍贵，穷途末路的认错悔改最虚伪 你曾经买了一件很喜欢的衣裳却舍不得穿，郑重地供奉在衣柜里；许久之后，当你再看见它的时候，却发现它已经过时了。所以，你就这样与它错过了。你也曾经买了一块漂亮的蛋糕却舍不得吃，郑重地供奉在冰箱里；许久之后，当你再看见它的时候，却发现它已经过期了。所以，你也这样与它错过了。没有在最喜欢的时候上身的衣裳，没有在最可口的时候品尝的蛋糕，就像没有在最想做的时候去做的事情，都是遗憾。生命也有保存期限，想做的事该趁早去做。如果你只是把你的心愿郑重地供奉在心里，却未曾去实行，那么唯一的结果，就是与它错过，一如那件过时的衣裳，一如那块过期的蛋糕 有些人注定是你生命中的过客，却总是成为你记忆中的常客，但永远也仅止于做客 你以为责任是什么？你以为责任就是终身相守，扔几个钱在家里。真正的责任是要在乎你所爱的人的每一分每一秒的感受 男人无事献殷勤非奸即盗，女人对爱来者不拒不是欺就是爱 人最伟大的力量不是创造，而是自省！如果不能自我反省，不能看到自身的错误和不足，即使有非凡的力量，创造出的一切都只是埋没自己的坟墓！ 越是嘴上说自己有原则的人，越是圆滑，因为他们的原则便是永远不说负责任的话，永远模棱两可！狡猾的眼神中永远透露的是欺骗，向下的嘴角代表的永远是严肃。 在我看来，绝大多数现代人的虚荣来自于虚伪，虚伪来自于自卑！在日常生活中衣着光鲜、牛逼哄哄的家伙其实内心很恐慌！]]></content>
      <categories>
        <category>感悟</category>
        <category>涂磊老师</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>人生方向</tag>
        <tag>智慧</tag>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---基础语法(1)]]></title>
    <url>%2F2019%2F03%2F07%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%951%2F</url>
    <content type="text"><![CDATA[一.标识符​ 对于各种变量, 方法和类等要素 命名时使用的字符序列 称为标识符 凡是自己可以命名的地方都叫标识符, 都遵循标识符的规则 二.关键字​ 一些赋以特定的含义, 用作专门用途的字符串 成为关键字 大部分编辑会将关键字用特殊方式标出所有Java关键字都是小写英文 三. java基础数据类型3.1 Java常量​ eg: 整型常量: 123, 字符常量: ‘a’ 注意: 区分字符常量和字符串常量注意: “常量”这个名词还会用在另外其它语境中表示 值不可变的变量 3.2 Java变量1234// 变量i(变量的名字)中存放常量100(变量的值)int i = 100; float f = 3.14;String s = "hello"; 变量是 内存 中的一小块区域, 使用 变量名 来访问这块区域因此,每一个变量使用前必须要先 声明, 然后必须进行 赋值 (填充内容), 才能使用 补充(本质上理解): 一个程序在运行的时候，实际上这个程序是位于内存里面，然后才开始运行。一个.exe文件 存放在硬盘上是无法运行的 ，在硬盘上看到的.exe文件无非就是一个文件而已，当我们双击这个.exe文件时，运行起来的时候实际上是 整个.exe文件被放在了在内存里面 ，然后操作系统找到main方法，也就是程序的入口，然后就开始执行了。执行的过程之中，会不断地在内存里面分配一些区域 变量在内存里面就是一小块区域，变量有两个概念，一个是变量的名字，另一个是变量的值即这一小块区域是有名字的，里面装着一个值，因此以后要想访问这小块区域里面的内容就可以根据这小块区域的名字来访问了。因此，变量的本质就是一小块内存区域 。变量在内存里面分配多大的存储空间呢？ 答: 不同的变量类型分配不同大小的存储空间，每一个变量都是属于特定的数据类型的，声明成不同的数据类型，它就在内存里面分配不同的存储空间。 Java变量的分类:按被声明的 位置 划分: 局部变量: 方法或语句块内部定义的变量 成员变量: 方法外部, 类的内部定义的变量 类外面不能有变量的声明 按所属数据的 数据类型 划分: 基本数据类型变量 引用数据类型变量 3.3 Java数据类型3.3.1 基本数据类型 整数型: byte, short, int, long, 浮动型: float, double 布尔型: bool 字符型: char 3.3.2 基本数据类型的转换 boolean 类型不可以转换为其他的数据类型 容量小的类型自动转换为容量大的数据类型 容量大的类型转换为容量小的数据类型时, 要加上强制转换符,可能造成精度降低或溢出 有多种类型的数据混合运算时,系统首先自动的将所有数据类型转换成 容量最大 的那一种数据类型,然后在进行计算 范例1234567891011121314151617181920public class TestConvert &#123; public static void main(String arg[]) &#123; int i1 = 123; int i2 = 456; double d1 = (i1+i2)*1.2;//系统将转换为double型运算 float f1 = (float)((i1+i2)*1.2);//需要加强制转换符 byte b1 = 67; byte b2 = 89; byte b3 = (byte)(b1+b2);//系统将转换为int型运算，需要强制转换符 System.out.println(b3); double d2 = 1e200; float f2 = (float)d2;//会产生溢出 System.out.println(f2); float f3 = 1.23f;//必须加f long l1 = 123; long l2 = 30000000000L;//必须加l float f = l1+l2+f3;//系统将转换为float型计算 long l = (long)f;//强制转换会舍去小数部分（不是四舍五入） &#125;&#125; 3.3.3 引用数据类型 类(class) 接口(interface) 数组 参考博文:​ java基础学习总结——基础语法1]]></content>
      <categories>
        <category>java基础知识</category>
        <category>基础语法</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 常用命令]]></title>
    <url>%2F2019%2F03%2F07%2FHexo---%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. 写文章 写文章 你可以执行下列命令来创建一篇新文章。 hexo new #新建文章，可以改成中文的，如“新文章”，如果标题包含空格的话，请使用引号括起来。 删除文章 先删除目标文章，然后重新运行 hexo clean # 清除缓存文件 (db.json) 和已生成的静态文件 (public) hexo g -d # 文件生成后立即部署网站 写完文章后，你可以使用 hexo g # 全称hexo generate , 生成静态文件（generate：产生） hexo s # 全称hexo server , 启动服务器，默认情况下，访问网址为http://localhost:4000/在本地预览效果 hexo d # 全称hexo deploy, 部署网站，同步到github上（deploy：部署） 2. 分类和标签 Front-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说： 12title: Hello Worlddate: 2013/7/13 20:46:25 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 分类和标签 只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 123456categories:- Diarytags:- PS3- Games# 会使分类Games成为PS3的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类]]></content>
      <categories>
        <category>hexo</category>
        <category>基本操作</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>写作常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试经典题目（1-5题）]]></title>
    <url>%2F2019%2F03%2F07%2Fjava%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE(1-5%E9%A2%98)%2F</url>
    <content type="text"><![CDATA[1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？答案： 运行原理：java源程序经过javac 编译器编译成二进制的xx.class 字节码文件, xx.class 在jvm（各平台装有不同的jvm）上运行，java解释器（jvm的一部分）会将相同的字节码解释成对应平台的机器码，进而执行。 知识： 一份 xx.class 文件(不会变化）被 不同的jvm 解释成 相对应的机器码 机器码: 依附于硬件，根本不存在跨平台行，不同型号的CPU给相同的指令（eg：10011110）,解析成不同的结果 题外知识： JDK (Java Development Kit): Java开发工具包，针对于Java开发员的产品，JDK是整个Java的核心，包括了JRE, Java工具（javac【编译java源码的编译器】，java程序调试和分析的工具）和Java基础的类库（即Java API) JRE (Java runtime environment)：Java运行环境 ,针对于使用Java程序的用户，java程序运行做需要的软件环境，不是一个开发环境, 包含jvm，java基础类库, 不包含任何开发工具（如编译器和调试器）。 JVM (Java Virtual Machine): Java虚拟机，实现java跨平台的最核心的部分，JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行 2. JDK和JRE的区别是什么？答案： 详细区别见第一题 如果需要运行Java程序，只需要安装JRE（JRE根据不同操作系统有很多不同的版本） 如果需要编写Java程序，需要安装JDK 补充知识： JRE和JVM的区别是什么？ JRE包括JVM和lib（Jvm所需要的类库），JRE里有运行xx.class 的java.exe 只有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库 时间：2019.3.7 3. ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？答案: static 表示静态的意思, 可用于修饰 成员变量和 方法 , 静态是随着类的加载而加载, 因此可以直接用类进行访问 private私有的方法不能被继承，子类就没有访问权限 覆盖 覆盖基于运动时动态绑定的 指覆盖了一个方法并且对其重写，以求达到不同的作用,，但是子类中的访问权限要不低于父类中的访问权限,重写的前提是必须要继承. Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。 私有的方法不能被继承，子类就没有访问权限，肯定也是不能别覆盖的。 12345678910111213141516171819202122232425262728class Super&#123; // 静态方法 static String greeting()&#123; return "Good night"; &#125; String name()&#123; return "Richard"; &#125; &#125; class Sub extends Super&#123; //子方法,继承Super //重写(覆盖)父类当中的静态方法 static String greeting()&#123; return "Hello"; &#125; String name()&#123; return "Dick"; &#125; &#125;class Test&#123; public static void main(String[] args)&#123; Super s = new Sub(); System.out.println(s.greeting()+","+s.name()); &#125; &#125;//运行结果：Good night,Dick (静态方法打印的是父类中的)//这个例子说明“实例方法被覆盖，静态方法被隐藏” 4. 是否可以在static环境中访问非static变量？答案: 不可以 因为静态的成员属于类，随着类的加载而加载到静态方法区内存，当类加载时，此时不一定有实例创建，没有实例，就不可以访问非静态的成员。 静态变量属于类变量，随着类的加载而加载，当调用类变量时java虚拟机会对类的静态变量，静态方法进行初始化，此时如果静态方法中有非静态变量，由于非静态变量是随着实例的创建而创建，此时还没有实例创建，所以非静态变量还没有创建，所以会出现编译错误。 参考博文:​ 牛客网优质答案 时间: 2019.3.11 5. Java支持的数据类型有哪些？什么是自动拆装箱？答案: 基本数据类型 整数型: byte, short, int, long, 浮动型: float, double 布尔型: bool 字符型: char 整数默认int型，小数默认是double型。Float和long类型的必须加后缀。 引用类型 引用类型也就是我们常说的对象，在java中每个基础类型的数据都有其包装类，对应上面分别是：Byte, Short, Int, Long, Float, Double, Char, Boolean 引用类型包括类、数组、接口, String等 自动装箱和拆箱就是基本类型和引用类型之间的转换 装箱：将基本类型转换成引用类型，如 Integer i = 10; 拆箱：将引用类型转换成基础类型，如 Integer i = 10; int j = i; 转化为引用类型之后，就可以new一个对象，从而就可以调用包装类型中的封装好的方法，方便使用 参考博客​ 牛客网优质答案 时间: 2019.3.12]]></content>
      <categories>
        <category>java面试经典题目</category>
      </categories>
      <tags>
        <tag>java面试经典题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间词话---文章]]></title>
    <url>%2F2019%2F03%2F06%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[感谢困难​ 林清玄​ 我做了一个梦。 梦见我在街上问人：“请问您可不可以给我一些困难、一些挫折，一些痛苦?” 所有的人都拒绝我，我着急地恳求别人：“那么，我雇用您，每小时五百元，请您给我一些折磨!” 那些陌生人摇摇头，沉默地离开，我因找不到愿意折磨我的人而惊醒。 我坐在床上发呆，是呀!困难，折磨，痛苦是多么珍贵!如果一切平顺，谁会静下来沉思，谁会生起智慧，谁又能在平凡安逸的日子中超越自我、登上高峰呢? 如果没有困难，谁又会谦卑地跪下来祈祷?谁又能相信有无边的宇宙?谁又能寄情于来生呢? 我深深地感谢着困难、挫折与痛苦。 也深深地感恩那些曾经折磨过我的人，他们是多么慈悲呀!我并未花钱聘雇他们，他们却以宝贵的时间来考验我、提升我，为了增长我的智慧。 真正的高贵​ 海明威 ​ 在风平浪静的大海，每个人都是领航员。 ​ 但是，只有阳光而无阴影，只有欢乐而无痛苦，那就不是人生。以最幸福的人的生活为例.他的生活也是一团缠结在一起的乱麻。痛苦与幸福交替出现,使得我们一会悲伤，一会高兴，甚至死亡本身也会使生命更加可爱。在人生的清醒的时刻，在悲伤与失落的阴影之下，人们与真实的自我最接近。 ​ 在生活和事业的种种事物中，性格比才智更能指导我们, 心灵比头脑更能引导我们,而由判断获得的克制, 耐心和教养比天分更能让我们受益。 ​ 我始终相信，内心生活开始更为严谨的人，他的外在生活也会变得更为简朴。在一个物欲横流的年代，但愿我能向世人表明，人类真正需求少得多么可怜。 ​ 反思自己的过错不至于重蹈覆辙才是真正的悔悟, 高人一等并没有什么值得夸耀的。真正的高贵是优于过去的自己。]]></content>
      <tags>
        <tag>人间词话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间词话---惊艳的文字]]></title>
    <url>%2F2019%2F03%2F06%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E6%83%8A%E8%89%B3%E7%9A%84%E6%96%87%E5%AD%97%2F</url>
    <content type="text"><![CDATA[现代诗 酒入豪肠，七分酿成了月光，余下的三分啸成剑气，绣口一吐，就半个盛唐。 —余光中《寻李白》 古诗 少年不知愁滋味,爱上层楼,爱上层楼.为赋新词强说愁.而今识尽愁滋味,欲说还休,欲说还休,却道天凉好个秋. —辛弃疾《丑奴儿》 十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。料得年年肠断处，明月夜，短松冈。 —苏轼 古文 斯是陋室,惟吾德馨. —刘禹锡《陋室铭》 夏虫不可语冰 —孔子 文章摘要 我知道我很大胆冒昧, 听说你朋友很多, 我不配高攀, 可是很想在你的朋友里凑个数目. —钱钟书《围城》 别客气,我求你明天来.我想去吃,对自己没有好借口,借你的名义,自己享受一下,你就体贴下情,答应了吧. —钱钟书《围城》]]></content>
      <tags>
        <tag>人间词话</tag>
        <tag>现代诗</tag>
        <tag>古诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常见简写]]></title>
    <url>%2F2019%2F02%2F28%2FJava%E5%B8%B8%E8%A7%81%E7%AE%80%E5%86%99%2F</url>
    <content type="text"><![CDATA[ORM Object Relational Mapping 对象关系映射 对象和关系数据库的映射简单说，一个对象，对应数据库里的一条记录 DAOData Access Object的缩写，这些类专门用于进行数据库访问的操作]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曾仕强教授语录]]></title>
    <url>%2F2019%2F01%2F10%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E6%88%91%E6%88%90%E9%95%BF---%E6%9B%BE%E4%BB%95%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[很多事情，从不同的角度看，才能体会到其中的奥妙 做一个领导者，一定要充分了解下属的特性是什么，及时的下达合理的命令，而且效果要非常的良好，此为将才 事事都透露着一个人的能力 顾全大局，大局的前提底下，很多细小的事情，不用太过于考虑 一件事，从不同的角度看，都有道理，怎么讲都对，不是对不对的事，是价值观的体现 得意勿忘形，人在得意时，千万不能忘形，做事情随他爱怎样怎样，变为得意忘形，当一个人处于逆境的时候，他还会谨慎一点，当一个人处顺境的时候，他就开始沉不住气 形势比人强 人生的理想在于不断提升自己的层次 有智慧没知识容易陷入空想，一事无成。有知识没智慧，就不要埋怨被人当做工具使用，用毕即弃。要善用智慧来运用知识，以求合理的表现 处逆境容易，正因留意，处顺境很难，正因大意 你要很谨慎地去保留你独特的地方，这个独特之处就是你之所以为人的地方。能够自我成全，才是人最伟大的地方]]></content>
      <categories>
        <category>感悟</category>
        <category>曾仕强教授</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>人生方向</tag>
        <tag>智慧</tag>
        <tag>成长</tag>
      </tags>
  </entry>
</search>
