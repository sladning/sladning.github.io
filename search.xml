<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构---图]]></title>
    <url>%2F2019%2F04%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[一. 图的定义图 (Graph) 是图形结构的简称，它是一种复杂的非线性数据结构，一个图 G 是由两个集合 V(G)和 E(G) 组成的 , 1. 图的二元组定义 : G(V,E) G表示一个图 V是图G中的 顶点的集合 E是图G中 边的集合 顶点(Vertex) : 图中的数据元素 (线性表中我们把数据元素叫元素，树中将数据元素叫结点) 边(Edge) : 顶点之间的逻辑关系用边来表示，边集可以是空的 2. 无向图 (如图G2) 无向边(Edge)：顶点V1到V2之间的边没有方向，则称这条边为无向边。 无向图(Undirected graphs)：图中任意两个顶点之间的边都是无向边。(V1, V2) = (V2, V1) 范例:对于无向图G2来说，G2 = (V, E) 顶点集合 V = { V1, V2, V3, V4 } 边集合 E = { (V1, V2), (V1, V4), (V2, V5), (V2, V3), (V3, V4), (V3, V5) } 3. 有向图 (如图G1)有向边 : 若从顶点 V1 到 V2 的边有方向，则称这条边为有向边，也称弧(Arc)。用 &lt;V1,V2&gt; 表示，V1 为弧尾(Tail)，V2 为弧头 (Head).&lt;V1，V2&gt; ≠ &lt;V2，V1&gt; 有向图(Directed graphs) : 图中任意两个顶点之间的边都是有向边 注意：无向边用“()”，而有向边用“&lt; &gt;”表示。 图的示例 二. 图的基本术语1. 端点和邻接点无向图中若存在一条边 (V~i~ , V~j~) ,则称 V~i~ 和 V~j~ 为此边的两个端点,并称为顶点 V~i~ 和 V~j~ 互为邻接点 有向图中若存在一条有向边 &lt;V~i~ , V~j~&gt; , 称此边是顶点 V~i~ 的一条出边 , 顶点 V~j~ 的一条入边 称 V~i~ 为此边的起点, 称 V~j~ 为此边的终点 V~i~ 是 V~j~ 的出边邻接点, 点 V~j~ 是 V~i~ 的入边邻接点, V~i~ 和 V~j~ 互为邻接点 2. 顶点的度, 入度和出度无向图中与顶点 V 相邻的边数称为该顶点的 度 , 记为 D(v) 图 G2 中, V3 的度为 3 有向图中 入度 : 与顶点 V 为终点的弧的数目 称为顶点 V 的入度 出度 : 与顶点 V 为起点的弧的数目 称为顶点 V 的入度 度 : 入度和出度的和 图 G1 中, V1的入度为1, 出度为2, 度为3 3. 完全图, 稠密图和稀疏图无向完全图：无向图中，任意两个顶点之间都存在边。 有向完全图：有向图中，任意两个顶点之间都存在方向互为相反的两条弧。 稀疏图：有很少条边 稠密图：有很多条边, 接近完全图 4. 子图(Subgraph)假设 G = (V,{E}) 和 G‘ = (V’,{E’}) , 如果 V’ 包含于 V 且 E’ 包含于 E ，则称G’为G的子图 5. 路径, 回路和路径长度如果G是有向图, 则路径也是有向的 路径长度 : 一条路径上所经过的边或弧的数目 回路(环) : 第一个顶点和最后一个顶点 相同 的路径 6. 连通, 连通分量和连通图在无向图中连通 : 如果从顶点 A 到顶点 B 有路径 连通图 : 图中任意两个顶点都是连通的 连通分量：无向图中的极大连通子图。(子图必须是连通的且含有极大顶点数)。图1有两个连通分量 7. 带权图和网权(Weight) : 与图的边或弧相关的数 网 : 每条边都带权的图称为带权图或网 三. 图的存储结构1. 邻接矩阵用两个数组 一个一维数组存储图中顶点信息 一个二维数组（称为邻接矩阵）存储图中的边或弧的信息 无向图 有向图 有向网图邻接矩阵 2. 邻接表​ 对于边数相对顶点较少的图，邻接矩阵是存在对存储空间的极大浪费的，特别是稀疏有向图。所以可以考虑用链表来按需存储。 邻接表 : 数组与链表相结合的存储方法 无向图有向图则类似 带权图 四. 图的遍历​ 从任意指定的某个顶点 (称此为初始点) 出发，按照一定的搜索方法 依次访问图中所有顶点，且每个顶点仅被访问一次 根据搜索路径不同, 图的遍历方法有两种 深度优先搜索遍历 (DFS) 广度优先搜索遍历 (BFS) 这两种方法对无向图和有向图都适用 1. 深度优先遍历 (DFS)类似于树的先序遍历, 是树的先序遍历的推广 首先访问初始出发点 V0，并将其标记设置为已访问 然后任选一个与 V0 邻接，且没有被访问的邻接点 V1 作为新的出发点，访问 V1 之后，将其标记设置为已访问 再以 V1 为新的出发点, 继续进行深度优先搜索 重复上述过程，若遇到一个所有邻接点均未被访问过的节点，则回到以访问节点序列中，最后一个还没有被访问的邻接点的顶点, 再从该顶点出发继续进行深度优先搜索，直到图中的所有顶点都被访问过，搜索结束 1. 深度优先遍历 (DFS)类似于树的层次遍历, 是树的层次遍历的推广 参考文章​ 数据结构 — 严蔚敏 ​ 数据结构 — 田鲁怀 ​ 数据结构-图-知识点总结 ​ 数据结构——图]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构---二叉树的遍历]]></title>
    <url>%2F2019%2F04%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E5%89%8D%E5%BA%8F%2C%E4%B8%AD%E5%BA%8F%2C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86(%E9%80%92%E5%BD%92%2C%E9%9D%9E%E9%80%92%E5%BD%92)%2F</url>
    <content type="text"><![CDATA[一. 遍历的概念按一定的次序 “访问“ 二叉树的 所有结点 , 并且每个结点只访问一次 根据二叉树的递归定义可知，一棵非空二叉树是由 根结点左子树和右子树 这三个部分组成的, 因此遍历一棵非空二叉树的问题，就可以分解为三项子任务 访问根结点 遍历左子树 (即依次访问左子树上的全部结点) 遍历右子树 (即依次访问右子树上的全部结点) 二叉树的遍历分为 前序遍历, 中序遍历, 后序遍历, 层级遍历 例图(后边结果均为此图的结果) 代码测试### 12// 输入检测ABD**E**CF**G** 创建二叉树12345678910111213141516171819202122// 先序创建树 void CreatTree(PTREE *Root) &#123; char val = 0; // 用于下面存放数据 val = getchar(); // 输入数据值 // 如果输入'*'，则指向为空 if (val == '*') (*Root) = NULL; // 如果输入非'*'，则给数据域赋值 else &#123; (*Root) = (PTREE)malloc(sizeof(TREE)); // 申请内存空间 if ((*Root) == NULL) &#123; printf("创建结点失败，无法分配可用内存..."); exit(-1); &#125; else &#123; (*Root)-&gt;Element = val; // 给结点数据域赋值 CreatTree(&amp;(*Root)-&gt;left); CreatTree(&amp;(*Root)-&gt;right); &#125; &#125; &#125; 1. 前序遍历前序遍历的顺序是：根结点 -&gt; 左子结点 -&gt; 右子结点 遍历结果 : ABDECFG 1234567891011// 树的前序遍历void PreOrderTree(PTREE Root) &#123; if (Root == NULL) return; else &#123; putchar(Root-&gt;Element); PreOrderTree(Root-&gt;left); PreOrderTree(Root-&gt;right); &#125;&#125; 2. 中序遍历中序遍历的顺序是： 左子结点 -&gt; 根结点 -&gt; 右子结点 遍历结果 : DBEAFCG 1234567891011// 树的中序遍历void InOrderTree(PTREE Root) &#123; if (Root == NULL) return; else &#123; InOrderTree(Root-&gt;left); putchar(Root-&gt;Element); InOrderTree(Root-&gt;right); &#125;&#125; 3. 后序遍历后续遍历的顺序为： 左子结点 -&gt; 右子结点 -&gt; 根结点 遍历结果 : DEBFGCA 1234567891011// 树的后序遍历void PostOrderTree(PTREE Root) &#123; if (Root==NULL) return ; else&#123; PostOrderTree(Root-&gt;left); PostOrderTree(Root-&gt;right); putchar( Root-&gt;Element); &#125;&#125; 4. 打印树的叶子结点12345678910111213// 打印树的叶子结点void LeafOfTree(PTREE Tree) &#123; if (Tree == NULL) &#123; return ; &#125; else &#123; if (Tree-&gt;left == NULL &amp;&amp; Tree-&gt;right == NULL) putchar(Tree-&gt;Element); else &#123; LeafOfTree(Tree-&gt;left); LeafOfTree(Tree-&gt;right); &#125; &#125;&#125; 5. 获取树的叶子结点个数123456789// 获取树的叶子结点个数int Get_Leaf_Num(PTREE Tree) &#123; if (Tree == NULL) return 0; if (Tree-&gt;left == NULL &amp;&amp; Tree-&gt;right == NULL) return 1; // 递归整个树的叶子结点个数 = 左子树叶子结点的个数 + 右子树叶子结点的个数 return Get_Leaf_Num(Tree-&gt;left) + Get_Leaf_Num(Tree-&gt;right);&#125; 6. 获取树高的函数1234567891011121314// 获取树高的函数int Get_Height(PTREE Tree) &#123; int Height = 0; if (Tree == NULL) return 0; //树的高度 = max(左子树的高度，右子树的高度) + 1 else &#123; int L_Height = Get_Height(Tree-&gt;left); int R_Height = Get_Height(Tree-&gt;right); Height = L_Height &gt;= R_Height ? L_Height + 1 : R_Height + 1; &#125; return Height;&#125; 7. 层级遍历层级遍历就是按照层次的顺序，从上往下一层一层遍历二叉树 递归实现为了能够逐层遍历二叉树，必须知道二叉树的高度，然后才能逐层遍历。而在每一层中，先遍历根结点的左子结点，再遍历右子结点 12345678910111213141516171819202122232425// 从左向右打印一层的结点 void PrintLevel (PTREE Root, int level) &#123; if (Root == NULL) return; if (level == 1) &#123; // 打印结点的值 putchar( Root-&gt;Element); return; &#125; // 先遍历根节点的左子结点 PrintLevel(Root-&gt;left, level-1); // 再遍历右子结点 PrintLevel( Root-&gt;right, level-1);&#125; // 层级遍历void LevelTraverseRec(PTREE Root) &#123; // 获取树的高度 int height = Get_Height(Root); // 从第一层遍历到最后一层 for (int i = 1; i &lt;= height; ++i) &#123; PrintLevel (Root, i); &#125; &#125; 7. 代码测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include&lt;stdlib.h&gt;typedef char Elementtype; // 定义数据类型，可根据需要自行定制typedef struct TreeNode * Node; // Node相当于struct treeNode *// 定义树结点结构typedef struct TreeNode &#123; Elementtype Element; Node left; // 树结点的左子结点 Node right; // 树结点的右子结点&#125; TREE, *PTREE;// 先序创建树 void CreatTree(PTREE *Root) &#123; char val = 0; // 用于下面存放数据 val = getchar(); // 输入数据值 // 如果输入'*'，则指向为空 if (val == '*') (*Root) = NULL; // 如果输入非'*'，则给数据域赋值 else &#123; (*Root) = (PTREE)malloc(sizeof(TREE)); // 申请内存空间 if ((*Root) == NULL) &#123; printf("创建结点失败，无法分配可用内存..."); exit(-1); &#125; else &#123; (*Root)-&gt;Element = val; // 给结点数据域赋值 CreatTree(&amp;(*Root)-&gt;left); CreatTree(&amp;(*Root)-&gt;right); &#125; &#125;&#125;// 树的前序遍历void PreOrderTree(PTREE Root) &#123; if (Root == NULL) return; else &#123; putchar(Root-&gt;Element); PreOrderTree(Root-&gt;left); PreOrderTree(Root-&gt;right); &#125;&#125;// 树的中序遍历void InOrderTree(PTREE Root) &#123; if (Root == NULL) return; else &#123; InOrderTree(Root-&gt;left); putchar(Root-&gt;Element); InOrderTree(Root-&gt;right); &#125;&#125;// 树的后序遍历void PostOrderTree(PTREE Root) &#123; if (Root==NULL) return ; else&#123; PostOrderTree(Root-&gt;left); PostOrderTree(Root-&gt;right); putchar( Root-&gt;Element); &#125;&#125;// 打印树的叶子结点void LeafOfTree(PTREE Tree) &#123; if (Tree == NULL) &#123; return ; &#125; else &#123; if (Tree-&gt;left == NULL &amp;&amp; Tree-&gt;right == NULL) putchar(Tree-&gt;Element); else &#123; LeafOfTree(Tree-&gt;left); LeafOfTree(Tree-&gt;right); &#125; &#125;&#125;// 获取树的叶子结点个数int Get_Leaf_Num(PTREE Tree) &#123; if (Tree == NULL) return 0; if (Tree-&gt;left == NULL &amp;&amp; Tree-&gt;right == NULL) return 1; // 递归整个树的叶子结点个数 = 左子树叶子结点的个数 + 右子树叶子结点的个数 return Get_Leaf_Num(Tree-&gt;left) + Get_Leaf_Num(Tree-&gt;right);&#125;// 获取树高的函数int Get_Height(PTREE Tree) &#123; int Height = 0; if (Tree == NULL) return 0; //树的高度 = max(左子树的高度，右子树的高度) + 1 else &#123; int L_Height = Get_Height(Tree-&gt;left); int R_Height = Get_Height(Tree-&gt;right); if (L_Height &gt;= R_Height) Height = L_Height + 1; else Height = R_Height + 1; &#125; return Height;&#125;// 从左向右打印一层的结点 void PrintLevel (PTREE Root, int level) &#123; if (Root == NULL) return; if (level == 1) &#123; // 打印结点的值 putchar( Root-&gt;Element); return; &#125; // 先遍历根节点的左子结点 PrintLevel(Root-&gt;left, level-1); // 再遍历右子结点 PrintLevel( Root-&gt;right, level-1);&#125; // 层级遍历void LevelTraverseRec(PTREE Root) &#123; // 获取树的高度 int height = Get_Height(Root); // 从第一层遍历到最后一层 for (int i = 1; i &lt;= height; ++i) &#123; PrintLevel (Root, i); &#125; &#125;// 主函数测试 int main() &#123; // 输入一: ABD***CE**FG*** // 输入二: ABD**E**CF**G** PTREE Root; printf("请先序输入二叉树的结点数据： "); CreatTree(&amp;Root); printf("\n前序遍历结果为："); PreOrderTree(Root); printf("\n中序遍历结果为："); InOrderTree(Root); printf("\n后序遍历结果为："); PostOrderTree(Root); int height = Get_Height(Root); printf("\n二叉树的高度为：%d", height); printf("\n层级遍历结果为："); LevelTraverseRec(Root); printf("\n打印叶子结点为："); LeafOfTree(Root); printf("\n叶子结点个数为：%d", Get_Leaf_Num(Root)); printf("\n"); return 0;&#125; 打印结果 参考文章​ C语言描述二叉树的实现及操作（链表实现）]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这时候你才算长大]]></title>
    <url>%2F2019%2F04%2F10%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%BF%99%E6%97%B6%E5%80%99%E4%BD%A0%E6%89%8D%E7%AE%97%E9%95%BF%E5%A4%A7%2F</url>
    <content type="text"><![CDATA[人总是要生病的。​ 躺在床上，不要说头疼、浑身都疼，翻过来覆过去怎么躺都不舒服，连满嘴的牙都跟着一起疼；舌苔白厚、不思茶饭、没有胃口；高烧烧得天昏地暗、眼冒金星、满嘴燎泡、浑身没劲儿……你甚至觉得这样活简直不如死去。 ​ 这时你先想起的是母亲。你想起小时候生病的光景，母亲的手摩挲着你滚烫的额头，你浑身的不适、一切的病痛似乎都消失了。好像你不管生什么大病，也不曾像现在这样的难熬：因为有母亲在替你扛着病痛；不管你的病后来是怎么好的，你最后记住的不过是日日夜夜守护着你生命的母亲，和母亲那双生着老茧、在你额头上一下一下摩挲的手掌。 ​ 你也不由得想起母亲给你做过的那碗热汤面。后来，你长大了，有了出息，山珍海味已成了你餐桌上的家常菜，你很少再想起那碗面。可是等到你重病在身，茕茕孑立、形影相吊的时候，你觉得母亲做的那碗面不过是放了一把菠菜、一把黄豆芽、打了一个蛋花的热汤面，却是你这一辈子吃过的最美的美味。 ​ 于是你不自觉地向上仰起额头，似乎母亲的手掌即刻会像你小时那样，摩挲过你的额头；你费劲地往干涸、急需浸润的喉咙里咽下一口难成气候的唾液。此时此刻你最想吃的，可不就是母亲做的那碗热汤面。 ​ 可是，母亲已经不在了。 ​ 你转而想念情人，盼望此时此刻他能将你搂在怀里，让他的温存和爱抚将你的病痛消解。他曾经如此爱你，当你什么也不缺、什么也不需要的时候，指天画地、海誓山盟、柔情蜜意、难舍难分，要星星不给你摘月亮。可你真是病倒无法再为他制造欢爱的时候，不要说是摘星星或月亮，即使设法为你换换口味也不曾做。你当然舍不得让他为你做碗羹汤，可他爱了你半天总该记得一个你特别爱吃、价钱也不贵的小菜，在满大街的饭馆里买一个似乎也并不困难。可是你的企盼落了空，不要说一个小菜，就是为你烧白开水也是不可能的。你想退而求其次：什么都不说，打个电话也行。电话就在他的身边，不过举手之劳。可连个电话也没有，当初每天一个乃至几个、一打就是一个小时不止的电话现在可不就是一场梦？ ​ 最后你明白了你其实没人可以指望，你一旦明白这一点，反倒不再流泪，而是豁达一笑。于是你不再空想母亲的热汤面，也不再期待情人的怀抱，并且坚决地关闭了电话。你心闲气定地望着被罩上太阳的影子从东往西渐渐地移动，在太阳的影子里，独自慢慢地消融着这份病痛。 ​ 你最终能够挣扎起来，摇摇晃晃地走到自来水龙头底下接杯凉水，喝得咕咚咕咚响，味美竟如在五星级饭店喝矿泉水一样。你惊奇地注视着这杯凉水，发现它一样可以解渴。 ​ 等你饿急了，还会在冰箱里搜出一块干面包，没有果酱也没有黄油，照样把它吃下去。 ​ 当你默数过太阳的影子在被罩上从东向西地移动了一遍又一遍的时候，你抗过了这场病，以及后来的许多场病。于是你发现，一个人关在屋子里生病，不但没有什么悲惨，相反感觉也许不错。 ​ 自此以后，你再不怕面对自己上街、自己下馆子、自己乐、自己笑、自己哭、自己应付天塌地陷的难题……这时你才尝到从必然王国飞跃到自由王国的乐趣，你会感到“天马行空，独往独来”比和另一个人什么都绑在一起更好。 ​ 这时候你才算真正地长大，虽然这时你可能已经70岁了。 ​ 《这时候你才算长大》张洁]]></content>
      <categories>
        <category>人间词话</category>
      </categories>
      <tags>
        <tag>人间词话</tag>
        <tag>送给自己</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构---树]]></title>
    <url>%2F2019%2F04%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%A0%91%2F</url>
    <content type="text"><![CDATA[一. 基本概念​ 树是 树型结构 的简称，是一种非常重要的非线性数据结构，它可以很好的描述，客观世界中广泛存在的具有分支关系或层次特性的对象 应用 操作系统中的文件管理 数据库系统中的信息组织形式 行政组织机构 人类社会的族谱 1. 树的定义树是一种非线性的数据结构，是由n（n &gt;=0）个结点组成的有限集合。 如果 n=0 ，树为 空树。 如果 n&gt;0 ，树为 非空树 有且仅有一个特定的结点，称为 根结点（根结点只有直接后继，没有直接前驱） 除根结点以外的其余结点，可分为 m （m&gt;=0) 个互不相交的有限集T1, T2, … Tm, 其中每个集合本身又是一棵树并称为根的子树 2. 树的基本术语1) 结点的度 和 树的度树的结点包含 一个数据 和 多个指向子树的分支 结点的度 : 结点拥有的子树的数量 (度为0的结点是叶结点, 度不为0的结点为分支结点) 树的度 : 树的所有结点的度的最大值 该树的度为3 2) 叶子结点和分支结点 叶子结点(终端结点) : 度为 0 的结点 分支结点(非终端结点) : 度不为 0 的结点 3) 双亲结点, 孩子结点, 兄弟结点树中的每个结点的子树的根 称为该结点的孩子，该结点称为 孩子结点的双亲 同一个双亲的孩子之间互称兄弟 4) 结点的层数和树的高度结点的层数 : 结点的层次从根开始定义, 根为第1层，根的孩子为第2层 树的深度 (高度) : 树中结点的最大层次 5) 堂兄弟双亲在同一层的结点互称堂兄弟 如 5 中的 F 与G, H, I, J 互为 堂兄弟 6) 有序树和无序树 有序树 : 树中结点的各子树从左到右是有次序的，且相对次序不能变 无序树 : 非有序树 7) 森林由 n 棵 互不相交 的树组成的集合 三棵树组成的森林如下: 二. 二叉树1. 二叉树简介​ 二叉树是由n（n&gt;=0）个结点组成的有序集合，集合或者为空，或者是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。 二叉树的五种形态： 2. 特殊形态的二叉树1) 满二叉树在一棵二叉树中，若所有的分支结点都有左孩子和右孩子，并且叶结点的层数都等于树的深度，这样的二叉树称为满二叉树 若满二叉树的深度为 k, 则叶结点有 2^k-1^ 个(所有结点总数的一半), 树中的结点总数为 2^k^ - 1 个 2) 完全二叉树在一棵二叉树中除最后一层外，其余各层都是满的，而最后一层或者是满的，或者是最右边缺少若干个连续的结点 特点 叶子结点只可能出现在最大的两层上， 若完全二叉树某结点没有左孩子，则他一定没有右孩子 满二叉树是完全二叉树的一种特例, 并且完全二叉树与深度相同的满二叉树对应的位置的结点有相同的编号 图解 3. 二叉树的基本性质 在二叉树的第 i 层上最多有 2^(i-1)^ 个 结点（i &gt;= 1） 高度为 k 的二叉树，最多有 2^k^ - 1 个 结点（k&gt;=0） 对任何一棵二叉树，如果其叶结点有 n 个，度为 2 的非叶子结点有 m 个，则 n = m + 1 具有 n 个结点的完全二叉树的高度为 「log~2~n」 + 1 对于有n个结点的完全二叉树，按层次对结点进行编号（从上到下，从左到右），对于任意编号为i的结点 4. 二叉树的存储结构二叉树常用的存储方法有两种 顺序存储结构 链式存储结构 1) 顺序存储结构方法把二叉树的所有结点按照一定的次序顺序放到一组地址连续的存储单元中，适当安排好二叉树中所有结点的存放次序, 使结点在这种存放数据中相互位置能反映出结点的逻辑关系 a. 完全二叉树顺序存储结构 b. 普通二叉树顺序存储结构 2) 链式存储结构 二叉树的链接存储结构是用一个链表来存储一棵二叉树的所有结点 二叉树的每个结点都用链表的一个链结点来存储 二叉树的结点结构链表中的每个链结点应有三个域: 数据域, 左孩子指针域, 右孩子指针域 当结点某个孩子为空时，相应的指针为空指针 二叉树的链式存储结构root 是指向二叉树根结点,简称为 根结点 作为二叉链表的头指针 若二叉树为空数，root = NULL 若结点的某个孩子不存在, 则相应的指针为空. 参考文章​ 数据结构（十三）——树 ​ 数据结构 — 严蔚敏 ​ 数据结构 — 田鲁怀]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构---队列]]></title>
    <url>%2F2019%2F04%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[一. 队列的定义​ 队列简称队 , 也是一种运算受限的线性表，其限定是只允许在线性表的一端进行插入运算，而在另一端进行删除运算 又称先进先出 (First In First Out, FIFO )的线性表 概念 队头 : 允许进行删除的一端 队尾 : 允许插入的一端 进队(入队) : 在队列中插入一个新元素的操作 出队(离队) : 从队列中删除一个元素的操作 空队列 : 队列中没有元素 例子 排队买火车票 排队买饭 基本操作 初始化队: initQueue() 检查队是否为空队 : isEmpty() 进队: enQueue() 出队: deQueue() 取队头元素: front() 二. 数组实现队列队列使用 front 和 rear 分别队列第一个元素和最后一个元素的位置 普通队列 入队出队操作 入队时，通过rear的位置判断队列是否已满。如果没有满，则将rear后移一位，将新元素放置在rear所在位置 出队时，也可以通过rear的位置判断队列是否为空。如果不空，则只需将front后移一位即可获取队头元素，判断队列不空，则只需返回front指向位置的元素即可 通过出队操作将数据弹出队列后，front之前的空间还能够再次得到吗？ 不能。所以使用普通数组实现队列，就再也不能使用front之前的空间了，这会导致大量空间丢失 循环数组为了解决这个问题，将普通数组换成循环数组。在循环数组中，末尾元素的下一个元素不是数组外，而是数组的头元素。这样就能够再次使用front之前的存储空间了。 图解 在实现修改入队和出队操作之前，再深思一步，这时是否还能简单通过判断rear的位置来判断队列空或满呢？ 当然不可以。那是否可以考虑front和rear之间的位置关系呢？考虑如下两种边界情况： 在数组中空出一个位置，用以标记队列是否已满 利用循环队列的取余的麽运算可以是循环队列的运算更加简介 1234// 队尾指针加1的操作q-&gt;rear = (q-&gt;rear + 1) % SIZE;// 队头指针加1的操作q-&gt;front = (q-&gt;front + 1) % SIZE; 准备123456789#define SIZE 6 // 循环队列,存入的元素为 SIZE - 1 // 队列数组结构typedef struct Queue&#123; int arr[SIZE]; // 队列的大小 int front; // 队头指针 int rear; // 队尾指针 &#125; Queue; 1. 入队1234567891011121314151617// 入队 void enQueue(Queue *q, int val) &#123; printf("入栈元素为: %d\n", val); // 如果队列满,则无法入队 if(IsFull(q)) &#123; printf("队列已满,入队失败!\n"); return; &#125; // 赋值 q-&gt;arr[q-&gt;rear] = val; // 队尾指针 +1, 因为是循环队列,所以取余判断 q-&gt;rear = (q-&gt;rear + 1) % SIZE; return; &#125; 2. 出队123456789101112131415161718// 出队 void deQueue(Queue *q) &#123; if (IsEmpty(q)) &#123; printf("队列为空,出队失败!\n"); return; &#125; // 获取出队元素的值 int val = q-&gt;arr[q-&gt;front]; printf("出队, 元素为: %d\n", val); // 清空后指针, 向前一动一个 int temp = q-&gt;front; q-&gt;front = (q-&gt;front + 1) % SIZE; temp = NULL; return; &#125; 3. 遍历队列1234567891011121314151617181920// 遍历队列void traverseQueue(Queue *q) &#123; printf("打印队列:\n"); // 临时指针,代替 front; int pTemp = q-&gt;front; if (IsEmpty(q)) &#123; printf("队列为空,无法打印!\n"); return; &#125; while (q-&gt;rear != pTemp) &#123; printf("%d ", q-&gt;arr[pTemp]); pTemp = (pTemp + 1) % SIZE; &#125; printf("\n-------------------------------------------------------\n"); return;&#125; 4. 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// 循环队列 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #define SIZE 6 // 循环队列,存入的元素为 SIZE - 1 // 队列数组结构typedef struct Queue&#123; int arr[SIZE]; // 队列的大小 int front; // 队头指针 int rear; // 队尾指针 &#125; Queue;// 初始化队列 Init(Queue *q) &#123; // 初始化队头,队尾指针 q-&gt;front = 0; q-&gt;rear = 0; printf("初始化队列!\n");&#125; // 队列是否已满 bool IsFull(Queue *q) &#123; // 队尾指针 + 1 (空出来的位置) == 队头指针 if ((q-&gt;rear + 1) % SIZE == q-&gt;front) return true; else return false; &#125;// 队列是否为空 bool IsEmpty(Queue *q) &#123; // 队尾指针 == 队头指针 if (q-&gt;rear == q-&gt;front) return true; else return false; &#125;// 入队 void enQueue(Queue *q, int val) &#123; printf("入栈元素为: %d\n", val); // 如果队列满,则无法入队 if(IsFull(q)) &#123; printf("队列已满,入队失败!\n"); return; &#125; // 赋值 q-&gt;arr[q-&gt;rear] = val; // 队尾指针 +1, 因为是循环队列,所以取余判断 q-&gt;rear = (q-&gt;rear + 1) % SIZE; return; &#125;// 遍历队列void traverseQueue(Queue *q) &#123; printf("打印队列:\n"); // 临时指针,代替 front; int pTemp = q-&gt;front; if (IsEmpty(q)) &#123; printf("队列为空,无法打印!\n"); return; &#125; while (q-&gt;rear != pTemp) &#123; printf("%d ", q-&gt;arr[pTemp]); pTemp = (pTemp + 1) % SIZE; &#125; printf("\n-------------------------------------------------------\n"); return;&#125;// 出队 void deQueue(Queue *q) &#123; if (IsEmpty(q)) &#123; printf("队列为空,出队失败!\n"); return; &#125; // 获取出队元素的值 int val = q-&gt;arr[q-&gt;front]; printf("出队, 元素为: %d\n", val); // 清空后指针, 向前一动一个 int temp = q-&gt;front; q-&gt;front = (q-&gt;front + 1) % SIZE; temp = NULL; return; &#125;// 主函数,测试 int main() &#123; Queue queue; // 初始化 Init(&amp;queue); // 入队 printf("\n"); enQueue(&amp;queue, 1); enQueue(&amp;queue, 2); enQueue(&amp;queue, 3); enQueue(&amp;queue, 4); enQueue(&amp;queue, 5); enQueue(&amp;queue, 6); // 遍历队列 printf("\n"); traverseQueue(&amp;queue); // 出队 printf("\n"); deQueue(&amp;queue); deQueue(&amp;queue); printf("\n"); traverseQueue(&amp;queue); return 0; &#125; 打印结果 三. 链表实现队列图解 准备1234567891011121314// 队列的单链表实现// 头结点：哨兵作用，不存放数据，用来初始化队列时使队头队尾指向的地方// 首结点：头结点后第一个结点，存放数据// 定义结点结构typedef struct Node &#123; Elementype Element; // 数据域 struct Node * Next;&#125;NODE, *PNODE;// 定义队列结构体typedef struct QNode &#123; PNODE Front, Rear; // 队列头，尾指针&#125; Queue, *PQueue; 1. 初始化队列1234567891011121314// 初始化队列 void InitQueue(PQueue queue) &#123; // 动态创建头结点，使队头，队尾指向该结点 queue-&gt;Front = queue-&gt;Rear = (PNODE)malloc(sizeof(NODE)); // 头结点相当于哨兵结点的作用，不存储数据（区别于首结点） if (queue-&gt;Front == NULL) &#123; // 判断内存是否分配成功 printf("创建队列，无法分配所需内存..."); exit(-1); &#125; queue-&gt;Front-&gt;Next = NULL; // 初始队列头结点指针指向为空 printf("初始化队列成功!\n");&#125; 2.入队12345678910111213141516// 入队,从队列尾部插入数据 valvoid enQueue(PQueue queue,int val) &#123; // 创建一个新结点用于存放插入的元素 PNODE P = (PNODE)malloc(sizeof(NODE)); if (P == NULL) &#123; printf("内存分配失败，无法插入数据%d...", val); exit(-1); &#125; P-&gt;Element = val; // 把要插入的数据放到结点数据域 P-&gt;Next = NULL; // 新结点指针指向为空 queue-&gt;Rear-&gt;Next = P; // 使上一个队列尾部的结点指针指向新建的结点 queue-&gt;Rear = P; // 更新队尾指针，使其指向队列最后的结点 printf("入队成功, 入队元素: %d\n", val);&#125; 3. 出队123456789101112131415161718192021// 出队, 从队列的首结点开始出队void deQueue(PQueue queue) &#123; if (IsEmptyQueue(queue)) &#123; printf("队列已经空，无法出队!\n"); return; &#125; PNODE P= queue-&gt;Front-&gt;Next; // 临时指针 int val = P-&gt;Element; // 保存其值 printf("出队成功, 出队元素: %d", val); queue-&gt;Front-&gt;Next = P-&gt;Next; // 更新头结点 // 没有看懂这一步 if (queue-&gt;Rear == P) queue-&gt;Rear = queue-&gt;Front; free(P); // 释放头队列 P = NULL; // 防止产生野指针&#125; 4. 遍历队列123456789101112131415// 遍历队列void TraverseQueue(PQueue queue) &#123; if (IsEmptyQueue(queue)) &#123; exit(-1); &#125; PNODE P = queue-&gt;Front-&gt;Next; // 从队列首结点开始遍历(非头结点，注意区分) printf("遍历队列结果为："); while (P != NULL) &#123; printf("%d ", P-&gt;Element); P = P-&gt;Next; &#125; printf("\n");&#125; 5. 删除整个队列，包括头结点1234567891011// 删除整个队列，包括头结点void DestroyQueue(PQueue queue) &#123; // 从头结点开始删除 while (queue-&gt;Front != NULL) &#123; queue-&gt;Rear = queue-&gt;Front-&gt;Next; free(queue-&gt;Front); queue-&gt;Front = queue-&gt;Rear; &#125; printf("摧毁队列成功!\n");&#125; 6. 清空队列(不包括头结点)1234567891011121314151617// 清空队列, 最后只剩下队头,队尾指针指向头结点,头结点没有删除void ClearQueue(PQueue queue) &#123; PNODE P = queue-&gt;Front-&gt;Next; // 临时指针 PNODE Q = NULL; // 临时指针 queue-&gt;Rear = queue-&gt;Front; // 使队尾指针指向头结点 // 使队头指针的 Next指向NULL queue-&gt;Front-&gt;Next = NULL; // 从首结点开始清空,利用 P和 Q 清理后向后移动 while (P != NULL) &#123; Q = P; P = P-&gt;Next; free(Q); &#125; printf("清空队列成功!\n");&#125; 7. 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178// 队列的单链表实现// 头结点：哨兵作用，不存放数据，用来初始化队列时使队头队尾指向的地方// 首结点：头结点后第一个结点，存放数据#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include&lt;stdlib.h&gt;typedef int Elementype; // 定义数据类型// 定义结点结构typedef struct Node &#123; Elementype Element; // 数据域 struct Node * Next;&#125;NODE, *PNODE;// 定义队列结构体typedef struct QNode &#123; PNODE Front, Rear; // 队列头，尾指针&#125; Queue, *PQueue;// 初始化队列 void InitQueue(PQueue queue) &#123; // 动态创建头结点，使队头，队尾指向该结点 queue-&gt;Front = queue-&gt;Rear = (PNODE)malloc(sizeof(NODE)); // 头结点相当于哨兵结点的作用，不存储数据（区别于首结点） if (queue-&gt;Front == NULL) &#123; // 判断内存是否分配成功 printf("创建队列，无法分配所需内存..."); exit(-1); &#125; queue-&gt;Front-&gt;Next = NULL; // 初始队列头结点指针指向为空 printf("初始化队列成功!\n");&#125;// 定义判断队列是否为空函数bool IsEmptyQueue(PQueue queue) &#123; // 如果队头 == 队尾,即为空 if (queue-&gt;Front == queue-&gt;Rear) &#123; printf("队列为空!\n"); return true; &#125; else &#123;// printf("队列不为空!\n"); return false; &#125; &#125;// 入队,从队列尾部插入数据 valvoid enQueue(PQueue queue,int val) &#123; // 创建一个新结点用于存放插入的元素 PNODE P = (PNODE)malloc(sizeof(NODE)); if (P == NULL) &#123; printf("内存分配失败，无法插入数据%d...", val); exit(-1); &#125; P-&gt;Element = val; // 把要插入的数据放到结点数据域 P-&gt;Next = NULL; // 新结点指针指向为空 queue-&gt;Rear-&gt;Next = P; // 使上一个队列尾部的结点指针指向新建的结点 queue-&gt;Rear = P; // 更新队尾指针，使其指向队列最后的结点 printf("入队成功, 入队元素: %d\n", val);&#125;// 出队, 从队列的首结点开始出队void deQueue(PQueue queue) &#123; if (IsEmptyQueue(queue)) &#123; printf("队列已经空，无法出队!\n"); return; &#125; PNODE P= queue-&gt;Front-&gt;Next; // 临时指针 int val = P-&gt;Element; // 保存其值 printf("出队成功, 出队元素: %d", val); queue-&gt;Front-&gt;Next = P-&gt;Next; // 更新头结点 // 没有看懂这一步 if (queue-&gt;Rear == P) queue-&gt;Rear = queue-&gt;Front; free(P); // 释放头队列 P = NULL; // 防止产生野指针&#125;// 遍历队列void TraverseQueue(PQueue queue) &#123; if (IsEmptyQueue(queue)) &#123; exit(-1); &#125; PNODE P = queue-&gt;Front-&gt;Next; // 从队列首结点开始遍历(非头结点，注意区分) printf("遍历队列结果为："); while (P != NULL) &#123; printf("%d ", P-&gt;Element); P = P-&gt;Next; &#125; printf("\n");&#125;// 删除整个队列，包括头结点void DestroyQueue(PQueue queue) &#123; // 从头结点开始删除 while (queue-&gt;Front != NULL) &#123; queue-&gt;Rear = queue-&gt;Front-&gt;Next; free(queue-&gt;Front); queue-&gt;Front = queue-&gt;Rear; &#125; printf("摧毁队列成功!\n");&#125;// 清空队列, 最后只剩下队头,队尾指针指向头结点,头结点没有删除void ClearQueue(PQueue queue) &#123; PNODE P = queue-&gt;Front-&gt;Next; // 临时指针 PNODE Q = NULL; // 临时指针 queue-&gt;Rear = queue-&gt;Front; // 使队尾指针指向头结点 // 使队头指针的 Next指向NULL queue-&gt;Front-&gt;Next = NULL; // 从首结点开始清空,利用 P和 Q 清理后向后移动 while (P != NULL) &#123; Q = P; P = P-&gt;Next; free(Q); &#125; printf("清空队列成功!\n");&#125;// 主函数int main() &#123; int val = 0; // 定义临时变量 Queue queue; // 创建队列变量 // 调用初始化队列函数 InitQueue(&amp;queue); // 调用判断队列是否为空函数 IsEmptyQueue(&amp;queue); // 入队 printf("\n"); enQueue(&amp;queue, 100); enQueue(&amp;queue, 200); enQueue(&amp;queue, 300); enQueue(&amp;queue, 400); printf("\n"); if (!IsEmptyQueue(&amp;queue)) printf("队列不为空!\n"); // 遍历队列 TraverseQueue(&amp;queue); // 出队 printf("\n"); deQueue(&amp;queue); TraverseQueue(&amp;queue); // 清空队列 printf("\n"); ClearQueue(&amp;queue); IsEmptyQueue(&amp;queue); // 摧毁队列 printf("\n"); DestroyQueue(&amp;queue); return 0;&#125; 打印结果 参考文章​ 数据结构 — 严蔚敏 ​ 数据结构 — 田鲁怀 ​ C语言描述队列的实现及操作（链表实现） ​ 数据结构-队列(queue)]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构---栈]]></title>
    <url>%2F2019%2F04%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%A0%88%2F</url>
    <content type="text"><![CDATA[一. 栈的定义栈 (Stack) 又称堆栈,是限定仅在表尾进行插入或删除操作的线性表 又称后进先出 (Last In First Out , LIFO ) 的线性表 概念 栈顶 (top) : 表尾端 , 允许进行插入和删除运算的一端 栈底 (bottom) : 表头端, 不允许进行插入和删除运算的一端 入栈(压栈) : 向栈中插入一个新元素 出栈(退栈) : 从栈中删除一个元素 栈顶指针 : 记录栈顶元素位置的变量 栈顶元素 : 处于栈顶位置的数据元素 空栈 : 不含任何数据元素的栈 例子 给枪的弹夹装子弹 洗干净的盘子总是逐个往上叠放 将衣服放入衣箱中进行收藏 基本操作 初始化栈: initStack() 检查栈是否为空栈 : isEmpty() 进栈: push 出栈: pop 取栈顶元素: GetTop 二. 数组实现栈图解 准备1234567#define SIZE 5 // 栈的大小 // 定义栈的结构typedef struct Stack &#123; int top; // 栈顶指针 int Stack[SIZE]; // 栈&#125; Stack; 1. 入栈123456789101112// 入栈 (压栈) void pushStack(Stack * pStack, int val) &#123; printf("入栈元素为: %d\n", val); // 栈是否已满 if( isFull(pStack) ) &#123; printf("栈满,无法入栈!\n"); &#125; else &#123; pStack-&gt;Stack[pStack-&gt;top] = val; // top + 1 pStack-&gt;top++; &#125;&#125; 图解 2. 出栈123456789101112131415// 出栈(退栈) bool popStack(Stack *pStack) &#123; if(isEmpty(pStack)) &#123; printf("空栈,出栈失败!\n"); return false; &#125; else &#123; printf("出栈成功!\n"); pStack-&gt;Stack[pStack-&gt;top-1] = NULL; // top-1 pStack-&gt;top--; return true; &#125;&#125; 图解 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include&lt;stdbool.h&gt;#define SIZE 5 // 栈的大小 // 定义栈的结构typedef struct Stack &#123; int top; // 栈顶指针 int Stack[SIZE]; // 栈&#125; Stack;// 初始化栈 void initStack(Stack * pStack) &#123; printf("初始化栈!\n"); // 栈顶指针指向 0 pStack-&gt;top = 0; return;&#125;// 判断是否为空栈 bool isEmpty(Stack *pStack) &#123; // 判断条件: 栈顶指针是否指向指向 0 if(0 == pStack-&gt;top) return true; else return false;&#125;// 判断是否栈满 bool isFull(Stack * pStack) &#123; // 判断条件: 栈顶指针指向栈的长度 if(SIZE == pStack-&gt;top) &#123; printf("栈满!\n"); return true; &#125; else &#123; return false; &#125;&#125;// 遍历栈 void traverseStack(Stack * pStack) &#123; // 若栈不为空 if (isEmpty(pStack)) &#123; printf("空栈!\n"); &#125; else &#123; printf("栈中的元素为: \n"); // 注意应该是 i &lt; pStack-&gt;top,而不是栈的大小 for(int i = pStack-&gt;top-1; i &gt;=0; i--) &#123; printf("%d \t", pStack-&gt;Stack[i]); &#125; printf("\n"); printf("栈的大小为: %d\n", pStack-&gt;top); printf("------------------------------------------------\n"); &#125;&#125; // 入栈 (压栈) void pushStack(Stack * pStack, int val) &#123; printf("入栈元素为: %d\n", val); // 栈是否已满 if( isFull(pStack) ) &#123; printf("栈满,无法入栈!\n"); &#125; else &#123; pStack-&gt;Stack[pStack-&gt;top] = val; // top + 1 pStack-&gt;top++; &#125;&#125;// 出栈(退栈) bool popStack(Stack *pStack) &#123; if(isEmpty(pStack)) &#123; printf("空栈,出栈失败!\n"); return false; &#125; else &#123; printf("出栈成功!\n"); pStack-&gt;Stack[pStack-&gt;top-1] = NULL; // top-1 pStack-&gt;top--; return true; &#125;&#125;// 取栈顶元素 int getTop(Stack *pStack) &#123; int val; if(isEmpty(pStack)) &#123; printf("空栈,取栈顶元素失败!\n"); return -1; &#125; else &#123; printf("取栈顶元素成功!\n"); val = pStack-&gt;Stack[pStack-&gt;top-1]; // top-1 pStack-&gt;top--; return val; &#125;&#125;// 主函数测试 int main() &#123; int val; Stack stack; initStack(&amp;stack); // 判断是否为空栈 if(isEmpty(&amp;stack)) &#123; printf("栈为空栈!\n"); &#125; else &#123; printf("栈不为空栈!\n"); &#125; // 入栈 printf("\n"); pushStack(&amp;stack, 1); pushStack(&amp;stack, 2); pushStack(&amp;stack, 3); pushStack(&amp;stack, 4); pushStack(&amp;stack, 5); pushStack(&amp;stack, 6); // 遍历栈 printf("\n"); traverseStack(&amp;stack); // 出栈 printf("\n"); popStack(&amp;stack); popStack(&amp;stack); traverseStack(&amp;stack); // 取栈顶元素 printf("\n"); val = getTop(&amp;stack); printf("栈顶元素为: %d", val); return 0;&#125; 三. 链表实现栈图解 准备1234567891011// 定义结点 typedef struct Node &#123; Elementtype Element; struct Node * Next;&#125;NODE, *PNODE;// 定义栈结构体typedef struct Stack &#123; PNODE PTOP; // 定义栈顶结点 PNODE PBOTTOM; // 定义栈底结点&#125; STACK,* PSTACK; 1. 初始化栈12345678910111213// 初始化栈void InitStack(STACK *Stack) &#123; NODE *PNew = (PNODE)malloc(sizeof(NODE)); if (PNew == NULL) &#123; printf("新结点空间分配失败！\n"); exit(-1); &#125; Stack-&gt;PTOP = PNew; // 栈顶指针指向新结点 Stack-&gt;PBOTTOM = PNew; // 栈底指针指向新结点 PNew-&gt;Next = NULL; // 新结点指针指向为空 printf("初始化栈栈！\n");&#125; 2. 入栈123456789101112// 入栈, 从栈顶插入数值 valvoid PushStack(STACK *Stack,int val) &#123; // 创建新的结点用于存放变量 NODE *P = (PNODE)malloc(sizeof(NODE)); if (P == NULL) &#123; printf("分配空间内存失败！"); exit(-1); &#125; P-&gt;Element = val; // 变量赋值给结点的数据域 P-&gt;Next = Stack-&gt;PTOP; // 让新建的结点指向上一个结点 Stack-&gt;PTOP = P; // 更新顶部结点，使其指向新建的结点 3. 出栈12345678910111213// 出栈, 从栈顶弹出，并将地址赋值给变量 valvoid PopStack(STACK *Stack, int *val) &#123; if (Stack-&gt;PBOTTOM == Stack-&gt;PTOP) &#123; // 判断栈是否为空 printf("出栈失败，栈为空！\n"); &#125; NODE *P = Stack-&gt;PTOP; // 建立一个临时结点指向栈顶结点 *val = P-&gt;Element; // 把栈顶结点元素弹出，地址放到变量val中 Stack-&gt;PTOP = P-&gt;Next; // 把栈顶指针指向上一个栈结点 free(P); // 释放结点内存，防止内存空间泄漏 P = NULL; // 防止产生野指针 printf("已将%d从栈弹出！\n", *val);&#125; 4. 取栈顶元素123456789101112// 取栈顶元素int getTop(STACK *Stack) &#123; if (IsEmpty(Stack)) &#123; // 判断栈是否为空 printf("遍历栈失败，栈为空！"); exit(-1); &#125; NODE *P = (PNODE)malloc(sizeof(NODE)); P = Stack-&gt;PTOP; int val = P-&gt;Element; return val;&#125; 5. 清空栈1234567891011121314151617181920// 清空栈函数void ClearStack(PSTACK Stack) &#123; if (IsEmpty(Stack)) &#123; printf("栈已经为空，无需清空！\n"); exit(-1); &#125; // 创建两个结点指针用来释放栈 PNODE P = Stack-&gt;PTOP; PNODE Q = NULL; // 清空栈 while (P != Stack-&gt;PBOTTOM) &#123; Q = P-&gt;Next; free(P); P = Q; &#125; Stack-&gt;PTOP = Stack-&gt;PBOTTOM; // 栈顶指向栈底指向的初始空结点 printf("已清空栈！\n");&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include&lt;stdlib.h&gt;typedef int Elementtype; // 定义数据类型// 定义结点 typedef struct Node &#123; Elementtype Element; struct Node * Next;&#125;NODE, *PNODE;// 定义栈结构体typedef struct Stack &#123; PNODE PTOP; // 定义栈顶结点 PNODE PBOTTOM; // 定义栈底结点&#125; STACK,* PSTACK;// 初始化栈void InitStack(STACK *Stack) &#123; NODE *PNew = (PNODE)malloc(sizeof(NODE)); if (PNew == NULL) &#123; printf("新结点空间分配失败！\n"); exit(-1); &#125; Stack-&gt;PTOP = PNew; // 栈顶指针指向新结点 Stack-&gt;PBOTTOM = PNew; // 栈底指针指向新结点 PNew-&gt;Next = NULL; // 新结点指针指向为空 printf("初始化栈栈！\n");&#125;// 入栈, 从栈顶插入数值 valvoid PushStack(STACK *Stack,int val) &#123; // 创建新的结点用于存放变量 NODE *P = (PNODE)malloc(sizeof(NODE)); if (P == NULL) &#123; printf("分配空间内存失败！"); exit(-1); &#125; P-&gt;Element = val; // 变量赋值给结点的数据域 P-&gt;Next = Stack-&gt;PTOP; // 让新建的结点指向上一个结点 Stack-&gt;PTOP = P; // 更新顶部结点，使其指向新建的结点 printf("%d 入栈成功！\n",val);&#125;// 出栈, 从栈顶弹出，并将地址赋值给变量 valvoid PopStack(STACK *Stack, int *val) &#123; if (Stack-&gt;PBOTTOM == Stack-&gt;PTOP) &#123; // 判断栈是否为空 printf("出栈失败，栈为空！\n"); &#125; NODE *P = Stack-&gt;PTOP; // 建立一个临时结点指向栈顶结点 *val = P-&gt;Element; // 把栈顶结点元素弹出，地址放到变量val中 Stack-&gt;PTOP = P-&gt;Next; // 把栈顶指针指向上一个栈结点 free(P); // 释放结点内存，防止内存空间泄漏 P = NULL; // 防止产生野指针 printf("已将%d从栈弹出！\n", *val);&#125;// 栈是否为空bool IsEmpty(PSTACK Stack) &#123; if (Stack-&gt;PBOTTOM == Stack-&gt;PTOP) &#123; printf("栈为空！\n"); return true; &#125; else return false;&#125;// 栈的遍历void traverseStack(STACK *Stack) &#123; if (IsEmpty(Stack)) &#123; // 判断栈是否为空 printf("遍历栈失败，栈为空！"); exit(-1); &#125; PNODE P = Stack-&gt;PTOP; // 建立一个临时结点指针，初始化时指向栈顶 // 使临时结点指针从栈顶开始遍历栈，直到栈底 printf("遍历栈的结果为： "); while (P != Stack-&gt;PBOTTOM) &#123; printf("%d ", P-&gt;Element); // 打印出数据 P = P-&gt;Next; &#125; printf("\n"); printf("--------------------------------------------\n"); &#125;// 取栈顶元素int getTop(STACK *Stack) &#123; if (IsEmpty(Stack)) &#123; // 判断栈是否为空 printf("遍历栈失败，栈为空！"); exit(-1); &#125; NODE *P = (PNODE)malloc(sizeof(NODE)); P = Stack-&gt;PTOP; int val = P-&gt;Element; return val;&#125;// 清空栈函数void ClearStack(PSTACK Stack) &#123; if (IsEmpty(Stack)) &#123; printf("栈已经为空，无需清空！\n"); exit(-1); &#125; // 创建两个结点指针用来释放栈 PNODE P = Stack-&gt;PTOP; PNODE Q = NULL; // 清空栈 while (P != Stack-&gt;PBOTTOM) &#123; Q = P-&gt;Next; free(P); P = Q; &#125; Stack-&gt;PTOP = Stack-&gt;PBOTTOM; // 栈顶指向栈底指向的初始空结点 printf("已清空栈！\n");&#125;// 主函数测试 int main() &#123; STACK Stack; // 创建一个栈变量 int val = 0; // 定义一个变量 InitStack(&amp;Stack); // 调用初始化栈函数 IsEmpty(&amp;Stack); // 用判断栈是否为空函数 // 入栈 printf("\n"); PushStack(&amp;Stack, 100); PushStack(&amp;Stack, 200); PushStack(&amp;Stack, 300); PushStack(&amp;Stack, 400); PushStack(&amp;Stack, 500); PushStack(&amp;Stack, 600); IsEmpty(&amp;Stack); // 遍历栈 printf("\n"); traverseStack(&amp;Stack); // 出栈 printf("\n"); PopStack(&amp;Stack, &amp;val); traverseStack(&amp;Stack); // 取栈顶元素 printf("\n"); val = getTop(&amp;Stack); printf("取出的栈顶元素为:%d\n", val); // 清空栈 printf("\n"); ClearStack(&amp;Stack); traverseStack(&amp;Stack); IsEmpty(&amp;Stack); return 0;&#125; 打印结果 参考文章​ 数据结构 — 严蔚敏 ​ 数据结构 — 田鲁怀 ​ C语言描述栈的实现及操作（链表实现）]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种测试]]></title>
    <url>%2F2019%2F04%2F07%2F%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[图片 动态图]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法---十大经典排序]]></title>
    <url>%2F2019%2F04%2F07%2F%E7%AE%97%E6%B3%95---%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[一. 排序1.1 概念排序是将一组 杂乱无章的数据 按规定的次序重新排列起来(排序就是整理文件的记录，将一组杂乱无章的数据按 关键字递增(或递减) 的次序重新排列，使之成为一个有序序列的过程) 排序的目的之一就是方便数据的查找 常见例子 学生成绩的排名 运动会中所有项目的成绩排名 英文字典中单词按字母的顺序排列 图书目录的编排顺序 仓库物资的分类管理 1.2 分类 1) 交换排序理解 : 两两比较待排序的记录的关键字，如果发现两个记录关键字的次序相反时进行交换，直到没有反序的记录为止 特点 : 通过记录的交换将关键字较大的记录向文件尾部移动而将关键字小的记录向文件的前部移动 常用的交换排序 : 冒泡排序和快速排序 2) 插入排序每次将一个待排序的记录，按其关键字的大小 插入到前面已排好的序列中的适当位置 ，直到全部记录插入为止 常见的插入排序方法直接插入排序，折半插入排序表，插入排序和希尔排序 选择排序1.3 比较 1.4 相关概念 稳定：如果a原本在b前面且a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面且a=b，排序之后 a 可能会出现在 b 的后面。 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 内部排序：所有排序操作都在内存中完成。本文主要介绍的是内部排序。 外部排序：待排序记录的数量很大，以致于内存不能一次容纳全部记录，所以在排序过程中需要对外存进行访问的排序过程。 二. 各算法原理及实现下面我们来逐一分析十大经典排序算法，主要围绕下列问题展开： 算法的基本思想是什么? 算法的描述(思路)? 算法的代码实现？ 算法的时间复杂度是多少？（平均、最好、最坏）什么情况下最好？什么情况下最坏？ 算法的空间复杂度是多少？ 算法的稳定性如何？ 1. 冒泡排序（Bubble Sort）1) 算法思想​ 将待排序的记录排成一个垂直的序列，而不是一个水平的序列，把记录想象成水箱里的气泡，其关键字相当于气泡的重量，对所有待排序的记录扫描一趟后，通过两个相邻记录之间的比较和交换使得气泡下沉或上升到其重量应该到的最终位置上 2) 算法描述 比较相邻的元素。如果前一个比后一个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 为了优化算法，可以设立一个布尔标识，每趟排序开始前设为false，如果该趟排序发生了交换就置为true，如果一趟排序结束标识仍为false表示该趟排序没有发生交换，即数组已经有序，可以提前结束排序。 动态演示 3) 算法实现123456789101112131415161718192021222324public static int[] bubbleSort(int[] array) &#123; if (array.length == 0) return array; // 外层循环一次为一趟排序 for (int i = 0; i &lt; array.length; i++) &#123; // 设置标识，判断这趟排序是否发生了交换。 // 如果未发生交换，则说明数组已经有序，不必再排序了 boolean isSwap = false; // 内层循环一次为一次相邻比较 for (int j = 0; j &lt; array.length - 1 - i; j++) // 如果后面的比前面的小则进行交换 if (array[j + 1] &lt; array[j]) &#123; int temp = array[j + 1]; array[j + 1] = array[j]; array[j] = temp; isSwap = true; &#125; if (!isSwap) break; &#125; return array;&#125; 4) 算法分析时间复杂度​ 冒泡排序平均时间复杂度为O(n^2^)，最好时间复杂度为O(n)，最坏时间复杂度为O(n^2^)。 最好情况：如果待排序元素本来是正序的，那么一趟冒泡排序就可以完成排序工作，比较和移动元素的次数分别是 (n - 1) 和 0，因此最好情况的时间复杂度为O(n)。 最坏情况：如果待排序元素本来是逆序的，需要进行 (n - 1) 趟排序，所需比较和移动次数分别为 n (n - 1) / 2和 3 n * (n-1) / 2。因此最坏情况下的时间复杂度为O(n^2^) 空间复杂度 冒泡排序使用了常数空间，空间复杂度为O(1) 稳定性 当 array[j] == array[j+1] 的时候，我们不交换 array[i] 和 array[j]，所以冒泡排序是稳定的 2. 简单选择排序（Selection Sort）1) 基本思想简单选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的开始(末尾)。以此类推，直到所有元素均排序完毕. 2) 算法描述 n个记录的简单选择排序可经过(n-1)趟简单选择排序得到有序结果 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R[i..n]。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； (n-1)趟结束，数组有序化了。 动态演示 3) 算法实现123456789101112131415public static int[] selectionSort(int[] array) &#123; if (array.length == 0) return array; for (int i = 0; i &lt; array.length; i++) &#123; int minIndex = i; for (int j = i; j &lt; array.length; j++) &#123; if (array[j] &lt; array[minIndex]) //找到最小的数 minIndex = j; //将最小数的索引保存 &#125; int temp = array[minIndex]; //将最小数和无序区的第一个数交换 array[minIndex] = array[i]; array[i] = temp; &#125; return array;&#125; 4) 算法分析时间复杂度 简单选择排序平均时间复杂度为O(n^2^)，最好时间复杂度为O(n2)，最坏时间复杂度为O(n^2^)。 最好情况：如果待排序元素本来是正序的，则移动元素次数为 0，但需要进行 n (n - 1) / 2 次比较。 最坏情况：如果待排序元素中第一个元素最大，其余元素从小到大排列，则仍然需要进行 n (n - 1) / 2 次比较，且每趟排序都需要移动 3 次元素，即移动元素的次数为3 * (n - 1)次。 需要注意的是，简单选择排序过程中需要进行的比较次数与初始状态下待排序元素的排列情况无关。 空间复杂度 简单选择排序使用了常数空间，空间复杂度为O(1) 稳定性简单选择排序不稳定，比如序列 2、4、2、1，我们知道第一趟排序第 1 个元素 2 会和 1 交换，那么原序列中 2 个 2 的相对前后顺序就被破坏了，所以简单选择排序不是一个稳定的排序算法。 3. 直接插入排序（Insertion Sort）1) 算法思想 把数组 R[n] 待排序的 n 个元素看成为一个有序表和一个无序表 开始时有序表只有一个元素 R1 , 而无序表包含有 n-1 个元素 R[2]-R[n] . 排序过程中，每次取出无序表中的一个元素，将它插入到有序表的适当位置，使之成为新的有序表 这样经过 n-1 次插入后,无序表变为空表而有序表包含n个元素，排序完毕 将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过 2) 算法描述 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5 动态演示 3) 实例12345678910111213141516171819202122232425// 直接插入排序,从有序表的表尾开始public static int[] insertSort(int[] arr) &#123; if (arr.length == 0) return arr; int current; // 有 n-1 个元素需要进行排序比较 for (int i = 0; i &lt; arr.length - 1; i++) &#123; // current 排序元素(无序表中的第一个元素) current = arr[i + 1]; // preIndex 比较元素的下标,(第一个为有序表中的最后一个元素的下标) int preIndex = i; // 与前面的 preIndex+1 个元素从后向前进行比较 // 如果比较元素大于排序元素 while (preIndex &gt;= 0 &amp;&amp; current &lt; arr[preIndex]) &#123; // 比较元素向后移动一个 arr[preIndex + 1] = arr[preIndex]; // 比较元素下标向前推进一个 preIndex--; &#125; // 如果比较元素小于排序元素,进行赋值,空出来的是array[preIndex + 1] arr[preIndex + 1] = current; &#125; return arr;&#125; 4) 算法分析时间复杂度​ 直接插入排序平均时间复杂度为O(n2)，最好时间复杂度为O(n)，最坏时间复杂度为O(n2)。 最好情况：如果待排序元素本来是正序的，比较和移动元素的次数分别是 (n - 1) 和 0，因此最好情况的时间复杂度为O(n)。​ 最坏情况：如果待排序元素本来是逆序的，需要进行 (n - 1) 趟排序，所需比较和移动次数分别为 n (n - 1) / 2和 n (n - 1) / 2。因此最坏情况下的时间复杂度为O(n2)。 空间复杂度​ 直接插入排序使用了常数空间，空间复杂度为O(1) 稳定性 直接插入排序是稳定的。 5) 算法拓展 在直接插入排序中，待插入的元素总是在有序区线性查找合适的插入位置，没有利用有序的优势，考虑使用二分查找搜索插入位置进行优化，即二分插入排序。 4. 希尔排序1) 算法思想​ 不断把待排序的记录分成若干个小组，然后对同一组内的记录进行排序，在分组时始终保证当前组内的记录个数超过前面分组排序时组内的记录个数 2) 算法描述 以 d1 (0 &lt; d1 &lt; n-1)为 步长 (增量)，把数组 R 中的 n 个元素分为 d1 个小组，将所有下标距离为 d1 的记录放在同一组中,每个序列有 n/d1 个元素 对每个组内的记录分别 进行直接插入排序 ，这样的一次分组排序过程称为 一次排序 以 d2 为步长(增量),重复以上步骤,直到 d1=1, 所有 n 个元素放在一个组内, 进行直接插入排序为止，该次排序结束时，整个序列的排序工作完成 一般选取增量序列的规则是: 取 di+1 为 [di/3]~[di/2] 之间的数.最简单的方法是取 di+1 = [di/2] 如果待排序的元素练越接近有序或记录个数越少，则直接排序算法的效率要高.在希尔排序中记录比较次数和移动次数排序时要少得多，特别是当a的大效果越明显 动态演示 3) 实现123456789101112131415161718192021222324252627public static int[] ShellSort(int[] array) &#123; int len = array.length; // 取步长 gap = len / 2 int temp, gap = len / 2; // 即 如果 gap != 0, 循环到 gap=1 为止 while (gap &gt; 0) &#123; // 每次循环对一组进行直接插入排序,一共 gap 组 for (int i = gap; i &lt; len; i++) &#123; // 排序元素 (这一组的最后一个元素) temp = array[i]; // 比较元素的下标 int preIndex = i - gap; // 如果比较元素大于排序元素 while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; temp) &#123; // 比较元素向后移动 array[preIndex + gap] = array[preIndex]; // 比较元素下标向前推进 preIndex -= gap; &#125; // 如果比较元素小于排序元素,进行赋值,空出来的是array[preIndex + gap] array[preIndex + gap] = temp; &#125; // 步长每次减半 gap /= 2; &#125; return array;&#125; 4) 算法分析时间复杂度​ 希尔排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlog~2~n)，最坏时间复杂度为O(nlog~2~n)。希尔排序的时间复杂度与增量序列的选取有关。 空间复杂度​ 希尔排序使用了常数空间，空间复杂度为O(1) 稳定性​ 由于相同的元素可能在各自的序列中插入排序，最后其稳定性就会被打乱，比如序列 2、4、1、2，所以希尔排序是不稳定的 5. 归并排序（Merge Sort）和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间 1) 算法思想归并排序是逐步将多个有序子表经过若干次归并操作，最终合并为一个有序表的过程 归并 : 将两个或多个有序表合并成一个有序表的过程 二路归并 : 将两个有序表合并成一个有序表 归并的方式有多种，有二路归并, 三路归并, 四路归并, 二路归并是最常用的排序方法，它既适合内排序也是和外排序 2) 算法描述 将有 n 个原始记录的无序表看成 由 n 个长度为1的有序子表组成 将相邻的两个有序子表进行归并 也就是将第1个表和第2个表归并，第3个表和第4个表合并… 若最后只剩下一个表则直接进入下一趟归并，就得到了[n/2]个长度为2或1的有序表, 称此为一趟归并 重复步骤2，直到归并第 [log~2~n] 趟以后，得到一个长度为 n 的有序表为止 动态演示 3) 算法实现123456789101112131415161718192021222324252627282930313233343536373839// 归并排序public static int[] MergeSort(int[] array) &#123; // 递归临界点,如果数组长度为 1,则返回数组 if (array.length &lt; 2) return array; // 如果不为1 int mid = array.length / 2; // 继续划分数组 int[] left = Arrays.copyOfRange(array, 0, mid); int[] right = Arrays.copyOfRange(array, mid, array.length); // 递归, 调用下面的函数 return merge(MergeSort(left), MergeSort(right));&#125;// 归并排序——将两段有序数组结合成一个有序数组public static int[] merge(int[] left, int[] right) &#123; // 新数组, 存放合并后的数组,长度为两数组之和 int[] result = new int[left.length + right.length]; int i = 0, j = 0, k = 0; while (i &lt; left.length &amp;&amp; j &lt; right.length) &#123; // 依次放入新数组中 if (left[i] &lt;= right[j]) &#123; result[k++] = left[i++]; &#125; else &#123; result[k++] = right[j++]; &#125; &#125; // 一个数组完全放入到新数组中后,另外一个数组可能剩余多个数 while (i &lt; left.length) &#123; result[k++] = left[i++]; &#125; while (j &lt; right.length) &#123; result[k++] = right[j++]; &#125; return result;&#125; 4) 算法分析时间复杂度归并排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(nlogn)。归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它在任何情况下时间复杂度均是O(nlogn)。 空间复杂度 归并排序空间复杂度为O(n) 稳定性 归并排序是稳定的 6. 快速排序（Quick Sort）1) 算法思想快速排序是对冒泡排序的一种改进，也是目前所有排序方法中速度最快的一种 在待排序的 n 个记录中任意选一个记录作为标准记录(通常选取序列的第1个记录作为标准记录) 以该记录的关键字为基准 ，将当前的无序区划分为左右两个比较小的无序区 使左边无序区中各记录的关键字均小于基准记录的关键字 使右区无序子区中各记录的关键字均大于或等于基准的关键字 而标准记录则位于两个无序区的中间位置上，也就是该记录最终排序的位置上 分别对两个做，那个无序区继续进行上述的划分过程，直到无序区中所有的记录都被排好位置 2) 算法描述快速排序使用分治法来把一个数列分为两个子数列。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），该基准就处于数列的中间位置。这称为分区（partition）操作； 递归地（recursive）对小于基准值元素的子数列和大于基准值元素的子数列进行快速排序。 动态演示 3) 算法实现123456789101112131415161718192021222324252627public static int partition(int[] array,int left,int right) &#123; int key = array[right];//初始坑 while(left &lt; right) &#123; //left找大 while(left &lt; right &amp;&amp; array[left] &lt;= key ) left++; array[right] = array[left];//赋值，然后left作为新坑 //right找小 while(left &lt;right &amp;&amp; array[right] &gt;= key) right--; array[left] = array[right];//right作为新坑 &#125; array[left] = key; /*将key赋值给left和right的相遇点， 保持key的左边都是比key小的数，key的右边都是比key大的数*/ return left;//最终返回基准&#125;// 递归地进行快速排序了public static int[] Quicksort(int array[], int left, int right) &#123; if (left &lt; right) &#123; int pos = partition(array, left, right); Quicksort(array, left, pos - 1); Quicksort(array, pos + 1, right); &#125; return array;&#125; 4) 算法分析时间复杂度 快速排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(n2)。最好情况：基准选择得当，partition函数每次恰好能均分序列，其递归树的深度就为logn，时间复杂度为O(nlogn)。最坏情况：选择了最大或者最小数字作为基准，每次划分只能将序列分为一个元素与其他元素两部分，此时快速排序退化为冒泡排序，如果用树画出来，得到的将会是一棵单斜树，即所有的结点只有左（右）结点的树，树的深度为 n，时间复杂度为O(n2)。 空间复杂度 快速排序的空间复杂度主要考虑递归时使用的栈空间。 在最好情况下，即partition函数每次恰好能均分序列，空间复杂度为O(logn)；在最坏情况下，即退化为冒泡排序，空间复杂度为O(n)。平均空间复杂度为O(logn)。 稳定性 快速排序是不稳定的 7. 堆排序（Heap Sort）1) 基本思想堆排序是一种树形选择排序方法，它利用了堆这种数据结构。在排序的过程中，将array[0，…，n-1]看成是一颗完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的关系，在当前无序区中选择关键字最大（最小）的元素。 2) 概念堆：堆是一种完全二叉树，且满足所有父节点的值均大于等于（或小于等于）其子节点的值。大根堆（最大堆）：满足所有父节点的值均大于等于其子节点的值的堆称为大根堆，堆顶元素是堆中元素的最大值。小根堆（最小堆）：满足所有父节点的值均小于等于其子节点的值的堆称为小根堆，堆顶元素是堆中元素的最小值。堆的顺序存储结构 : 使用顺序数据结构（数组）存储堆，表示方法为： 数组按层序遍历的顺序存放完全二叉树的结点，下标为 0 处为堆顶，下标为 len - 1 处为堆尾。 结点 i 如果存在左孩子（下标不超过 len - 1 就存在），左孩子的下标为（2 i ）；如果存在右孩子，右孩子的下标为（2 i + 1）。结点 i 的父结点下标为 [i / 2] (下标为 0 的结点除外，它没有父结点)。最后一个非叶子结点即为堆尾元素的父结点，下标为 (len - 1 - 1) / 2 = (len - 2) / 2。 3) 算法描述 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为（n-1），则整个排序过程完成。 动态演示 4) 算法实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 声明全局变量，用于记录数组array的长度；static int len;// 堆排序算法public static int[] HeapSort(int[] array) &#123; len = array.length; if (len == 0) return array; // 1.构建一个大根堆 buildMaxHeap(array); // 2.循环将堆顶（最大值）与堆尾交换，删除堆尾元素，然后重新调整大根堆 while (len &gt; 0) &#123; swap(array, 0, len - 1); len--; // 原先的堆尾进入有序区，删除堆尾元素 adjustHeap(array, 0); // 重新调整大根堆 &#125; return array;&#125;// 自顶向下调整以 i 为根的堆为大根堆public static void adjustHeap(int[] array, int i) &#123; int maxIndex = i; // 如果有左子树，且左子树大于父节点，则将最大指针指向左子树 if (2 * i &lt; len &amp;&amp; array[2 * i] &gt; array[maxIndex]) maxIndex = 2 * i; // 如果有右子树，且右子树大于父节点，则将最大指针指向右子树 if (2 * i + 1 &lt; len &amp;&amp; array[2 * i + 1] &gt; array[maxIndex]) maxIndex = 2 * i + 1; // 如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。 if (maxIndex != i) &#123; swap(array, maxIndex, i); adjustHeap(array, maxIndex); &#125;&#125;// 自底向上构建初始大根堆public static void buildMaxHeap(int[] array) &#123; // 从最后一个非叶子节点开始自底向上构造大根堆 for (int i = (len - 2) / 2; i &gt;= 0; i--) &#123; adjustHeap(array, i); &#125;&#125;// 交换数组内两个元素public static void swap(int[] array, int i, int j) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp;&#125; 拓展 1）插入元素：只需要把待插入的元素放置在堆尾，然后 len++ 把其纳入堆，然后调用 adjustHeap 函数重新调整堆即可。 2）删除堆顶元素：只需要把堆顶元素交换到堆尾，然后 len– 把其移出堆，然后调用 adjustHeap 函数重新调整堆即可 5) 算法分析时间复杂度堆排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(nlogn)。堆排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它在任何情况下时间复杂度均是O(nlogn)。 空间复杂度堆排序使用了常数空间，空间复杂度为O(1)。 稳定性堆排序是不稳定的 8.### 参考博文​ 一文搞定十大经典排序算法（Java实现） ​ 十大经典排序算法总结——Java实现]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery---常用方法]]></title>
    <url>%2F2019%2F04%2F04%2FJQuery---%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一. 简介JQuery是一个JavaScript工具库（类库），它通过封装原生的JavaScript函数得到一整套定义好的方法 一句话总结类库。 就是 JavaScript 的工具库。 原始社会生火方式， 钻木取火。 但是有了火柴就不一样了 引用jQuery 库是一个 JavaScript 文件，可以使用 HTML 的 标签引用它 12345&lt;head&gt; &lt;!-- 两种方式 --&gt; &lt;scriptsrc="http://libs.baidu.com/jquery/2.0.0/jquery.js"&gt;&lt;/script&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt; 二. jQuery 语法基础语法1$(selector).action() 美元符号定义 jQuery 选择符（selector）“查询”和“查找” HTML 元素 jQuery 的 action() 执行对元素的操作 文档就绪函数这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码。 如果在文档没有完全加载之前就运行函数，操作可能失败。下面是两个具体的例子： 试图隐藏一个不存在的元素 获得未完全加载的图像的大小 1234567$(document).ready(function() &#123; &#125;);// 简写$(function()&#123;&#125;) JQuery 选择器 选择器 CSS模式 jQuery模式 描述 标签名 div{} $(‘div’) 获取所有div标签的DOM元素 ID #box{} $(‘#box’) 获取一个ID为box的DOM对象 class(类名) .box{} $(‘.box’) 获取所有class名为box的DOM对象 JQuery HTML1. 获取与设置(没有看回调)1) 获得与设置 内容三个简单实用的用于 DOM 操作的 jQuery 方法： text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值 下面的例子演示如何通过 jQuery text() 和 html() 方法来获得内容： 获取实例1234567891011$("#btn1").click(function()&#123; alert("Text: " + $("#test").text());&#125;);$("#btn2").click(function()&#123; alert("HTML: " + $("#test").html());&#125;);$("#btn3").click(function()&#123; alert("Value: " + $("#test").val());&#125;); 设置实例123456789$("#btn1").click(function()&#123; $("#test1").text("Hello world!");&#125;);$("#btn2").click(function()&#123; $("#test2").html("&lt;b&gt;Hello world!&lt;/b&gt;");&#125;);$("#btn3").click(function()&#123; $("#test3").val("Dolly Duck");&#125;); 2) 获取与设置属性 attr() 用于获取与设置属性值 获取实例123$("button").click(function()&#123; alert($("#w3s").attr("href"));&#125;); 设置实例1234567891011$("button").click(function()&#123; $("#w3s").attr("href","http://www.w3school.com.cn/jquery");&#125;);// 设置多个属性$("button").click(function()&#123; $("#w3s").attr(&#123; "href" : "http://www.w3school.com.cn/jquery", "title" : "W3School jQuery Tutorial" &#125;);&#125;); 参考博文​ JQuery简介 ​ W3school]]></content>
      <categories>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用类---Collections]]></title>
    <url>%2F2019%2F04%2F04%2FJava%E5%B8%B8%E7%94%A8%E7%B1%BB---Collections%2F</url>
    <content type="text"><![CDATA[一. 概念​ Collections是一个工具类，sort是其中的静态方法，是用来对List类型进行排序的 二. 使用两种用法123456789// 用法一public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123; list.sort(null);&#125;// 用法二public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) &#123; list.sort(c);&#125; 参考博文​ java基础——Collections.sort的两种用法]]></content>
      <categories>
        <category>java常用类</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java常用类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS---常用]]></title>
    <url>%2F2019%2F04%2F04%2FCSS---%E5%B8%B8%E7%94%A8%2F</url>
    <content type="text"><![CDATA[!important 提高指定样式规则的应用优先权（优先级） 语法格式 { cssRule !important } , 即写在定义的最后面， 例如：p {color:red !important;}]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS---框模型]]></title>
    <url>%2F2019%2F04%2F04%2FCSS---%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[术语翻译 element : 元素。 padding : 内边距，也有资料将其翻译为填充。 border : 边框。 margin : 外边距，也有资料将其翻译为空白或空白边 参考博文​ CSS 框模型概述]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS---基础]]></title>
    <url>%2F2019%2F04%2F04%2FCSS---%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一. CSS 简介1.1 概述 CSS : 层叠样式表 (简称样式表 Cascading Style Sheets) 样式定义 如何显示 HTML 元素 外部样式表通常存储在 CSS 文件 中 CSS 用于布局与美化网页, 是一种标记语言,因此不需要编译,可以直接由浏览器执行(属于浏览器解释型语言). CSS 文件是一个文本文件,它包含了一些CSS标记,CSS文件必须使用 .css 为文件名后缀. CSS是大小写不敏感的,CSS与css是一样的. 1.2 使用CSS的优势： 内容与表现分离,有了CSS,网页的内容(XHMTL)与表现就可以分开了. 表现的统一,可以使网页的表现非常统一,并且容易修改. CSS可以支持多种设备,比如手机,PDA,打印机,电视机,游戏机等. 使用CSS可以减少网页的代码量,增加网页的浏览速度,减少硬盘容量. 二. CSS基础语法CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明, 每条声明由一个属性和一个值组成 实例123456789101112131415/* 格式 */selector &#123; property: value&#125;/* 实例 */h1 &#123; color:red; /* 声明 */ font-size:14px; /* 声明 */ font-family: "sans serif"; /* 如果值为若干单词，则要给值加引号 */&#125;/* * 选择器:h1 * 属性:color,font-size * 值:red,14px */ 三. 高级语法对选择器进行分组，这样，被分组的选择器就可以分享相同的声明。用逗号将需要分组的选择器分开实例1234/* 所有的标题元素都是绿色的 */h1,h2,h3,h4,h5,h6 &#123; color: green; &#125; 四. 派生选择器通过依据元素在其位置的上下文关系来定义样式，你可以使标记更加简洁 实例12345/* 列表中的 strong 元素变为斜体字 */li strong &#123; font-style: italic; font-weight: normal; &#125; 五. id 选择器 id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。 id 选择器以 “#” 来定义 id 属性只能在每个 HTML 文档中出现一次 实例HTML12&lt;p id="red"&gt;这个段落是红色。&lt;/p&gt;&lt;p id="green"&gt;这个段落是绿色。&lt;/p&gt; CSS12#red &#123;color:red;&#125;#green &#123;color:green;&#125; id 选择器和派生选择器在现代布局中，id 选择器常常用于建立派生选择器。 12345#sidebar p &#123; font-style: italic; text-align: right; margin-top: 0.5em; &#125; 六. 类选择器 选择器以一个点号显示 类名的第一个字符不能使用数字！它无法在 Mozilla 或 Firefox 中起作用 实例HTML12345678&lt;!-- h1 和 p 元素都有 center 类。这意味着两者都将遵守 ".center" 选择器中的规则 --&gt;&lt;h1 class="center"&gt;This heading will be center-aligned&lt;/h1&gt;&lt;p class="center"&gt;This paragraph will also be center-aligned.&lt;/p&gt; CSS1.center &#123;text-align: center&#125; 七. 属性选择器为拥有指定属性的 HTML 元素设置样式 实例: 为带有 title 属性的所有元素设置样式123456789101112131415161718&lt;!DOCTYPE&gt;&lt;html&gt; &lt;head&gt; &lt;style type="text/css"&gt; [title] &#123; color:red;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;可以应用样式：&lt;/h1&gt; &lt;h2 title="Hello world"&gt;Hello world&lt;/h2&gt; &lt;a title="W3School" href="http://w3school.com.cn"&gt;W3School&lt;/a&gt; &lt;hr/&gt; &lt;h1&gt;无法应用样式：&lt;/h1&gt; &lt;h2&gt;Hello world&lt;/h2&gt; &lt;a href="http://w3school.com.cn"&gt;W3School&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 八. 混合使用实例12345/* class="top" 的nav 下面的&lt;span&gt;和&lt;a&gt;标签被选中 */nav.top span, nav.top a &#123; color: #999; margin: 0px 10px 0px 10px;&#125; 九. 创建9.1 外部样式表123&lt;head&gt; &lt;link rel="stylesheet" type="text/css" href="mystyle.css" /&gt;&lt;/head&gt; 9.2 内部样式表1234567&lt;head&gt; &lt;style type="text/css"&gt; hr &#123;color: sienna;&#125; p &#123;margin-left: 20px;&#125; body &#123;background-image: url("images/back40.gif");&#125; &lt;/style&gt;&lt;/head&gt; 9.3 内联样式123&lt;p style="color: sienna; margin-left: 20px"&gt; This is a paragraph&lt;/p&gt; 参考博文​ CSS是干什么用的，学来有什么用？ ​ W3school CSS]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JSP的九个内置对象]]></title>
    <url>%2F2019%2F03%2F27%2FJavaWeb---JSP%E7%9A%84%E4%B9%9D%E4%B8%AA%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[一. JSP运行原理 每个JSP 页面在第一次被访问时，WEB容器都会把请求交给JSP引擎（即一个Java程序）去处理。JSP引擎先将JSP翻译成一个 _jspServlet(实质上也是一个 servlet ) ，然后按照servlet的调用方式进行调用。 由于 JSP 第一次访问时会翻译成 servlet ，所以第一次访问通常会比较慢，但第二次访问，JSP引擎如果发现JSP没有变化，就不再翻译，而是直接调用，所以程序的执行效率不会受到影响。 JSP 引擎在调用 JSP 对应的 _jspServlet 时，会传递或创建9个与web开发相关的对象供 _jspServlet 使用。JSP技术的设计者为便于开发人员在编写JSP页面时获得这些web对象的引用，特意定义了9个相应的变量，开发人员在JSP页面中通过这些变量就可以快速获得这9大对象的引用。 二. 认识九个内置对象 NO. 内置对象 类型 1 pageContext javax.servlet.jsp.PageContext 2 request javax.servlet.http.HttpServletRequest 3 response javax.servlet.http.HttpServletResponse 4 session javax.servlet.http.HttpSession 5 application javax.servlet.ServletContext 6 config javax.servlet.ServletConfig 7 out javax.servlet.jsp.JspWriter 8 page java.lang.Object 9 exception java.lang.Throwable request，response，session，application，config这些对象在前面都已经作了详细的介绍，这里重点介绍一下剩下的pageContext对象，out对象，page对象 内置对象（又叫隐式对象）:不需要预先声明就可以在脚本代码和表达式中随意使用 三. page对象 page 对象表示当前一个 JSP 页面，可以理解为一个对象本身，即：把一个JSP当作一个对象来看待。 ​ page对象在开发中几乎不用，了解一下即可 四. out对象 out对象用于向客户端发送文本数据。out对象是通过调用 pageContext 对象的 getOut 方法返回的, 其作用和用法与ServletResponse.getWriter 方法返回的 PrintWriter 对象非常相似。 JSP页面中的out对象的类型为 JspWriter，JspWriter 相当于一种带缓存功能的 PrintWriter，设置 JSP 页面的page指令的buffer属性可以调整它的缓存大小，甚至关闭它的缓存。 只有向out对象中写入了内容，且满足如下任何一个条件时，out对象才去调用ServletResponse.getWriter方法，并通过该方法返回的PrintWriter对象将out对象的缓冲区中的内容真正写入到Servlet引擎提供的缓冲区中： 条件 设置page指令的buffer属性关闭了out对象的缓存功能 out对象的缓冲区已满 整个JSP页面结束 五. pageContext对象 pageContext对象是 JSP 技术中最重要的一个对象，它代表 JSP 页面的运行环境，这个对象不仅封装了对其它8大隐式对象的引用，它自身还是一个域对象(容器)，可以用来保存数据。并且，这个对象还封装了web开发中经常涉及到的一些常用操作，例如引入和跳转其它资源、检索其它域对象中的属性等。 5.1 获得其他对象方法 方法 含义 getException() 返回exception隐式对象 getPage() 返回page隐式对象 getRequest() 返回request隐式对象 getResponse() 返回response隐式对象 getServletConfig() 返回config隐式对象 getServletContext() 返回application隐式对象 getSession() 返回session隐式对象 getOut() 返回out隐式对象 5.2 pageContext封装其它8大内置对象的意义 如果在编程过程中，把pageContext对象传递给一个普通java对象，那么这个java对象将可以获取8大隐式对象，此时这个java对象就可以和浏览器交互了，此时这个java对象就成为了一个动态web资源了，这就是pageContext封装其它8大内置对象的意义，把pageContext传递给谁，谁就能成为一个动态web资源 那么什么情况下需要把pageContext传递给另外一个java类呢，什么情况下需要使用这种技术呢? ​ 在比较正规的开发中，jsp页面是不允许出现java代码的，如果jsp页面出现了 java 代码，那么就应该想办法把 java 代码移除掉，我们可以开发一个自定义标签来移除 jsp 页面上的 java 代码，首先围绕自定义标签写一个java类，jsp引擎在执行自定义标签的时候就会调用围绕自定义标签写的那个 java 类，在调用 java 类的时候就会把 pageContext 对象传递给这个java类，由于pageContext对象封装了对其它8大隐式对象的引用，因此在这个java类中就可以使用jsp页面中的8大隐式对象(request，response，config，application，exception，Session，page，out)了，pageContext对象在jsp自定义标签开发中特别重要。 5.3 pageContext作为域对象 pageContext对象可以作为容器来使用，因此可以将一些数据存储在pageContext对象中。 1) 常用方法1234public void setAttribute(String name, Object value)public Object getAttribute(String name)public void removeAttribute(String name)public Object findAttribute(String name) findAttribute() : 用来查找各个域中的属性的 当要查找某个属性时，findAttribute方法按照查找顺序 “page→request→session→application” 在这四个对象中去查找，只要找到了就返回属性值，如果四个对象都没有找到要查找的属性，则返回一个null。 范例：使用pageContext的findAttribute方法查找属性值12345678910111213141516171819202122232425262728&lt;%@page contentType="text/html;charset=UTF-8"%&gt;&lt;%@page import="java.util.*"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;head&gt; &lt;title&gt;pageContext的findAttribute方法查找属性值&lt;/title&gt;&lt;/head&gt;&lt;% pageContext.setAttribute("name1", "孤傲苍狼"); request.setAttribute("name2", "白虎神皇"); session.setAttribute("name3", "玄天邪帝"); application.setAttribute("name4", "灭世魔尊");%&gt;&lt;% // 使用pageContext的findAttribute方法查找属性，由于取得的值为Object类型，因此必须使用String强制向下转型，转换成String类型 // 查找name1属性，按照顺序"page→request→session→application"在这四个对象中去查找 String refName1 = (String)pageContext.findAttribute("name1"); String refName2 = (String)pageContext.findAttribute("name2"); String refName3 = (String)pageContext.findAttribute("name3"); String refName4 = (String)pageContext.findAttribute("name4"); String refName5 = (String)pageContext.findAttribute("name5"); // 查找一个不存在的属性%&gt;&lt;h1&gt;pageContext.findAttribute方法查找到的属性值：&lt;/h1&gt;&lt;h3&gt;pageContext对象的name1属性：$&#123;name1&#125;&lt;/h3&gt;&lt;h3&gt;request对象的name2属性：$&#123;name2&#125;&lt;/h3&gt;&lt;h3&gt;session对象的name3属性：$&#123;name3&#125;&lt;/h3&gt;&lt;h3&gt;application对象的name4属性：$&#123;name4&#125;&lt;/h3&gt;&lt;h3&gt;不存在的name5属性：$&#123;name5&#125;&lt;/h3&gt; 2) pageContext对象中封装了访问其它域的方法123public Object getAttribute(String name, int scope)public void setAttribute(String name, Object value, int scope)public void removeAttribute(String name, int scope) 代表各个域的常量 1234PageContext.APPLICATION_SCOPEPageContext.SESSION_SCOPEPageContext.REQUEST_SCOPEPageContext.PAGE_SCOPE 范例：pageContext访问其它域123456789101112&lt;% // 此时相当于往session对象中存放了一个name属性， // 等价于 session.setAttribute("name","孤傲苍狼"); pageContext.setAttribute("name","孤傲苍狼",PageContext.SESSION_SCOPE);%&gt;&lt;% // 两种取出来的方式 // 取得session对象的属性，使用pageContext对象获取 String refName1 = (String)pageContext.getAttribute("name",PageContext.SESSION_SCOPE); // 由于取得的值为Object类型，因此必须使用String强制向下转型，转换成String类型 String refName2 = (String)session.getAttribute("name"); %&gt; 5.4 PageContext 引入和跳转到其他资源 PageContext类中定义了一个forward方法(用来跳转页面)和两个include方法(用来引入页面)来分别简化和替代RequestDispatcher.forward方法和include方法。 方法接收的资源如果以“/”开头， “/”代表当前web应用。 范例：使用pageContext的forward方法跳转到其他页面 12345678&lt;% // 使用pageContext的forward方法跳转到 pageContextDemo05.jsp 页面，/代表了当前的web应用 pageContext.forward("/pageContextDemo05.jsp");// 使用 pageContext.forward(relativeUrlPath)替代 RequestDispatcher.forward(relativeUrlPath) // 使用 RequestDispatcher 的 forward 方法实现的跳转方式 pageContext.getRequest().getRequestDispatcher("/pageContextDemo05.jsp").forward(request, response);%&gt; 1pageContext.forward("/pageContextDemo05.jsp"); ​ 这种写法是用来简化和替代 pageContext.getRequest().getRequestDispatcher(&quot;/pageContextDemo05.jsp&quot;).forward(request, response);这种写法的。在实际开发中，使用pageContext.forward(relativeUrlPath)方法跳转页面用得不多，主要是因为要在Jsp页面中嵌套java代码，所以这种做法简单了解一下即可 ​ 在开发中，要想从一个Jsp页面采用服务器端跳转的方式跳转到另一个Jsp页面，那么一般会使用 &lt;jsp:forward&gt; 标签，&lt;jsp:forward&gt; 标签用于把请求转发给另外一个资源。 范例：使用pageContext的include方法引入资源1234567891011&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;head&gt; &lt;title&gt;使用pageContext的include方法引入资源&lt;/title&gt;&lt;/head&gt;&lt;%-- 使用jsp:include标签引入资源, &lt;jsp:include page="/jspfragments/head.jsp"/&gt; --%&gt;&lt;% pageContext.include("/jspfragments/head.jsp");%&gt;&lt;hr/&gt; 参考博文​ JavaWeb学习总结(十七)——JSP中的九个内置对象]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---Cookie]]></title>
    <url>%2F2019%2F03%2F27%2FJavaWeb---Cookie%2F</url>
    <content type="text"><![CDATA[一. 会话的概念 会话 : (简单理解)用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话。 有状态会话 : 一个同学来过教室，下次再来教室，我们会知道这个同学曾经来过，这称之为有状态会话。 二、会话过程中要解决的一些问题？ 每个用户在使用浏览器与服务器进行会话的过程中，不可避免各自会产生一些数据，程序要想办法为每个用户保存这些数据。 三、保存会话数据的两种技术3.1、Cookie Cookie是客户端技术，程序把每个用户的数据以cookie的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去。这样，web资源处理的就是用户各自的数据了。 3.2、Session Session是服务器端技术，利用这个技术，服务器在运行时可以为每一个用户的浏览器创建一个其独享的session对象，由于session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的session中，当用户再去访问服务器中的其它web资源时，其它web资源再从用户各自的session中取出数据为用户服务。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用类---图片处理ImageIO类]]></title>
    <url>%2F2019%2F03%2F27%2FJava%E5%B8%B8%E7%94%A8%E7%B1%BB---%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86ImageIO%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[一. 获取图片1) 从本地文本读取图片12File sourceimage = new File("c:\mypic.jpg");Image image = ImageIO.read(sourceimage); 2) 从网络上获取图片12URL url = new URL("http://www.mkyong.com/image/mypic.jpg");Image image = ImageIO.read(url); 3) 使用ImageIO读取图片实例1234567891011121314151617181920public class ReadImage &#123; public static void main(String[] args) &#123; Image image = null; try &#123; // 从网络上获取图片 URL url = new URL("https://sladning.github.io/images/Audrey_Hepburn.jpg"); image = ImageIO.read(url); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 将图片输出到 JLabel 上 JFrame frame = new JFrame(); frame.setSize(900, 900); JLabel label = new JLabel(new ImageIcon(image)); frame.add(label); frame.setVisible(true); &#125;&#125;// 结果打印出来图片 二. 写入图片1) 从网络上读取图片写入本地文件中实例123456789101112131415161718public class WriteImage &#123; public static void main(String[] args) &#123; BufferedImage image = null; try &#123; // 从网络上获取图片 URL url = new URL("https://sladning.github.io/images/Audrey_Hepburn.jpg"); image = ImageIO.read(url); // 进行图片的写入 ImageIO.write(image, "jpg", new File("G:\\aaa.jpg")); // .jpg文件占空间最小 ImageIO.write(image, "gif", new File("G:\\bbb.gif")); ImageIO.write(image, "png", new File("G:\\ccc.png")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println("成功写入G盘"); &#125;&#125; 2) 从本地文件中读取图片和写入图片123456789101112131415public class TestLocalImage &#123; public static void main(String[] args) &#123; try &#123; // 加载图片 BufferedImage originalImage = ImageIO.read(new File("G:\\aaa.jpg")); // 写入图片 ImageIO.write(originalImage, "jpg", new File("G:\\abc.jpg")); System.out.println("成功写入!!"); &#125; catch (IOException e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125; 参考博文​ ImageIO类的使用]]></content>
      <categories>
        <category>java常用类</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java常用类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---数组]]></title>
    <url>%2F2019%2F03%2F27%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[一．数组的基本概念 数组可以看成是多个相同类型数据组合，对这些数据的统一管理。 数组变量属于引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。 数组的元素可以是任何数据类型，包括基本类型和引用类型。 C 和 C++ 中的数组都可以分配在栈上面，而JAVA中的数组是只能分配在堆上面的，因为JAVA中的数组是引用类型 二．一维数组一维数组的声明方式有两种 格式一：数组元素类型 数组名[ ]; 格式二：数组元素类型[ ] 数组名; 例如： 12345int a1[ ]; int[ ] a2;String[ ] s1; String s1[ ]; 注意：JAVA语言中声明数组时不能指定其长度(数组中的元素个数) 如：int a[5]; 这样声明一维数组是非法的 三．数组的模型 一维数组：一维数组就是一行，一行小格。 二维数组：二维数组就是一行加一列组成的一个平面分成的小格，有行有列。 三维数组：三维数组就是一个立方体。 人类对最多认识到三维空间。 四. 数组对象的创建JAVA中使用关键字new创建数组对象 格式1234567891011121314// 数组名 = new 数组元素的类型[数组元素的个数]public class Test &#123; public static void main(String args[])&#123; // 进行声明,在栈内存中创建变量s int[] s; // 进行数组的创建 // 在堆内存中创建int[5](一组相邻的内存),s指向对象 s = new int[5]; for(int i = 0; i &lt; 5; i++)&#123; s[i] = i*i; &#125; &#125;&#125; 五. 元素为引用数据类型的数组注意：元素为引用数据类型的数组中的每一个元素都需要实例化范例123456789101112131415161718class Date&#123; int year; int moth; int day; Date(int y, int m, int d)&#123; year = y; month = m; day = d; &#125;&#125;public class Test &#123; public static void main(String args[]) &#123; Date[] days; days = new Date[3]; for(int i = 0 ; i &lt; 3; i++) &#123; day[i] = new Date(2004+i, 4, i+1); &#125; &#125;&#125; 六. 数组的初始化范例1234567891011121314public class Test&#123; public static void main(String args[ ])&#123; // 1.动态初始化,数组定义与为数组元素分配空间和赋值的操作分开进行。 int a[ ]; // 定义数组，即声明一个int类型的数组a[ ] a=new int[3]; // 给数组元素分配内存空间。 a[0]=3; a[1]=9; a[2]=8; // 给数组元素赋值。 // 2.静态初始化,在定义数组的同时就为数组元素分配空间并赋值。 int a[ ] = &#123; 3, 9, 8&#125;; // 在定义数组的同时给数组分配空间并赋值。 // 3.默认初始化,数组是引用类型，它的元素相当于类的成员变量，因此给数组分配内存空间后，每个元素也被按照成员变量的规则被隐式初始化 int a[ ] = new int[5]; &#125; &#125; 七. 数组元素的引用定义并用运算符new为之分配内存空间后，才可以引用数组中的每个元素 数组元素的引用方式为：arrayName[index] (index为数组元素下标，可以是整型常量或整型表达式) 1a[3], b[i], c[6*i] 数组元素下标从0开始；长度为n的数组的合法下标取值范围为 0～n—1 每个数组都有一个属性length指明它的长度，例如：a.length 的值为数组a的长度(元素个数) 参考博文​ java基础学习总结——数组]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---泛型(2)]]></title>
    <url>%2F2019%2F03%2F27%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%B3%9B%E5%9E%8B(2)%2F</url>
    <content type="text"><![CDATA[一. 泛型的基本概念泛型的定义 : 泛型是JDK 1.5的一项新特性，它的本质是参数化类型（Parameterized Type）的应用，也就是说所操作的数据类型被指定为一个参数，在用到的时候在指定具体的类型。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。 实例分析在JDK1.5之前，Java泛型程序设计是用继承来实现的。因为Object类是所用类的基类，所以只需要维持一个Object类型的引用即可。就比如ArrayList只维护一个Object引用的数组 12345678// JDK1.5之前的public class ArrayList&#123; public Object get(int i)&#123;......&#125; public void add(Object o)&#123;......&#125; private Object[] elementData;&#125; 两个问题： 没有错误检查，可以向数组列表中添加类的对象 在取元素的时候，需要进行强制类型转换 很容易发生错误，比如123456789/**jdk1.5之前的写法，容易出问题*/ArrayList arrayList1 = new ArrayList();arrayList1.add(1);arrayList1.add(1L);arrayList1.add("asa");// 因为不知道取出来的值的类型，类型转换的时候容易出错int i = (Integer) arrayList1.get(1); 在JDK1.5之后，加入了泛型来解决类似的问题。 范例123456789101112/** jdk1.5之后加入泛型*/// 限定数组列表中的类型ArrayList&lt;String&gt; arrayList2=new ArrayList&lt;String&gt;(); // 因为限定了类型，所以不能添加整形// arrayList2.add(1); // 只能添加字符串arrayList2.add("asa");// 因为知道取出来的值的类型，所以不需要进行强制类型转换String str=arrayList2.get(0); 二. 基本术语以 ArrayList&lt;E&gt; 和 ArrayList&lt;Integer&gt; 做简要介绍： 元素 名称 ArrayList&lt;E&gt; 泛型类型 ArrayList&lt;E&gt; 中的 E 类型变量或者类型参数 ArrayList&lt;Integer&gt; 参数化的类型 ArrayList&lt;Integer&gt; 中的 integer 类型参数的实例或者实际类型参数 ArrayList&lt;Integer&gt; 中的 &lt;Integer&gt; typeof Integer ArrayList 原始类型 三. 泛型的使用泛型的参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。 1) 泛型类的定义和使用一个泛型类（generic class）就是具有一个或多个类型变量的类。定义一个泛型类十分简单，只需要在类名后面加上&lt;&gt;，再在里面加上类型参数 实例12345678910111213141516171819202122232425262728public class Pair&lt;T&gt; &#123; private T value; public Pair(T value) &#123; // 构造函数 this.value=value; &#125; public T getValue() &#123; // get return value; &#125; public void setValue(T value) &#123; // set this.value = value; &#125; public static void main(String[] args) throws ClassNotFoundException &#123; Pair&lt;String&gt; pair = new Pair&lt;String&gt;(Hello"); String str = pair.getValue(); System.out.println(str); Pair&lt;Integer&gt; ii = new Pair&lt;Integer&gt;(2); System.out.println(ii.getValue()); &#125;&#125;// 输出结果:// 变量类型为字符串时: Hello// 变量类型为整形时: 2 Pair类引入了一个类型变量T，用尖括号&lt;&gt;括起来，并放在类名的后面。泛型类可以有多个类型变量。例如，可以定义Pair类，其中第一个域和第二个域使用不同的类型： 1public class Pair&lt;T,U&gt;&#123;......&#125; 注意 : 类型变量使用大写形式，且比较短，这是很常见的。在Java库中，使用变量E表示集合的元素类型，K和V分别表示关键字与值的类型。（需要时还可以用临近的字母U和S）表示“任意类型” 2) 泛型接口的定义和使用实例123456789101112131415161718192021222324252627282930313233343536373839interface Show&lt;T, U&gt; &#123; void show(T t, U u);&#125;// 接口1class ShowTest01 implements Show&lt;String, Date&gt; &#123; @Override public void show(String str, Date date) &#123; System.out.println(str + ", 现在的时间为" + date); &#125;&#125;// 接口2class ShowTest02 implements Show&lt;Integer, Integer&gt; &#123; @Override // 不同类型的参数 public void show(Integer a, Integer b) &#123; System.out.println("a+b的值为:" + (a + b)); &#125;&#125;/* * @Description:对两组不同的参数的对象进行输出测试 */public class testImplements &#123; public static void main(String[] args) throws ClassNotFoundException &#123; ShowTest01 showTest01 = new ShowTest01(); showTest01.show("Hello", new Date()); ShowTest02 showTest02 = new ShowTest02(); showTest02.show(7, 8); &#125;&#125;// 打印结果// Hello, 现在的时间为Wed Mar 27 21:02:59 CST 2019// a+b的值为:15 3) 泛型方法的定义和使用泛型类在多个方法签名间实施类型约束。 在 List&lt;V&gt; 中，类型参数 V 出现在 get()、add()、contains() 等方法的签名中。当创建一个 Map&lt;K, V&gt; 类型的变量时，您就在方法之间宣称一个类型约束。您传递给 add() 的值将与 get() 返回的值的类型相同 12345678910111213141516171819public class test &#123; public static void main(String[] args) throws ClassNotFoundException &#123; String str=get("Hello", "World"); System.out.println(str); int aa = get(1, 2); System.out.println(aa); &#125; public static &lt;T, U&gt; T get(T t, U u) &#123; if (u != null) return t; else return null; &#125;&#125;// 打印结果// Hello// 1 三、泛型变量的类型限定略 参考博客​ java泛型（一）、泛型的基本介绍和使用]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机知识---绝对路径与相对路径]]></title>
    <url>%2F2019%2F03%2F26%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86---%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[一. 基本概念 相对路径 : 顾名思义，相对路径就是相对于当前文件的路径。网页中一般表示路径使用这个方法。 1"/admin/add" 绝对路径 : 绝对路径就是你的主页上的文件或目录在硬盘上真正的路径。 硬盘上 : 你的Perl 程序是存放在 c:/apache/cgi-bin 下的，那么 c:/apache/cgi-bin就是cgi-bin目录的绝对路径 1c:/apache/cgi-bin 网络中 : 以http开头的链接都是绝对路径，绝对路径就是你的主页上的文件或目录在硬盘上真正的路径，绝对路径一般在CGI程序的路径配置中经常用到，而在制作网页中实际很少用到。 1https://www.baidu.com/ 二、相对路径使用的特殊符号相对路径使用的特殊符号 ./：代表目前所在的目录 ../ : 代表上一层目录 / : 代表根目录 根目录下有Site1和Image/Image.jpg，Site1下有Page1.html文件和Site2文件夹。Site2下有Page2.html和Page2Image.jpg图片文件。 1、文件在当前目录 12Page2.html访问Page2Image.jpg&lt;img src=”./Page2Image.jpg”&gt;或者&lt;img src=”Page2Image.jpg”&gt; 三. 绝对路径与相对路径的比较3.1 绝对路径的优点A、如果有人抄袭你的网站内容，里面的链接还会指向你的网站，有些抄袭的人比较懒，根本不会去改内容。其实也不局限于被抄袭，如果有人将你的网页保存到本地电脑中，里面的链接、图片、css、以及js仍然会连接到你的网站。 B、如果网页位置改变，里面的链接还是指向正确的URL。 3.2 绝对路径的缺点A、在编码编写时不方便使用绝对路径，因为链接应该指向真正的域名而不是开发站点。 相对路径的优缺点和绝对路径几乎相反。 3.3 相对路径的优点：A、容易移动内容，可以整个目录移动。 B、测试方法比较灵活，本机测试时比较方便。 3.4 相对路径的缺点：A、部分内容页面换了位置时，链接容易失效。 B、容易被人大面积采集抄袭。 相对路径和绝对路径在系统文件中与在网络中类似，文件的路径符号是斜线 “/”，而网络路径却是和它相反的反斜线“/” 四. 路径分割符在目录中的分隔符 在Windows中分隔符为 \ 在Unix/Linux中分隔符为 / 浏览器地址栏网址使用 / 有时我们会看到这样的路径写法，&quot;C:\\Windows\\System&quot;，也就是用两个反斜杠来分隔路径 这种写法在网络应用或编程中经 常看到，事实上，上面这个路径可以用 &quot;C:/Windows/System&quot; 来代替，不会出错。但是如果写成了 &quot;C:\Windows\System&quot; ， 那就可能会出现各种奇怪的错误了 在 Java程序中 反斜杠 \ 与不同的字符会组成不同的转义字符,如 \n 代表换行, 在字符串中要表示字符 \ , 需要写成 \\ ​ 字符串解析不仅仅局限于C编译器，Java编译器、一些配置文件的解析、Web服务器等等，都会遇到对字符串进行解析的这个问题，由于传统的 Windows采用的是单个反斜杠的路径分隔形式，导致在对文件路径进行解析的时候可能发生不必要的错误，所以就出现了用双反斜杠”\\”分隔路径的形式。 不管解析引擎是否将反斜杠解析成转义字符，最终在内存中得到的都是”\”，结果也就不会出问题了。 参考博文​ 关于绝对路径和相对路径 ​ 编程中常见的斜杠（”/“和”\”）问题 ​]]></content>
      <categories>
        <category>计算机知识</category>
      </categories>
      <tags>
        <tag>计算机知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---File]]></title>
    <url>%2F2019%2F03%2F26%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---File%2F</url>
    <content type="text"><![CDATA[一. 初识 File1.1 File类说明​ 存储在变量,数组和对象中的数据是暂时的,当程序终止时他们就会丢失. ​ 为了能够永久的保存程序中创建的数据,需要将他们存储到硬盘或光盘的文件中.这些文件可以移动,传送,亦可以被其他程序使用.由于数据存储在文件中,所以我们需要学习一个和文件有密切关系的类,叫做File类,将要掌握获取文件的属性以及删除和重命名文件.最终如何向文件中写入数据和从文件中读取数据. ​ File类关心的是在磁盘上文件的存储. 说明 File类描述的是一个文件或文件夹。（文件夹也可以称为目录） 该类的出现是对文件系统的中的文件以及文件夹进行对象的封装。可以通过对象的思想来操作文件以及文件夹。 可以用面向对象的处理问题，通过该对象的方法，可以得到文件或文件夹的信息方便了对文件与文件夹的属性信息进行操作。 文件包含很多的信息:如文件名、创建修改时间、大小、可读可写属性等。 1.2 体验File类​ 检验指定路径下是否存在指定的目录或者文件. 123456789// 检验指定路径下是否存在指定的目录或者文件.File file = new File("c:\\a.txt");System.out.println(file.exists());// File对象是否是目录System.out.println(file.isDirectory());// 对象是否是文件System.out.println(file.isFile()); 结论 File对象也可以表示不存在的文件。其实代表了一个抽象路径 构建一个File类的实例并不会在机器上创建一个文件.不管文件是否存在都可以创建任意文件名的File实例,可以调用File实例的exists方法判断文件或目录是否存在 1.3 创建File类12345678910// 通过将给定路径来创建一个新File实例。new File(String pathname);// 根据parent路径名字符串和child路径名创建一个新File实例。// parent是指上级目录的路径，完整的路径为parent+child.new File(String parent, String child);// 根据parent抽象路径名和child路径名创建一个新File实例。// parent是指上级目录的路径，完整的路径为parent.getPath()+child.new File(File parent, String child); 如果指定的路径不存在（没有这个文件或是文件夹），不会抛异常，这时file.exists()返回false 新建File对象File file=new File(); 12345678910public static void main(String[] args) &#123; // file01 是一个文件对象 String path01 = "c:/a.txt"; File file01 = new File(path); // file02 是一个文件夹 String path02 = "c:/test"; File file02 = new File(path);&#125; 注意 创建File对象需要导包, import java.io.File File对象没有无参数构造.创建对象需要传参. 根据API文档提示,传入一个文件的字符串路径. String path=&quot;c:/a.txt&quot;; (a.txt 文件在c盘下已经存在) File类的对象，既可以代表文件也可以代表文件夹 二. 路径​ 路径就是文件或文件夹所在的位置。 2.1 绝对路径与相对路径： 对于UNIX平台，绝对路径名的前缀是”/“。相对路径名没有前缀。 对于Windows平台，绝对路径名的前缀由驱动器号和一个”:”组成，例”c:\…”。相对路径没有盘符前缀。 一般在使用时，建议用绝对路径，因为相对路径容易出问题，不好确定到底在什么地方 实例1234567891011public class TestFile &#123; public static void main(String[] args) &#123; // 绝对路径 File f1 = new File("d:/LOLFolder"); System.out.println("f1的绝对路径：" + f1.getAbsolutePath()); // 相对路径,相对于工作目录，如果在eclipse中，就是项目目录 File f2 = new File("LOL.exe"); System.out.println("f2的绝对路径：" + f2.getAbsolutePath()); &#125;&#125; 2.2 路径分割符上下级文件夹之间使用分隔符分开 在Windows中分隔符为 \ 在Unix/Linux中分隔符为 / 跨平台的目录分隔符​ 更专业的做法是使用File.separatorChar，这个值就会根据系统得到的相应的分割符。例如: 1new File("c:" + File.separatorChar + "a.txt"); 注意 : 如果是使用”\”，则需要进行转义，写为”\“才可以，如果是两个”\”，则写为”\\“ 三. 操作文件的相关方法1) 创建 序号 方法名称 描述 14 public boolean createNewFile() throws IOException 在指定位置创建一个空文件，成功就返回true，如果已存在就不创建然后返回false 21 public boolean mkdir() 在指定位置创建目录，这只会创建最后一级目录，如果上级目录不存在就抛异常 22 public boolean mkdirs() 在指定位置创建目录，这会创建路径中所有不存在的目录 23 public boolean renameTo(File dest) 重新命名此抽象路径名表示的文件 2)获取文件相关 序号 方法名称 描述 1 public String getName() 返回由此抽象路径名表示的文件或目录的名称。 2 public String getParent() 返回此抽象路径名的父路径名的路径名字符串 3 public File getParentFile() 返回此抽象路径名的父路径名的抽象路径名 4 public String getPath() 将此抽象路径名转换为一个路径名字符串 6 public String getAbsolutePath() 返回抽象路径名的绝对路径名字符串 12 public long lastModified() 返回此抽象路径名表示的文件最后一次被修改的时间 13 public long length() 返回由此抽象路径名表示的文件的长度 文件夹相关 序号 方法名称 描述 3) 判断 序号 方法名称 描述 5 public boolean isAbsolute() 测试此抽象路径名是否为绝对路径名 7 public boolean canRead() 测试应用程序是否可以读取此抽象路径名表示的文件 9 public boolean exists() 测试此抽象路径名表示的文件或目录是否存在 10 public boolean isDirectory() 测试此抽象路径名表示的文件是否是一个目录 11 public boolean isFile() 测试此抽象路径名表示的文件是否是一个标准文件 参考博文​ java File类 ​ Java 关于File使用 ​ Java File类]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---Iterator迭代器]]></title>
    <url>%2F2019%2F03%2F26%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一. 迭代器概述1.1 迭代器模式​ 提供一种方法对一个容器对象中的各个元素进行访问，而又不暴露该对象容器的内部细节 1.2 什么是迭代器？ Java集合框架的集合类，我们有时候称之为容器。容器的种类有很多种，比如ArrayList、LinkedList、HashSet…，每种容器都有自己的特点，每种容器都有自己特有的数据结构。 因为容器的内部结构不同，很多时候可能不知道该怎样去遍历一个容器中的元素。所以为了使对容器内元素的操作更为简单，Java引入了迭代器模式！ 二. java.util.Iterator 在Java中Iterator为一个接口，它只提供了迭代的基本规则。 ​ 在JDK中它是这样定义的：对Collection进行迭代的迭代器。迭代器取代了Java Collection Framework中的Enumeration。 迭代器与枚举有两点不同: 迭代器在迭代期间可以从集合中移除元素。 方法名得到了改进，Enumeration的方法名称都比较长。 接口定义123456package java.util;public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); void remove();&#125; 三个方法解释 hasNext() : 如判断是否存在下一个对象元素.有仍有元素可以迭代,则返回true next() : 返回迭代的下一个元素 remove() : 从迭代器指向 collenction 中移除元素 三. java.util.Iterable Java中还提供了一个Iterable接口，Iterable接口实现后的功能是 “”返回“ 一个迭代器，我们常用的实现了该接口的子接口有:Collection、List、Set等。该接口的iterator()方法返回一个标准的Iterator实现。实现Iterable接口允许对象成为Foreach语句的目标。就可以通过foreach语句来遍历你的底层序列。 Iterable接口包含一个能产生Iterator对象的方法，并且Iterable被foreach用来在序列中移动。因此如果创建了实现Iterable接口的类，都可以将它用于foreach中。 接口定义123456Package java.lang;import java.util.Iterator;public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator();&#125; 四. 使用迭代器遍历集合12345678910111213141516171819202122public static void main(String[] args)&#123; List&lt;String&gt; list=new ArrayList&lt;&gt;(); list.add("abc"); list.add("edf"); list.add("ghi"); // 方式一, 不常用 for(Iterator&lt;String&gt; iterator = list.iterator(); it.hasNext(); ) &#123; System.out.println(iterator.next()); &#125; // 方式二, 常用 Iterator&lt;Person&gt; iterator = array.iterator(); while(iterator.hasNext() ) &#123; System.out.println(iterator.next().getName()); //输出的是wang，而不是tom &#125; // 使用forEach遍历 for(String string : List) &#123; System.out.println(string); &#125;&#125; 使用 foreach 遍历集合的优势在于代码更加的简洁，更不容易出错，不用关心下标的起始值和终止值。 参考博文​ 深入理解Java中的迭代器 ​ Java集合Iterator迭代器的实现 ​ Java迭代器(iterator详解以及和for循环的区别)]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---Session]]></title>
    <url>%2F2019%2F03%2F26%2FJavaWeb---Session%2F</url>
    <content type="text"><![CDATA[一. Session 概述1.1 简单介绍 在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。 2.2 Session和Cookie的主要区别 Cookie数据存储在客户端的浏览器内存中或本地缓存文件中，Session数据存储在服务器端的内存中。 Cookie数据存储安全性较低，Session数据存储安全性较高。 Session数据存储在服务器端内存中，访问增多时，降低服务器端性能。而Cookie则不会对服务器端性能造成影响。 单个Cookie存储的数据最大是4KB，一个网站只能存储20个Cookie。Session则没有这个问题。 Session在关闭浏览器时失效，而持久Cookie则可以存储更长有效时间。 Session对象由服务器创建，开发人员可以调用request对象的getSession方法得到session对象。 二. Session入门2.1 Session常用API request.getSession() : 获得HttpSession对象 session.setAttribute(String name, Object value) : 设置数据 session.getAttribute(String name) : 获取共享数据 实例123HttpSession session = request.getSession();session.setAttribute("name", "longestory");String name = (String)session.getAttribute("name"); 2.2 Servlet三大域对象现在掌握了 HttpSession 对象的基本使用方法，到目前为止，Servlet的 三大域对象 都已经掌握。 HttpServletRequest : 一个请求创建一个request对象，所以在同一个请求中可以共享request，例如一个请求从 AServlet 转发到 BServlet，那么 AServlet 和 BServlet 可以共享request域中的数据 ServletContext : 一个应用只创建一个 ServletContext 对象，所以在 ServletContext 中的数据可以在整个应用中共享，只要不启动服务器，那么 ServletContext 中的数据就可以共享 HttpSession : 一个会话创建一个对象，同一会话中的多个请求中可以共享session中的数据。 参考博文​ JavaWeb学习总结(十二)——Session ​ JavaWeb Session]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---文件上传与下载]]></title>
    <url>%2F2019%2F03%2F26%2FJavaWeb---%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[​ 在web应用系统开发中，文件上传和下载功能是非常常用的功能， ​ 对于文件上传，浏览器在上传的过程中是将文件以流的形式提交到服务器端的，如果直接使用Servlet获取上传文件的输入流然后再解析里面的请求参数是比较麻烦 ​ 一般选择采用apache的开源工具common-fileupload这个文件上传组件 一. 开发环境搭建创建一个 FileUploadAndDownLoad 项目，加入Apache的 commons-fileupload 文件上传组件的相关Jar包 12commons-io-1.4.jarcommons-fileupload-1.2.2.jar 二. 实现文件上传2.1 文件上传页面和消息提示页面upload.jsp 页面 123456&lt;form action="$&#123;pageContext.request.contextPath&#125;/servlet/UploadHandleServlet" enctype="multipart/form-data" method="post"&gt; 上传用户：&lt;input type="text" name="username"&gt;&lt;br/&gt; 上传文件1：&lt;input type="file" name="file1"&gt;&lt;br/&gt; 上传文件2：&lt;input type="file" name="file2"&gt;&lt;br/&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 注意 form 的 method 必须是 post 的，get不能上传文件。 还需要加上 enctype=&quot;multipart/form-data&quot; 表示提交的数据是二进制文件 需要提供 type=&quot;file&quot; 的字段进行上传 2.2 处理文件上传的ServletUploadHandleServlet 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class UploadHandleServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 得到上传文件的保存目录，将上传的文件存放于WEB-INF目录下，不允许外界直接访问，保证上传文件的安全 String savePath = this.getServletContext().getRealPath("/WEB-INF/upload"); File file = new File(savePath); // 判断上传文件的保存目录是否存在 if (!file.exists() &amp;&amp; !file.isDirectory()) &#123; System.out.println(savePath + "目录不存在，需要创建"); // 创建目录 file.mkdir(); &#125; // 消息提示 String message = ""; try&#123; // 使用Apache文件上传组件处理文件上传步骤： // 1、创建一个DiskFileItemFactory工厂 DiskFileItemFactory factory = new DiskFileItemFactory(); // 2、创建一个文件上传解析器 ServletFileUpload upload = new ServletFileUpload(factory); // 解决上传文件名的中文乱码 upload.setHeaderEncoding("UTF-8"); // 3、判断提交上来的数据是否是上传表单的数据 if(!ServletFileUpload.isMultipartContent(request))&#123; // 按照传统方式获取数据 return; &#125; // 4、使用ServletFileUpload解析器解析上传数据，解析结果返回的是一个List&lt;FileItem&gt;集合，每一个FileItem对应一个Form表单的输入项 List&lt;FileItem&gt; list = upload.parseRequest(request); for(FileItem item : list)&#123; // 如果fileitem中封装的是普通输入项的数据 if(item.isFormField())&#123; String name = item.getFieldName(); // 解决普通输入项的数据的中文乱码问题 String value = item.getString("UTF-8"); // value = new String(value.getBytes("iso8859-1"),"UTF-8"); System.out.println(name + "=" + value); &#125; else &#123; // 如果fileitem中封装的是上传文件 // 得到上传的文件名称， String filename = item.getName(); System.out.println(filename); if(filename==null || filename.trim().equals(""))&#123; continue; &#125; // 注意：不同的浏览器提交的文件名是不一样的，有些浏览器提交上来的文件名是带有路径的，如： c:\a\b\1.txt，而有些只是单纯的文件名，如：1.txt // 处理获取到的上传文件的文件名的路径部分，只保留文件名部分 filename = filename.substring(filename.lastIndexOf("\\")+1); // 获取item中的上传文件的输入流 InputStream in = item.getInputStream(); // 创建一个文件输出流 FileOutputStream out = new FileOutputStream(savePath + "\\" + filename); //创建一个缓冲区 byte buffer[] = new byte[1024]; //判断输入流中的数据是否已经读完的标识 int len = 0; //循环将输入流读入到缓冲区当中，(len=in.read(buffer))&gt;0就表示in里面还有数据 while((len=in.read(buffer))&gt;0)&#123; //使用FileOutputStream输出流将缓冲区的数据写入到指定的目录(savePath + "\\" + filename)当中 out.write(buffer, 0, len); &#125; //关闭输入流 in.close(); //关闭输出流 out.close(); //删除处理文件上传时生成的临时文件 item.delete(); message = "文件上传成功！"; &#125; &#125; &#125;catch (Exception e) &#123; message= "文件上传失败！"; e.printStackTrace(); &#125; request.setAttribute("message",message); request.getRequestDispatcher("/message.jsp").forward(request, response); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 参考博文​ JavaWeb学习总结(五十)——文件上传和下载 ​ Java文件上传功能代码 —— 普遍适用 ​ JavaWeb开发之网站实现文件上传功能]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript---函数]]></title>
    <url>%2F2019%2F03%2F26%2FJavaScript---%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一. 定义 名称 作用 function 关键字 print 函数名称 (message) 参数列表,参数为message { 函数开始 返回结果 } 函数结束 实例123456789&lt;script&gt; function print(message)&#123; document.write("这一句话是由一个自定义函数打印"); return message + "!!!!" &#125; &lt;!-- 光有函数的定义，还不够，它不会自动执行,需要调用--&gt; print();&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---流]]></title>
    <url>%2F2019%2F03%2F25%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%B5%81%2F</url>
    <content type="text"><![CDATA[一. 流式输入/输出原理1) 流是用来==读写==数据的​ Java有一个类叫File，它封装的是文件的文件名，只是内存里面的一个对象，真正的文件是在硬盘上的一块空间，在这个文件里面存放着各种各样的数据. 2) 如何读文件里面的数据？​ 通过流的方式来读 ​ 咱们要想从程序读数据，对于计算机来说，无论读什么类型的数据都是以010101101010这样的形式读取的。可以把文件想象成一个桶，文件里面的数据就相当于是这个桶里面的水 怎么从这个桶里面取水 (怎么从这个文件读取数据) 取水办法 : 用一根管道插到桶上面，然后在管道的另一边打开水龙头，桶里面的水就开始哗啦哗啦地从水龙头里流出来了，桶里面的水是通过这根管道流出来的，因此这根管道就叫流 JAVA里面的 流式输入/输出 跟水流的原理一模一样，当你要从文件读取数据的时候，一根管道插到文件里面去，然后文件里面的数据就顺着管道流出来，这时你在管道的另一头就可以读取到从文件流出来的各种各样的数据了。当你要往文件写入数据时，也是通过一根管道，让要写入的数据通过这根管道哗啦哗啦地流进文件里面去。 除了从文件去取数据以外，还可以通过网络，比如用一根管道把我和你的机子连接起来，我说一句话，通过这个管道流进你的机子里面，你马上就可以看得到，而你说一句话，通过这根管道流到我的机子里面，我也马上就可以看到。 有的时候，一根管道不够用，比方说这根管道流过来的水有一些杂质，我们就可以在这个根管道的外面再包一层管道，把杂质给过滤掉。从程序的角度来讲，从计算机读取到的原始数据肯定都是010101这种形式的，一个字节一个字节地往外读，当你这样读的时候你觉得这样的方法不合适，没关系，你再在这根管道的外面再包一层比较强大的管道，这个管道可以把010101帮你转换成字符串。这样你使用程序读取数据时读到的就不再是010101这种形式的数据了，而是一些可以看得懂的字符串了。 理解 原始 类比成 文件 一个桶 文件中的数据 桶中的水 Java 流式输入/输出 接水的管道 更强大的管道 过滤杂质 二. 输入输出流分类io包里面定义了所有的流，所以一说流指的就是 io 包 里面的 用一根管道一端插进文件里程序里面，然后开始读数据，那么这是输入还是输出呢？ 在文件的角度上，这叫输出 在程序的角度上，这叫输入 以后说输入流和输出流都是站在==程序==的角度上来说 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer ​ 这4个类都是抽象类，可以把这4个类想象成4根不同的管道，一端接着你的程序，另一端接着数据源，你可以通过输出管道从数据源里面往外读数据，也可以通过输入管道网数据源里面输入数据，总之通过这4根管道可以让数据流进来和流出去. 所有类型位于 java.io 内部都分别继承这4种抽象流类型 从不同的角度进行分类 按数据流的方向不同，可以分为输入流和输出流 按处理数据单位不同可以分为字节流和字符流 字符流 : 一个字符, 一个字符的往外读数据，一个字符是两个字节 字节流 : 一个字节, 一个字节的往外读数据, 一个字节是八位 按功能不同可以分为节点流和处理流 三. 节点流和处理流3.1 节点流类型 类型 字符流 字节流 File(文件) FileReader / FileWriter FileInputStream / FileOutputStream Memory Array CharArrayReader / CharArrayWriter ByteArrayInputStream / ByteArrayOutputStream Memory String StringReader / StringWriter — Pipe(管道) PipedReader / PipedWriter PipedInputStream / PipedOutputStream 可以从一个特定的数据源 (节点) 读写数据 (如: 文件, 内存) 就像一根管道直接插到数据源上面，直接读数据源里面的数据，或者是直接往数据源里面写入数据。，这根管道就叫做节点流 典型的节点流是文件流： 文件的字节输入流（FileInputStream），文件的字节输出流（FileOutputStream） 文件的字符输入流（FileReader），文件的字符输出流（FileWriter） 3.2 处理流类型 处理流是包在别的流上面的流，相当于是包到别的管道上面的管道 (通过对数据的处理为程序提供更为强大的读写功能) 为什么需要处理流呢？ 这就跟水流里面有杂质，你要过滤它，你可以再套一层管道过滤这些杂质一样。 四. InputStream(输入流)继承自 inputStream 的流都是用于向程序中输入数据且数据的单位为字节 凡是以 inputStream 结尾的管道，都是以字节的形式向我们的程序输入数据 基本方法12345678910111213// 读取一个字节并以整数的形式返回 (ASCII 0~255)// 如果返回 -1 已到输入流的末尾int read() throws IOException// 读取一个字节，并存到一个数组 buffer// 返回实际读取的字节数，如果读取前已到输入流的末尾返回-1int read(byte[] buffer) throws IOException// 关闭流释放内存资源void close() throws IOException// 跳过n个字节不读，返回实际跳过的字节数long skip(long n) throws IOException 总结 read() 的方法是一个字节，一个字节的往外读，每读取一个字节就处理一个字节. read(byte[] buffer) 方法读取数据时先把读取到的数据填满这个 byte[] 的buffer (buffer是内存里面一块缓冲区), 然后再处理数组里面的数据 这就跟我们取水一样，先用一个桶去接，等桶接满后再处理桶里面的水，如果是每读取一个字节就处理一个字，这样读取也太累了 五. OutputStream(输出流)继承自outputStream 的流是用于程序中输入数据, 且数据的单位为字节(8 bit) 基本方法123456789101112131415// 将输出流中写入一个字节的数据，该字节数据为参数b的低8位void write(int b) throws IOException// 将一个字节类型的数据中的数据写入输出流int write(byte[] buffer) throws IOException// 将一个字节类型的数组中的从指定位置(off)开始// len 个字节写入到输出流void write(byte[] b, int off, int len) throws IOException// 关闭流释放内存资源void close() throws IOException// 将输出流中缓冲区的数据全部写出到目的地void flush() throws IOException 六. Reader流一个字符也就是两个字节，使用 Reader 流读取数据时都是两个字节，两个字节的往外读 为什么还要有这种两个字节的读取方式呢？ 因为有些字符是占两个字节的，如我们中文字符在Java里面就是占两个字节的，如果采用一个字节一个字节往外读的方式，那么读出来的就是半个汉子，这样Java是没有办法正确显示中文字符的所有必要存在这种留一个字符，一个字符的往外读， 和 inputStream 一模一样，唯一的区别就是在于读的数据单位不同 基本方法1234567891011121314151617// 读取一个字节并以整数的形式返回(0~255)// 如果返回 -1 已到输入流的末尾int read() throws IOException// 读取一个字节，并存到一个数组 buffer// 返回实际读取的字节数，如果读取前已到输入流的末尾返回-1int read(char[] cbuf) throws IOException// 读取length个字符并存储到一个数组buffer// 从length位置开始,返回实际读取的字符数,如果读取前已到输入流的末尾返回-1int read(char[] cbuf, int offset, int length) throws IOException// 关闭流释放内存资源void close() throws IOException// 跳过n个字节不读，返回实际跳过的字节数long skip(long n) throws IOException 七. Writer流继承自writer的流都是用于程序中输出数据, 且数据的单位为字符(16 bit) 基本方法123456789101112131415// 将输出流中写入一个字节的数据，该字节数据为参数b的低 16 位void write(int b) throws IOException// 将一个字符类型的数据中的数据写入输出流int write(byte[] buffer) throws IOException// 将一个字符类型的数组中的从指定位置(offset)开始// len 个字节写入到输出流void write(char[] cbuf, int offset, int length) throws IOException// 关闭流释放内存资源void close() throws IOException// 将输出流中缓冲区的数据全部写出到目的地void flush() throws IOException 八. 节点流讲解 以File(文件)这个类型作为讲解节点流的典型代表 范例：使用 FileInputStream 流来读取文件的内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class TestFileInputStream &#123; public static void main(String args[]) &#123; // 使用变量b来装调用read()方法时返回的整数 int b = 0; // 使用FileInputStream流来读取有中文的内容时，读出来的是乱码 FileInputStream in = null; //使用FileReader流来读取内容时，中英文都可以正确显示 // FileReader in = null; try &#123; in = new FileInputStream("G:\\test.txt"); // in = new FileReader("G:/test.txt"); &#125; catch (FileNotFoundException e) &#123; System.out.println("系统找不到指定文件！"); System.exit(-1); // 系统非正常退出 &#125; // 使用变量num来记录读取到的字符数 long num = 0; try &#123; // 调用read()方法时会抛异常，所以需要捕获异常 // 循环结束的条件就是返回一个值-1，表示此时已经读取到文件的末尾了 while ((b = in.read()) != -1) &#123; // 如果没有使用“(char)b”进行转换，那么直接打印出来的b就是数字，而不是英文和中文了 // System.out.print(b+" "); // “char(b)”把使用数字表示的汉字和英文字母转换成字符输入 System.out.print((char) b); num++; &#125; // 关闭输入流 in.close(); System.out.println(); System.out.println("总共读取了" + num + "个字节的文件"); &#125; catch (IOException e1) &#123; System.out.println("文件读取错误！"); &#125; &#125;&#125;// 打印结果// 104 101 108 108 111 32 119 111 114 108 100 32 33 33// hello world !!// 总共读取了14个字节的文件 范例：使用 FileOutputStream 流往一个文件里面写入数据1234567891011121314151617181920212223242526public class TestFileOutputStream &#123; public static void main(String args[]) &#123; int b = 0; FileInputStream in = null; FileOutputStream out = null; try &#123; in = new FileInputStream("D:\\Java\\MyEclipse 10\\Workspaces\\AnnotationTest\\src\\cn\\galc\\test\\MyMouseAdapter.java"); out = new FileOutputStream("D:/java/TestFileOutputStream1.java"); // 指明要写入数据的文件，如果指定的路径中不存在TestFileOutputStream1.java这样的文件，则系统会自动创建一个 while ((b = in.read()) != -1) &#123; out.write(b); // 调用write(int c)方法把读取到的字符全部写入到指定文件中去 &#125; in.close(); out.close(); &#125; catch (FileNotFoundException e) &#123; System.out.println("文件读取失败"); System.exit(-1);// 非正常退出 &#125; catch (IOException e1) &#123; System.out.println("文件复制失败！"); System.exit(-1); &#125; System.out .println("TestFileInputStream.java文件里面的内容已经成功复制到文件TestFileOutStream1.java里面"); &#125;&#125; FileInputStream 和 FileOutputStream 这两个流都是字节流，都是以一个字节为单位进行输入和输出的.所以对于占用2个字节存储空间的字符来说读取出来时就会显示成乱码 范例：使用FileWriter（字符流）向指定文件中写入数据有点问题,回头在补充 12 九. 处理流讲解9.1 第一种处理流——缓冲流(Buffering)缓冲流就要嵌套在相应的节点流上，对读写的数据提供了缓冲的功能，提高了读写的效率，同时增加了一些新的方法 J2SDK 提供了四种缓冲流，其常用的构造方法为 12345678BufferReader(Reader in)BufferReader(Reader in, int sz) // sz 为自定义缓存区的大小BufferReader(Writer out)BufferReader(Writer out, int sz)BufferReader(InputStream in)BufferReader(InputStream in, int size)BufferReader(OutputStream out)BufferReader(OutputStream out, int size) 注意 缓冲输入流支持其父类的Mark和reset方法 BufferedReader 提供流 readLine 方法用于读取一行字符串(以\r或\n分隔) BufferedWriter提供了newLine用于写入一个行分隔符 对于输出的缓冲流写出的数据会先在内存中缓存, 使用 flush 方法将会使内存中的数据立刻写出 ​ 带有缓冲区的，缓冲区(Buffer)就是内存里面的一小块区域，读写数据时都是先把数据放到这块缓冲区域里面，减少 io 对硬盘的访问次数，保护我们的硬盘。 ​ 可以把缓冲区想象成一个小桶，把要读写的数据想象成水，每次读取数据或者是写入数据之前，都是先把数据装到这个桶里面，装满了以后再做处理。这就是所谓的缓冲。先把数据放置到缓冲区上，等到缓冲区满了以后，再一次把缓冲区里面的数据写入到硬盘上或者读取出来，这样可以有效地减少对硬盘的访问次数，有利于保护我们的硬盘 缓冲流读取1234567891011121314151617181920212223242526272829303132public class TestBufferStream &#123; public static void main(String args[]) &#123; FileInputStream fis = null; try &#123; fis = new FileInputStream("D:/java/TestFileInputStream.java"); // 在FileInputStream节点流的外面套接一层处理流BufferedInputStream BufferedInputStream bis = new BufferedInputStream(fis); int c = 0; System.out.println((char) bis.read()); System.out.println((char) bis.read()); // 在第100个字符处做一个标记 bis.mark(100); for (int i = 0; i &lt;= 10 &amp;&amp; (c = bis.read()) != -1; i++) &#123; System.out.print((char) c); &#125; System.out.println(); // 重新回到原来标记的地方 bis.reset(); for (int i = 0; i &lt;= 10 &amp;&amp; (c = bis.read()) != -1; i++) &#123; System.out.print((char) c); &#125; bis.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (Exception e1) &#123; e1.printStackTrace(); &#125; &#125;&#125; 缓冲流写入12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TestBufferStream1 &#123; public static void main(String args[]) &#123; try &#123; /* * 往文件 dat2.txt 写入数据的时候,直接从节点流FilterWriter写入觉得不好写， * 因此在节点流外部包了一层处理流 BufferedWriter， * 这样写入数据时是先通过处理流把数据写入到缓冲区(Buffer)里面， * 再通过节点流写入到文件 dat2.txt */ BufferedWriter bw = new BufferedWriter(new FileWriter("G:\\dat.txt")); // 在节点流FileWriter的外面再套一层处理流BufferedWriter String s = null; for (int i = 0; i &lt; 5; i++) &#123; // Math.random() 将会生成一系列介于0～1之间的随机数。 // static String valueOf(double d) // 这个valueOf()方法的作用就是把一个double类型的数转换成字符串 s = String.valueOf(Math.random()); /* *读出来的文件的内容是装在了s这个字符串变量里面了， * 也就是存放在内存里面名字为s的那块区域里面， * 即读取到的文件内容是纯处在内存里面的 */ bw.write(s);// 把随机数字符串写入到指定文件中 bw.newLine();// 调用newLine()方法使得每写入一个随机数就换行显示 &#125; // 调用flush()方法清空缓冲区 bw.flush(); /* * 读取这个文件里面的数据是通过节点流直接读取数据，是一个字符一个字符的读取， * 这样读取的效率太慢了，因此在节点流 FileReader 外部包了一层处理流 BufferedReader, * 先要把读取的数据通过 BufferedReader 处理流存放到内存的缓冲区里面， * 然后再使用方法 flush() 把缓冲区里面的数据立刻写出来， * */ BufferedReader br = new BufferedReader(new FileReader("G:\\dat.txt")); // 在节点流FileReader的外面再套一层处理流BufferedReader while ((s = br.readLine()) != null) &#123; // 使用BufferedReader处理流里面提供String readLine()方法读取文件中的数据时是一行一行读取的 // 循环结束的条件就是使用readLine()方法读取数据返回的字符串为空值后则表示已经读取到文件的末尾了。 System.out.println(s); &#125; bw.close(); br.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; ​ 程序的输入指的是把从文件读取到的内容存储到为程序分配的内存区域里面去。 9.2 转换流 InputStreamReader和 OutputStreamWriter用于字节数据到字符数据之间的转换 InputStreamReader 需要和 InputStream “套接” OutStreamWriter 需要和 OutputStream “套接” InputStream isr = InputStreamReader(System.in, &quot;ISO8859_1&quot;) 转换流非常的有用，它可以把一个字节流转换成一个字符流 转换流有两种， InputStreamReader : 把 InputStream 转换成 Reader OutputStreamWriter : 把 OutputStream 转换成 Writer, 而且还可以写入字符串 12345678910111213141516171819202122232425262728293031public class TestTransform1 &#123; public static void main(String args[]) &#123; try &#123; // 使用了转换流之后就可以字符串的形式写入文件里面， // 提高了写入的速度，也减少了对硬盘的访问次数 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("G:\\char.txt")); // 把字符串写入到指定的文件中去 osw.write("My name is 小明."); // 使用getEncoding()方法取得当前系统的默认字符编码 System.out.println(osw.getEncoding()); osw.close(); // 这里如果不写true，那么前面的数据将会被后面写入的数据给替换掉， // 如果写了true,那么后面写出的数据就会跟在前面写入的数据后面不会替换掉前面写入的数据 // 在调用构造方法时指定了字符的编码 osw = new OutputStreamWriter(new FileOutputStream("G:\\char.txt", true), "ISO8859_1"); // 再次向指定的文件写入字符串，新写入的字符串加入到原来字符串的后面 osw.write("My name is 小明."); System.out.println(osw.getEncoding()); osw.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;// char.txt 里面的内容// My name is 小明.My name is ??. 范例2(接受键盘输入的数据)1234567891011121314151617181920212223242526public class TestTransform2 &#123; public static void main(String args[]) &#123; try &#123; // System.in这里的in是一个标准的输入流，用来接收从键盘输入的数据 InputStreamReader isr = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(isr); String s = null; // 使用readLine()方法把读取到的一行字符串保存到字符串变量s中去 s = br.readLine(); while (s != null) &#123; System.out.println(s.toUpperCase()); // 在循环体内继续接收从键盘的输入 s = br.readLine(); // 只要输入exit循环就结束，就会退出 if (s.equalsIgnoreCase("exit")) &#123; break; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 9.3 数据流9.4 打印流—Print9.5 对象流—Object十. IO流总结 参考博文​ java基础学习总结——流 ​ JAVA基础知识之IO——Java IO体系及常用类 ​ Java中IO流，输入输出流概述与总结 ​ Java IO最详解 ​ Java输入输出流]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML---form表单]]></title>
    <url>%2F2019%2F03%2F25%2FHTML---form%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[一. 表单的作用​ 表单用于显示、收集信息，并将信息提交给服务器 二. form 属性 属性 描述 name 规定识别表单的名称（对于 DOM 使用：document.forms.name）。 method 规定在提交表单时所用的 HTTP 方法（默认：GET , 一般有两种方法 GET 和 POST） action 规定向何处提交表单的地址（URL）（提交页面）。 enctype 规定被提交数据的编码（默认：url-encoded）。 target 规定 action 属性中地址的目标（默认：_self）。 accept-charset 规定在被提交表单中使用的字符集（默认：页面字符集）。 autocomplete 规定浏览器应该自动完成表单（默认：开启）。 novalidate 规定浏览器不验证表单。 name 属性​ 通过为表单命名可以控制表单与后台程序之间的关系。 method 属性​ 当不指明是哪种方式时，默认为GET方式。 enctype 属性​ 设置表单信息提交的编码方式，有以下几种： TEXT/plain : 只允许提交普通字符。特殊字符，文件等都无法提交 Application/x-www-Form-urlencoded : 默认的编码形式, 允许将 普通字符，特殊字符，都提交给服务器，不允许提交 文件 Multipart/Form-data : 使用MINE编码, 允许将文件提交给服务器 注意: 如果有文件需要提交给服务器，method必须为POST，enctype必须为multipart/form-data TARGET属性​ 设置表单信息返回的窗口 TARGET的值有以下几种： blank:将返回信息显示在新开的浏览器窗口中 parent:将返回信息显示在父级浏览器窗口中 self:将返回信息显示在当前浏览器窗口中 top:将返回信息显示在顶级浏览器窗口中 autocomplete 属性​ 表单或输入字段是否应该自动完成。 当自动完成开启，浏览器会基于用户之前的输入值自动填写值。 注意 : 您可以把表单的 autocomplete 设置为 on，同时把特定的输入字段设置为 off，反之亦然。 三. form 表单提交方式3.1 利用submit按钮实现提交当点击submit按钮时，触发onclick事件，由JavaScript里函数判断输入内容是否为空，如果为空，返回false, 不提交，如果不为空，提交到由action指定的地址 12345&lt;form action="login.do?act=login" method="post"&gt; 用户帐号 &lt;input type=text name="userId" size="18" value="" &gt;&lt;br&gt; 登录密码 &lt;input type="password" name="password" size="19" value=""/&gt; &lt;input type=submit name="submit1" value="登陆"&gt; &lt;/form&gt; 参考博文​ 表单FORM的5个属性name,method,action,enctype,target ​ HTML 表单 ​ 前端HTML表单的属性和使用]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML---input属性]]></title>
    <url>%2F2019%2F03%2F25%2FHTML---input%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[一. input 属性 name : 元素的名称；这个不需要多解释了，也就是name的取值代表为当前input元素起个名字 width : 当 input type=”image”时，通过width属性控制元素的宽度； height : 当 input type=”image”时，通过width属性控制元素的高度； type : 该属性是input标签里唯一的必须输入的属性，默认为type = “text” size : 元素的宽度；很多人都知道在HTML中，常见的宽度是用 width 表示的，而在input中 width 属性只使用与 type=&quot;image&quot; 时使用，input元素的宽度需要通过size属性来设定，size的值为 数字 step : 和max min类似，作用是提供一个可以上下点的按钮，比如当前数字是1，你设置了step = “5”，点一下上的按钮，就变成6了。 placeholder : 一般是用来提示用户输入的，当用户真的输入了文字之后，会被输入的文字覆盖。 readonly : 顾名思义，该属性会让表单空控件不可编辑。这里的不可编辑不是禁用，只是不能编辑文本而已，比如像单选框radio，复选框checkbox这种，本来就是不可编辑的，所以这个属性对它们来说毫无意义 disabled : 该属性会禁用一个表单元素。这里是禁用，完全禁用掉除了 &lt;output&gt; 之外的所有表单元素 maxlength : 该属性用于限制用户输入的最大字数限制。 autocomplete : 顾名思义，自动完成，用户输入一部分，后面的自动补全。需要浏览器保存用户输入的内容，以便下一次自动补全。 autofocus : 该属性指的是表示这个表单控件在页面载入的时候自动获得焦点。 二. input中的type属性&lt;input type=&quot;text&quot;&gt; : 如果一个input没有type属性，那么它会是默认type=”text”。允许输入文本&lt;input type=&quot;password&quot;&gt; : 用户输入的文字将会变成 * ,传给后台会是用户输入的文本。&lt;input type=&quot;checkbox&quot;&gt; : 复选框，默认是小方格，可以选择多个。&lt;input type=&quot;radio&quot;&gt; : 单选框，默认是小圆圈，只能选择一个。 &lt;input type=&quot;submit&quot;&gt;：提交按钮，当点击此按钮时，提交本表单的数据。&lt;input type=&quot;file&quot;&gt;：用于从本地硬盘中上传文件并提交 input的file类型的accept属性的值 值 描述 audio/* 接受所有的声音文件。 video/* 接受所有的视频文件。 image/* 接受所有的图像文件。 MIME_type 一个有效的 MIME 类型，不带参数 &lt;input type=&quot;hidden&quot;&gt; : 隐藏域在页面上不显示，用来存储与传递表单的值，当用户提交表单时，隐藏域的内容会一起提交给处理程序&lt;input type=&quot;image&quot;&gt; : 图像按钮, 该属性接受所有，将会像submit一样提交图片，如果想上传图片，照片，不妨使用这个属性。&lt;input type=&quot;reset&quot;&gt; ：重置按钮，点了这个按钮，表单的数据全部重置，也就是清空的意思&lt;input type=&quot;button&quot;&gt; ：表单按钮，和单纯的元素相比，没有&lt;button&gt;使用CSS方便，所以如果你不是想用这个按钮去重置（reset）或者提交（submit），并且为了和传统的表单风格相比配的话，建议你都使用而不是 以上的都是HTML5以前都有的属性，下面是新增的（跟键盘有关的都是要配合手机端使用才有效果）： ：该属性外观上和文本栏相似，用于指定一个电子邮箱地址。在web端没有什么差别，但是在手机端就不一样了，输入键盘会自动的变成有@ 数字 A-Z .等，与输入邮箱有关的字符，用户体验直线上升，有木有？ ：外观功能和 类似，用于指定一个web地址。在手机端上会自动转换成有类似于.com \等方便用户输入web地址的键盘。 ：用于指定输入的是电话号码。键盘就会变成输入电话号码的键盘。当然，也可以自己定义一些格式什么的，比如023-1235····之类的，需要与pattern属性连用。 ：用于指定输入的是数字，键盘为输入数字的键盘。 ：变成一个滑动条，不同的客户端显示出默认的样式是不一样的。用户可以左右滑动。webkit中可以使用CSS：input[type=range]{=webkit-appearance:slider-vertical}让滑动条竖起来。 ：提供一个搜索栏。如果有文本输入的话，很多浏览器会在最右边提供一个清空搜索栏的小叉，点了就清空该搜索栏。 ：在浏览器支持的情况下，提供一个拾色器，虽然功能没有PS里面的那么强大，不过感觉和window自带的图画功能里面的拾色器差不多。 ：顾名思义，日期选择器，可以用来选择年月日。 ：该属性提供两个栏，一个年月日，一个用于时分秒。时区被设置成了UTC。 ：和 几乎完全一样，只是不是UTC时间。 ：只包括了年，月的时间选择器。 ：只包括了时分秒的时间选择器，而且是24小时制。 ：该属性是输入多少年的多少周，你可以选择日期，但是返回的是XXXX年XX周。 参考博文​ input标签 各属性解释 ​ html5的input类型和所有属性详解]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---GET 与 POST]]></title>
    <url>%2F2019%2F03%2F25%2FJavaWeb---get%E4%B8%8Epost%2F</url>
    <content type="text"><![CDATA[一. GET 方法从指定的资源请求数据, 查询字符串（名称/值对）是在 GET 请求的 URL 中发送的 GET 方法向页面请求发送已编码的用户信息。页面和已编码的信息中间用 ? 字符分隔，如下所示： ​ http://www.test.com/hello?key1=value1&amp;key2=value2 解释 GET 方法是默认的从浏览器向 Web 服务器传递信息的方法，它会产生一个很长的字符串，出现在浏览器的地址栏中。如果您要向服务器传递的是密码或其他的敏感信息，请不要使用 GET 方法。 GET 方法有大小限制：请求字符串中最多只能有 1024 个字符。 这些信息使用 QUERY_STRING 头传递，并可以通过 QUERY_STRING 环境变量访问，Servlet 使用 doGet() 方法处理这种类型的请求。 二. POST 方法123POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2 三. 两者比较 GET POST 后退按钮/刷新 无害 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中。 参数不会保存在浏览器历史中。 对数据长度的限制 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 无限制。 对数据类型的限制 只允许 ASCII 字符。 没有限制。也允许二进制数据。 安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。 在发送密码或其他敏感信息时绝不要使用 GET ！ POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 可见性 数据在 URL 中对所有人都是可见的。 数据不会显示在 URL 中。 参考博文​ HTTP 方法：GET 对比 POST ​ HTTP协议中GET和POST方法的区别 ​ Get与Post区别与范例讲解]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用类---基本类型之间的转换]]></title>
    <url>%2F2019%2F03%2F25%2FJava%E5%B8%B8%E7%94%A8%E7%B1%BB---%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[一. 装箱与拆箱1.1 概述​ 虽然 Java 语言是典型的面向对象编程语言，但其中的八种基本数据类型并不支持面向对象编程，基本类型的数据不具备“对象”的特性——不携带属性、没有方法可调用。 沿用它们只是为了迎合人类根深蒂固的习惯，并的确能简单、有效地进行常规数据处理。 这种借助于非面向对象技术的做法有时也会带来不便，比如引用类型数据均继承了 Object 类的特性，要转换为 String 类型（经常有这种需要）时只要简单调用 Object 类中定义的 toString() 即可，而基本数据类型转换为 String 类型则要麻烦得多。为解决此类问题 ，Java为每种基本数据类型分别设计了对应的类，称之为包装类(Wrapper Classes) 1.2 基本数据类型及对应的包装类 基本数据类型 对应的包装类 byte Byte short Short int Integer long Long char Character float Float double Double boolean Boolean 每个包装类的对象可以封装一个相应的基本类型的数据，并提供了其它一些有用的方法。包装类对象一经创建，其内容（所封装的基本类型数据值）不可改变。 基本类型和对应的包装类可以相互装换 由基本类型向对应的包装类转换称为装箱，例如把 int 包装成 Integer 类的对象； 包装类向对应的基本类型转换称为拆箱，例如把 Integer 类的对象重新简化为 int 1.3 自动拆箱和装箱在进行基本数据类型和对应的包装类转换时，系统将自动进行，这将大大方便程序员的代码书写。 实例12345678910111213public class Demo &#123; public static void main www.120xh.cn (String[] args) &#123; int m = 500; Integer obj = m; // 自动装箱 int n = obj; // 自动拆箱 System.out.println("n = " + n); Integer obj1 = 500; System.out.println("obj 等价于 obj1？" + obj.equals(obj1)); &#125;&#125;// 运行结果// n = 500// obj 等价于 obj1？true 二. 基本类型之间的转换1. 将字符串转化为整型12int i = Integer.parseInt(String str);int i = Integer.valueOf(String str).intValue(); 注意 Integer.parseInt 和 Integer.valueOf 不同，前者生成的是整型，而后者是一个对象，所以要通过intValue()来获得对象的值； 字串转成 Double, Float, Long 的方法大同小异 2. 整型转化为字符串123String str = String.valueOf(int i);String str = Integer.toString(int i);String str = “” + i ; 注意 : Double, Float, Long 的方法大同小异. 3. Long 转化为 date SimpleDateFormat sf = new SimpleDateFormat(“yyyy/MM/dd HH:mm:ss”); //tieml,timef是long,前面转化过来的 Date date = new Date(timel - timef); String time = sf.parse(date); 1、float型转换为double型： float f1=100.00f; Float F1=new Float(f1); //F1.doubleValue()为Float类的返回double值型的方法 double d1=F1.doubleValue(); 2、double型转换为int型： double d1=100.00; Double D1=new Double(d1); int i1=D1.intValue(); 3、int型转换为double型： int i1=200; double d1=i1; (2). 字符串与其它数据类型的转换 4、字符串与其它类型间的转换： ⑴其它类型向字符串的转换 ①调用类的串转换方法:X.toString(); ②自动转换:X+“”; ③使用String的方法:String.valueOf(X); ⑵字符串作为值,向其它类型的转换 ①先转换成相应的封装器实例,再调用对应的方法转换成其它类型 例如，字符中“32.1”转换double型的值的格式为:new Float(“32.1”).doubleValue()。 也可以用:Double.valueOf(“32.1”).doubleValue() ②静态parseXXX方法 String s = “1”; byte b = Byte.parseByte( s ); short t = Short.parseShort( s ); int i = Integer.parseInt( s ); long l = Long.parseLong( s ); Float f = Float.parseFloat( s ); Double d = Double.parseDouble( s ); ③Character的getNumericValue(char ch)方法 返回指定的 Unicode 字符表示的 int 值。 参考博文​ java的常见类型转换 ​ JAVA数据类型转换大全]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java常用类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---XML详解(2)]]></title>
    <url>%2F2019%2F03%2F25%2FJavaWeb---XML%E8%AF%A6%E8%A7%A3(2)%2F</url>
    <content type="text"><![CDATA[一. web.xml 的加载过程​ 当启动一个WEB项目时，容器包括 (JBoss、Tomcat等) 首先会读取项目web.xml配置文件里的配置，当这一步骤没有出错并且完成之后，项目才能正常地被启动起来 启动WEB项目的时候，容器首先会去它的配置文件web.xml读取两个节点 : &lt;listener&gt;&lt;/listener&gt; 和 &lt;context-param&gt;&lt;/context-param&gt; 紧接着，容器创建一个ServletContext（Application），这个WEB项目所有部分都将共享这个上下文。 容器以 &lt;context-param&gt;&lt;/context-param&gt; 的 name 作为键，value 作为值，将其转化为键值对，存入ServletContext 容器创建 &lt;listener&gt;&lt;/listener&gt; 中的类实例，根据配置的class类路径来创建监听，在监听中会有contextInitialized(ServletContextEvent args)初始化方法，启动Web应用时，系统调用Listener的该方法，在这个方法中获得：ServletContext application = ServletContextEvent.getServletContext(); context-param的值 = application.getInitParameter(“context-param的键”); 得到这个context-param的值之后，你就可以做一些操作了。 举例：你可能想在项目启动之前就打开数据库，那么这里就可以在中设置数据库的连接方式（驱动、url、user、password），在监听类中初始化数据库的连接。这个监听是自己写的一个类，除了初始化方法，它还有销毁方法，用于关闭应用前释放资源。比如:说数据库连接的关闭，此时，调用contextDestroyed(ServletContextEvent args)，关闭Web应用时，系统调用Listener的该方法。 接着，容器会读取，根据指定的类路径来实例化过滤器。 以上都是在WEB项目还没有完全启动起来的时候就已经完成了的工作。如果系统中有Servlet，则Servlet是在第一次发起请求的时候被实例化的，而且一般不会被容器销毁，它可以服务于多个用户的请求。所以，Servlet的初始化都要比上面提到的那几个要迟。 总的来说，web.xml的加载顺序是:-&gt;-&gt;-&gt;。其中，如果web.xml中出现了相同的元素，则按照在配置文件中出现的先后顺序来加载。 对于某类元素而言，与它们出现的顺序是有关的。以为例，web.xml中当然可以定义多个，与相关的一个元素是，注意，对于拥有相同的和元素而言，必须出现在之后，否则当解析到时，它所对应的还未定义。web容器启动初始化每个时，按照出现的顺序来初始化的，当请求资源匹配多个时，拦截资源是按照元素出现的顺序来依次调用doFilter()方法的。同类似，此处不再赘述。 二. web.xml标签详解2.1 XML文档有效性检查1&lt;!DOCTYPE web-app PUBLIC"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN""http://java.sun.com/dtd/web-app_2_3.dtd" &gt; 这段代码指定文件类型定义（DTD），可以通过它检查XML文档的有效性。下面显示的&lt;!DOCTYPE&gt;元素有几个特性，这些特性告诉我们关于DTD的信息： web-app定义该文档（部署描述符，不是DTD文件）的根元素 PUBLIC意味着DTD文件可以被公开使用 -//Sun Microsystems, Inc.//DTD Web Application 2.3//EN”意味着DTD由Sun Microsystems, Inc.维护。该信息也表示它描述的文档类型是DTD Web Application 2.3，而且DTD是用英文书写的。 URL “http://java.sun.com/dtd/web-app_2_3.dtd” 表示D文件的位置。 2.2 &lt;web-app&gt;&lt;/web-app&gt;部署描述符的根元素是 &lt;web-app&gt; ，DTD文件规定 &lt;web-app&gt; 元素的子元素的语法如下： 1&lt;!ELEMENT web-app (icon?, display-name?, description?,distributable?, context-param*, filter*, filter-mapping*,listener*, servlet*, servlet-mapping*, session-config?,mime-mapping*, welcome-file-list?,error-page*, taglib*, resource-env-ref*, resource-ref*,security-constraint*, login-config?, security-role*,env-entry*,ejb-ref*, ejb-local-ref*)&gt; 正如您所看到的，这个元素含有23个子元素，而且子元素都是可选的。问号（?）表示子元素是可选的，而且只能出现一次。星号（*）表示子元素可在部署描述符中出现零次或多次。有些子元素还可以有它们自己的子元素。web.xml文件中元素声明的是下面每个子元素的声明。下面讲述部署描述符中可能包含的所有子元素。 注意：在Servlet 2.3中，子元素必须按照DTD文件语法描述中指定的顺序出现。比如：如果部署描述符中的元素有和两个子元素，则子元素必须出现在子元素之前。在Servlet2.4中，顺序并不重要。 3. &lt;display-name&gt;&lt;/display-name&gt;&lt;display-name&gt;test-hwp-web-application&lt;/display-name&gt; 定义了web应用的名称，可以在 &lt;http://localhost:8080/manager/html&gt; 中显示 参考博文​ Web.xml详解]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---XML详解(1)]]></title>
    <url>%2F2019%2F03%2F25%2FJavaWeb---XML%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一. XML 概念1.1 什么是 XML ?​ XML是指可扩展标记语言(eXtensible Markup Language)，它是一种标记语言，很类似HTML。它被设计的宗旨是传输数据，而非显示数据。 XML标签没有被预定义，需要用户自行定义标签。 XML技术是W3C组织(World Wide Web Consortium万维网联盟)发布的，目前遵循的是W3C组织于2000年发布的XML1.0规范。 1.2 XML技术用于解决什么问题？ XML语言出现的根本目的在于 描述树状图等关系的数据 XML是一种通用的数据交换格式 在XML语言中，它允许用户自定义标签。一个标签用于描述一段数据；一个标签可分为开始标签和结束标签，在起始标签之间，又可以使用其它标签描述其它数据，以此来实现数据关系的描述。 XML中的数据必须通过软件程序来解析执行或显示，如IE；这样的解析程序称之为Parser(解析器)。 实例123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;中国&gt; &lt;北京&gt; &lt;海淀&gt;&lt;/海淀&gt; &lt;丰台&gt;&lt;/丰台&gt; &lt;/北京&gt; &lt;山东&gt; &lt;济南&gt;&lt;/济南&gt; &lt;青岛&gt;&lt;/青岛&gt; &lt;/山东&gt; &lt;湖北&gt; &lt;武汉&gt;&lt;/武汉&gt; &lt;荆州&gt;&lt;/荆州&gt; &lt;/湖北&gt;&lt;/中国&gt; 1.3 XML常见应用：XML技术除用于保存有关系的数据之外，它还经常用作软件配置文件，以描述程序模块之间的关系。(如后面将要学习到的Struts、Spring和Hibernate都是基于XML作为配置文件的) 在一个软件系统中，通过 XML 配置文件可以提高系统的灵活性。即程序的行为是通过XML文件来配置的，而不是硬编码。 数据交换：不同语言之间用来交换数据 小型数据库：用来当数据库存储数据 二. XML 语法一个XML文件分为如下几部分内容： 文档声明 元素 属性 注释 CDATA区 、特殊字符 处理指令（PI:Processing Instruction） 1.1 文档声明​ 在编写XML文档时，需要先使用文档声明来声明XML文档。且必须出现在文档的第一行。并且必须指定 实例12345678&lt;!-- 最简单的语法: --&gt;&lt;?xml version=“1.0”?&gt;&lt;!-- 用encoding属性说明文档所使用的字符编码。保存在磁盘上的文件编码要与声明的编码一致 --&gt;&lt;?xml version=“1.0” encoding=“GB2312”?&gt;&lt;!-- 用standalone属性说明文档是否独立，即是否依赖其他文档, yes不用引入外部的文件，no需要引入。（不常用） --&gt;&lt;?xml version=“1.0” standalone=“yes”?&gt; 1.2 元素1) 标签XML元素指XML文件中出现的标签。 一个标签分为起始和结束标签(不能省略)。一个标签有如下几种书写形式： 包含标签主体：&lt;mytag&gt;some content&lt;/mytag&gt; 不含标签主体：&lt;mytag/&gt; 一个标签中可以嵌套若干子标签，但所有标签必须合理的嵌套，不允许有交叉嵌套。 &lt;mytag1&gt;&lt;mytag2&gt;&lt;/mytag1&gt;&lt;/mytag2&gt; WRONG！ 一个XML文档必须有且仅有一个根标签，其他标签都是这个根标签的子标签或孙标签。 2) 标签的空格、换行对于XML标签中出现的所有空格和换行，XML解析程序都会当作标签内容进行处理。例如：下面两段内容的意义是不一样的。 1234567&lt;!-- 第一个 --&gt;&lt;网址&gt;www.baidu.com&lt;/网址&gt;&lt;!-- 第二个 --&gt;&lt;网址&gt; www.baidu.com&lt;/网址&gt; 由于在XML中，空格和换行都作为原始内容被处理，所以，在编写XML文件时，使用换行和缩进等方式来让原文件中的内容清晰可读的“良好”书写习惯可能要被迫改变 3) 命名规范一个XML元素可以包含字母、数字以及其它一些可见字符，但必须遵守下面的一些规范： 区分大小写，例如，和是两个不同的标记。 不能以数字或“-” (中划线)开头。 不能以xml(或XML、或Xml 等)开头。 不能包含空格。 名称中间不能包含冒号（:）。 4) 属性一个元素可以有多个属性，每个属性都有它自己的名称和取值 例如: &lt;mytag name=“value” …/&gt; 注意 属性值一定要用引号(单引号或双引号)引起来。 属性名称的命名规范与元素的命名规范相同 元素中的属性是不允许重复的 在XML技术中，标签属性所代表的信息也可以被改成用子元素的形式来描述，例如： 123456&lt;mytag&gt; &lt;name&gt; &lt;firstName/&gt; &lt;lastName/&gt; &lt;/name&gt;&lt;/mytag&gt; 5) 注释XML中的注释语法为：&lt;!--这是注释--&gt; 注意： XML声明之前不能有注释 注释不能嵌套 6) 转义字符 特殊字符 代替字符 &amp; &amp;amp; &lt; &amp;lt; &gt; &amp;gt; “ &amp;quot; ‘ apos; 实体必须以符号”&amp;”开头，以符号”;”结尾 只有”&lt;” 字符和”&amp;”字符对于XML来说是严格禁止使用的。剩下的都是合法的，为了减少出错，使用实体是一个好习惯。 7) CDATA区CDATA是Character Data的缩写 作用 : 把标签当做普通文本内容； 语法 : &lt;![CDATA[内容]]&gt; 123&lt;![CDATA[ &lt;itcast&gt;www.itcast.cn&lt;/itcast&gt;]]&gt; &lt;itcast&gt;www.itcast.cn&lt;/itcast&gt; 被当做普通文本而不是标签 8) 处理指令处理指令，简称 PI (Processing Instruction)。 作用 : 用来指挥软件如何解析XML文档。 语法 : 必须以“&lt;?”作为开头，以“?&gt;”作为结尾。 常用处理指令： 常用处理指令： XML声明： &lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312”?&gt; xml-stylesheet指令： 作用：指示XML文档所使用的CSS样式XSL。 &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;some.css”?&gt; 注：对中文命名的标签元素不起作用 XML语法规则总结 所有 XML 元素都须有关闭标签 XML 标签对大小写敏感 XML 必须正确地嵌套顺序 XML 文档必须有根元素(只有一个) XML 的属性值须加引号 特殊字符必须转义 — CDATA XML 中的空格、回车换行会解析时被保留 三. XML 约束略 参考博文​ JavaWeb之XML详解]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---XML详解(1)]]></title>
    <url>%2F2019%2F03%2F25%2FJavaWeb---XML%E8%AF%A6%E8%A7%A3(1)%2F</url>
    <content type="text"><![CDATA[一. XML 概念1.1 什么是 XML ?​ XML是指可扩展标记语言(eXtensible Markup Language)，它是一种标记语言，很类似HTML。它被设计的宗旨是传输数据，而非显示数据。 XML标签没有被预定义，需要用户自行定义标签。 XML技术是W3C组织(World Wide Web Consortium万维网联盟)发布的，目前遵循的是W3C组织于2000年发布的XML1.0规范。 1.2 XML技术用于解决什么问题？ XML语言出现的根本目的在于 描述树状图等关系的数据 XML是一种通用的数据交换格式 在XML语言中，它允许用户自定义标签。一个标签用于描述一段数据；一个标签可分为开始标签和结束标签，在起始标签之间，又可以使用其它标签描述其它数据，以此来实现数据关系的描述。 XML中的数据必须通过软件程序来解析执行或显示，如IE；这样的解析程序称之为Parser(解析器)。 实例123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;中国&gt; &lt;北京&gt; &lt;海淀&gt;&lt;/海淀&gt; &lt;丰台&gt;&lt;/丰台&gt; &lt;/北京&gt; &lt;山东&gt; &lt;济南&gt;&lt;/济南&gt; &lt;青岛&gt;&lt;/青岛&gt; &lt;/山东&gt; &lt;湖北&gt; &lt;武汉&gt;&lt;/武汉&gt; &lt;荆州&gt;&lt;/荆州&gt; &lt;/湖北&gt;&lt;/中国&gt; 1.3 XML常见应用：XML技术除用于保存有关系的数据之外，它还经常用作软件配置文件，以描述程序模块之间的关系。(如后面将要学习到的Struts、Spring和Hibernate都是基于XML作为配置文件的) 在一个软件系统中，通过 XML 配置文件可以提高系统的灵活性。即程序的行为是通过XML文件来配置的，而不是硬编码。 数据交换：不同语言之间用来交换数据 小型数据库：用来当数据库存储数据 二. XML 语法一个XML文件分为如下几部分内容： 文档声明 元素 属性 注释 CDATA区 、特殊字符 处理指令（PI:Processing Instruction） 1.1 文档声明​ 在编写XML文档时，需要先使用文档声明来声明XML文档。且必须出现在文档的第一行。并且必须指定 实例12345678&lt;!-- 最简单的语法: --&gt;&lt;?xml version=“1.0”?&gt;&lt;!-- 用encoding属性说明文档所使用的字符编码。保存在磁盘上的文件编码要与声明的编码一致 --&gt;&lt;?xml version=“1.0” encoding=“GB2312”?&gt;&lt;!-- 用standalone属性说明文档是否独立，即是否依赖其他文档, yes不用引入外部的文件，no需要引入。（不常用） --&gt;&lt;?xml version=“1.0” standalone=“yes”?&gt; 1.2 元素1) 标签XML元素指XML文件中出现的标签。 一个标签分为起始和结束标签(不能省略)。一个标签有如下几种书写形式： 包含标签主体：&lt;mytag&gt;some content&lt;/mytag&gt; 不含标签主体：&lt;mytag/&gt; 一个标签中可以嵌套若干子标签，但所有标签必须合理的嵌套，不允许有交叉嵌套。 &lt;mytag1&gt;&lt;mytag2&gt;&lt;/mytag1&gt;&lt;/mytag2&gt; WRONG！ 一个XML文档必须有且仅有一个根标签，其他标签都是这个根标签的子标签或孙标签。 2) 标签的空格、换行对于XML标签中出现的所有空格和换行，XML解析程序都会当作标签内容进行处理。例如：下面两段内容的意义是不一样的。 1234567&lt;!-- 第一个 --&gt;&lt;网址&gt;www.baidu.com&lt;/网址&gt;&lt;!-- 第二个 --&gt;&lt;网址&gt; www.baidu.com&lt;/网址&gt; 由于在XML中，空格和换行都作为原始内容被处理，所以，在编写XML文件时，使用换行和缩进等方式来让原文件中的内容清晰可读的“良好”书写习惯可能要被迫改变 3) 命名规范一个XML元素可以包含字母、数字以及其它一些可见字符，但必须遵守下面的一些规范： 区分大小写，例如，和是两个不同的标记。 不能以数字或“-” (中划线)开头。 不能以xml(或XML、或Xml 等)开头。 不能包含空格。 名称中间不能包含冒号（:）。 4) 属性一个元素可以有多个属性，每个属性都有它自己的名称和取值 例如: &lt;mytag name=“value” …/&gt; 注意 属性值一定要用引号(单引号或双引号)引起来。 属性名称的命名规范与元素的命名规范相同 元素中的属性是不允许重复的 在XML技术中，标签属性所代表的信息也可以被改成用子元素的形式来描述，例如： 123456&lt;mytag&gt; &lt;name&gt; &lt;firstName/&gt; &lt;lastName/&gt; &lt;/name&gt;&lt;/mytag&gt; 5) 注释XML中的注释语法为：&lt;!--这是注释--&gt; 注意： XML声明之前不能有注释 注释不能嵌套 6) 转义字符 特殊字符 代替字符 &amp; &amp;amp; &lt; &amp;lt; &gt; &amp;gt; “ &amp;quot; ‘ apos; 实体必须以符号”&amp;”开头，以符号”;”结尾 只有”&lt;” 字符和”&amp;”字符对于XML来说是严格禁止使用的。剩下的都是合法的，为了减少出错，使用实体是一个好习惯。 7) CDATA区CDATA是Character Data的缩写 作用 : 把标签当做普通文本内容； 语法 : &lt;![CDATA[内容]]&gt; 123&lt;![CDATA[ &lt;itcast&gt;www.itcast.cn&lt;/itcast&gt;]]&gt; &lt;itcast&gt;www.itcast.cn&lt;/itcast&gt; 被当做普通文本而不是标签 8) 处理指令处理指令，简称 PI (Processing Instruction)。 作用 : 用来指挥软件如何解析XML文档。 语法 : 必须以“&lt;?”作为开头，以“?&gt;”作为结尾。 常用处理指令： 常用处理指令： XML声明： &lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312”?&gt; xml-stylesheet指令： 作用：指示XML文档所使用的CSS样式XSL。 &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;some.css”?&gt; 注：对中文命名的标签元素不起作用 XML语法规则总结 所有 XML 元素都须有关闭标签 XML 标签对大小写敏感 XML 必须正确地嵌套顺序 XML 文档必须有根元素(只有一个) XML 的属性值须加引号 特殊字符必须转义 — CDATA XML 中的空格、回车换行会解析时被保留 三. XML 约束略 参考博文​ JavaWeb之XML详解]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[街舞---popping]]></title>
    <url>%2F2019%2F03%2F24%2F%E8%A1%97%E8%88%9E---popping%2F</url>
    <content type="text"><![CDATA[一. popping由来​ 比较为大众所知的是一个名叫 Boogaloo Sam 的人，在看到电视节目 Soul Train 上 locker 的表演后激发出来的，然后他在1977年建立了一个舞团, 叫做 The Electric boogaloos(EB舞团) 1.1 EB舞团的成员 Popin Pete Robot Dane Boogaloo Sam Puppet Boozer Creeping Sidney Scarecrow Scalley Skeeter Rabbit(中期加入) Sugar Pop(后期加入) Mr.Wigles(后期加入) 有趣的是即使在同一个舞团内,每个人对于popping的想法却都有差异 Boogaloo Sampopping 只是他的Boogaloo style里头14种style的其中一种，然后每一种都是由他自己受到启发，想出来的 14 种Style 1. popping 8. Master Flex 2. Secrecrow 9. Creeping 3. Puppet 10. Toy Man 4. Ticking 11. Backslide 5. Tidal Wave 12. Moon walk 6. Old Man 13. Romeo Twist 7. Twist O/ Neck O Flex 14. Egyptian Twisst Petepopping就是把肌肉瞬间收缩(pop), 对应到音乐之中，对他来说算是一种技术.就是一种 style , popping 就是dance + pop 作者观点同意大多数其他团员的观点,毕竟像 tuttin 或者是 moon walk 等舞步早在 Sam 之前就已经存在，更重要的是在之后的 popping 发展中，已经不再只是14种舞步了(Tickin Deck/Twist O Flex Don/ Tickin Will) 1.2 popping命名的由来Sam在跳舞的时候每震(摇动)一次肌肉肌肉就说一次pop，所以popping这个名称就是这样来的(没有争议) 1.3 G Style舞者: greenteck(加拿大)、 babybang和spazm（挪威 ）、cocopops（很像是瑞典）、 poppin ten 、 gstyle australia, :john gt kite madoka G Style:这个派别的出现，它并不是一种popping中的舞风，基本上它只是一个类似组织的派别，唯一比较能够确定的是G Style的舞者，喜欢用大量的waving 和 animation 等等比较细微控制的舞步，但也不是用animation和waving比较多的，就是G style 舞者，Slick dogg 算是创始人，而且他早在声称popping早在Sam之前就已经有了(认为Sam跳的不是popping),不能算是Boogaloo Sam 所发明的. 这也变成著名的 G Style 跟 Boogaloo style决赛斗争，其实原本他们是关系不错的，只是不知道为什么就突然吵起来 二. popping的种类现在来讲讲发展到近时所拥有的舞步种类 2.1 pop/hit(震动)1) Fresno​ 重心右移，右手平抬强震,重心左移,左手平抬强震，这是我们常常看见的 popping 基础 2) Sac Walk(空军踏步)​ 左脚上前半步, 右脚后退半步，二步于一个拍子间同时完成, 3) lift​ 类似爬楼梯的动作，左右手呈90度一朝上朝下，然后重复 2.2 wave 电流1) snake​ 用胸部做转动 roll 的动作，若双手放置于前方，像蛇一般 2) king snake (snake的强化版)3)October(章鱼)​ 从手开始带到全身的电流 2.3 Slide 滑步1) 向后滑2) 向侧边滑3) 原地滑4) 转圈圈的滑行方式(加上膝盖的滑行变成膝盖的滑步)2.4 Boogaloo style基本上是以身体各个点为轴心作圆的风格，Roll在其中是很重要的元素 1) boogaloo​ 下半身左右脚互换，上身不动，身体有牵引的感觉 2) work out​ 大步朝前迈出,记得 的是画圆的轨迹，然后身体在跟着扭过去 3) Boogaloo Walk Out跟 work out 差不多, 多了身体的 wave 和连带动作 4) Filmore做交通指挥一般的动作, 5) Neck-O-Flex​ 头转向一侧,固定,转动身体，给人感觉脑袋没动，身体动 6) Twist-O-Flex头,身体,脚,分开转动, 7) master-O-Flex​ 和 Twist-O-Flex 差不多，不过脚步往后跨了一个步,类似work out 的步法 8) Flex Walk​ 手成架构姿势,左右横摆,往前走 9) Botom First​ 手脚抬成90度，类似lift, 然后脚后转, 有点像是被人从肚子往后推了一下 10) Botom Boogaloo First​ 跟 bottom first 差不多，但是往后跨了一步,类似walk out 的步法 11) Egyption Twist 埃及步​ 双脚并拢，微屈膝盖，45度侧移脚掌,反复，头一定要看反方向， 12) Romeo Twist​ 造成内八字外八字状，侧向移动，又名 toe&amp;heel walk, 脚尖脚跟移动的步伐 13) crazy legs(疯狂的腿)​ 脚步的左右roll，让人眼花缭乱, 14) rollpopping 舞种里不可缺少的重要基本功之一，也是不同风格的舞种里都会运用到的一种元素 身体的脖子，胸,胯,肩以及腿部的转动，最后结合一起转动的 2.5 style 风格1) robot机器人2)Toy Man 玩具人3) Puppet 木偶4) Scarecrow 稻草人5) Spider Man 蜘蛛人​ 手像蜘蛛一样在身上各个部位爬行的动作 6) KingTut/Tutting 埃及手​ 手腕, 手肘, 手背, 各成90度 7) Strutting 阔步​ 一格一格的动作，头部要上下左右分格看， 8) Strobing 快门​ 像照相时不断闪光所出现的间断的动作 9) Ticking 连震10) Strobing + pop11) AirPose 滞空​ 加上感觉像在月球上一样，动作被吸的一张一合 12) Shadow Box​ Skeeter Rabbit 的独创分割，这个用语言很难表达 13) Senthapeed​ 一整套的连续动作，身体每一个部分都像是被手带过去的 2.6 Body Contral 身体控制1) animation(动画)​ 像早期的电影一般, 帧数不足24帧时快速分格动作 2) Slow Move 慢动作​ 做之前先加速，然后突然变慢 3) Isolation​ 身体各个部位关节肢体能够独立运动，而不会牵连其他部分 三. 著名Popper很多舞者钻研单一舞步的Popper练到极致会变得相当不像人类所能做的动作 3.1 EB元老3.2 杨文昊属于偏向使用大量 waving 和 animation 的舞者 3.3 田一德基本上是以 Boogaloo style 为主 3.4 Nonstop本命Marquese scott, 把waving,slow motion, animation, tutting 做到极致. 加上他那瘦弱的身形，竟然能做出一些匪夷所思的失去平衡感的动作，他的特色是跳 dubstep 这种音乐，而且会使用快速地连震 dubstep 在 popping中 算是一个很爱被使用的音乐类型, 3.5 Popping John常与Nonstop上镜头的舞者,比较常用的 waving 还有 robot 去表现， 3.6 Greenteck使用了许多 waving 还有 crazy legs在他的舞蹈中 3.7 Salah虽然他是一位Popper，但是他会很多popping之外的舞风，拥有很多独门绝活，甚至在battle的时候会使出魔术把戏，而他又有强烈的表演风格，跳舞的时候即使在白头也像是在演戏，会有很多的表情动作，所以有人会认为他是actor,不是dancer , 但他也是 battle 上的常胜军 3.8 Jaja最著名的就是它在Robot还有Puppet的舞步，超强的控制力搭配时不时的加入krump的元素.也在&lt;舞力全开&gt;中担任女机器人的角色 3.9 Madd Chadd与其说他是proper不如说它已经是完整的机器人 3.10 Dytto一位有奇怪技能的nvpopper, 经常使用她的头发到舞步当中，再搭配上特有的tutting, 3.11 Fik Shun特色除了waving之外,还会再加上一些非 popping 的动作，配上他很喜欢的脚尖站立，搭配他的幽默表情是他的一大卖点. 他跟 Les twins 一样，是受火影忍者荼毒很深的舞者，甚至跳舞的时候还使用螺旋丸当舞步 四. 著名的舞团4.1 Elektro Botz (三人团体)4.2 Robot boys (曾与 popping John)都是很喜欢用很多机械音效的音乐去呈现他们的robot style的舞团，他们在对音乐都可以对得到很细微的程度 4.3 Roreotics很有趣的舞团，曾在ABDC上获得冠军，也由于ABDC给了许多考验，使他们晋升为带有很多其他风格的popping舞团，他们的 animation 和 Strobing 加上他们常使用的速度差是他们的特色，搭配一定要带个墨镜跟不知道为什么让你好像很有特色的发型，是他们舞团的卖点 4.4 World Fame Us 虽然是较新的韩国舞团，但成员全部都是battle 的常胜军, popping J, Boogaloo Kin, hozin, hoan, Jaygee 个人风格跟战力都是无可挑剔的, 看他们的排舞有种很纯正的popping的感觉，没有混什么其他的舞风在里头，几乎是是纯popping，卖点大概是每个人的粉丝都很多吧，毕竟每个都是 battle 届赫赫有名的人物 参考视频​ 【这！就是街舞】特輯六Popping震爆眼珠的田一德與視覺震撼的楊文昊]]></content>
      <categories>
        <category>街舞</category>
      </categories>
      <tags>
        <tag>街舞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---泛型]]></title>
    <url>%2F2019%2F03%2F22%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一. 概述泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。 什么是泛型？为什么要使用泛型？ 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 一个被举了无数次的例子12345678List arrayList = new ArrayList();arrayList.add("aaaa");arrayList.add(100);for(int i = 0; i&lt; arrayList.size();i++)&#123; String item = (String)arrayList.get(i); Log.d("泛型测试","item = " + item);&#125; 毫无疑问，程序的运行结果会以崩溃结束： 1java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String ArrayList 可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。 我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。 123List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();...// arrayList.add(100); 在编译阶段，编译器就会报错 Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 二. 泛型的使用泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法 2.1 泛型类范例123456789101112131415public class TestGeneric &#123; public static void main(String[] args) &#123; ArrayList&lt;Hero&gt; heros = new ArrayList&lt;Hero&gt;(); // 简写, 后面可以只用 &lt;&gt; ArrayList&lt;Hero&gt; heros2 = new ArrayList&lt;&gt;(); // 只有作为Hero的子类可以放进去 heros.add(new APHero()); heros.add(new ADHero()); // 和 Hero无关的类型Item还是放不进去 // heros.add(new Item()); &#125;&#125; 三. 通配符3.1 ? extendsArrayList heroList&lt;? extends Hero&gt;表示这是一个Hero泛型或者其子类泛型 heroList 的泛型可能是Hero heroList 的泛型可能是APHero heroList 的泛型可能是ADHero 所以 可以确凿的是，从heroList取出来的对象，一定是可以转型成Hero的 但是，不能往里面放东西，因为 放APHero就不满足 放ADHero又不满足 123456789101112131415public class TestGeneric &#123; public static void main(String[] args) &#123; ArrayList&lt;APHero&gt; apHeroList = new ArrayList&lt;APHero&gt;(); apHeroList.add(new APHero()); ArrayList&lt;? extends Hero&gt; heroList = apHeroList; //可以确凿的是，从heroList取出来的对象，一定是可以转型成Hero的 Hero h= heroList.get(0); // 但是，不能往里面放东西 heroList.add(new ADHero()); // 编译错误，因为heroList的泛型 有可能是APHero &#125; &#125; 3.2 ? superArrayList heroList&lt;? super Hero&gt; 表示这是一个Hero泛型或者其父类泛型 heroList的泛型可能是Hero heroList的泛型可能是Object 可以往里面插入Hero以及Hero的子类但是取出来有风险，因为不确定取出来是Hero还是Object 123456789101112131415public class TestGeneric &#123; public static void main(String[] args) &#123; ArrayList&lt;? super Hero&gt; heroList = new ArrayList&lt;Object&gt;(); // 所以就可以插入Hero heroList.add(new Hero()); // 也可以插入Hero的子类 heroList.add(new APHero()); heroList.add(new ADHero()); // 但是，不能从里面取数据出来,因为其泛型可能是Object,而Object是强转Hero会失败 Hero h= heroList.get(0); &#125;&#125; 3.3 ?泛型通配符? 代表任意泛型,这个容器什么泛型都有可能 所以只能以Object的形式取出来 并且不能往里面放对象，因为不知道到底是一个什么泛型的容器 1234567891011121314151617public class TestGeneric &#123; public static void main(String[] args) &#123; ArrayList&lt;APHero&gt; apHeroList = new ArrayList&lt;APHero&gt;(); // ?泛型通配符，表示任意泛型 ArrayList&lt;?&gt; generalList = apHeroList; // ?的缺陷1： 既然?代表任意泛型，那么换句话说，你就不知道这个容器里面是什么类型 // 所以只能以Object的形式取出来 Object o = generalList.get(0); // ?的缺陷2： 既然?代表任意泛型，那么既有可能是Hero,也有可能是Item // 所以，放哪种对象进去，都有风险，结果就什么什么类型的对象，都不能放进去 generalList.add(new Item()); //编译错误 因为?代表任意泛型，很有可能不是Item generalList.add(new Hero()); //编译错误 因为?代表任意泛型，很有可能不是Hero &#125;&#125; 3.4 总结 如果希望只取出，不插入，就使用? extends Hero 如果希望只插入，不取出，就使用? super Hero 如果希望，又能插入，又能取出，就不要用通配符？ 参考博文​ java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一 ​ 泛型]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---集合框架]]></title>
    <url>%2F2019%2F03%2F22%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[一. 集合框架图 ​ 所有集合类都位于java.util包下。Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。 Collection : 接口，是高度抽象出来的集合(一组允许重复的对象)，它包含了集合的基本操作和属性。Collection包含了List和Set两大分支 List : 接口, 继承 Collection, 有序集合, 允许重复，每一个元素都有它的索引, 访问集合中的元素可以根据元素的索引来访问。 Set : 接口, 继承 Collection, 无序集合，集合中的元素不可以重复, 访问集合中的元素只能根据元素本身来访问 Map : 接口是键－值对象(Key-value对形式) , 访问时只能根据每项元素的key来访问其value，与Collection接口没有什么关系。 Set、List和Map可以看做集合的三大类 Iterator。它是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。ListIterator是专门为遍历List而存在的。 Enumeration，它是JDK 1.0引入的抽象类。作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。在上面的框图中，Enumeration只能在Hashtable, Vector, Stack中使用。 Arrays和Collections。它们是操作数组、集合的两个工具类。 二. Collection接口​ Collection接口是处理对象集合的 根接口 ，其中定义了很多对元素进行操作的方法。Collection接口有两个主要的子接口List和Set 注意Map不是Collection的子接口，这个要牢记。 常用方法 add() : 添加一个元素到集合中 addAll() : 将指定集合中的所有元素添加到集合中 contains() : 检测集合中是否包含指定的元素 toArray() : 返回一个表示集合的数组。 另外，Collection中有一个iterator()函数，它的作用是返回一个Iterator接口。通常，我们通过Iterator迭代器来遍历集合。ListIterator是List接口所特有的，在List接口中，通过ListIterator()返回一个ListIterator对象。 2.1 List 接口​ List接口继承于Collection接口，它可以定义一个允许重复的有序集合。因为List中的元素是有序的，所以我们可以通过使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。 ​ List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。 ArrayList​ ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。 ​ size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）. ArrayList擅长于随机访问。同时ArrayList是非同步的。 2. Set接口​ Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。Set接口有三个具体实现类，分别是散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet。 ​ Set是一种不包含重复的元素的Collection，无序，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。需要注意的是:虽然Set中元素没有顺序，但是元素在set中的位置是由该元素的HashCode决定的，其具体位置其实是固定的。 ​ 此外需要说明一点，在set接口中的不重复是有特殊要求的。​ 举一个例子:对象A和对象B，本来是不同的两个对象，正常情况下它们是能够放入到Set里面的，但是如果对象A和B的都重写了hashcode和equals方法，并且重写后的hashcode和equals方法是相同的话。那么A和B是不能同时放入到Set集合中去的，也就是Set集合中的去重和hashcode与equals方法直接相关。 三. Map接口​ Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。 ​ 遍历Map 1.HashMap ​ 以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。 参考博文​ Java 集合框架 ​ java集合框架综述 ​]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---Servlet跳转]]></title>
    <url>%2F2019%2F03%2F21%2FJavaWeb---Servlet%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[一. Servlet 跳转1.1 redirect 方式 (客户端跳转)​ 发送一个请求给服务器端资源，这个服务器资源会首先给客户端一个响应，客户端再根据这个响应当中所包含的地址，再次向服务器端发送一个请求，也就是说客户端跳转是两次请求，两次响应； 1response.sendRedirect("/index.jsp"); 页面的路径是相对路径 , sendRedirect可以将页面跳转到任何页面，不一定局限于本web应用中 跳转后 浏览器地址栏变化 称之为请求重定向/302 1.2 forward方式 (服务器端跳转)​ 由客户端发送一个请求，请求一个服务器资源 (如JSP和Servlet) ，这个资源又将请求转到另一个服务器资源，然后再给客户端发送一个响应，也就是说服务器端跳转是客户端发送一次请求，服务器端给出一次响应 1234RequestDispatcher dispatcher = request.getRequestDispatcher("/index.jsp"); dispatcher.forward(request, response); // 简写request.getRequestDispatcher("/index.jsp").forward(request, response); 页面的路径是 相对路径 , forward方式 只能跳转到本web应用中的页面上 跳转后浏览器地址栏 不会变化 请求转发/307 称为 二. 两者之间的区别 方面 redirect 方式 (response , 客户端跳转) forward方式 (request , 服务器端跳转) 浏览器地址 会变化 (在地址栏中显示的是最后一次请求地址) 会不变化 (在地址栏中显示的事第一次页面地址) 当前资源 指定目标资源的URL “”代表的是应用服务器根目录，即http://localhost:8080/ 代表的是应用程序根目录,即http://localhost:8080/项目名/ 可以向站外跳转 只能站内跳转 是否可以获取到请求中的属性和参数 不可以 可以 注意： 1、客户端跳转“/”代表服务器路径webapps，即服务器根路径，服务器端跳转“/”代表站点根路径，即应用程序根路径； ​ 2、尽量使用response.sendRedirect(“fail.jsp”)而不去使用forward，因为当服务器崩溃了，那么sendRedirect则就会起很大的好处了 参考博文​ java学习心得——servlet的两种跳转方式]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---项目中的绝对路径与相对路径]]></title>
    <url>%2F2019%2F03%2F21%2FJavaWeb---%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[一. 与路径相关的操作 超链接 表单 转发 包含 重定向 &lt;url-pattern&gt; ServletContext获取资源 Class获取资源 ClassLoader获取资源 结论 强烈建议使用 / 开头的路径 超链接、表单、重定向 : 以 / 开头的的路径相对于主机根目录 http://localhost:8080/ 转发、包含、&lt;url-pattern&gt;：以 / 开头的的路径相对项目根目录 http://localhost:8080/项目名称/ 不带 / 的相对路径，是相对于访问到当前文件的路径，而不是当前文件所在的目录。 2 客户端路径超链接、表单、重定向都是客户端路径，客户端路径可以分为三种方式： 绝对路径； 以“/”开头的相对路径； 不以“/”开头的相对路径； 范例 1 超链接, 标签http://localhost:8080/hello1/pages/a.html 中的超链接 (表单同理) 要访问 http://localhost:8080/hello2/index.html 中的 index.html 12345678&lt;!-- 链接1 : 使用绝对路径 --&gt;&lt;a href="http://localhost:8080/hello2/index.html"&gt;链接1&lt;/a&gt;&lt;!-- 链接2：以“/”开头, 最终访问的页面为http://localhost:8080/hello2/index.html --&gt;&lt;a href="/hello2/index.html"&gt;链接2&lt;/a&gt;&lt;!-- 链接3：不以“/”开头，最终访问的路径为：http://localhost:8080/hello1/pages/index.html --&gt;&lt;a href="index.html"&gt;链接3&lt;/a&gt; 范例 2 重定向123456789101112publicclass AServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 以“/”开头，所以相对当前主机，即 http://localhost:8080/hello2/index.html response.sendRedirect("/hello2/index.html"); // 假设访问 AServlet 的路径为：http://localhost:8080/hello/servlet/AServlet // 不以“/”开头，所以相对当前路径，即http://localhost:8080/hello/servlet/index.html response.sendRedirect("index.html"); &#125;&#125; 2.1 建议使用 /​ 强烈建议使用“/”开头的路径，这说明在页面中的超链接和表单都要以“/”开头，后面是当前应用的名称，再是访问路径 其中/hello是当前应用名称，这也说明如果将来修改了应用名称，那么页面中的所有路径也要修改，这一问题的处理方案是使用 request.getContextPath() 来获取应用名称。 1response.sendRedirect(request.getContextPath() +"/BServlet"); 详情见 JavaWeb—HttpResponse对象 三. 服务端路径请求转发(forward), 请求包含 是服务器端路径, 服务器端路径必须是相对路径，不能是绝对路径, 但相对路径有两种形式： 以“/”开头； 不以“/”开头 服务器端路径与客户端路径的区别是： 客户端路径以“/”开头：相对当前主机； 服务器端路径以“/”开头：相对当前应用； 理解: 因为客户端是浏览器访问, 而服务端本来就是在项目中,自然默认是这个项目,所以是相对于当前应用,而客户端访问时不知道是哪个项目,所以客户端是相对于主机 范例1234567891011121314public class AServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 假设访问AServlet的路径为：http://localhost:8080/hello/servlet/AServlet // 以“/”开头，所以相对当前应用，即http://localhost:8080/hello/BServlet request.getRequestDispatcher("/BServlet").forward(request, response); // 假设访问AServlet的路径为：http://localhost:8080/hello/servlet/AServlet // 不以“/”开头，所以相对当前应用，即http://localhost:8080/hello/servlet/BServlet request.getRequestDispatcher("BServlet").forward(request, response); &#125;&#125; 参考博文​ WEB项目的相对路径与绝对路径]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---final关键字]]></title>
    <url>%2F2019%2F03%2F21%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---final%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1. 修饰类 当用final修饰一个类时，表明这个类不能被继承。 如果一个类你永远不会让他被继承，就可以用final进行修饰。 final类中的成员变量可以根据需要设为final，但是要注意 final类中的所有成员方法都会被隐式地指定为final方法 在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类 范例123456final class People &#123; // 默认为 final 方法 public People() &#123; &#125;&#125; 2. 修饰方法使用 final 方法的原因有两个 把方法锁定，以防任何继承类修改它的含义； 效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。 如果只有在想 明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。即父类的final方法是不能被子类所覆盖的，也就是说子类是不能够存在和父类一模一样的方法 12345678910111213141516171819202122public class B extends A &#123; public static void main(String[] args) &#123; &#125; public void getName() &#123; &#125;&#125;class A &#123; /** * 因为private修饰，子类中不能继承到此方法，因此，子类中的getName方法是重新定义的、 * 属于子类本身的方法，编译正常 */ private final void getName() &#123; &#125; /* 因为pblic修饰，子类可以继承到此方法，导致重写了父类的final方法，编译出错 public final void getName() &#123; &#125; */&#125; 3. 修饰变量final成员变量表示常量，只能被赋值一次，赋值后值不再改变。 当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化； 如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。 初始化方式final修饰一个成员变量（属性），必须要显示初始化。这里有两种初始化方式 在变量声明的时候初始化； 1在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。 当函数的参数类型声明为final时，说明该参数是只读型的。即你可以读取使用该参数，但是无法改变该参数的值。 12345678class Man &#123; private final int i = 0; public Man() &#123; i = 1; // 报错 final Object obj = new Object(); obj = new Object(); // 报错 &#125;&#125; 二、深入理解final关键字 在了解了final关键字的基本用法之后，这一节我们来看一下final关键字容易混淆的地方。 类的final变量和普通变量有什么区别？ 2、被final修饰的引用变量指向的对象内容可变吗？123456789101112131415public class TestFinal &#123; public static void main(String[] args) &#123; final MyClass myClass = new MyClass(); for(int i=0; i&lt;4; i++) &#123; myClass.i++; &#125; System.out.println(myClass.i); &#125; &#125;class MyClass &#123; public int i = 0; &#125; // 打印结果: 4 这段代码可以顺利编译通过并且有输出结果，输出结果为4。这说明引用变量被final修饰之后，虽然不能再指向其他对象，但是它指向的对象的内容是可变的 参考博文​ 浅谈Java中的final关键字]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---异常处理]]></title>
    <url>%2F2019%2F03%2F21%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[一. 异常的概念​ 异常指的是运行期出现的错误，也就是当程序开始执行以后执行期出现的错误。出现错误时观察错误的名字和行号最为重要。 Java 异常是 Java 提供的用于处理程序中错误的一种机制 所谓错误是指在程序运行的过程中发生的一些异常事件(eg: 除0溢出, 数组下标越界, 所要读取的文件不存在) 设计良好的程序应该在异常发生时提供处理这些错误的方法,是的程序不会因为异常的发生而阻断或产生不可预见的结果 Java 程序的执行过程中,如出现异常事件,可以生成一个异常类对象。该异常类对象封装了异常事件的信息并将提交给Java运行时系统(Java 运行时系统默认处理是直接把这个异常对象里面包装的信息打印出来)。这个过程称为抛出(throw)异常 当 Java 运行时系统接收到的异常对象时, 会寻找能处理这一异常的代码，并将当前异常对象交给其处理,这一过程称为捕获(catch)异常 二. 异常的分类 Error : 称为错误，由Java虚拟机生成并抛出，包括动态链接失效，虚拟机错误的，程序对其不作处理 Exception : 所有异常类的父类，其子类对应了各种各样可能出现的异常事件，一般需要用户显示的声明或捕获 Runtime Exception : 一类特殊的异常, 如被0除，数组下标超范围等，其产生比较频繁处理麻烦，如果显示的声明或捕获会对程序可读性和运行效率影响很大，因此由系统自动检测并将他们交给缺省的异常处理程序，用户可不必对其处理 三、异常的捕获和处理Java异常处理的五个关键字：try、catch、finally、throw、throws 3.1 try-catch-finally语句 try{...}：负责捕获异常，一旦try中发现异常，程序的控制权将被移交给catch块中的异常处理程序,如果没有异常产生,所有的catch代码段都被略过不执行。 【try语句块不可以独立存在，必须与 catch 或者 finally 块同存】 catch{...} ：对异常进行处理,比如发出警告：提示、检查配置、网络连接，记录错误等。执行完catch块之后程序跳出catch块，继续执行后面的代码。 【编写catch块的注意事项：多个catch块处理的异常类，要按照先catch子类后catch父类的处理方式，因为会”就近处理”异常(由上自下)】 finally{...} : 最终执行的代码，用于关闭和释放资源。无论是否抛出异常,finally所指定的代码都要被执行. 【通常在finally语句中可以惊醒资源的清除工作,如:关闭打开的文件,删除临时文件】 语法格式12345678910111213try&#123; //一些会抛出的异常&#125;catch（Exception e）&#123; //第一个catch //处理该异常的代码块&#125;catch（Exception2 e）&#123; //第二个catch，可以有多个catch //处理该异常的代码块 e.printStackTrace(); System.out.println("异常抛出了！！");&#125;finally&#123; //最终要执行的代码&#125; 总结： finally中最好不要包含return，否则程序会提前退出，返回会覆盖try或catch中保存的返回值。 printStackTrace()可以输出异常信息。 return值为-1为抛出异常的习惯写法。 如果方法中try,catch,finally中没有返回语句，则会调用这三个语句块之外的return结果。 finally 在try中的return之后 在返回主调函数之前执行。 3.2 throw和throws关键字Java中的 异常抛出 通常使用throw和throws关键字来实现。 3.3 throw将产生的异常抛出，是抛出异常的一个动作 一般会用于程序出现某种逻辑时程序员主动抛出某种特定类型的异常 语法格式 throw (异常对象)12345678public static void main(String[] args) &#123; String s = "abc"; if(s.equals("abc")) &#123; throw new NumberFormatException(); &#125; else &#123; System.out.println(s); &#125; &#125; 3.4 throws声明将要抛出何种类型的异常(声明),一个方法可以导致一个异常但不处理它，它必须指定这种行为以使方法的调用者可以保护它们自己而不发生异常 语法格式123public void person(String name) throws (Exception1, Exception2)&#123; ...&#125; throw与throws的比较 throws 出现在方法头；而throw出现在方法体。 throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。 两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。 范例12345678910111213void doA(int a) throws (Exception1,Exception2,Exception3)&#123; try &#123; ...... &#125; catch(Exception1 e) &#123; throw e; &#125; catch(Exception2 e) &#123; System.out.println("出错了！"); &#125; if(a!=b) throw new Exception3("自定义异常");&#125; 分析: 代码块中可能会产生3个异常，(Exception1,Exception2,Exception3)。 如果产生Exception1异常，则捕获之后再抛出，由该方法的调用者去处理。 如果产生Exception2异常，则该方法自己处理了（即System.out.println(“出错了！”);）。所以该方法就不会再向外抛出Exception2异常了，void doA() throws Exception1,Exception3 里面的Exception2也就不用写了。因为已经用try-catch语句捕获并处理了。 Exception3异常是该方法的某段逻辑出错，程序员自己做了处理，在该段逻辑错误的情况下抛出异常Exception3，则该方法的调用者也要处理此异常。这里用到了自定义异常 使用throw和throws关键字需要注意以下几点： throws的异常列表可以是抛出一条异常，也可以是抛出多条异常，每个类型的异常中间用逗号隔开 方法体中调用会抛出异常的方法或者是先抛出一个异常：用throw new Exception（） throw写在方法体里，表示“抛出异常”这个动作。 如果某个方法调用了抛出异常的方法，那么必须添加try catch语句去尝试捕获这种异常， 或者添加声明，将异常抛出给更上一层的调用者进行处理 四. 自定义异常略 五. 习惯​ 当捕获到异常以后一定要做出处理，哪怕是把这个异常的错误信息打印出来，这是一种良好的编程习惯。如果不处理，那就是把这个错误悄悄地隐藏起来了，可是这个错误依然是存在的，只不过看不到了而已。这是一种非常危险的编程习惯，绝对不能这样做，捕获到异常就一定要做出处理，实在处理不了就把异常抛出去，让别的方法去处理。总之就是不能捕获到异常之后却又不做出相应的处理，这是一种非常不好的编程习惯。 任何方法往外抛能处理的异常的时候都有一种简单的写法：“throws Exception”，因为Exception类是所有能处理的异常类的根基类，因此抛出Exception类就会抛出所有能够被处理的异常类里了。使用“throws Exception”抛出所有能被处理的异常之后，这些被抛出来的异常就是交给JAVA运行时系统处理了，而处理的方法是把这些异常的相关错误堆栈信息全部打印出来。除了在做测试以外，在实际当中编程的时候，在main方法里抛Exception是一个非常不好的编程习惯，应该使用try……catch去捕获异常并处理掉捕获后的异常。不能直接在main方法里把Exception抛出去交给JAVA运行时系统出力就完事了，这是一种不负责任的表现。如果想把程序写得特别健壮，使用try……catch去捕获异常并处理掉捕获后的异常是必不可少的做法。 参考博文​ JAVA异常与异常处理详解 ​ 异常处理 ​ java基础学习总结——异常处理]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typoro快捷键]]></title>
    <url>%2F2019%2F03%2F20%2Ftypero%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[功能 快捷键 插入表格 Ctrl+T 关闭 Ctrl+W 下划线 Ctrl+U 斜体 Ctrl+I Ctrl+O 标题 Ctrl+数字 插入链接 Ctrl+K 参考博文​ Typora快捷键 ​ typora 快捷键[补充] ​ typora]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---String类(深入理解)]]></title>
    <url>%2F2019%2F03%2F20%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---String%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[一. String类1.1 源码(String成员属性)123456789public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence&#123; /** The value is used for character storage. */ private final char value[]; /** The offset is the first index of the storage that is used. */ private final int offset;&#125; 可以看出 String类是 final 类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法 上面列举出了String类中一些的成员属性，从上面可以看出String类其实是通过char数组来保存字符串的 1.2 源码(String方法)123456789101112131415161718192021222324public String substring(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex &gt; count) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; if (beginIndex &gt; endIndex) &#123; throw new StringIndexOutOfBoundsException(endIndex - beginIndex); &#125; return ((beginIndex == 0) &amp;&amp; (endIndex == count)) ? this : new String(offset + beginIndex, endIndex - beginIndex, value);&#125;public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; char buf[] = new char[count + otherLen]; getChars(0, count, buf, 0); str.getChars(0, otherLen, buf, count); return new String(0, count + otherLen, buf);&#125; 可以看出 无论是sub操做还是concat都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。也就是说进行这些操作后，最原始的字符串并没有被改变。 在这里要永远记住一点：“String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”。 二. 字符串常量池​ 我们知道字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。 ​ JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串（这点对理解上面至关重要）。 ​ Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。 静态常量池，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。 运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。 范例12345String a = "chenssy";String b = "chenssy";String c = new String("chenssy"); a, b(保存在栈中)和字面上的chenssy都是指向JVM字符串常量池中的”chenssy”对象，他们指向同一个对象 ​ new关键字一定会产生一个对象chenssy（注意这个chenssy和上面的chenssy不同），同时这个对象是存储在堆中。所以上面应该产生了两个对象：保存在栈中的c和保存堆中chenssy。但是在Java中根本就不存在两个完全一模一样的字符串对象。故堆中的chenssy应该是引用字符串常量池中chenssy。所以c、chenssy、池chenssy的关系应该是：c —&gt; chenssy —&gt; 池chenssy。所以我们修改内存中的值，他变化的是所有。 总结： 栈: a, b, c 堆: chenssy(c指向的对象) JVM字符串常量: chenssy 虽然a、b、c、chenssy是不同的对象，但是从String的内部结构我们是可以理解上面的。String c = new String(“chenssy”);虽然c的内容是创建在堆中，但是他的内部value还是指向JVM常量池的chenssy的value，它构造chenssy时所用的参数依然是chenssy字符串常量。 例子11234567// 采用字面值的方式赋值public void test1()&#123; String str1="aaa"; String str2="aaa"; System.out.println(str1==str2);// true 可以看出str1跟str2是指向同一个对象 &#125; 执行上述代码，结果为：true分析： 当执行 String str1=&quot;aaa&quot; 时，JVM首先会去字符串池中查找是否存在”aaa”这个对象 如果不存在，则在字符串池中创建”aaa”这个对象然后将池中”aaa”这个对象的引用地址返回给字符串常量str1，这样str1会指向池中”aaa”这个字符串对象； 如果存在，则不创建任何对象，直接将池中”aaa”这个对象的地址返回，赋给字符串常量。 当创建字符串对象str2时，字符串池中已经存在”aaa”这个对象，直接把对象”aaa”的引用地址返回给str2，这样str2指向了池中”aaa”这个对象，也就是说str1和str2指向了同一个对象，因此语句 System.out.println(str1 == str2) 输出：true 例子21234567// 采用new关键字新建一个字符串对象public void test2()&#123; String str3 = new String("aaa"); String str4 = new String("aaa"); System.out.println(str3==str4);// false 可以看出用new的方式是生成不同的对象 &#125; 执行上述代码，结果为：false 分析： 采用new关键字新建一个字符串对象时，JVM首先在字符串池中查找有没有”aaa”这个字符串对象， 如果有，则不在池中再去创建”aaa”这个对象了，直接在堆中创建一个”aaa”字符串对象，然后将堆中的这个”aaa”对象的地址返回赋给引用str3，这样，str3就指向了堆中创建的这个”aaa”字符串对象； 如果没有，则首先在字符串池中创建一个”aaa”字符串对象，然后再在堆中创建一个”aaa”字符串对象，然后将堆中这个”aaa”字符串对象的地址返回赋给str3引用，这样，str3指向了堆中创建的这个”aaa”字符串对象。 当执行 String str4=new String(&quot;aaa&quot;) 时， 因为采用 new 关键字创建对象时，每次new出来的都是一个新的对象，也即是说引用str3和str4指向的是两个不同的对象，因此语句 System.out.println(str3 == str4) 输出：false 例子312345678910// 编译期确定public void test3()&#123; String s0 = "helloworld"; String s1 = "helloworld"; String s2 = "hello"+"world"; System.out.println(s0==s1); //true 可以看出s0跟s1是指向同一个对象 System.out.println(s0==s2); //true 可以看出s0跟s2是指向同一个对象 &#125; 执行上述代码，结果为：true、true 分析： s0和s1中的”helloworld”都是字符串常量，它们在编译期就被确定了，所以 s0==s1 为true； “hello” 和 “world” 也都是字符串常量，当一个字符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以s2也同样在编译期就被解析为一个字符串常量，所以s2也是常量池中”helloworld”的一个引用。所以我们得出 s0==s1==s2 例子412345678910// 编译期无法确定public void test4()&#123; String s0 = "helloworld"; String s1 = new String("helloworld"); String s2 = "hello" + new String("world"); System.out.println( s0==s1 ); // false System.out.println( s0==s2 ); // false System.out.println( s1==s2 ); // false&#125; 执行上述代码，结果为：false、false、false 分析： 用 new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间(在堆中,堆中的对象又指向常量池中的字符串) s0 还是常量池中”helloworld”的引用，s1因为无法在编译期确定，所以是运行时创建的新对象”helloworld”的引用，s2因为有后半部分new String(”world”)所以也无法在编译期确定，所以也是一个新创建对象”helloworld”的引用 例子5123456789// 继续-编译期无法确定public void test5()&#123; String str1="abc"; String str2="def"; String str3=str1+str2; System.out.println(str3=="abcdef"); // false&#125; 执行上述代码，结果为：false 分析： 因为str3指向堆中的“abcdef”对象，而”abcdef”是字符串池中的对象，所以结果为false JVM 对 String str=&quot;abc&quot; 对象放在常量池中是在编译时做的，而 String str3=str1+str2 是在运行时刻才能知道的。new对象也是在运行时才做的 + 运算符会在堆中建立来两个String对象，这两个对象的值分别是”abc”和”def”，也就是说从字符串池中复制这两个值，然后在堆中创建两个对象，然后再建立对象str3,然后将”abcdef”的堆地址赋给str3。 步骤： 栈中开辟一块中间存放引用str1，str1指向池中String常量”abc”。 栈中开辟一块中间存放引用str2，str2指向池中String常量”def”。 栈中开辟一块中间存放引用str3。 str1 + str2通过StringBuilder的最后一步toString()方法还原一个新的String对象”abcdef”，因此堆中开辟一块空间存放此对象。 引用str3指向堆中(str1 + str2)所还原的新String对象。 str3指向的对象在堆中，而常量”abcdef”在池中，输出为false。 最后: 栈中: 3个, str1, str2, str3 字符串池中: 3个, “abc”, “def”, “abcdef” 堆中: 3个, str1, str2, (str1+str2) 参考博文​ 深入理解Java中的String]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---String类(深入理解)]]></title>
    <url>%2F2019%2F03%2F20%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---String%E7%B1%BB(%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3)%2F</url>
    <content type="text"><![CDATA[一. String类1.1 源码(String成员属性)123456789public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence&#123; /** The value is used for character storage. */ private final char value[]; /** The offset is the first index of the storage that is used. */ private final int offset;&#125; 可以看出 String类是 final 类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法 上面列举出了String类中一些的成员属性，从上面可以看出String类其实是通过char数组来保存字符串的 1.2 源码(String方法)123456789101112131415161718192021222324public String substring(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex &gt; count) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; if (beginIndex &gt; endIndex) &#123; throw new StringIndexOutOfBoundsException(endIndex - beginIndex); &#125; return ((beginIndex == 0) &amp;&amp; (endIndex == count)) ? this : new String(offset + beginIndex, endIndex - beginIndex, value);&#125;public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; char buf[] = new char[count + otherLen]; getChars(0, count, buf, 0); str.getChars(0, otherLen, buf, count); return new String(0, count + otherLen, buf);&#125; 可以看出 无论是sub操做还是concat都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。也就是说进行这些操作后，最原始的字符串并没有被改变。 在这里要永远记住一点：“String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”。 二. 字符串常量池​ 我们知道字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。 ​ JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串（这点对理解上面至关重要）。 ​ Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。 静态常量池，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。 运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。 范例12345String a = "chenssy";String b = "chenssy";String c = new String("chenssy"); a, b(保存在栈中)和字面上的chenssy都是指向JVM字符串常量池中的”chenssy”对象，他们指向同一个对象 ​ new关键字一定会产生一个对象chenssy（注意这个chenssy和上面的chenssy不同），同时这个对象是存储在堆中。所以上面应该产生了两个对象：保存在栈中的c和保存堆中chenssy。但是在Java中根本就不存在两个完全一模一样的字符串对象。故堆中的chenssy应该是引用字符串常量池中chenssy。所以c、chenssy、池chenssy的关系应该是：c —&gt; chenssy —&gt; 池chenssy。所以我们修改内存中的值，他变化的是所有。 总结： 栈: a, b, c 堆: chenssy(c指向的对象) JVM字符串常量: chenssy 虽然a、b、c、chenssy是不同的对象，但是从String的内部结构我们是可以理解上面的。String c = new String(“chenssy”);虽然c的内容是创建在堆中，但是他的内部value还是指向JVM常量池的chenssy的value，它构造chenssy时所用的参数依然是chenssy字符串常量。 例子11234567// 采用字面值的方式赋值public void test1()&#123; String str1="aaa"; String str2="aaa"; System.out.println(str1==str2);// true 可以看出str1跟str2是指向同一个对象 &#125; 执行上述代码，结果为：true分析： 当执行 String str1=&quot;aaa&quot; 时，JVM首先会去字符串池中查找是否存在”aaa”这个对象 如果不存在，则在字符串池中创建”aaa”这个对象然后将池中”aaa”这个对象的引用地址返回给字符串常量str1，这样str1会指向池中”aaa”这个字符串对象； 如果存在，则不创建任何对象，直接将池中”aaa”这个对象的地址返回，赋给字符串常量。 当创建字符串对象str2时，字符串池中已经存在”aaa”这个对象，直接把对象”aaa”的引用地址返回给str2，这样str2指向了池中”aaa”这个对象，也就是说str1和str2指向了同一个对象，因此语句 System.out.println(str1 == str2) 输出：true 例子21234567// 采用new关键字新建一个字符串对象public void test2()&#123; String str3 = new String("aaa"); String str4 = new String("aaa"); System.out.println(str3==str4);// false 可以看出用new的方式是生成不同的对象 &#125; 执行上述代码，结果为：false 分析： 采用new关键字新建一个字符串对象时，JVM首先在字符串池中查找有没有”aaa”这个字符串对象， 如果有，则不在池中再去创建”aaa”这个对象了，直接在堆中创建一个”aaa”字符串对象，然后将堆中的这个”aaa”对象的地址返回赋给引用str3，这样，str3就指向了堆中创建的这个”aaa”字符串对象； 如果没有，则首先在字符串池中创建一个”aaa”字符串对象，然后再在堆中创建一个”aaa”字符串对象，然后将堆中这个”aaa”字符串对象的地址返回赋给str3引用，这样，str3指向了堆中创建的这个”aaa”字符串对象。 当执行 String str4=new String(&quot;aaa&quot;) 时， 因为采用 new 关键字创建对象时，每次new出来的都是一个新的对象，也即是说引用str3和str4指向的是两个不同的对象，因此语句 System.out.println(str3 == str4) 输出：false 例子312345678910// 编译期确定public void test3()&#123; String s0 = "helloworld"; String s1 = "helloworld"; String s2 = "hello"+"world"; System.out.println(s0==s1); //true 可以看出s0跟s1是指向同一个对象 System.out.println(s0==s2); //true 可以看出s0跟s2是指向同一个对象 &#125; 执行上述代码，结果为：true、true 分析： s0和s1中的”helloworld”都是字符串常量，它们在编译期就被确定了，所以 s0==s1 为true； “hello” 和 “world” 也都是字符串常量，当一个字符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以s2也同样在编译期就被解析为一个字符串常量，所以s2也是常量池中”helloworld”的一个引用。所以我们得出 s0==s1==s2 例子412345678910// 编译期无法确定public void test4()&#123; String s0 = "helloworld"; String s1 = new String("helloworld"); String s2 = "hello" + new String("world"); System.out.println( s0==s1 ); // false System.out.println( s0==s2 ); // false System.out.println( s1==s2 ); // false&#125; 执行上述代码，结果为：false、false、false 分析： 用 new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间(在堆中,堆中的对象又指向常量池中的字符串) s0 还是常量池中”helloworld”的引用，s1因为无法在编译期确定，所以是运行时创建的新对象”helloworld”的引用，s2因为有后半部分new String(”world”)所以也无法在编译期确定，所以也是一个新创建对象”helloworld”的引用 例子5123456789// 继续-编译期无法确定public void test5()&#123; String str1="abc"; String str2="def"; String str3=str1+str2; System.out.println(str3=="abcdef"); // false&#125; 执行上述代码，结果为：false 分析： 因为str3指向堆中的“abcdef”对象，而”abcdef”是字符串池中的对象，所以结果为false JVM 对 String str=&quot;abc&quot; 对象放在常量池中是在编译时做的，而 String str3=str1+str2 是在运行时刻才能知道的。new对象也是在运行时才做的 + 运算符会在堆中建立来两个String对象，这两个对象的值分别是”abc”和”def”，也就是说从字符串池中复制这两个值，然后在堆中创建两个对象，然后再建立对象str3,然后将”abcdef”的堆地址赋给str3。 步骤： 栈中开辟一块中间存放引用str1，str1指向池中String常量”abc”。 栈中开辟一块中间存放引用str2，str2指向池中String常量”def”。 栈中开辟一块中间存放引用str3。 str1 + str2通过StringBuilder的最后一步toString()方法还原一个新的String对象”abcdef”，因此堆中开辟一块空间存放此对象。 引用str3指向堆中(str1 + str2)所还原的新String对象。 str3指向的对象在堆中，而常量”abcdef”在池中，输出为false。 最后: 栈中: 3个, str1, str2, str3 字符串池中: 3个, “abc”, “def”, “abcdef” 堆中: 3个, str1, str2, (str1+str2) 参考博文​ 深入理解Java中的String]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用类---StringUtils]]></title>
    <url>%2F2019%2F03%2F20%2FJava%E5%B8%B8%E7%94%A8%E7%B1%BB---StringUtils%2F</url>
    <content type="text"><![CDATA[一. 转换 StringUtils 中涉及大小写转换以及判断字符串大小写的方法 1.1 字符串首字母大小写转换12345StringUtils.capitalize(null)); // null (注意此处不会报异常)StringUtils.capitalize("china")); // China (首字母转大写)StringUtils.uncapitalize(null)); // null StringUtils.uncapitalize("CHINA")); // cHINA (首字母转小写) 1.2 字符串整体大小写转换1234567StringUtils.upperCase(null)); // nullStringUtils.upperCase("china")); // CHINA (全部转为大写)StringUtils.upperCase("china", Locale.ENGLISH)); // CHINA (按照指定规则转换为大写)StringUtils.lowerCase(null)); // nullStringUtils.lowerCase("CHINA")); // china (全部转换为小写)StringUtils.lowerCase("CHINA", Locale.ENGLISH)); // china (按照指定转换规则转换为小写) 1.3 字符串大小写互换12StringUtils.swapCase(null)); // nullStringUtils.swapCase("chINA")); // CHina 1.4 判断字符串是否全部是大写或小写(空或空白符均为false)12345678StringUtils.isAllUpperCase(null)); // falseStringUtils.isAllUpperCase("")); // falseStringUtils.isAllUpperCase(" ")); // falseStringUtils.isAllUpperCase("CHINA")); // trueStringUtils.isAllLowerCase(null)); // falseStringUtils.isAllLowerCase("")); // falseStringUtils.isAllLowerCase(" ")); // falseStringUtils.isAllLowerCase("china")); // true 二. 移除 从字符串中移除匹配的字符或字符序列，如果要移除的字符或字符序列在字符串中不存在，即无匹配，则不进行移除 2.1 移除单个字符1234StringUtils.remove(null, 'a')); // null (注意此处及下一行为null)StringUtils.remove('china', null) // china StringUtils.remove("china", 'i')); // chnaStringUtils.remove("china", 'b')); // china (如果要移除的字符不存在，则返回原字符串 2.2 移除指定字符序列12StringUtils.remove("china", "in")); // chaStringUtils.remove("china", "nin")); // 没有匹配到字符串, china 2.3 移除开头匹配的字符序列12StringUtils.removeStart("china", "ch")); // inaStringUtils.removeStartIgnoreCase("china", "CHI")); // na (忽略大小写) 2.4 移除结尾匹配的字符序列12StringUtils.removeEnd("china", "na")); // chiStringUtils.removeEndIgnoreCase("china", "NA")); // chi (忽略大小写) 2.5 移除空白字符12StringUtils.deleteWhitespace(null)); // nullStringUtils.deleteWhitespace(" c h i\tn\ra")); // china 三. 替换四. 反转五. 截取字符串5.1 截取指定位置的字符串12StringUtils.substring("hello", 1); // 结果是：ello, 截取的字符串包括前面的(起始是0)StringUtils.substring("hello", 1, 3); // 结果是：el, 截取的字符串不包括后面的,[1,3) 5.2 截取指定字符串之前/之后的内容123456StringUtils.substringBefore("helloWorld", "o"); // 结果是：hellStringUtils.substringBeforeLast("helloWorld", "o"); // 结果是：helloW,一直找到最后一个指定的字符串StringUtils.substringAfter("helloWorld", "o"); // 结果是：WorldStringUtils.substringAfterLast("helloWorld", "o"); // 结果是：rld// 总结: 带有 Last 的都是找到最后一个字符 5.3 截取参数2和参数3中间的字符1234StringUtils.substringBetween("hello_world_I_love_you", "_", "_");// 结果是: worldStringUtils.substringsBetween("hello_world_I_love_you", "_", "_");// 返回的是一个数组,循环遍历,打印结果为: world love 参考博文​ java StringUtils截取字符串]]></content>
      <categories>
        <category>java常用类</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java常用类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---String类(2)]]></title>
    <url>%2F2019%2F03%2F20%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---String%E7%B1%BB(2)%2F</url>
    <content type="text"><![CDATA[一. String常用方法1.1 基本操作 int length() : 获取字符串的长度 int index(int ch) : 返回指定字符串在此字符串中第一次出现的索引 int lastIndexOf(int ch) : 返回指定字符在此字符串中最后一次出现的索引 char charAt(int index) : 返回字符串中index位置上的字符,其中index的取值范围是:0 ~ (length-1) 1.2 转换操作1.3 替换与去除1.4 截取和分割 String[] split(String reges) : 根据参数regex将原来的字符串分割为若干个字符串 String substring(int beginIndex): 截取从索引 beginIndex后的所有字符 String substring(int beginIndex, int endIndex): 截取从索引 beginIndex 到 endIndex 索引之间字符 1.5 判断操作 boolean startWith(String prefix) : 判断此字符串是否以指定的字符串开始 boolean endWith(String prefix) : 判断此字符串是否以指定的字符串j结束 其他 Remove(int startIndex)：删除此字符串中从指定位置到最后位置的所有字符 StringUtilsStringUtils类常用方法：转换、移除、替换、反转 参考博文​ Java常用类（二）String类详解]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---线程(3)]]></title>
    <url>%2F2019%2F03%2F19%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E7%BA%BF%E7%A8%8B(3)%2F</url>
    <content type="text"><![CDATA[一. 一个典型的 Java 线程安全例子范例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class ThreadTest &#123; public static void main(String[] args) &#123; Account account = new Account("123456", 1000); DrawMoneyRunnable drawMoneyRunnable = new DrawMoneyRunnable(account, 700); Thread myThread1 = new Thread(drawMoneyRunnable); Thread myThread2 = new Thread(drawMoneyRunnable); myThread1.start(); myThread2.start(); &#125;&#125;class DrawMoneyRunnable implements Runnable &#123; private Account account; // 取钱数目 private double drawAmount; public DrawMoneyRunnable(Account account, double drawAmount) &#123; super(); this.account = account; this.drawAmount = drawAmount; &#125; public void run() &#123; // 如果取钱数小于余额 if (account.getBalance() &gt;= drawAmount) &#123; //1 System.out.println("取钱成功， 取出钱数为：" + drawAmount); double balance = account.getBalance() - drawAmount; // 更新余额 account.setBalance(balance); System.out.println("余额为：" + balance); &#125; &#125;&#125;class Account &#123; // 银行卡密码 private String accountNo; // 银行卡余额 private double balance; // 两个构造方法 public Account() &#123; &#125; public Account(String accountNo, double balance) &#123; this.accountNo = accountNo; this.balance = balance; &#125; // get/set 方法 public String getAccountNo() &#123; return accountNo; &#125; public void setAccountNo(String accountNo) &#123; this.accountNo = accountNo; &#125; public double getBalance() &#123; return balance; &#125; public void setBalance(double balance) &#123; this.balance = balance; &#125;&#125; 上面例子很容易理解，有一张银行卡，里面有1000的余额，程序模拟你和你老婆同时在取款机进行取钱操作的场景。多次运行此程序，可能具有多个不同组合的输出结果。其中一种可能的输出为： 1234取钱成功， 取出钱数为：700.0余额为：300.0取钱成功， 取出钱数为：700.0余额为：-400.0 对于一张只有1000余额的银行卡，你们一共可以取出1400，这显然是有问题的。 ​ 问题在于 Java多线程环境下的执行的不确定性。CPU可能随机的在多个处于就绪状态中的线程中进行切换 ​ 因此，很有可能出现如下情况：当thread1执行到//1处代码时，判断条件为true，此时CPU切换到thread2，执行//1处代码，发现依然为真，然后执行完thread2，接着切换到thread1，接着执行完毕。 讲到线程安全问题，其实是指多线程环境下对共享资源的访问可能会引起此共享资源的不一致性。因此，为避免线程安全问题，应该避免多线程环境下对此共享资源的并发访问。 二. 同步方法对共享资源进行访问的方法定义中加上synchronized关键字修饰，使得此方法称为同步方法。 可以简单理解成对此方法进行了加锁，其锁对象为当前方法所在的对象自身。多线程环境下，当执行此方法时，首先都要获得此同步锁（且同时最多只有一个线程能够获得），只有当线程执行完此同步方法后，才会释放锁对象，其他的线程才有可能获取此同步锁，以此类推… 只有一个对象可以执行此方法,其他的都要在后面排队,等他使用完,其他的对象才可以使用,次方法只能同时被一个对象使用 在上例中，共享资源为account对象，当使用同步方法时，可以解决线程安全问题。只需在run()方法前加上synshronized关键字即可。 123public synchronized void run() &#123; // ....&#125; 三. 同步代码块解决线程安全问题其实只需限制对共享资源访问的不确定性即可。使用同步方法时，使得整个方法体都成为了同步执行状态，会使得可能出现同步范围过大的情况，于是，针对需要同步的代码可以直接另一种同步方式—同步代码块来解决。 同步代码块的格式为： 123synchronized (obj) &#123; //...&#125; 其中，obj 为锁对象，因此，选择哪一个对象作为锁是至关重要的。一般情况下，都是选择此共享资源对象作为锁对象。 如上例中，最好选用account对象作为锁对象. (当然，选用this也是可以的，那是因为创建线程使用了runnable 方式，如果是直接继承Thread方式创建的线程，使用this对象作为同步锁会其实没有起到任何作用，因为是不同的对象了。因此，选择同步锁时需要格外小心…) 四.Lock 对象同步锁上面我们可以看出，正因为对同步锁对象的选择需要如此小心，有没有什么简单点的解决方案呢？ 以方便同步锁对象与共享资源解耦，同时又能很好的解决线程安全问题。 使用 Lock对象同步锁 可以方便的解决此问题，唯一需要注意的一点是Lock对象需要与资源对象同样具有一对一的关系。Lock对象同步锁一般格式为： 12345678910111213class X &#123; // 显示定义Lock同步锁对象，此对象与共享资源具有一对一关系 private final Lock lock = new ReentrantLock(); public void m()&#123; // 加锁 lock.lock(); //... 需要进行线程安全同步的代码 // 释放Lock锁 lock.unlock(); &#125;&#125; 五. wait()/notify()/notifyAll()线程通信任何Object对象都可以作为这三个方法的主调，在实际的多线程编程中，只有同步锁对象调这三个方法，才能完成对多线程间的线程通信。Obj.wait() , 与 Obj.notify() 必须要与 synchronized(Obj) 一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作. wait()： 导致==当前线程等待==并使其进入到等待阻塞状态。直到其他线程==调用该同步锁对象==的notify()或notifyAll()方法来唤醒此线程。 wait()方法执行后，当前线程立即进入到等待阻塞状态，其后面的代码不会执行 当wait线程唤醒后并执行时，是接着上次执行到的wait()方法代码后面继续往下执行的 notify()： 唤醒在此同步锁对象上等待的单个线程，如果有多个线程都在此同步锁对象上等待，则会任意选择其中某个线程进行唤醒操作 如果notify()/notifyAll()后面还有代码，还会继续进行，直到当前线程执行完毕才会释放同步锁对象 notify()/notifyAll()执行后，如果右面有sleep()方法，则会使当前线程进入到阻塞状态，但是同步对象锁没有释放，依然自己保留，那么一定时候后还是会继续执行此线程,接下来同上 notifyAll()： 唤醒在此同步锁对象上等待的所有线程，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程 解释wait()中的当前线程​ jdk的解释中，说wait()的作用是让“当前线程”等待, 而“当前线程”是指正在cpu上运行的线程！而不是这个对象进行等待. 范例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TestWait implements Runnable &#123; private String name; private Object prev; private Object self; private TestWait(String name, Object prev, Object self) &#123; this.name = name; this.prev = prev; this.self = self; &#125; @Override public void run() &#123; int count = 10; while (count &gt; 0) &#123; synchronized (prev) &#123; synchronized (self) &#123; System.out.print(name + " "); count--; self.notify(); &#125; try &#123; prev.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; Object a = new Object(); Object b = new Object(); Object c = new Object(); TestWait pa = new TestWait("A", c, a); TestWait pb = new TestWait("B", a, b); TestWait pc = new TestWait("C", b, c); new Thread(pa).start(); Thread.sleep(1000); //确保按顺序A、B、C执行, 很重要 new Thread(pb).start(); Thread.sleep(1000); new Thread(pc).start(); Thread.sleep(1000); &#125; &#125; /* * 打印结果: A B C A B C A B C A B C A B C A B C A B C A B C A B C A B C */ 整体思路从大的方向上来讲，该问题为三线程间的同步唤醒操作，主要的目的就是 ThreadA -&gt; ThreadB -&gt; ThreadC -&gt; ThreadA 循环执行三个线程。 为了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能继续执行。一个对象锁是prev，就是前一个线程所持有的对象锁。还有一个就是自身对象锁。 主要的思想就是，为了控制执行的顺序，必须要先持有prev锁，也就前一个线程要释放自身对象锁，再去申请自身对象锁，两者兼备时打印，之后首先调用self.notify()释放自身对象锁，唤醒下一个等待线程，再调用prev.wait()释放prev对象锁，终止当前线程，等待循环结束后再次被唤醒。 看起来似乎没什么问题，但如果你仔细想一下，就会发现有问题，就是初始条件，三个线程按照A,B,C的顺序来启动，按照前面的思考，A唤醒B，B唤醒C，C再唤醒A。但是这种假设依赖于JVM中线程调度、执行的顺序。所以需要在main方法中设置sleep()方法,保证创建的顺序. 为什么notify(), wait()等函数定义在Object中，而不是Thread中notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。 参考博文​ Java多线程系列–“基础篇”05之 线程等待与唤醒 ​ Java多线程学习（总结很详细！！！） ​ Java总结篇系列：Java多线程（三）]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git---将本地项目上传到Github]]></title>
    <url>%2F2019%2F03%2F19%2FGit---%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0Github%2F</url>
    <content type="text"><![CDATA[一. 关键步骤 在本地创建一个版本库（即文件夹），通过git init把它变成Git仓库； git init 把项目复制到这个文件夹里面，再通过git add .把项目添加到仓库； git add . 再通过git commit -m “注释内容”把项目提交到仓库； git commit -m “first commit” 在Github上设置好SSH密钥 后，新建一个远程仓库，通过 git remote add origin https://github.com/sladning/test 将本地仓库和远程仓库进行关联； git remote add origin https://github.com/sladning/test 最后通过 git push -u origin master 把本地仓库的项目推送到远程仓库（也就是Github）上；（若新建远程仓库的时候自动创建了README文件会报错，解决办法看下面）。 git push -u origin master 由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了 git push origin master 二. 注关于 README.md 创建远程仓库的时候，如果你勾选了Initialize this repository with a README（就是创建仓库的时候自动给你创建一个README文件） 那么到了将本地仓库内容推送到远程仓库的时候就会报一个failed to push some refs to https://github.com/guyibang/TEST2.git的错 这是由于你新创建的那个仓库里面的README文件不在本地仓库目录中，这时我们可以通过以下命令先将内容合并以下：git pull --rebase origin master 再push就能成功了。 参考博文: ​ Git的使用–如何将本地项目上传到Github]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---EL表达式]]></title>
    <url>%2F2019%2F03%2F19%2FJavaWeb---EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一. EL表达式简介 EL 全名为 Expression Language。 EL主要作用： 获取数据EL表达式主要用于替换 JSP 页面中的脚本表达式，以从各种类型的web域中检索 java 对象、获取数据。(某个web域 中的对象，访问javabean的属性、访问list集合、访问map集合、访问数组) 执行运算利用 EL 表达式可以在JSP页面中执行一些基本的关系运算、逻辑运算和算术运算，以在JSP页面中完成一些简单的逻辑运算。${user==null} 获取web开发常用对象EL 表达式定义了一些隐式对象，利用这些隐式对象，web开发人员可以很轻松获得对web常用对象的引用，从而获得这些对象中的数据。 调用Java方法EL表达式允许用户开发自定义EL函数，以在JSP页面中通过EL表达式调用Java类的方法。 二. 获取数据 使用EL表达式获取数据语法：${标识符} EL表达式语句在执行时，会调用 pageContext.findAttribute 方法，用 标识符 为关键字，分别从page、request、session、application四个域中查找相应的对象，找到则返回相应对象，找不到则返回 ”” （注意，不是null，而是空字符串）。 EL表达式可以很轻松获取JavaBean的属性，或获取数组、Collection、Map类型集合的数据 2.1 获取 JavaBean 的属性通过 . 符号操作就可以了。 如${hero.name} ， 如果属性是非boolean类型, 会自动调用 getXXX 方法 如果属性是boolean类型，会自动调用 isXXX 方法 范例1234567891011121314151617181920212223242526// person 的 JavaBeanpublic class Person &#123; // 姓名 String类型 private String name; //是否已婚 boolean类型 private boolean married; public Person() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public boolean isMarried() &#123; return married; &#125; public void setMarried(boolean married) &#123; this.married = married; &#125;&#125; 获取12345678910&lt;body&gt;&lt;!-- 在jsp页面中，使用el表达式可以获取bean的属性 --&gt; &lt;% Person p = new Person(); p.setName("Mike"); p.setMarried(True); request.setAttribute("person",p); %&gt; 使用el表达式可以获取bean的属性：$&#123;person.name&#125;, $&#123;person.married&#125;&lt;/body&gt; el表达式获取数据范例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;body&gt; &lt;% request.setAttribute("name","孤傲苍狼"); %&gt; &lt;%--$&#123;name&#125;等同于pageContext.findAttribute("name") --%&gt; 使用EL表达式获取数据：$&#123;name&#125; &lt;hr&gt; &lt;hr&gt; &lt;!-- 在jsp页面中，使用el表达式可以获取bean中的。。。。。。。。。的属性 --&gt; &lt;% Person person = new Person(); Address address = new Address(); person.setAddress(address); request.setAttribute("person",person); %&gt; $&#123;person.address.name&#125; &lt;hr&gt; &lt;!-- 在jsp页面中，使用el表达式获取list集合中指定位置的数据 --&gt; &lt;% Person p1 = new Person(); p1.setName("孤傲苍狼"); Person p2 = new Person(); p2.setName("白虎神皇"); List&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); list.add(p1); list.add(p2); request.setAttribute("list",list); %&gt; &lt;!-- 取list指定位置的数据 --&gt; $&#123;list[1].name&#125; &lt;!-- 迭代List集合 --&gt; &lt;c:forEach var="person" items="$&#123;list&#125;"&gt; $&#123;person.name&#125; &lt;/c:forEach&gt; &lt;hr&gt; &lt;!-- 在jsp页面中，使用el表达式获取map集合的数据 --&gt; &lt;% Map&lt;String,String&gt; map = new LinkedHashMap&lt;String,String&gt;(); map.put("a","aaaaxxx"); map.put("b","bbbb"); map.put("c","cccc"); map.put("1","aaaa1111"); request.setAttribute("map",map); %&gt; &lt;!-- 根据关键字取map集合的数据 --&gt; $&#123;map.c&#125; $&#123;map["1"]&#125; &lt;hr&gt; &lt;!-- 迭代Map集合 --&gt; &lt;c:forEach var="me" items="$&#123;map&#125;"&gt; $&#123;me.key&#125;=$&#123;me.value&#125;&lt;br/&gt; &lt;/c:forEach&gt; &lt;hr&gt;&lt;/body&gt; 1.7、EL注意事项 EL表达式是JSP 2.0规范中的一门技术 。因此，若想正确解析EL表达式，需使用支持Servlet2.4/JSP2.0技术的WEB服务器。注意：有些Tomcat服务器如不能使用EL表达式 （1）升级成tomcat6 （2）在 JSP 中加入&lt;%@ page isELIgnored=”false” %&gt; 1.8、EL表达式保留关键字 And eq gt true Or ne le false No lt ge null instanceof empty div mod ​ 保留字的意思是指变量在命名时，应该避开上述的名字，以免程序编译时发生错误，关于EL表达式的内容的总结就这么多。 参考博文​ javaweb学习总结(二十九)——EL表达式]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JSTL标签库之核心标签]]></title>
    <url>%2F2019%2F03%2F19%2FJavaWeb---JSTL%E6%A0%87%E7%AD%BE%E5%BA%93%E4%B9%8B%E6%A0%B8%E5%BF%83%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[一. JSTL标签库介绍 JSTL标签库的使用是为弥补 html 标签的不足，规范自定义标签的使用而诞生的,是一个 JSP 的标签集合, 使用 JSLT 标签的目的就是 不希望在 jsp 页面中出现 java 逻辑代码 二. JSTL标签库的分类 核心标签(用得最多) 国际化标签(I18N格式化标签) 数据库标签(SQL标签，很少使用) XML标签(几乎不用) JSTL函数(EL函数) 三. 核心标签库使用说明 JSTL 的核心标签库标签共13个，使用这些标签能够完成 JSP 页面的基本功能，减少编码工作。 从功能上可以分为 4 类 表达式控制标签： out 标签、set 标签、remove 标签、catch 标签。 流程控制标签： if 标签、choose 标签、when 标签、otherwise 标签 循环标签： forEach 标签、forTokens 标签 URL操作标签： import 标签、url 标签、redirect 标签、param 标签 在JSP页面引入核心标签库的代码为： ​ &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 3.1 表达式控制标签1) &lt;c:out&gt; 标签主要是用来输出数据对象（字符串、表达式）的内容或结果 语法格式1&lt;c:out value="&lt;string&gt;" default="&lt;string&gt;" escapeXml="&lt;true|false&gt;"/&gt; 属性 属性 描述 是否必要 默认值 value 要输出的内容 是 无 default 输出的默认值 否 主体中的内容 escapeXml 是否忽略XML特殊字符 否 true 实例12345&lt;body&gt; &lt;c:out value="&amp;lt 未使用转义字符 &amp;gt" escapeXml="true" default="默认值"&gt;&lt;/c:out&gt;&lt;br/&gt; &lt;c:out value="&amp;lt 使用转义字符 &amp;gt" escapeXml="false" default="默认值"&gt;&lt;/c:out&gt;&lt;br/&gt; &lt;c:out value="$&#123;null&#125;" escapeXml="false"&gt;使用的表达式结果为null，则输出该默认值&lt;/c:out&gt;&lt;/body&gt; 打印结果123&amp;lt 未使用转义字符 &amp;gt&lt; 使用转义字符 &gt;使用的表达式结果为null，则输出该默认值 2) &lt;c:set&gt; 标签设置变量值和对象属性 语法格式123456&lt;c:set var="&lt;string&gt;" value="&lt;string&gt;" target="&lt;string&gt;" property="&lt;string&gt;" scope="&lt;string&gt;"/&gt; 属性 属性 描述 是否必要 默认值 value 要存储的值 否 主体的内容 target 要修改的属性所属的对象 否 无 property 要修改的属性 否 无 var 存储信息的变量 否 无 scope var属性的作用域 否 Page 实例123&lt;c:set var="salary" scope="session" value="$&#123;2000*2&#125;"/&gt;&lt;c:out value="$&#123;salary&#125;"/&gt;&lt;!-- 运行结果: 4000 --&gt; 3.2 表达式控制标签1) &lt;c:if&gt; 标签判断表达式的值，如果表达式的值为 true 则执行其主体内容 语法格式123&lt;c:if test="&lt;boolean&gt;" var="&lt;string&gt;" scope="&lt;string&gt;"&gt; ...&lt;/c:if&gt; 属性 属性 描述 是否必要 默认值 test 条件 是 无 var 用于存储条件结果的变量 否 无 scope var属性的作用域 否 page 实例 (模拟 if-else )12345678&lt;c:set var="salary" scope="session" value="$&#123;2000*2&#125;"/&gt;&lt;c:if test="$&#123;salary &gt; 2000&#125;" var="flag" scope="session"&gt; &lt;p&gt;我的工资为: &lt;c:out value="$&#123;salary&#125;"/&gt;&lt;p&gt;&lt;/c:if&gt;&lt;c:if test="$&#123;not flag&#125;"&gt; &lt;p&gt;我的工资为: &lt;c:out value="$&#123;salary&#125;"/&gt;&lt;p&gt;&lt;/c:if&gt; 3.3 循环标签forEach 语法格式1234567&lt;c:forEach items="&lt;object&gt;" begin="&lt;int&gt;" end="&lt;int&gt;" step="&lt;int&gt;" var="&lt;string&gt;" varStatus="&lt;string&gt;" &gt; 属性 属性 描述 是否必要 默认值 items 要被循环的信息 否 无 begin 开始的元素（0=第一个元素，1=第二个元素） 否 0 end 最后一个元素（0=第一个元素，1=第二个元素） 否 Last element step 每一次迭代的步长 否 1 var 代表当前条目的变量名称 否 无 varStatus 代表循环状态的变量名称 否 无 实例 (表格隔行背景色变化,)12345&lt;c:forEach var="item" items="&#123;contents&#125;" varStatus="status"&gt; &lt;tr &lt;c:if test="&#123;status.count%2==0&#125;"&gt;bgcolor="#CCCCFE"/c:if align="left"&gt; xxx &lt;/tr&gt;&lt;/c:forEach&gt; 参考博文​ javaweb学习总结(二十八)——JSTL标签库之核心标签 ​ 菜鸟教程]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---线程(2)]]></title>
    <url>%2F2019%2F03%2F18%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E7%BA%BF%E7%A8%8B(2)%2F</url>
    <content type="text"><![CDATA[四. 线程控制的基本方法 isAlive() : 判断线程是否还”活着”, 即线程是否还未终止 getPriority() : 获得线程的优先级数值 setPriority() : 设置线程的优先级数值 Thread.sleep() : 将当前线程睡眠指定毫秒数 join() 调用某线程的该方法,将当前线程与该线程 “合并”, 即等待该线程结束, 再回复当前线程的运行 yield() : 让出CPU, 当前线程进入就绪队列等待调度 wait() : 当前线程进入对象的 wait pool notify()\notigyAll() : 唤醒对象的 wait pool 中的一个/所有等待线程 3.3 sleep/join/yield 方法介绍主线程的概念所有进程，至少会有一个线程即主线程，即main方法开始执行，就会有一个看不见的主线程存在。 sleep() 方法​ 让当前的正在执行的线程暂停指定的时间，并进入阻塞状态。在其睡眠的时间段内，该线程由于不是处于就绪状态，因此不会得到执行的机会。即使此时系统中没有任何其他可执行的线程，出于sleep()中的线程也不会执行。因此sleep()方法常用来暂停线程执行。 注意 可以调用Thread的静态方法 public static void sleep(long millis) throws InterruptedEcception 使得当前线程休眠(暂时停止执行 millis 毫秒) 因为是静态方法, sleep可以有类名直接调用, Thread.sleep(…) Thread.sleep(1000); 表示当前线程暂停1000毫秒 ，其他线程不受影响 范例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class TestSleep &#123; public static void main(String args[])&#123; MyThread thread = new MyThread(); // 调用start()方法启动新开辟的线程 thread.start(); try &#123; System.out.println("主线程开始启动"); // 静态方法的调用可以直接使用“类名.静态方法名”或者“对象的引用.静态方法名”的方式来调用 Thread.sleep(4000); System.out.println("主线程睡眠了4秒种后再次启动了"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 使用interrupt()方法去结束掉一个线程的执行并不是一个很好的做法 // thread.interrupt(); // 改变循环条件，结束死循环 thread.flag = false; /** * 当发生InterruptedException时，直接把循环的条件设置为false即可退出死循环， * 继而结束掉子线程的执行，这是一种比较好的结束子线程的做法 */ /** * 调用interrupt()方法把正在运行的线程打断相当于是主线程一盆凉水泼上去把正在执行分线程打断了 * 分线程被打断之后就会抛InterruptedException异常，这样就会执行return语句返回， * 结束掉线程的执行所以这里的分线程在执行完4秒钟之后就结束掉了线程的执行 */ &#125;&#125;class MyThread extends Thread &#123; boolean flag = true;// 定义一个标记，用来控制循环的条件 public void run() &#123; /* * 注意：这里不能在run()方法的后面直接写throw Exception来抛异常， * 因为现在是要重写从Thread类继承而来的run()方法,重写方法不能抛出比被重写的方法的不同的异常。 * 所以这里只能写try……catch()来捕获异常 */ while (flag) &#123; System.out.println("==========" + new Date().toLocaleString() + "==========="); try &#123; // 在本类中声明的静态方法时调用时直接写静态方法名即可 // 这里是让这个新开辟的线程每隔一秒睡眠一次，然后睡眠一秒钟后再次启动该线程 sleep(1000); // 睡眠的时如果被打断就会抛出InterruptedException异常 &#125; catch (InterruptedException e) &#123; // 睡眠的时一盘冷水泼过来就有可能会打断睡眠 // 因此让正在运行线程被一些意外的原因中断的时候有可能会抛被打扰中断(InterruptedException)的异常 // 线程被中断后就返回，相当于是结束线程 return; &#125; &#125; &#125;&#125;// 打印结果:/*主线程开始启动==========2019-3-19 16:54:53=====================2019-3-19 16:54:54=====================2019-3-19 16:54:55=====================2019-3-19 16:54:56===========主线程睡眠了4秒种后再次启动了*/ join() 方法合并某个线程 让一个线程等待另一个线程完成才继续执行。如A线程线程执行体中调用B线程的join()方法，则A线程被阻塞，直到B线程执行完为止，A才能得以继续执行 范例12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class TestJoin &#123; public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName() + "主线程运行开始!"); Thread1 mTh1 = new Thread1("A"); Thread1 mTh2 = new Thread1("B"); mTh1.start(); mTh2.start(); try &#123; // 加入main()方法中 mTh1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; // 加入main()方法中 mTh2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "主线程运行结束!"); &#125;&#125;class Thread1 extends Thread &#123; private String name; public Thread1(String name) &#123; super(name); this.name = name; &#125; public void run() &#123; System.out.println(Thread.currentThread().getName() + " 线程运行开始!"); for (int i = 0; i &lt; 3; i++) &#123; System.out.println("子线程" + name + "运行 : " + i); try &#123; // 睡眠时间随机 sleep((int) Math.random() * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + " 线程运行结束!"); &#125;&#125; 应用​ 在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到 join() 方法了 yield() 方法​ 暂停当前正在执行的线程对象(让出CPU)，并执行其他线程 注意 yield()从未导致线程转到等待/睡眠/阻塞状态 yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。当调用线程的 yield() 方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。 范例12345678910111213141516171819202122232425class ThreadYield extends Thread&#123; public ThreadYield(String name) &#123; super(name); &#125; @Override public void run() &#123; for (int i = 1; i &lt;= 50; i++) &#123; System.out.println("" + this.getName() + "-----" + i); // 当i为30时，该线程就会把CPU时间让掉，让其他或者自己的线程执行（也就是谁先抢到谁执行） if (i ==30) &#123; this.yield(); &#125; &#125; &#125; &#125; public class Main &#123; public static void main(String[] args) &#123; ThreadYield yt1 = new ThreadYield("张三"); ThreadYield yt2 = new ThreadYield("李四"); yt1.start(); yt2.start(); &#125; &#125; 运行结果： 第一种情况: 李四 (线程) 当执行到30时会CPU时间让掉，这时张三(线程)抢到CPU时间并执行。 第二种情况: 李四 (线程) 当执行到30时会CPU时间让掉，这时李四 (线程) 抢到CPU时间并执行。 sleep() 和 yield() 的区别 sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。 sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的 实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程 sleep 方法允许较低优先级的线程获得运行机会，但 yield() 方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。 在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行 4. 改变线程的优先级/setPriority()：每个线程在执行时都具有一定的优先级，优先级高的线程具有较多的执行机会。每个线程默认的优先级都与创建它的线程的优先级相同。main线程默认具有普通优先级。 设置线程优先级：setPriority(int priorityLevel) 参数 priorityLevel 范围在1-10之间，常用的有如下三个静态常量值： MAX_PRIORITY: 10 MIN_PRIORITY: 1 NORM_PRIORITY: 5 获取线程优先级：getPriority() 范例1234567891011121314151617181920212223public class TestPriority &#123; public static void main(String[] args) &#123; Thread myThread = new MyThread03(); for (int i = 0; i &lt; 30; i++) &#123; System.out.println("main thread i = " + i); if (i == 5) &#123; // 当 i=5 时,将myThread的优先级设为最高 myThread.setPriority(Thread.MAX_PRIORITY); myThread.start(); &#125; &#125; &#125;&#125;class MyThread03 extends Thread &#123; public void run() &#123; for (int i = 0; i &lt; 30; i++) &#123; System.out.println("i = " + i); &#125; &#125;&#125; 注意​ 具有较高线程优先级的线程对象仅表示此线程具有较多的执行机会，而非优先执行。]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---super关键字]]></title>
    <url>%2F2019%2F03%2F18%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---super%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[一. super 关键字作用 主要存在于子类方法中，用于指向子类对象中父类对象 访问父类的属性 访问父类的函数 访问父类的构造函数 二. super 注意的地方 this 和 super 很像，this指向的是当前对象的调用，super指向的是当前调用对象的父类。 类加载完毕，创建对象，父类的构造方法会被调用（默认自动无参），然后执行子类相应构造创建了一个子类对象，该子类对象还包含了一个父类对象。该父类对象在子类对象内部。 this super 只能在有对象的前提下使用，不能在static方法内使用。 三. super关键字的使用1. 子类隐式调用父类构造函数子类的构造函数默认第一行会默认调用父类无参的构造函数，隐式语句 super(); 范例123456Son(int y) &#123; // super();隐式语句 this.y = y + x; System.out.println("这是子类的有参构造");&#125; 2. 子类显式调用父类构造函数​ 在子类构造函数 第一行 通过super关键字调用父类任何构造函数。如果显式调用父类构造函数，编译器自动添加的调用父类无参数的构造就消失。构造函数间的调用只能放在第一行，只能调用一次 。super()和this()不能同时存在构造函数第一行 。 12345Son(int y) &#123; super(y);// 子类显式调用父类构造函数 this.y = y + x; System.out.println("这是子类的有参构造");&#125; 实例1234567891011121314151617181920212223242526272829303132333435363738394041424344class Father &#123; public int value; public void method() &#123; value = 100; System.out.println("父类的value属性值 = " + value); &#125;&#125;class Son extends Father &#123; // 子类除了继承父类所具有的valu属性外，自己又另外声明了一个value属性，此时的子类拥有两个value属性。 public int value; // 在子类ChildClass里面重写了从父类继承下来的method()方法里面的实现，即重写(覆盖)了method()方法 public void method() &#123; // 使用super作为父类对象的引用对象来调用父类对象里面的f()方法 super.method(); // 这个value是子类自己定义的那个value，不是从父类继承下来的那个value value = 200; System.out.println("子类的value属性值=" + value); System.out.println("修改父类的value之前,值为: " + super.value); super.value = 300; System.out.println("修改父类的value之后,值为: " + super.value); &#125;&#125;public class TestSuper &#123; public static void main(String[] args) &#123; Son son = new Son(); son.method(); &#125;&#125;/** 打印结果: * 父类的value属性值 = 100 * 子类的value属性值=200 * 修改父类的value之前,值为: 100 * 修改父类的value之后,值为: 300 * */ 详细的内存分析见 参考博文 四. super思考如果开发者自定义了一个类，没有显示的进行类的继承，那么该类中成员函数是否可以使用super关键字？ 答: 可以使用，继承了Object类，Object类是所有类的父类 参考博文​ Java super关键字详解 ​ java基础学习总结——super关键字]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---this关键字]]></title>
    <url>%2F2019%2F03%2F18%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---this%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[一. 概念​ this 关键字代表自身 注意 this关键字必须放在非静态方法里面 当必须指出 当前使用方法的对象是谁 时要使用 this 有时使用 this 可以处理方法中 成员变量和参数重名的现象 this 可以看做是 一个变量, 它的值是当前对象的引用 二. 在程序中使用用途: 使用this关键字 引用成员变量 使用this关键字在 自身构造方法内部引用其它构造方法 使用this关键字代表 自身类的对象 使用this关键字引用成员方法 1. 使用 this 引用成员变量​ 在一个类的方法或构造方法内部，可以使用“this.成员变量名”这样的格式来引用成员变量名，有些时候可以省略，有些时候不能省略。 1234567891011public class ReferenceVariable &#123; private int a; public ReferenceVariable(int a)&#123; this.a = a; &#125; public void setA(int a)&#123; this.a = a; &#125;&#125; 在该代码的构造方法和setA方法内部，都是用this.a引用类的成员变量。因为无论在构造方法还是setA方法内部，都包含2个变量名为a的变量，一个是参数a，另外一个是成员变量a。按照Java语言的变量作用范围规定，参数a的作用范围为构造方法或方法内部，成员变量a的作用范围是类的内部，这样在构造方法和setA方法内部就存在了变量a的冲突，Java语言规定当变量作用范围重叠时，作用域小的变量覆盖作用域大的变量。所以在构造方法和setA方法内部，参数a起作用。 这样需要访问成员变量a则必须使用this进行引用。当然，如果变量名不发生重叠，则this可以省略。 但是为了增强代码的可读性，一般将参数的名称和成员变量的名称保持一致，所以this的使用频率在规范的代码内部应该很多。 2. 引用构造方法​ 在一个类的构造方法内部，也可以使用this关键字引用其它的构造方法，这样可以降低代码的重复，也可以使所有的构造方法保持统一，这样方便以后的代码修改和维护，也方便代码的阅读。 1234567891011public class ReferenceConstructor &#123; int a; public ReferenceConstructor()&#123; this(0); &#125; public ReferenceConstructor(int a)&#123; this.a = a; &#125;&#125; 这里在不带参数的构造方法内部，使用this调用了另外一个构造方法，其中0是根据需要传递的参数的值 当一个类内部的构造方法比较多时，可以只书写一个构造方法的内部功能代码，然后其它的构造方法都通过调用该构造方法实现，这样既保证了所有的构造是统一的，也降低了代码的重复。 在实际使用时，需要注意的是，在构造方法内部使用this关键字调用其它的构造方法时，调用的代码只能出现在构造方法内部的第一行可执行代码。这样，在构造方法内部使用this关键字调用构造方法最多会出现一次。 3. 代表自身对象​ 在一个类的内部，也可以使用this代表自身类的对象，或者换句话说，每个类内部都有一个隐含的成员变量，该成员变量的类型是该类的类型，该成员变量的名称是this，实际使用this代表自身类的对象的 解释​ 假设我们在堆内存new了一个对象，在这个对象里面你有一个引用 this，this 指向这个对象自己，所以这就是this，这个new出来的对象名字是什么，我们不知道，不知道也没关系，因为这并不影响这个对象在内存里面的存在，这个对象只要在内存中存在，他就一定有一个引用this ,在 类的方法定义中 使用的 this 关键字代表 使用该方法的==对象的引用== 示例代码如下： 123456789public class ReferenceObject &#123; ReferenceObject instance; public ReferenceObject()&#123; instance = this; &#125; public void test()&#123; System.out.println(this); &#125;&#125; ​ 构造方法内部，将对象this的值赋值给instance，在test方法内部，输出对象this的内容，这里的this都代表自身类型的对象。 4. 引用成员方法 在一个类的内部，成员方法之间的互相调用时也可以使用“this.方法名(参数)”来进行引用，只是所有这样的引用中this都可以省略，所以这里就不详细介绍了 三. 内存中的分析范例12345678910111213141516171819202122232425// 如何区分两个 ipublic class Leaf &#123; // 在 Leaf 类里面定义一个成员变量 i int i = 0; // 定义 Leaf 这个类的构造方法,构造方法里面有一个局部变量i,这个i与成员变量i同名 // public Leaf(int i) &#123; // this.i 中使用this就是为了却分开成员变量i和形参i,如果这里不写this,而是直接写"i=i",这样就不好区分了,因此有时使用this可以处理方法中成员变量和参数重名的情况 // 后面这个 i 是构造方法里面声明的形参i,在这里有一个原则,当你确定不了一个参数到时指的是哪一个变量的时候,赵丽这个参数最近的声明(就近声明原则) this.i = i; &#125; Leaf increament() &#123; i++; // 这个方法要求的返回类型是Leaf本身的类型,也就是指向Leaf的一个引用,既然是要指向Leaf的一个引用,return this,this指向自身,自身又是Leaf.因此使用 return this 返回的值就是 Leaf本身 return this; &#125; void print() &#123; System.out.println("i = " + i); &#125; public static void main(String[] args) &#123; Leaf leaf = new Leaf(100); leaf.increament().increament().print(); &#125;&#125; 在内存中分析main方法的执行过程* Leaf leaf = new Leaf(100); 程序执行到这里的时候，栈空间里面有一个变量leaf，它指向了我们new出来的在堆空间里面的Leaf对象。new这个Leaf对象的时候，调用了构造方法Leaf(),这个构造方法里面有一个形参 i，所以在栈空间里面给构造方法分配有一小块内存，名字叫i用来装传递过来的实参。这里传过来的实参是100，所以 i 里面装的值就是100。得到这个值之后，构造方法继续执行，执行 this.i = i; 这里就是把栈空间里面的 i 的值通过值传递给Leaf对象里面的成员变量i，所以成员变量 i 的值也变成了100。 leaf.increament().increament().print(); 详情见参考博文 四. 总结​ this一般出现在方法里面，当这个方法还没有调用的时候，this指的是谁并不知道。但是实际当中，你如果new了一个对象出来，那么this指的就是当前这个对象。对哪个对象调用方法，this指的就是调用方法的这个对象（你对哪个对象调用这个方法，this指的就是谁）。如果再new一个对象，这个对象他也有自己的this，他自己的this就当然指的是他自己了。 参考博文​ JAVA中this的三种用法的详解 ​ java基础学习总结——this关键字]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---对象转型]]></title>
    <url>%2F2019%2F03%2F15%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一. 对象转型介绍1.1 解释把一种形式转成另外一种形式就叫转型 基础数据类型的转型, (例如: 把 float 类型转成 int 类型，把 float 类型转成 double 类型) 对象领域里面对象之间的转型。 对象转型分为两种： 向上转型 向下转型 二. 向上转型2.1 定义:​ 子类引用的对象转换为父类类型称为向上转型, 通俗地说就是是将子类对象转为父类对象.父类对象可以是接口 2.2 解释​ 比如说我有两个类，一个是父类Animal，另一个是Dog类为子类. Animal c = new Dog(); 2.3 实例12345678910public class TestObjectShift &#123; public static void main(String[] args)&#123; Animal a = new Animal("name"); Dog d = new Dog("dogname", "black"); // 向上转型, a这个引用不指向Animal类的实例对象了，而是指向了Dog这个类的一个实例对象 a = new Dog("bigyellow", "yellow"); &#125;&#125; 注意 一个父类(基类)对象的引用是不可以访问其子类对象新增加的成员(属性和方法)的。 三. 对象的向下转型3.1 定义父类引用的对象转换为子类类型成为向下转型 3.2 解释​ 比如说我有两个类，一个是父类Animal，另一个是Dog类为子类. Dog d1 = (Dog) a; 3.3 实例123456789101112131415161718public class TestObjectShift &#123; public static void main(String[] args)&#123; Animal a = new Animal("AnimalName"); Dog d = new Dog("dogName", "black"); // 向下转型 // 父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错， // 但是运行时会出现java.lang.ClassCastException错误 // Dog dd = (Dog) a; // 向下转型,父类引用的对象如果引用的是指向的子类对象，那么在向下转型的过程中是安全的。也就是编译是不会出错误的 // 这里使用强制转换，把指向Animal类的引用对象a转型成指向Dog类对象的引用， // 这样转型后的引用对象d1就可以直接访问Dog类对象里面的新增的成员了。 a = new Dog("bigyellow", "yellow"); Dog d1 = (Dog) a; &#125;&#125; 注意 如果父类引用的对象如果引用的是指向的子类对象，那么在向下转型的过程中是安全的。也就是编译是不会出错误的。 如果父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，但是运行时会出现java.lang.ClassCastException错误。它可以使用instanceof来避免出错此类错误。 四. 完整实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package test;class Animal &#123; public String name; public Animal(String name) &#123; this.name = name; &#125;&#125;class Cat extends Animal &#123; public String eyeColor; public Cat(String n, String c) &#123; super(n); // 调用父类Animal的构造方法 this.eyeColor = c; &#125;&#125;class Dog extends Animal &#123; // Dog类添加自己特有的属性 public String furColor; public Dog(String n, String c) &#123; super(n); // 调用父类Animal的构造方法 this.furColor = c; &#125;&#125;public class TestObjectShift &#123; public static void main(String[] args) &#123; Animal a = new Animal("AnimalName"); Cat c = new Cat("catName", "blue"); Dog d = new Dog("dogName", "black"); // a instanceof Animal这句话的意思是a是一只动物吗？ // a是Animal这个类里面的是一个实例对象，所以a当然是一只动物，其结果为true。 System.out.println(String.format("a instanceof Animal的结果是%s", a instanceof Animal)); // true // c是Cat类的实例对象的引用，即c代表的就是这个实例对象，所以“c是一只动物”打印出来的结果也是true。 System.out.println(String.format("c instanceof Animal的结果是%s", c instanceof Animal)); // true // 这里判断说“动物是一只猫”，不符合逻辑，所以打印出来的结果是false。 System.out.println(String.format("a instanceof Cat的结果是%s", a instanceof Cat)); // 向下转型 // 父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错， // 但是运行时会出现java.lang.ClassCastException错误 // Dog dd = (Dog) a; /** * 向上转型 a这个引用不指向Animal类的实例对象了，而是指向了Dog这个类的一个实例对象 * 这里也就是父类对象的引用指向了子类的一个实例对象。 */ a = new Dog("bigyellow", "yellow"); System.out.println(a.name); // bigyellow /** * 这里的furColor属性是子类在继承父类的基础上新增加的一个属性，是父类没有的。 * 因此这里使用父类的引用对象a去访问子类对象里面新增加的成员变量是不允许的， * 因为在编译器眼里，你a就是Animal类对象的一个引用对象，你只能去访问Animal类对象里面所具有的name属性， * 除了Animal类里面的属性可以访问以外，其它类里面的成员变量a都没办法访问。 * 这里furColor属性是Dog类里面的属性，因此你一个Animal类的引用是无法去访问Dog类里面的成员变量的， * 尽管你a指向的是子类Dog的一个实例对象，但因为子类Dog从父类Animal继承下来， * 所以new出一个子类对象的时候，这个子类对象里面会包含有一个父类对象， * 因此这个a指向的正是这个子类对象里面的父类对象，因此尽管a是指向Dog类对象的一个引用， * 但是在编译器眼里你a就是只是一个Animal类的引用对象，你a就是只能访问Animal类里面所具有的成员变量， 别的你都访问不了。 * 因此一个父类(基类)对象的引用是不可以访问其子类对象新增加的成员(属性和方法)的。 */ // System.out.println(a.furColor); // 这里判断说“a是一只Dog”是true。 因为instanceof探索的是实际当中你整个对象到底是什么东西， // 并不是根据你的引用把对象看出什么样来判断的。 System.out.println(String.format("a instanceof Dog的结果是%s", a instanceof Dog));// true // 向下转型,父类引用的对象如果引用的是指向的子类对象，那么在向下转型的过程中是安全的。也就是编译是不会出错误的 // 这里使用强制转换，把指向Animal类的引用对象a转型成指向Dog类对象的引用， // 这样转型后的引用对象d1就可以直接访问Dog类对象里面的新增的成员了。 Dog d1 = (Dog) a; System.out.println(d1.furColor); // yellow &#125;&#125; 详细解释见 参考博文 总结对象转型可以使父类对象的引用可以指向子类对象，给程序带来了比较好的可扩展性：我们可以在一个方法的参数里面定义父类的引用，然后实际当中传的时候传的是子类的对象，然后我们再在方法里面判断这个传过来的子类对象到底属于哪个子类，然后再去执行这个子类里面的方法或者调用这个子类里面的成员变量，因此程序的可扩展性比单独定义好多个方法要好一些。不过这个可扩展性还没有达到最好，使用多态就可以让程序的扩展性达到极致。 参考博文​ java上转型和下转型（对象的多态性）]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---多态]]></title>
    <url>%2F2019%2F03%2F15%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[一. 概念多态是同一个行为具有多个不同表现形式或形态的能力(同一个事件发生在不同的对象上会产生不同的结果) 例子 现实中，比如我们按下 F1 键这个动作: 1. 如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档; 2. 如果当前在 Word 下弹出的就是 Word 帮助; 3. 在 Windows 下弹出的就是 Windows 帮助和支持。 Java中操作符 +: 1. 可以作为算数运算; 2. 可以作为字符串连接 Java中类的多态: 父类引用指向子类对象 二. 观察类的多态现象范例MagicPotion.java12345public class MagicPotion extends Item&#123; public void effect()&#123; System.out.println("蓝瓶使用后，可以回魔法"); &#125;&#125; LifePotion.java12345public class LifePotion extends Item &#123; public void effect()&#123; System.out.println("血瓶使用后，可以回血"); &#125;&#125; Item.java1234567891011121314151617181920public class Item &#123; public void effect() &#123; System.out.println("物品使用后，可以有效果 "); &#125; public static void main(String[] args) &#123; Item i1= new LifePotion(); Item i2 = new MagicPotion(); System.out.print("i1 是Item类型，执行effect打印:"); i1.effect(); System.out.print("i2 也是Item类型，执行effect打印:"); i2.effect(); &#125;&#125;/** * 打印结果: * i1 是Item类型，执行effect打印:血瓶使用后，可以回血 * i2 也是Item类型，执行effect打印:蓝瓶使用后，可以回魔法 */ 观察类的多态现象 i1和i2都是Item类型 都调用effect方法 输出不同的结果 多态: 都是同一个类型，调用同一个方法，却能呈现不同的状态 三. 多态存在的三个必要条件3.1 继承类的多态发生在父类调用指向子类对象, 所以一定有子类继承父类 3.2 重写子类对父类中某些方法进行重新定义 父类调用相同的方法, 实现却不一样,所以必定有重写 3.3 向上转型将子类的引用赋给父类对象(父类引用指向子类对象) 四. 多态的实现方式4.1 重写子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。 4.2 接口 生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。 java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。 4.3 抽象类和抽象方法五. 深入理解多态也叫动态绑定 : 动态绑定是指在 执行期间 (而非编译期间) 判断所引用对象的实际类型，根据其实际的类型调用其相应的方法 总结动态绑定（多态）动态绑定是指在“执行期间”（而非编译期间）判断所引用的实际对象类型，根据其实际的类型调用其相应的方法。所以实际当中找要调用的方法时是动态的去找的，new的是谁就找谁的方法，这就叫动态绑定。动态绑定帮助我们的程序的可扩展性达到了极致 六. 多态存在的意义范例1假设你要设计一个通用框架，这个框架会涉及到数据库的操作，但是你不能限定用户用哪个数据库，这个时候你就可以用到多态。 你可以设计一个接口：DataBaseDao 然后，每个不同的数据库，你可以编写接口的实现类，比如：SQLServerDao, MySqlDao, DB2Dao等等当用户使用你框架的时候，他就可以用多态，实现自己的数据库连接功能： 123 // 针对SQLServer的接口实现，这里dao就是多态DaoBaseDao dao = new SQLServerDao(); dao.connect(); 范例2实例: 【超经典】Java多态有什么好处？怎样用？ 参考博文​ java基础学习总结——多态(动态绑定) ​ Java 多态 ​ 接口与继承 ​ java提高篇(四)—–理解java的三大特性之多态]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---反射]]></title>
    <url>%2F2019%2F03%2F15%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[一. 什么是反射​ 反射之中包含了一个「反」字，所以想要解释反射就必须先从「正」开始解释。 1.1 正射​ 一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。 正射范例1234// 进行类对象的初始化，可以理解为「正」。Apple apple = new Apple(); //直接初始化，「正射」apple.setPrice(5);System.out.println("Apple Price:" + apple.getPrice()); 1.2 反射​ 反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。 这时候，我们使用 JDK 提供的反射 API 进行反射调用 反射范例123456789101112131415// 使用反射获取一个对象的步骤：// 1. 获取类的 Class 对象, 类对象Class clz = Class.forName("how2j10.Apple");// 2. 根据 Class 对象实例获取 Constructor 对象, 构造器Constructor appleConstructor = clz.getConstructor();// 3. 使用 Constructor 对象的 newInstance 方法获取反射类对象, 通过构造器实例化Object appleObj = appleConstructor.newInstance();// 如果要调用某一个方法，则需要经过下面的步骤// 1. 获取方法的 Method 对象Method setPriceMethod = clz.getMethod("setPrice", int.class);// 2. 利用 invoke 方法调用方法setPriceMethod.invoke(appleObj, 14);Method getPriceMethod = clz.getMethod("getPrice");System.out.println("Apple Price:" + getPriceMethod.invoke(appleObj)); ​ 上面两段代码的执行结果，其实是完全一样的。 ​ 但是其思路完全不一样，第一段代码在未运行时就已经确定了要运行的类（Apple），而第二段代码则是在运行时通过字符串值才得知要运行的类（com.chenshuyi.reflect.Apple）。 什么是反射？ 反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。 二. 获取反射中的 Class 对象(类对象)2.1 类对象​ 概念: 类对象用于提供类本身的信息，比如有几种构造方法， 有多少属性，有哪些普通方法 什么是类对象 对象之间的区别: garen和teemo都是Hero对象，他们的区别在于，各自有不同的名称，血量，伤害值。 类之间的区别: Hero和Item都是类，他们的区别在于有不同的方法，不同的属性。 ==类对象，就是用于描述这种类，都有什么属性，什么方法的== 在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。 2.2 获取class对象(类对象) 在 Java API 中，获取 Class 类对象有三种方法 在一个JVM中，一种类，只会有一个类对象存在。所以三种方式取出来的class对象，都是一样的。 方法范例123456789101112131415// how2j10 是包名, Apple 是类名String className = "how2j10.Apple";// 1. 使用 Class.forName 静态方法。当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。Class clz = Class.forName(className);// 2. 使用 .class 方法。 这种方法只适合在编译前就知道操作的 Class。Class clz = Apple.class;Class clz = this.class; // 这种调用本类的类对象,常用// 3. 第三种，使用类对象的 getClass() 方法。Class clz = new Apple().getClass();System.out.println("clz的值为:" + clz);// 打印结果: clz的值为:class how2j10.Apple 2.3 注意:​ 获取类对象的时候，会导致类属性被初始化 ​ 无论什么途径获取类对象，都会导致静态属性被初始化，而且只会执行一次。（除了直接使用 Class c = Hero.class 这种方式，这种方式不会导致静态属性被初始化） 三. 通过反射获取构造方法并使用3.1 获取单个的构造方法，并调用： public Constructor getConstructor(Class... parameterTypes) : 获取单个的”公有的”构造方法： public Constructor getDeclaredConstructor(Class... parameterTypes): 获取“某个构造方法”可以是私有的，或受保护、默认、公有 范例12// 获取构造器Constructor appleConstructor = clz.getConstructor(); 3.3 调用构造方法：​ newInstance是 Constructor类的方法（管理构造函数的类） api的解释为： newInstance(Object... initargs) : 使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。 它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象。并为之调用 范例12// 通过构造器实例化,使用 Constructor 对象的 newInstance 方法获取反射类对象Object appleObj = appleConstructor.newInstance(); 四. 获取成员变量4.1 获取成员变量并调用 批量的 Field[] getFields(): 获取所有的”公有字段” Field[] getDeclaredFields(): 获取所有字段，包括：私有、受保护、默认、公有 获取单个的 public Field getField(String fieldName) : 获取某个”公有的”字段； public Field getDeclaredField(String fieldName) : 获取某个字段***(可以是私有的) 4.2 设置字段的值​ Field --&gt; public void set(Object obj,Object value) 参数说明： obj : 要设置的字段所在的对象； value : 要为字段设置的值； 范例12345678910111213141516171819public class Fields &#123; public static void main(String[] args) throws Exception &#123; // 1.获取Class对象 Class stuClass = Class.forName("fanshe.field.Student"); // 2.获取字段 System.out.println("********获取公有字段**并调用*********"); Field f = stuClass.getField("name"); System.out.println(f); // 3.获取一个对象 // 产生Student对象 --&gt; Student stu = new Student(); Object obj = stuClass.getConstructor().newInstance(); // 4.为字段设置值 // 为Student对象中的name属性赋值 --&gt; stu.name = "刘德华" f.set(obj, "刘德华"); &#125;&#125; 五. 获取成员方法并调用5.1 获取成员方法： 批量的批量的 public Method[] getMethods() : 获取所有”公有方法”；（包含了父类的方法也包含Object类） public Method[] getDeclaredMethods() : 获取所有的成员方法，包括私有的(不包括继承的) 获取单个的： public Method getMethod(String name,Class&lt;?&gt;... parameterTypes) 参数说明 name : 方法名； Class … : 形参的Class类型对象 public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes) 5.2 成员方法调用​ Method --&gt; public Object invoke(Object obj,Object... args) 参数说明 obj : 要调用方法的对象； args : 调用方式时所传递的实参； 12345678910111213141516171819202122public class MethodClass &#123; public static void main(String[] args) throws Exception &#123; // 1.获取Class对象 Class stuClass = Class.forName("fanshe.method.Student"); System.out.println("***************获取公有的show1()方法*******************"); //2. 获取方法 Method m = stuClass.getMethod("show1", String.class); System.out.println(m); // 3.实例化一个Student对象 Object obj = stuClass.getConstructor().newInstance(); // 4.方法的调用,一个是要调用的对象（获取有反射），一个是实参 m.invoke(obj, "刘德华"); System.out.println("***************获取私有的show4()方法******************"); m = stuClass.getDeclaredMethod("show4", int.class); System.out.println(m); m.setAccessible(true);//解除私有限定 Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参 System.out.println("返回值：" + result); &#125;&#125; 六. 通过反射运行配置文件内容6.1 反射的作用 我们利用反射和配置文件，可以使：应用程序更新时，对源码无需进行任何修改 我们只需要将新类发送给客户端，并修改配置文件即可 代码实现student类12345public class Student &#123; public void show()&#123; System.out.println("is show()"); &#125;&#125; 配置文件以 txt 文件为例子（pro.txt） 12className = cn.fanshe.StudentmethodName = show 测试类1234567891011121314151617181920public class Demo &#123; public static void main(String[] args) throws Exception &#123; // 1.通过反射获取Class对象 Class stuClass = Class.forName(getValue("className")); //"cn.fanshe.Student" // 2.获取 show()方法 Method m = stuClass.getMethod(getValue("methodName")); //show // 3.调用show()方法 m.invoke( stuClass.getConstructor().newInstance()); &#125; // 此方法接收一个 key，在配置文件中获取相应的 value public static String getValue(String key) throws IOException&#123; Properties pro = new Properties();//获取配置文件的对象 FileReader in = new FileReader("pro.txt");//获取输入流 pro.load(in);//将流加载到配置文件对象中 in.close(); return pro.getProperty(key);//返回根据key获取的value值 &#125;&#125;// 打印结果: is show() 需求​ 当我们升级这个系统时，不要Student类，而需要新写一个Student2的类时，这时只需要更改pro.txt的文件内容就可以了。代码就一点不用改动 要替换的student2类12345public class Student2 &#123; public void show2()&#123; System.out.println("is show2()"); &#125;&#125; 配置文件更改为12className = cn.fanshe.Student2methodName = show2 控制台输出：1// 打印结果: is show2() 参考博文​ 大白话说Java反射：入门、使用、原理 ​ Java基础之—反射（非常重要） ​ how2j ​ Java 反射机制]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---框架图解]]></title>
    <url>%2F2019%2F03%2F14%2FJavaWeb-%E6%A1%86%E6%9E%B6%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. MVC 模式 2. sevlet]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JSP指令]]></title>
    <url>%2F2019%2F03%2F14%2FJavaWeb---JSP%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一、JSP 指令简介 JSP指令（directive）是为 JSP 引擎而设计的，它们并不直接产生任何可见输出，而只是告诉引擎 如何处理JSP页面中的其余部分。 在 JSP 2.0规范中共定义了三个指令： page指令 Include指令 taglib指令 JSP指令的基本语法格式：&lt;%@ 指令 属性名=”值” %&gt; 例如12345678&lt;%@ page contentType="text/html;charset=gb2312"%&gt;&lt;!--如果一个指令有多个属性，这多个属性可以写在一个指令中，也可以分开写--&gt;&lt;%@ page contentType="text/html;charset=gb2312"%&gt;&lt;%@ page import="java.util.Date"%&gt;&lt;!--也可以写作--&gt;&lt;%@ page contentType="text/html;charset=gb2312" import="java.util.Date"%&gt; 二、Page指令​ page指令 用于定义 JSP 页面的==各种属性== ，无论page指令出现在JSP页面中的什么地方，它作用的都是整个JSP页面，为了保持程序的可读性和遵循良好的编程习惯，page指令最好是放在整个JSP页面的起始位置。 范例123456789101112131415161718&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!--指令完整语法--&gt;&lt;%@ page [ language="java" ] [ extends="package.class" ] [ import="&#123;package.class | package.*&#125;, ..." ] [ session="true | false" ] [ buffer="none | 8kb | sizekb" ] [ autoFlush="true | false" ] [ isThreadSafe="true | false" ] [ info="text" ] [ errorPage="relative_url" ] [ isErrorPage="true | false" ] [ contentType="mimeType [ ;charset=characterSet ]" | "text/html ; charset=ISO-8859-1" ] [ pageEncoding="characterSet | ISO-8859-1" ] [ isELIgnored="true | false" ] &lt;!--是否忽略 EL 表达式--&gt;%&gt; 三. include指令在JSP中对于包含有两种语句形式： @include 指令 &lt;jsp:include&gt; 指令 3.1 @include指令 @include可以包含任意的文件，当然，只是把文件的内容包含进来。 include指令用于引入其它JSP页面，如果使用include指令引入了其它JSP页面，那么JSP引擎将把这两个JSP翻译成一个servlet。所以include指令引入通常也称之为静态引入。 语法： 12&lt;!--其中的file属性用于指定被引入文件的路径。路径以“/”开头，表示代表当前web应用。--&gt;&lt;%@ include file="relativeURL"%&gt; include指令细节注意问题： 被引入的文件必须遵循 JSP 语法。 被引入的文件可以使用任意的扩展名，即使其扩展名是html，JSP引擎也会按照处理jsp页面的方式处理它里面的内容，为了见明知意，JSP规范建议使用 .jspf（JSP fragments(片段)）作为静态引入文件的扩展名。 由于使用include指令将会涉及到2个JSP页面，并会把2个JSP翻译成一个servlet，所以这2个JSP页面的指令不能冲突(除了pageEncoding和导包除外)。 范例 新建head.jspf页面和foot.jspf页面，分别作为jsp页面的头部和尾部，存放于WebRoot下的jspfragments文件夹中，代码如下： head.jspf代码： 12&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;h1 style="color:red;"&gt;网页头部&lt;/h1&gt; foot.jspf代码： 12&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;h1 style="color:blue;"&gt;网页尾部&lt;/h1&gt; 在WebRoot文件夹下创建一个IncludeTagTest.jsp页面，在IncludeTagTest.jsp页面中使用@include指令引入head.jspf页面和foot.jspf页面，代码如下： 1234567891011121314&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;jsp的Include指令测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%--使用include标签引入引入其它JSP页面--%&gt; &lt;%@include file="/jspfragments/head.jspf" %&gt; &lt;h1&gt;网页主体内容&lt;/h1&gt; &lt;%@include file="/jspfragments/foot.jspf" %&gt; &lt;/body&gt;&lt;/html&gt; 3.2 总结 @include 指令 使用@include可以包含任意的内容，文件的后缀是什么都无所谓。这种把别的文件内容包含到自身页面的@include语句就叫作静态包含，作用只是把别的页面内容包含进来，属于静态包含 3.3 jsp:include指令 jsp:include指令为动态包含，如果被包含的页面是JSP，则先处理之后再将结果包含，而如果包含的是非*.jsp文件，则只是把文件内容静态包含进来，功能与@include类似。后面再具体介绍 四. taglib 指令4.1 引入Taglib 指令是定义一个标签库以及其自定义标签的前缀.需要导入standard.jar ; jsp-api.jar 两个包 在 JSP 页面中使用第三方的标签库时，需要使用 taglib 指令来 “导包”。例如： 1&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt; 解释 prefix : 标签库别名 uri : 是由第三方标签库定义的，所以你需要知道第三方定义的uri 4.2 标签库引入 jsp 文件时 uri 有两种写法 自定义 标准定义 当打开一个tld文件时，在文件的头部会有一个uri节点，里面的内容即为uri的标准定义。 使用标准定义的优点在于，不用在web.xml下加上上面的代码 源码 Referenced Library/standard.jar/META-INF/c.tld12&lt;short-name&gt;c&lt;/short-name&gt;&lt;uri&gt;http://java.sun.com/jsp/jstl/core&lt;/uri&gt; jsp12345678910111213&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt; &lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt; &lt;!DOCTYPE&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;collection&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 参考博文​ javaweb学习总结(十六)——JSP指令]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JSP基础语法]]></title>
    <url>%2F2019%2F03%2F14%2FJavaWeb---JSP%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[​ 任何语言都有自己的语法，JAVA 中有，JS P虽然是在JAVA上的一种应用，但是依然有其自己扩充的语法，而且在 JSP 中，所有的 JAVA 语句都可以使用。 一. JSP 模版元素 JSP 页面中的 HTML 内容 称之为 JSP 模版元素 。 JSP 模版元素定义了网页的 基本骨架 ，即定义了页面的结构和外观。 二、JSP表达式 JSP 脚本表达式（expression）用于将程序数据输出到客户端 ​ 语法：&lt;%= 变量或表达式 %&gt; 举例：输出当前系统时间: 1&lt;%= new java.util.Date() %&gt; JSP引擎在翻译脚本表达式时，会将程序数据转成字符串，然后在相应位置用out.print(…) 将数据输给客户端。 JSP脚本表达式中的变量或表达式后面不能有分号（;）。 三、JSP脚本片断 JSP脚本片断(scriptlet)用于在JSP页面中编写多行Java代码。 语法1234&lt;!-- 在&lt;% %&gt;中可以定义变量、编写语句，不能定义方法--&gt;&lt;% 多行java代码 %&gt; 范例: 在Scriptlet中定义变量、编写语句 123456789&lt;% int sum=0;//声明变量 /*编写语句*/ for (int i=1;i&lt;=100;i++)&#123; sum+=i; &#125; out.println("&lt;h1&gt;Sum="+sum+"&lt;/h1&gt;");%&gt; 注意事项 JSP脚本片断中只能出现java代码，不能出现其它模板元素， JSP引擎在翻译JSP页面中，会将JSP脚本片断中的Java代码将被原封不动地放到Servlet的_jspService方法中。 JSP脚本片断中的Java代码必须严格遵循Java语法，例如，每执行语句后面必须用分号（;）结束。 在一个 JSP 页面中可以有多个脚本片断，在两个或多个脚本片断之间可以嵌入文本、HTML标记和其他JSP元素。 四、JSP声明JSP页面中编写的所有代码，默认会翻译到 servlet 的 service 方法中， 而 JSP 声明中的 java代码 被翻译到 _jspService方法的外面。 语法123&lt;%！ java代码%&gt; ​ 所以，JSP声明可用于定义JSP页面转换成的Servlet程序的静态代码块、成员变量和方法 。 多个静态代码块、变量和函数可以定义在一个JSP声明中，也可以分别单独定义在多个JSP声明中。JSP隐式对象的作用范围仅限于Servlet的 _jspService 方法，所以在 JSP 声明中不能使用这些隐式对象。 范例1234567891011121314151617&lt;%! static &#123; System.out.println("loading Servlet!"); &#125; private int globalVar = 0; public void jspInit()&#123; System.out.println("initializing jsp!"); &#125;%&gt;&lt;%! public void jspDestroy()&#123; System.out.println("destroying jsp!"); &#125;%&gt; 五. JSP注释在 JSP 中，注释有两大类： 显式注释：直接使用HTML风格的注释：&lt;!- - 注释内容**- -&gt; 隐式注释：直接使用JAVA的注释：//、/*……***/** JSP自己的注释：&lt;%- -注释内容- -%&gt; 范例1234567891011&lt;!--这个注释可以看见--&gt;&lt;% //JAVA中的单行注释 /* JAVA中的多行注释 */%&gt;&lt;%--JSP自己的注释--%&gt; 区别 ​ HTML的注释在浏览器中查看源文件的时候是可以看得到的，而JAVA注释和JSP注释在浏览器中查看源文件时是看不到注释的内容 参考博文​ javaweb学习总结(十五)——JSP基础语法]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JavaWeb开发入门]]></title>
    <url>%2F2019%2F03%2F14%2FJavaWeb---JavaWeb%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[一. 基本概念1.1 WEB 开发的相关知识 WEB，在英语中web即表示网页的意思，它用于表示Internet主机上供外界访问的资源。 Internet上供外界访问的Web资源分为： 静态web资源（如html 页面）：指web页面中供人们浏览的数据始终是不变的。 动态web资源：指web页面中供人们浏览的数据是** 由程序产生的，不同时间点访问web页面看到的内容各不相同**。 静态web资源开发技术：Html 常用动态web资源开发技术：JSP/Servlet、ASP、PHP等 在 Java 中，动态web资源开发技术统称为 ==Javaweb==。 1.2 WEB应用程序 WEB应用程序指供浏览器访问的程序，通常也简称为web应用。例如有a.html 、b.html…..多个web资源，这多个web资源用于对外提供服务，此时应把这多个web资源放在一个目录中，以组成一个web应用（或web应用程序） 一个web应用由多个静态web资源和动态web资源组成，如:html、css、js文件，Jsp文件、java程序、支持jar包、配置文件等等。 Web应用开发好后，若想供外界访问，需要把web应用所在目录交给web服务器管理，这个过程称之为虚似目录的映射 二. WEB服务器2.1 WEB服务器简介 1. Web服务器是指驻留于因特网上某种类型计算机的程序，是可以向发出请求的浏览器提供文档的程序。当Web浏览器（客户端）连到服务器上并请求文件时，服务器将处理该请求并将文件反馈到该浏览器上，附带的信息会告诉浏览器如何查看该文件（即文件类型）。 2、服务器是一种被动程序：只有当Internet上运行在其他计算机中的浏览器发出请求时，服务器才会响应。 2.2、常见的Web服务器介绍1. WebLogic2. WebSphere3. Tomcat TomcatTomcat是一个实现了JAVA EE标准的最小的WEB服务器，是Apache 软件基金会的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。因为Tomcat 技术先进、性能稳定，而且开源免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。学习JavaWeb开发一般都使用Tomcat服务器，该服务器支持全部JSP以及Servlet规范，启动界面如图： 4. IIS 学习web开发，需要先安装一台web服务器，然后再在web服务器中开发相应的web资源，供用户使用浏览器访问。 三. 搭建JavaWeb应用开发环境——Tomcat服务器3.1 疑问：学习web开发，为什么必须要先装一个WEB服务器？ 在本地计算机上随便创建一个 web 页面，用户是无法访问到的，但是如果启动 tomcat 服务器，把 web 页面放在 tomcat 服务器中，用户就可以访问了。这说明什么问题？ 1. 不管什么 web 资源，想被远程计算机访问，都必须有一个与之对应的网络通信程序，当用户来访问时，这个网络通信程序读取 web 资源数据，并把数据发送给来访者。 2. WEB 服务器就是这样一个程序，它用于完成底层网络通迅。使用这些服务器，We应用的开发者只需要关注web资源怎么编写，而不需要关心资源如何发送到客户端手中，从而极大的减轻了开发者的开发工作量。 3.2、下载和安装Tomcat服务器见参考博客参考博文​ JavaWeb学习总结(一)——JavaWeb开发入门]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JSP原理]]></title>
    <url>%2F2019%2F03%2F14%2FJavaWeb---JSP%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[一. 什么是 JSP？ JSP全称是 Java Server Pages ，它和 servle 技术一样，都是SUN公司定义的一种用于开发动态web资源的技术。 JSP 这门技术的最大的特点在于，写 jsp 就像在写 html ，但它相比 html 而言，html 只能为用户提供静态数据，而 Jsp 技术允许在页面中嵌套java代码，为用户提供动态数据。 二. JSP原理2.1 Web服务器是如何调用并执行一个jsp页面的？ 浏览器向服务器发请求，不管访问的是什么资源，其实都是在访问Servlet，所以当访问一个jsp页面时，其实也是在访问一个Servlet ​ 服务器在执行jsp的时候，首先==把jsp翻译成一个Servlet==，所以我们访问 jsp 时，其实不是在访问 jsp，而是在访问 jsp 翻译过后的那个Servlet 当我们通过浏览器访问index.jsp时，服务器首先将 index.jsp 翻译成一个index_jsp.class index_jsp 这个类是继承 org.apache.jasper.runtime.HttpJspBase 这个类的 HttpJspBase 类是继承 HttpServlet 的，所以index_jsp类也是一个Servlet，所以当浏览器访问服务器上的 index.jsp 页面时，其实就是在访问index_jsp 这个Servlet，index_jsp 这个 Servlet 使用_jspService 这个方法处理请求。 2.2 Jsp页面中的java代码服务器是如何执行的？ 在 jsp 中编写的 java 代码会被翻译到 _jspService 方法中去，当执行 _jspService方法处理请求时，就会执行在jsp编写的java代码了，所以Jsp页面中的java代码服务器是通过调用_jspService方法处理请求时执行的。 参考博文​ javaweb学习总结(十四)——JSP原理]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试经典题目(11-15题)]]></title>
    <url>%2F2019%2F03%2F14%2FJava%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE(11-15%E9%A2%98)%2F</url>
    <content type="text"><![CDATA[11. 进程和线程的区别是什么？答案: 通俗解释什么是进程和线程: 开个QQ，开了一个进程；开了迅雷，开了一个进程。 在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。 所以运行某个软件，相当于开了一个进程。在这个软件运行的过程里（在这个进程里），多个工作支撑的完成QQ的运行，那么这“多个工作”就是多个线程。 所以一个进程管着多个线程。 专业解释1. 进程是执行着的应用程序 2. 线程是进程内部的一个执行序列。 3. 一个进程可以有多个线程。线程又叫做轻量级进程。 线程与进程的区别归纳优质答案一 进程是运行中的程序，线程是进程的内部的一个执行序列 进程是资源分配的单元，线程是执行行单元(进程是资源分配的基本单位, 线程是调度的基本单位) 进程间切换代价大，线程间切换代价小 进程拥有资源多，线程拥有资源少 多个线程共享进程的资源 优质答案二 a.地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。 b.通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。 c.调度和切换：线程上下文切换比进程上下文切换要快得多。 d.在多线程OS中，进程不是一个可执行的实体。 知识补充1. 进程是什么？程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。 2. 进程和线程的并发层次不同：进程属于在处理器这一层上提供的抽象；线程则属于在进程这个层次上再提供了一层并发的抽象。 参考博文​ 进程与线程的一个简单解释 ​ 进程篇：进程和线程的本质和区别 ​ 深入理解进程和线程 ​ 线程与进程的区别 12. 创建线程有几种不同的方式？你喜欢哪一种？为什么？1. 方式 继承Thread类，重写run方法； 实现Runnable接口，重写run方法，但是比继承Thread类好用，实现接口还可以继承类，避免了单继承带来的局限性； 实现callable接口，重写call方法，有返回值。 使用实现了Executor接口的ThreadPoolExecutor来创建线程池。 2. 选择 一般情况下，常见的是第二种。 Runnable接口有如下好处： 避免点继承的局限，一个类可以继承多个接口。 适合于资源的共享 线程详细见: xxxxxx 参考博文​ 牛客网优质答案 时间: 2019.3.14 13. 概括的解释下线程的几种可用状态答: 新建(new)：新创建了一个线程对象。 可运行(runnable)：线程对象创建后，其他线程(比如main线程) 调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权。 运行(running)：可运行状态(runnable)的线程获得了 cpu 时间片(timeslice), 执行程序代码。 阻塞(block)：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，即让出了cpu 时间片(timeslice), 暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu 时间片(timeslice)转到运行(running)状态。阻塞的情况分三种： 等待阻塞：运行(running)的线程执行o.wait()方法, JVM会把该线程放入等待队列( waitting queue )中。 同步阻塞： 运行(running)的线程在获取对象的同步锁时, 若该同步锁被别的线程占用，则 JVM会把该线程放入锁池(lock pool)中。 其他阻塞: 运行(running)的线程执行 Thread.sleep(longms)或t.join() 方法，或者发出了I/O 请求时，JVM会把该线程置为阻塞状态。当 sleep() 状态超时、join() 等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 死亡(dead)：线程run()、 main()方法执行结束，或者因异常退出了 run() 方法，则该线程结束生命周期。死亡的线程不可再次复生。 14. 同步方法和同步代码块的区别是什么？答: 同步方法(粗粒度锁):由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用给方法前，要获取内置锁，否则处于阻塞状态。 修饰一般方法: 获取的是当前调用对象 this 上的锁, 代码: 123public synchronized void method ()&#123; // ...&#125; 修饰静态方法: 获取当前类的字节码对象上的锁, 代码: 123public static synchronized void method ()&#123; // ...&#125; 注: synchronized修饰静态方法，如果调用该静态方法，将锁住整个类 同步代码块(细粒度锁):即有synchronized修饰符修饰的语句块，被该关键词修饰的语句块，将加上内置锁。实现同步。 同步代码块可以指定获取哪个对象上的锁, obj 任意, 代码: 123synchronized (obj) &#123; //...&#125; 总结 同步是高开销的操作，因此尽量减少同步的内容。通常没有必要同步整个方法，同步部分代码块即可。 同步方法默认用this或者当前类class对象作为锁。 同步代码块可以选择以什么来加锁，比同步方法要更颗粒化，我们可以选择只同步会发生问题的部分代码而不是整个方法。 补: 为何使用同步？ java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（增删改查），将会导致数据的不准确，相互之间产生冲突。类似于在atm取钱，银行数据确没有变，这是不行的，要存在于一个事务中。因此加入了同步锁，以避免在该线程没有结束前，调用其他线程。从而保证了变量的唯一性，准确性。]]></content>
      <categories>
        <category>java面试常考题目</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java面试常考题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---Servlet开发(2)]]></title>
    <url>%2F2019%2F03%2F13%2FJavaWeb---Servlet%E5%BC%80%E5%8F%91(2)%2F</url>
    <content type="text"><![CDATA[一. ServletConfig讲解1.1. 配置 Servlet 初始化参数 在Servlet的配置文件 web.xml 中，可以使用一个或多个 &lt;init-param&gt; 标签为servlet配置一些初始化参数。 代码实例12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;ServletConfigDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;gacl.servlet.study.ServletConfigDemo1&lt;/servlet-class&gt; &lt;!--配置ServletConfigDemo1的初始化参数 --&gt; &lt;init-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;gacl&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;123&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; 1.2、通过 ServletConfig 获取 Servlet 的初始化参数 当 servle t配置了初始化参数后，web 容器在创建 servlet 实例对象时，会自动将这些初始化参数封装到 ServletConfig 对象中，并在调用 servlet 的 init 方法时，将 ServletConfig 对象传递给servlet。进而，我们通过 ServletConfig 对象就可以得到当前servlet的初始化参数信息。 例如： 123456789101112131415161718192021222324public class ServletConfigDemo1 extends HttpServlet &#123; // 定义ServletConfig对象来接收配置的初始化参数 private ServletConfig config; @Override public void init(ServletConfig config) throws ServletException &#123; this.config = config; &#125; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获取在 web.xml 中配置的初始化参数 // 获取指定的初始化参数 String paramVal = this.config.getInitParameter("name"); // 获取所有的初始化参数 Enumeration&lt;String&gt; e = config.getInitParameterNames(); while(e.hasMoreElements())&#123; String name = e.nextElement(); String value = config.getInitParameter(name); response.getWriter().print(name + "=" + value + "&lt;br/&gt;"); &#125; &#125;&#125; 二、ServletContext对象 WEB容器在启动时，它会为每个WEB应用程序都创建一个对应的 ServletContext 对象，它代表当前web应用。 ServletConfig 对象中维护了 ServletContext 对象的引用，开发人员在编写servlet时，可以通过ServletConfig.getServletContext 方法获得 ServletContext 对象。 由于一个 WEB 应用中的 所有 Servlet共享同一个 ServletContext 对象 ，因此 Servlet 对象之间可以通过ServletContext 对象来实现通讯 。ServletContext 对象通常也被称之为 context 域对象 三. ServletContext的应用 3.1 多个Servlet通过ServletContext对象实现数据共享范例: Demo1 和 Demo2 通过 ServletContext 对象实现数据共享 Demo1123456789101112131415161718/* * ServletConfig对象中维护了ServletContext对象的引用，开发人员在编写servlet时， * 可以通过ServletConfig.getServletContext方法获得ServletContext对象。 */public class ServletContextDemo1 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String data = "xdp_gacl"; // 获得ServletContext对象 ServletContext context = this.getServletConfig().getServletContext(); // 另一种获取方法 // request.getServletContext() //将data存储到ServletContext对象中 context.setAttribute("data", data); &#125;&#125; Demo212345678910111213public class ServletContextDemo2 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获得ServletContext对象 ServletContext context = this.getServletContext(); // 从ServletContext对象中取出数据 String data = (String) context.getAttribute("data"); response.getWriter().print("data = " + data); &#125;&#125; 浏览器上输出结果: data = xdp_gacl 3.2 获取WEB应用的初始化参数在web.xml文件中使用标签配置WEB应用的初始化参数，如下所示： 范例 12345678910public class ServletContextDemo3 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ServletContext context = this.getServletContext(); // 获取整个web站点的初始化参数 String contextInitParam = context.getInitParameter("name"); response.getWriter().print(contextInitParam); &#125;&#125; 3.3 用servletContext实现请求转发范例12345678910111213141516public class ServletContextDemo4 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String data = "&lt;h1&gt;&lt;font color='red'&gt;abcdefghjkl&lt;/font&gt;&lt;/h1&gt;"; response.getOutputStream().write(data.getBytes()); // 获取ServletContext对象 ServletContext context = this.getServletContext(); // 获取请求转发对象(RequestDispatcher) RequestDispatcher rd = context.getRequestDispatcher("/servlet/ServletContextDemo5"); rd.forward(request, response);//调用forward方法实现请求转发 &#125;&#125; 3.4利用ServletContext对象读取资源文件略 四. 在客户端缓存Servlet的输出略 参考博文​ javaweb学习总结(六)——Servlet开发(二)]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---Servlet开发(1)]]></title>
    <url>%2F2019%2F03%2F13%2FJavaWeb---Servlet%E5%BC%80%E5%8F%91(1)%2F</url>
    <content type="text"><![CDATA[一. Servlet简介Servlet是sun公司提供的一门用于 开发动态web资源的技术 若想开发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤： 编写一个 Java 类，实现 servlet 接口。 把开发好的 Java类部署到 web 服务器中。 按照一种约定俗成的称呼习惯，通常我们也把实现了servlet接口的java程序，称之为Servlet 二. Servlet的运行过程Servlet程序是由 WEB服务器 调用，web服务器 收到客户端的 Servlet 访问请求后: ​ ① Web服务器首先 检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第②步。 ​ ② 装载并创建该Servlet的一个实例对象。 ​ ③ 调用Servlet实例对象的 init()方法。 ​ ④ 创建一个用于封装 HTTP请求消息的 HttpServletRequest 对象 和一个 代表HTTP响应消息的 HttpServletResponse 对象 ，然后调用Servlet的service()方法并将 请求和响应对象 作为参数传递进去 ​ ⑤ WEB应用程序被 停止或重新启动之前，Servlet引擎将 卸载Servlet ，并在卸载之前调用Servlet的destroy()方法。 三. Servlet调用图 四. Servlet接口实现类 Servlet接口SUN公司定义了两个默认实现类，分别为：GenericServlet、HttpServlet。 ==HttpServlet== 指能够处理HTTP请求的servlet，它在原有Servlet接口上添加了一些与HTTP协议处理方法，它比Servlet接口的功能更为强大。因此开发人员在编写Servlet时，通常应继承这个类，而避免直接去实现Servlet接口。 HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。因此，开发人员在编写Servlet时，通常只需要覆写doGet或doPost方法，而不要去覆写service方法 五. Servlet开发注意细节4.1 Servlet访问URL映射配置 由于客户端是通过URL地址访问web服务器中的资源，所以Servlet程序若想被外界访问，必须把servlet程序映射到一个URL地址上，这个工作在==web.xml文件==中使用&lt;servlet&gt;元素和&lt;servlet-mapping&gt;元素完成。 &lt;servlet&gt;元素用于注册Servlet，它包含有两个主要的子元素：&lt;servlet-name&gt;和&lt;servlet-class&gt;，分别用于设置Servlet的注册名称和Servlet的完整类名。 &lt;servlet-mapping&gt;元素用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：&lt;servlet-name&gt;和&lt;url-pattern&gt;，分别用于指定Servlet的注册名称和Servlet的对外访问路径。 都是成对出现的 有注册,有映射 web.xml 是什么 web.xml文件用来初始化配置信息：比如Welcome页面、servlet、servlet-mapping、filter、listener、启动加载级别等 每个xml文件都有定义它书写规则的Schema文件，也就是说javaEE的定义 web.xml 所对应的 xml Schema 文件中定义了多少种标签元素，web.xml中就可以出现它所定义的标签元素，也就具备哪些特定的功能。 范例123456789&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;gacl.servlet.study.ServletDemo1&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/ServletDemo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 同一个Servlet可以被映射到多个URL上，即多个元素的子元素的设置值可以是同一个Servlet的注册名。 4.2 Servlet与普通Java类的区别 Servlet是一个供其他Java程序（Servlet引擎）调用的Java类，不能独立运行，它的运行完全由Servlet引擎来控制和调度。 针对客户端的多次Servlet请求，通常情况下，服务器只会创建一个Servlet实例对象，也就是说Servlet实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至web容器退出，servlet实例对象才会销毁。 在Servlet的整个生命周期内，Servlet的init()方法只被调用一次。而对一个Servlet的每次访问请求都导致Servlet引擎调用一次servlet的service()方法。对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。 参考博文​ javaweb学习总结(五)——Servlet开发(一) ​ web.xml文件的作用]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---接口]]></title>
    <url>%2F2019%2F03%2F13%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[一. 概念 官方解释: Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能） 通俗理解: 接口可以理解为一种特殊的抽象类(100%的抽象类, 所有的方法都是抽象方法)，里面全部是由全局常量和公共的抽象方法(方法的定义)所组成,而没有变量和方法的实现 范例123456789101112131415/** * java中定义接口 * 把一个类定义成一个接口的格式是把声明类的关键字class用声明接口的关键字interface替换掉即可 */public interface JavaInterfaces &#123; // 常量的声明格式, 都是公共的、静态的，不能改变的 // 下面两种都可以,因为在接口里面默认的属性声明都是“public static final”的 public static final int id=10; int id=10; //方法的声明 // 在接口里面的声明的方法都是抽象方法,默认是抽象的，因此在接口里面的抽象方法都会把abstract关键字省略掉 // 在接口里面声明的抽象方法默认是“public(公共的) public void start();&#125; 二. 特点 接口指明了一个类必须要做什么和不能做什么，相当于类的蓝图 接口可以继承其他的接口,并添加新的属性和抽象方法. 抽象方法只能存在于抽象类或者接口中，但抽象类中却能存在非抽象方法，即有方法体的方法。接口是百分之百的抽象类 接口是解决Java无法使用多继承的一种手段,, 实际中更多的作用是制定标准的。 一个类可以实现多个接口, 接口里面的成员变量不专属于某个对象，都是静态的成员变量，是属于整个类的,不会存在对象之间互相冲突的问题。实现多个接口，也就实现了多重继承 见范例 接口和接口之间可以相互继承，类和类之间可以相互继承，类和接口之间，只能是类来实现接口 三. 重点 一个类如果要实现某个接口的话，那么它必须要实现这个接口中的所有方法。 不能直接去实例化一个接口，因为接口中的方法都是抽象的，是没有方法体的. 但是，我们可以使用接口类型的引用指向一个实现了该接口的对象，并且可以调用这个接口中的方法(Java多态的特性). 四. 接口的进一步理解​ 如果某个设备需要向电脑中读取或者写入某些东西，这些设备一般都是采用USB方式与电脑连接的，我们发现，只要带有USB功能的设备就可以插入电脑中使用了，那么我们可以认为USB就是一种功能，这种功能能够做出很多的事情（实现很多的方法），其实USB就可以看做是一种标准，一种接口，只要实现了USB标准的设备我就认为你已经拥有了USB这种功能。（因为你实现了我USB标准中规定的方法） 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344// 先声明USB接口：其中规定了要实现USB接口就必须实现接口规定实现的read( )和write( )这两个方法。interface USB &#123; void read(); void write();&#125;// 一个USB类实现USB接口。（实现其中的方法）class YouPan implements USB &#123; @Override public void read() &#123; System.out.println("U盘正在通过USB功能读取数据"); &#125; @Override public void write() &#123; System.out.println("U盘正在通过USB功能写入数据"); &#125;&#125;// 一个键盘类实现USB接口。（实现其中的方法）class JianPan implements USB &#123; @Override public void read() &#123; System.out.println("键盘正在通过USB功能读取数据"); &#125; @Override public void write() &#123; System.out.println("键盘正在通过USB功能写入数据"); &#125;&#125;// 测试public class Main &#123; public static void main(String[] args) &#123; // 生成一个实现可USB接口（标准）的U盘对象 YouPan youPan = new YouPan(); // 调用U盘的read( )方法读取数据 youPan.read(); // 调用U盘的write( )方法写入数据 youPan.write(); // 生成一个实现可USB接口（标准）的键盘对象 JianPan jianPan = new JianPan(); // 调用键盘的read( )方法读取数据 jianPan.read(); // 调用键盘的write( )方法写入数据 jianPan.write(); &#125;&#125; 参考博文​ java基础学习总结——接口 ​ JAVA基础——接口（全网最详细教程）]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---抽象]]></title>
    <url>%2F2019%2F03%2F13%2Fjava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%8A%BD%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[一. 抽象的出现​ 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类 ​ 在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口 二.抽象方法​ 一种特殊的方法：它只有声明，而没有具体的实现 123// 声明格式// 抽象方法必须用abstract关键字进行修饰abstract void fun(); 抽象方法必须定义在抽象类中。 三. 抽象类2.1 概念​ 抽象方法的类(一个类含有抽象方法，则称这个类为抽象类), 抽象类必须在类前用 abstract关键字 修饰。 一个类不包含抽象方法，只是用abstract修饰的话也是抽象类。也就是说抽象类不一定必须含有抽象方法。 2.2 特点 子类继承父类时，如果这个父类里面有抽象方法，并且子类觉得可以去实现父类的所有抽象方法，那么子类必须去实现父类的所有抽象方法, 父类里面的抽象方法，子类如果觉得实现不了，那么把就子类也声明成一个抽象类 因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。父类里面的方法是抽象的，那么对于整个类来说，它就有一个没有实现的方法，这个方法不知道怎么去实现，那么这个类是就是残缺不全的，因此这个类应该被定义为一个抽象类 含有抽象方法的类必须被声明为抽象类 不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法 抽象类必须被继承 抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情 抽象方法必须被重写 从某种意义上来说，抽象方法就是被用来重写的，所以在父类声明的抽象方法一定要在子类里面重写 范例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * 父类Animal * 在class的前面加上abstract，即声明成这样：abstract class Animal * 这样Animal类就成了一个抽象类了 */abstract class Animal &#123; public String name; public Animal(String name) &#123; this.name = name; &#125; /** * 抽象方法 * 这里只有方法的定义，没有方法的实现。 */ public abstract void enjoy(); &#125;/** * 这里的子类Cat从抽象类Animal继承下来，自然也继承了Animal类里面声明的抽象方法enjoy()， * 但子类Cat觉得自己去实现这个enjoy()方法也不合适，因此它把它自己也声明成一个抽象的类， * 那么，谁去实现这个抽象的enjoy方法，谁继承了子类，那谁就去实现这个抽象方法enjoy()。 */abstract class Cat extends Animal &#123; // Cat添加自己独有的属性 public String eyeColor; public Cat(String n, String c) &#123; super(n);//调用父类Animal的构造方法 this.eyeColor = c; &#125;&#125;/** * 子类BlueCat继承抽象类Cat，并且实现了从父类Cat继承下来的抽象方法enjoy */class BlueCat extends Cat &#123; public BlueCat(String n, String c) &#123; super(n, c); &#125; // 实现了抽象方法enjoy @Override public void enjoy() &#123; System.out.println("蓝猫叫..."); &#125; &#125;/** * 子类Dog继承抽象类Animal，并且实现了抽象方法enjoy */class Dog extends Animal &#123; // Dog类添加自己特有的属性 public String furColor; public Dog(String n, String c) &#123; super(n);//调用父类Animal的构造方法 this.furColor = c; &#125; @Override public void enjoy() &#123; System.out.println("狗叫...."); &#125;&#125;public class TestAbstract &#123; public static void main(String[] args) &#123; /** * 把Cat类声明成一个抽象类以后，就不能再对Cat类进行实例化了， * 因为抽象类是残缺不全的，缺胳膊少腿的，因此抽象类不能被实例化。 */ //Cat c = new Cat("Catname","blue"); Dog d = new Dog("dogname","black"); d.enjoy();//调用自己实现了的enjoy方法 BlueCat c = new BlueCat("BlueCatname","blue"); c.enjoy();//调用自己实现了的enjoy方法 &#125;&#125; 2.3 抽象类和普通类的区别： 抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法,没有意义），缺省情况下默认为public 抽象类不能用来创建对象 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。 参考博文​ Java抽象类与接口的区别 ​ java基础学习总结——抽象类 ​ 深入理解Java的接口和抽象类]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---继承]]></title>
    <url>%2F2019%2F03%2F13%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[一. 概念 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的 一些属性或方法 二. 类的继承格式123456// Java继承的关键字是：extendsclass 父类 &#123;&#125; class 子类 extends 父类 &#123;&#125; 需要注意的是 Java 不支持多继承，但支持多重继承(接口) 三. 继承的特性 子类拥有父类非 private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差） 四. 为什么需要继承 提高代码的 复用性 (复用性主要是可以多次使用，不用再多次写同样的代码）)。 提高程序的扩展性。 五. Java中子类能继承父类的私有属性吗答: 不能 Java官方文档的解释 : 子类 不能继承父类的私有属性，但是如果子类中公有的方法影响到了父类私有属性，那么私有属性是能够被子类使用的 12345678910111213141516171819202122232425class Father_ &#123; private String name;// 私有属性 public void tell() &#123; System.out.println(name + "is telling!"); &#125; private void speak() &#123; System.out.println(name + "is speaking!"); &#125;&#125;class Child extends Father_ &#123;&#125;public class TestJicheng &#123; public static void main(String[] args) &#123; Child c = new Child(); // tell方法是可以用的 c.tell(); //报错，父类的私有方法不可见 // c.speak(); &#125;&#125; 从继承的概念来说​ private和final不被继承 从内存的角度来说​ 类的一切都被继承(从父类构造方法被调用就知道了，因为new一个对象，就会调用构造方法，子类被 new 的时候就会调用父类的构造方法，所以从内存的角度来说，子类拥有一个完整的父类)。子类对象所引用的内存中有父类对象。 ​ 子类的对象是给父类的私有属性分配了空间的，但是没有访问的权限，不算是继承. 参考博文​ Java继承总结 ​ 菜鸟教程 ​ Java中子类能继承父类的私有属性吗？ ​ 知乎答案]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试经典题目(6-10题)]]></title>
    <url>%2F2019%2F03%2F12%2FJava%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE(6-10%E9%A2%98)%2F</url>
    <content type="text"><![CDATA[6. Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？ 答案: 方法覆盖(重写)的原则： 重写方法的方法名称、参数列表必须与原方法的相同，返回类型可以相同也可以是原类型的子类型(从Java SE5开始支持)。 重写方法不能比原方法访问性差（即访问权限不允许缩小）。 重写方法不能比原方法抛出更多的异常。 被重写的方法 不能为final类型 ，因为final修饰的方法是无法重写的。 被重写的方法 不能为private ，否则在其子类中只是新定义了一个方法，并没有对其进行重写。 被重写的方法 不能为static 。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足重写条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足重写条件，但是仍然不会发生重写，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。 重写是 发生在运行时的 ，因为编译期编译器不知道并且没办法确定该去调用哪个方法，JVM会在代码运行的时候作出决定。 方法重载的原则： 方法名称必须相同。 参数列表必须不同（个数不同、或类型不同、参数类型排列顺序不同等）。 方法的返回类型可以相同也可以不相同。 仅仅返回类型不同不足以成为方法的重载。 重载是 发生在编译时的 ，因为编译器可以根据参数的类型来选择使用哪个方法。 重写和重载的不同： 方法重写要求参数列表必须一致，而方法重载要求参数列表必须不一致。 方法重写要求返回类型必须一致(或为其子类型)，方法重载对此没有要求。 方法重写只能用于子类重写父类的方法(覆盖者可能不会限制它所覆盖的方法的访问)，方法重载用于同一个类中的所有方法。 方法重写对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。 父类的一个方法只能被子类重写一次，而一个方法可以在所有的类中可以被重载多次。 重载是编译时多态，重写是运行时多态。 参考博客​ 牛客网优质答案 7. Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？答案: 什么是构造方法？主要作用:** 完成对象的初始化工作(如果写的类里面没有构造函数,那么编译器会默认加上一个无参数且方法体为空的构造函数) 特点 使用 new + 构造方法创建一个新的对象 构造函数是定义在 Java类中的一个用来 初始化对象 的函数 (new一个东西的时候，实际上你调用的是一个构造方法，构造方法就是把自己构造成一个新的对象，所以叫构造方法，构造一个新对象用的方法叫构造方法) 构造函数与类同名, 且没有返回值(构造方法的名字必须和类的名字完全一模一样，包括大小写,这个方法的名字和类名完全相同，并且没有返回值，也就是在这个方法前面不能写任何的方法的返回类型修饰符，连void都不可以写) 什么是构造方法重载？Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己 唯一的参数列表 。 什么是复制构造方法？复制构造函数C++中的复制构造函数通常有三种作用: 对象作为函数参数 对象作为函数返回值 使用一个对象对另一个对象初始化。 C++语法允许用户定义自己的复制构造函数以实现自定义的复制，比如说进行深复制。Java并不支持这样的复制构造函数。但是这并不代表Java中没有这种机制，在Java中Object类的clone()方法就是这种机制的体现 Java中不支持构造函数的复制。构造函数的复制属于C++的内容。 时间: 2019.3.12 8. Java支持多继承么？答案: Java中类不支持多继承，只支持单继承（即一个类只有一个父类）. Java中的 接口 支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能） 9. 接口和抽象类的区别是什么？答案: 相同点 类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。 接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。 抽象类可以在不提供接口方法实现的情况下实现接口。 语法层面上的区别 抽象类可以提供成员方法的实现细节(成员函数可以是private，protected或者是public)，而接口中只能存在public abstract 方法(默认是public的) 抽象类中的成员变量可以是各种类型的(包含非final的变量)，而接口中的成员变量只能是public static final类型的； 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法； 接口中所有的方法默认的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 设计层面上的区别 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 抽象类是对一种事物的抽象，即 对类抽象 ，而接口是 对行为的抽象 。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。 举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将飞行这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系 。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。 什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。 参考博文​ 牛客网优质答案 ​ Java抽象类与接口的区别 ​ 深入理解Java的接口和抽象类 时间: 2019.3.13 10. 什么是值传递和引用传递？答案: 一般认为,Java内的基础类型数据传递都是值传递. Java中实例对象的传递是引用传递 值传递，顾名思义传递的是其值，也可以理解为副本给你，任意修改，原本不变。 引用传递，顾名思义传递本身，或者说传递的是地址，修改的是本身或者是原本地址里的内容。 值传递，原本不改变，引用传递，原本改变 详细解析见：知乎答案参考博文: ​ 牛客网答案 时间: 2019.3.14]]></content>
      <categories>
        <category>java面试常考题目</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java面试常考题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构---线性表之顺序表]]></title>
    <url>%2F2019%2F03%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[一. 特点​ 逻辑关系相邻的两个结点在 物理位置上也相邻 , 结点的逻辑次序和物理次序一致 二. 实现方式数组 三. 数组的优缺点优点 查询速度快 O(1) 可以直接根据下标找到内存位置 缺点 浪费存储空间. 要求实现估计容量,比较困难,需要的空间过大,造成浪费,过小将导致溢出 插入和删除 运算不方便,效率低,时间复杂度为O(n) 顺序表的存储空间 不容易扩充 四. 基本操作的实现准备1234567#define SIZE 10 // 数组的大小 // 定义结构体typedef struct Arr &#123; int currentLen; // 线性表当前长度 int arr[SIZE]; // 数组&#125; Arr; 1. 初始化数组123456// 初始化数组 void initArr(Arr * pArr) &#123; // 线性表当前长度为0 pArr-&gt;currentLen = 0; return; &#125; 2. 判断数组是否为空1234567891011// 判断数组是否为空bool isEmpty(Arr * pArr) &#123; // 判断条件: 线性表当前长度是不是 0 if(0 == pArr-&gt;currentLen)&#123; // 若数组为空,返回true return true; &#125; else &#123; return false; &#125;&#125; 3. 判断数组是否满12345678910// 判断数组是否满了bool isFull(Arr * pArr) &#123; // 判断条件: 线性表当前长度 等于数组的长度 if(SIZE == pArr-&gt;currentLen) &#123; printf("数组已满!\n"); return true; &#125; else &#123; return false; &#125;&#125; 4. 打印数组内容123456789101112131415161718// 打印数组内容void showArr(Arr * pArr) &#123; // 若数组不为空 if (isEmpty(pArr)) &#123; printf("数组为空!\n"); &#125; else &#123; printf("数组中的元素为: \n"); // 注意应该是 i &lt; pArr-&gt;currentLen,而不是数组的大小 for(int i = 0; i &lt; pArr-&gt;currentLen; i++) &#123; printf("%d \t", pArr-&gt;arr[i]); &#125; printf("\n"); printf("线性表长度为: %d\n", pArr-&gt;currentLen); printf("------------------------------------------------\n"); &#125;&#125; 5. 向数组中追加元素12345678910111213// 向数组中追加元素void append(Arr * pArr, int val) &#123; // 数组是否已满 if( isFull(pArr) ) &#123; printf("数组已经满了,无法添加!\n"); &#125; else &#123; printf("添加元素为: %d\n", val); pArr-&gt;arr[pArr-&gt;currentLen] = val; // 线性表当前长度 +1 pArr-&gt;currentLen++; &#125;&#125; 6. 向数组中指定的位置插入元素12345678910111213141516171819202122232425// 向数组中指定的位置插入元素bool insert(Arr * pArr, int pos, int val) &#123; if( isFull(pArr) ) &#123; printf("数组已经满了,无法插入!\n"); return false; &#125; // 插入的位置不能小于1，同时不能比数组长度大 if (pos &lt; 1 || pos &gt; pArr-&gt;currentLen+1) &#123; printf("插入失败, 位置不合法!\n"); return false; &#125; else &#123; // 注意判断条件 i = pArr-&gt;currentlen, i &gt;= pos, 可以画图推算 for(int i = pArr-&gt;currentLen; i &gt;= pos; i--) &#123; pArr-&gt;arr[i] = pArr-&gt;arr[i-1]; &#125; // 进行插入的值的赋值 pArr-&gt;arr[pos-1] = val; printf("在位置: %d 插入元素: %d\n", pos, val); pArr-&gt;currentLen++; return true; &#125;&#125; 7. 删除指定元素12345678910111213141516171819// 删除指定元素, 注意是 delete_, 有个"_" bool delete_(Arr * pArr, int pos) &#123; int val; if(pos&lt;1 || pos &gt;= pArr-&gt;currentLen) &#123; printf("删除失败，位置不合法\n"); return false; &#125; else &#123; // 获取删除元素的值 val = pArr-&gt;arr[pos-1]; printf("在位置: %d 删除元素: %d\n", pos, val); // 注意循环条件 for(int i = pos; i &lt; pArr-&gt;currentLen; i++)&#123; pArr-&gt;arr[i-1] = pArr-&gt;arr[i]; &#125; // 线性表当前长度 -1 pArr-&gt;currentLen--; return true; &#125;&#125; 8. 数组进行倒置123456789101112131415161718192021// 数组元素进行倒置bool inverse(Arr * pArr) &#123; if( isEmpty(pArr) ) &#123; printf("倒置失败，数组为空!\n"); return false; &#125; int start = 0; // 数组的第一个元素 int end = pArr-&gt;currentLen-1; // 数组的最后一个元素 printf("数组元素进行倒置"); while(start &lt; end)&#123; // 利用一个 temp 临时数据进行数据交换 int temp = pArr-&gt;arr[start]; pArr-&gt;arr[start] = pArr-&gt;arr[end]; pArr-&gt;arr[end] = temp; // 下一组 start++; end--; &#125; return true; &#125; 五. 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include&lt;stdbool.h&gt;#define SIZE 10 // 数组的大小 // 定义结构体typedef struct Arr &#123; int currentLen; // 线性表当前长度 int arr[SIZE]; // 数组&#125; Arr;// 初始化数组 void initArr(Arr * pArr) &#123; // 线性表当前长度为0 pArr-&gt;currentLen = 0; return; &#125;// 判断数组是否为空bool isEmpty(Arr * pArr) &#123; // 判断条件: 线性表当前长度是不是 0 if(0 == pArr-&gt;currentLen)&#123; // 若数组为空,返回true return true; &#125; else &#123; return false; &#125;&#125;// 判断数组是否满了bool isFull(Arr * pArr) &#123; // 判断条件: 线性表当前长度 等于数组的长度 if(SIZE == pArr-&gt;currentLen) &#123; printf("数组已满!\n"); return true; &#125; else &#123; return false; &#125;&#125;// 打印数组内容void showArr(Arr * pArr) &#123; // 若数组不为空 if (isEmpty(pArr)) &#123; printf("数组为空!\n"); &#125; else &#123; printf("数组中的元素为: \n"); // 注意应该是 i &lt; pArr-&gt;currentLen,而不是数组的大小 for(int i = 0; i &lt; pArr-&gt;currentLen; i++) &#123; printf("%d \t", pArr-&gt;arr[i]); &#125; printf("\n"); printf("线性表长度为: %d\n", pArr-&gt;currentLen); printf("------------------------------------------------\n"); &#125;&#125; // 向数组中追加元素void append(Arr * pArr, int val) &#123; // 数组是否已满 if( isFull(pArr) ) &#123; printf("数组已经满了,无法添加!\n"); &#125; else &#123; printf("添加元素为: %d\n", val); pArr-&gt;arr[pArr-&gt;currentLen] = val; // 线性表当前长度 +1 pArr-&gt;currentLen++; &#125;&#125;// 向数组中指定的位置插入元素bool insert(Arr * pArr, int pos, int val) &#123; if( isFull(pArr) ) &#123; printf("数组已经满了,无法插入!\n"); return false; &#125; // 插入的位置不能小于1，同时不能比数组长度大 if (pos &lt; 1 || pos &gt; pArr-&gt;currentLen+1) &#123; printf("插入失败, 位置不合法!\n"); return false; &#125; else &#123; // 注意判断条件 i = pArr-&gt;currentlen, i &gt;= pos, 可以画图推算 for(int i = pArr-&gt;currentLen; i &gt;= pos; i--) &#123; pArr-&gt;arr[i] = pArr-&gt;arr[i-1]; &#125; // 进行插入的值的赋值 pArr-&gt;arr[pos-1] = val; printf("在位置: %d 插入元素: %d\n", pos, val); pArr-&gt;currentLen++; return true; &#125;&#125;// 删除指定元素, 注意是 delete_, 有个"_" bool delete_(Arr * pArr, int pos) &#123; int val; if(pos&lt;1 || pos &gt;= pArr-&gt;currentLen) &#123; printf("删除失败，位置不合法\n"); return false; &#125; else &#123; // 获取删除元素的值 val = pArr-&gt;arr[pos-1]; printf("在位置: %d 删除元素: %d\n", pos, val); // 注意循环条件 for(int i = pos; i &lt; pArr-&gt;currentLen; i++)&#123; pArr-&gt;arr[i-1] = pArr-&gt;arr[i]; &#125; // 线性表当前长度 -1 pArr-&gt;currentLen--; return true; &#125;&#125;// 数组元素进行倒置bool inverse(Arr * pArr) &#123; if( isEmpty(pArr) ) &#123; printf("倒置失败，数组为空!\n"); return false; &#125; int start = 0; // 数组的第一个元素 int end = pArr-&gt;currentLen-1; // 数组的最后一个元素 printf("数组元素进行倒置"); while(start &lt; end)&#123; // 利用一个 temp 临时数据进行数据交换 int temp = pArr-&gt;arr[start]; pArr-&gt;arr[start] = pArr-&gt;arr[end]; pArr-&gt;arr[end] = temp; // 下一组 start++; end--; &#125; return true; &#125;// 代码测试 int main() &#123; Arr arr; // 将结构体的地址作为实参，这样才能修改结构体中的值 // 如果传的是结构体变量，那么将进行拷贝，不会改变值 initArr(&amp;arr); // 进行追加 if(isEmpty(&amp;arr)) &#123; printf("数组为空数组!\n"); &#125; else &#123; printf("数组不为空数组!\n"); &#125; append(&amp;arr, 1); if(isEmpty(&amp;arr)) &#123; printf("数组为空数组!\n"); &#125; else &#123; printf("数组不为空数组!\n"); &#125; printf("\n"); append(&amp;arr, 2); append(&amp;arr, 3); append(&amp;arr, 4); printf("\n"); insert(&amp;arr, 3, 100); // 打印 showArr(&amp;arr); // 删除元素 printf("\n"); delete_(&amp;arr, 7); showArr(&amp;arr); // 进行倒置 printf("\n"); inverse(&amp;arr); showArr(&amp;arr); return 0;&#125; 打印结果 参考博文:​ 数据结构基础（1）–数组C语言实现–动态内存分配 数据结构：链表(linked-list)]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言---常用函数]]></title>
    <url>%2F2019%2F03%2F12%2FC%E8%AF%AD%E8%A8%80---%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[C语言常用函数sizeof用法 如何使用]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JDBC(1)]]></title>
    <url>%2F2019%2F03%2F12%2FJavaWeb---JDBC(1)%2F</url>
    <content type="text"><![CDATA[一、JDBC相关概念介绍1.1、数据库驱动 这里的驱动的概念和平时听到的那种驱动的概念是一样的，比如平时购买的声卡，网卡直接插到计算机上面是不能用的，必须要安装相应的驱动程序之后才能够使用声卡和网卡，同样道理，我们安装好数据库之后，我们的应用程序也是不能直接使用数据库的，必须要通过相应的数据库驱动程序，通过驱动程序去和数据库打交道 1.2、JDBC介绍 SUN公司为了简化、统一对数据库的操作，定义了一套Java操作数据库的规范（接口），称之为JDBC 。这套接口由数据库厂商去实现，这样，开发人员只需要学习jdbc接口，并通过jdbc加载具体的驱动，就可以操作数据库。 JDBC全称为：Java Data Base Connectivity（java数据库连接），它主要由接口组成。组成JDBC的２个包： java.sql javax.sql 开发JDBC应用需要以上2个包的支持外，还需要 导入相应JDBC的数据库实现(即数据库驱动) 。 二、编写JDBC程序2.1. 搭建实验环境 在mysql中创建一个库，并 创建user表和插入表的数据 。 新建一个Java工程，并 导入数据驱动 编写程序从user表中读取数据，并打印在命令行窗口中 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Statement;public class JdbcConn &#123; public static void main(String[] args) throws Exception &#123; //要连接的数据库URL String url = "jdbc:mysql://localhost:3306/jdbcStudy"; //连接的数据库时使用的用户名 String username = "root"; //连接的数据库时使用的密码 String password = "XDP"; //1.加载驱动 //DriverManager.registerDriver(new com.mysql.jdbc.Driver());不推荐使用这种方式来加载驱动 Class.forName("com.mysql.jdbc.Driver");//推荐使用这种方式来加载驱动 //2.获取与数据库的链接 Connection conn = DriverManager.getConnection(url, username, password); //3.获取用于向数据库发送sql语句的statement Statement st = conn.createStatement(); String sql = "select id,name,password,email,birthday from users"; //4.向数据库发sql,并获取代表结果集的resultset ResultSet rs = st.executeQuery(sql); //5.取出结果集的数据 while(rs.next())&#123; System.out.println("id=" + rs.getObject("id")); System.out.println("name=" + rs.getObject("name")); System.out.println("password=" + rs.getObject("password")); System.out.println("email=" + rs.getObject("email")); System.out.println("birthday=" + rs.getObject("birthday")); &#125; //6.关闭链接，释放资源 rs.close(); st.close(); conn.close(); &#125;&#125;//详细解析见原博文 2.2 释放资源 Jdbc程序运行完后，切记要释放程序在运行过程中，创建的那些与数据库进行交互的对象，这些对象通常是ResultSet, Statement和Connection对象，特别是Connection对象，它是非常稀有的资源，用完后必须马上释放，如果Connection不能及时、正确的关闭，极易导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。 为确保资源释放代码能运行，资源释放代码也一定要放在finally语句中。 参考博文:​ javaweb学习总结(三十二)——JDBC学习入门]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JavaBean]]></title>
    <url>%2F2019%2F03%2F12%2FJavaWeb---JavaBean%2F</url>
    <content type="text"><![CDATA[一、什么是 JavaBean JavaBean是一个遵循特定写法的Java类，它通常具有如下特点： 这个Java类必须具有一个无参的构造函数 属性必须私有化 私有化的属性必须通过public类型的方法暴露给其它程序，并且方法的命名也必须遵守一定的命名规范(getter和setter) 如果属性是boolean,那么就对应is和setter方法 javaBean范例： 123456789101112131415161718192021222324252627282930313233/** * Person类就是一个最简单的JavaBean */public class Person &#123; //------------------Person类封装的私有属性------------------------------------- // 姓名 String类型 private String name; //是否已婚 boolean类型 private boolean married; //------------------Person类的无参数构造方法----------------------------------- // 无参数构造方法 public Person() &#123; &#125; //------------------Person类对外提供的用于访问私有属性的public方法---------------- public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public boolean isMarried() &#123; return married; &#125; public void setMarried(boolean married) &#123; this.married = married; &#125;&#125; JavaBean在J2EE开发中，通常用于封装数据，对于遵循以上写法的JavaBean组件，其它程序可以通过反射技术实例化JavaBean对象，并且通过反射那些遵守命名规范的方法，从而获知JavaBean的属性，进而调用其属性保存数据 二、JavaBean的属性 JavaBean的属性可以是任意类型，并且一个JavaBean可以有多个属性。每个属性通常都需要具有相应的setter、 getter方法，setter方法称为属性修改器，getter方法称为属性访问器。 属性修改器必须以小写的set前缀开始，后跟属性名，且属性名的第一个字母要改为大写，例如，name属性的修改器名称为setName，password属性的修改器名称为setPassword。 属性访问器通常以小写的get前缀开始，后跟属性名，且属性名的第一个字母也要改为大写，例如，name属性的访问器名称为getName，password属性的访问器名称为getPassword。 一个JavaBean的某个属性也可以只有set方法或get方法，这样的属性通常也称之为只写、只读属性。 参考博文:javaweb学习总结(二十)——JavaBean总结]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse---快捷键]]></title>
    <url>%2F2019%2F03%2F12%2Feclipse%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[eclipse快捷键eclipse配置折叠/展开代码快捷键​ 如何设置]]></content>
      <categories>
        <category>eclipse</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how2J天猫整站---笔记]]></title>
    <url>%2F2019%2F03%2F12%2Fhow2J%E5%A4%A9%E7%8C%AB%E6%95%B4%E7%AB%99J2EE---%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一.关于表表与表之间的关系，基本上是3种 一对一 一对多 多对一 表的杂谈 修改表结构是代价最大的改动 在建表过程中，会设置外键约束，所以表和表之间有依赖关系。 因此会先建立被外键指向的表 一般说来，对于一个新项目，建表的时候，会把sql语句都准备好，一次性执行]]></content>
      <categories>
        <category>how2J</category>
      </categories>
      <tags>
        <tag>how2J</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---线程(1)]]></title>
    <url>%2F2019%2F03%2F12%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E7%BA%BF%E7%A8%8B(1)%2F</url>
    <content type="text"><![CDATA[一. 线程的基本概念线程是一个程序里面不同的执行路径 每一个分支都叫做一个线程，main()叫做主分支，也叫主线程 程序的执行过程​ 首先把程序的代码放到内存的代码区里面，代码放到代码区后并没有马上开始执行，但这时候说明了一个进程准备开始，进程已经产生了，但还没有开始执行，这就是进程，所以进程其实是一个静态的概念，它本身就不能动。 进程: 机器上的一个.class文件，机器上的一个.exe文件，这个叫做一个进程 平常所说的进程的执行指的是进程里面主线程开始执行了，也就是main()方法开始执行了。 ==进程是一个静态的概念，在我们机器里面实际上运行的都是线程。== 知识补充: CPU难道真的很神通广大，能够同时执行那么多程序吗？ 不是的，CPU的执行是这样的：CPU的速度很快，一秒钟可以算好几亿次，因此CPU把自己的时间分成一个个小时间片，我这个时间片执行你一会，下一个时间片执行他一会，再下一个时间片又执行其他人一会，虽然有几十个线程，但一样可以在很短的时间内把他们通通都执行一遍，但对我们人来说，CPU的执行速度太快了，因此看起来就像是在同时执行一样，但实际上在一个时间点上，CPU只有一个线程在运行。 小总结(学习线程首先要理清楚三个概念): 进程：进程是一个静态的概念 线程：一个程序里面的，一个进程里面不同的执行路径 (一个进程里面有一个主线程叫main()方法)。 在同一个时间点上，一个CPU只能支持一个线程在执行。因为CPU运行的速度很快，因此我们看起来的感觉就像是多线程一样。 什么才是真正的多线程？ 答: 如果你的机器是双CPU，或者是双核，这确确实实是多线程。 二. 线程的创建和启动​ 在 JAVA 里面，JAVA的线程是通过java.lang.Thread类来实现的，每一个Thread对象代表一个新的线程。 创建一个新线程出来有两种方法： 从Thread类继承 实现接口 2.1 继承Thread类继承Thread类，重写该类的run()方法12345678910111213141516171819202122232425262728293031323334353637/** * @Description: 定义Thread的子类并实现run()方法 * 并发进行 */public class TestThread3 &#123; public static void main(String args[]) &#123; // 创建一个新的线程 r3, 此线程进入新建(new)状态 Runner3 r3 = new Runner3(); // 调用start()方法使得线程进入就绪状态(runnable),此时此线程并不一定会马上得以执行，这取决于CPU调度时机 r3.start(); for (int i = 0; i &lt;= 4; i++) &#123; System.out.println("mainMethod：" + i); &#125; &#125;&#125;class Runner3 extends Thread &#123; // 重写run()方法的实现 public void run() &#123; for (int i = 0; i &lt;= 4; i++) &#123; System.out.println("Runner3：" + i); &#125; &#125;&#125;/*打印结果: mainMethod：0 Runner3：0 mainMethod：1 Runner3：1 Runner3：2 Runner3：3 Runner3：4 mainMethod：2 mainMethod：3 mainMethod：4*/ 注意 start() 方法的调用后并不是立即执行多线程代码，而是使得该线程变为就绪状态(Runnable)，什么时候运行是由操作系统决定的 多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。 所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的 2.2 使用实现 Runnable 接口创建和启动新线程实现Runnable接口，并重写该接口的run()方法 该 run() 方法同样是线程执行体，创建Runnable实现类的实例，并以此实例作为Thread类的target来创建Thread对象，该Thread对象才是真正的线程对象 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @Description: 开辟一个新的线程来调用run方法 * 程序执行到 t.start() 后开辟了一条新的线程,主线程继续向下执行 * t.start() 这条线程是 run() 方法执行的线程, * run() 方法和 main() 方法再在交替进行,或者说叫并行执行 */public class TestThread1 &#123; public static void main(String args[]) &#123; // 创建一个新的线程对象r1, 此线程进入新建状态 Runner1 r1 = new Runner1(); // 这里使用的是Thread(Runnable target)构造方法 Thread t = new Thread(r1); // 调用start()方法使得线程进入就绪状 t.start(); for (int i = 0; i &lt; 4; i++) &#123; System.out.println("maintheod：" + i); &#125; &#125;&#125;// 定义一个类用来实现 Runnable 接口，实现Runnable接口就表示这个类是一个线程类 class Runner1 implements Runnable &#123; // 每个线程都是方法run()来完成其操作的，方法run()称为线程体 public void run() &#123; for (int i = 0; i &lt; 4; i++) &#123; System.out.println("Runner1：" + i); &#125; &#125;&#125;/*打印结果: maintheod：0 maintheod：1 Runner1：0 maintheod：2 Runner1：1 maintheod：3 Runner1：2 Runner1：3*/ 补:不开辟新线程直接调用run() 方法首先进入主程序, 子程序 r2 执行完之后主程序 main() 在继续执行 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @Description: 不开辟新线程直接调用run方法 * 首先进入主程序, 子程序 r2 执行完之后主程序 main() 在继续执行 * @author zn * */public class TestThread2 &#123; public static void main(String args[]) &#123; // 这里new了一个线程类的对象出来 Runner2 r2 = new Runner2(); // 这个称为方法调用，方法调用的执行是run()方法执行完之后才会继续执行main()方法 r2.run(); // Thread t = new Thread(r2); // t.start(); for (int i = 0; i &lt; 4; i++) &#123; System.out.println("maintheod：" + i); &#125; &#125;&#125;// 定义一个类用来实现 Runnable 接口，实现Runnable接口就表示这个类是一个线程类class Runner2 implements Runnable &#123; // 每个线程都是方法run()来完成其操作的，方法run()称为线程体 public void run() &#123; for (int i = 0; i &lt; 4; i++) &#123; System.out.println("Runner2：" + i); &#125; &#125;&#125;/*打印结果: Runner2：0 Runner2：1 Runner2：2 Runner2：3 maintheod：0 maintheod：1 maintheod：2 maintheod：3*/ Thread和Runnable之间到底是什么关系呢？范例123456789101112131415161718192021222324252627282930313233343536373839404142public class ThreadTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + " " + i); if (i == 30) &#123; Runnable myRunnable = new MyRunnable(); Thread thread = new MyThread(myRunnable); thread.start(); &#125; &#125; &#125;&#125;class MyRunnable implements Runnable &#123; private int i = 0; @Override public void run() &#123; System.out.println("in MyRunnable run"); for (i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + " " + i); &#125; &#125;&#125;class MyThread extends Thread &#123; private int i = 0; public MyThread(Runnable runnable)&#123; super(runnable); &#125; @Override public void run() &#123; System.out.println("in MyThread run"); for (i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + " " + i); &#125; &#125;&#125; 与实现Runnable接口创建线程方式相似，不同的地方在于 1Thread thread = new MyThread(myRunnable); 那么这种方式可以顺利创建出一个新的线程么？ 答案是肯定的。至于此时的线程执行体到底是MyRunnable接口中的run()方法还是MyThread类中的run()方法呢？通过输出我们知道线程执行体是MyThread类中的 run() 方法。其实原因很简单，因为Thread类本身也是实现了Runnable接口，而 run() 方法最先是在Runnable接口中定义的方法 123public interface Runnable &#123; public abstract void run();&#125; Thread类中对Runnable接口中run()方法的实现： 123456@Override public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; 当执行到Thread类中的run()方法时，会首先判断target是否存在，存在则执行target中的run()方法，也就是实现了Runnable接口并重写了run()方法的类中的run()方法。 但是上述给到的列子中，由于多态的存在，根本就没有执行到Thread类中的run()方法，而是直接先执行了运行时类型即MyThread类中的run()方法 2.3 两种方法的选择优先选择实现Runnable接口 去开辟一个新的线程。 实现Runnable接口比继承Thread类所具有的优势： 适合多个相同的程序代码的线程去处理同一个资源 可以避免java中的单继承的限制 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立 线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类 注意 main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。 三. 线程状态转换 新建(new)：新创建了一个线程对象。 可运行(runnable)：线程对象创建后，其他线程(比如main线程) 调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权。 运行(running)：可运行状态(runnable)的线程获得了 cpu 时间片(timeslice), 执行程序代码。 阻塞(block)：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，即让出了cpu 时间片(timeslice), 暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu 时间片(timeslice)转到运行(running)状态。阻塞的情况分三种： 等待阻塞：运行(running)的线程执行o.wait()方法, JVM会把该线程放入等待队列( waitting queue )中。 同步阻塞： 运行(running)的线程在获取对象的同步锁时, 若该同步锁被别的线程占用，则 JVM会把该线程放入锁池(lock pool)中。 其他阻塞: 运行(running)的线程执行 Thread.sleep(longms)或t.join() 方法，或者发出了I/O 请求时，JVM会把该线程置为阻塞状态。当 sleep() 状态超时、join() 等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 死亡(dead)：线程run()、 main()方法执行结束，或者因异常退出了 run() 方法，则该线程结束生命周期。死亡的线程不可再次复生。 参考博文​ java基础学习总结——线程(一) ​ Java总结篇系列：Java多线程（二） ​ Java多线程学习（总结很详细！！！） ​ how2j ​ 牛客网]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql语句]]></title>
    <url>%2F2019%2F03%2F11%2Fsql%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[一. 数据库 创建数据库 1CREATE database database-name; 删除数据库 1DROP database database-name; 查看当前数据库 1show databases; 选择(进入)数据库 1use database-name； 二. 表 查看当前数据库所有的表(已经选定数据库) 1show tables-name； 创建新表 1CEEATE DATABASE database-name 1CEEATE DATABASE database-name 1CEEATE DATABASE database-name 参考博文: 经典SQL语句大全(绝对的经典) how2J MySQL数据库–命令行操作]]></content>
      <tags>
        <tag>sql语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---方法的重载和覆盖]]></title>
    <url>%2F2019%2F03%2F11%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[一. 方法的重载(overload)指一个类中可以定义有 相同的名字 ,但 参数不同 的多个方法. 调用时, 会根据 不同的参数表 选择对应的方法 范例 构造方法 注意 方法名一样, 但参数不一样,就是重载(overload) 参数不一样 (1.参数的个数不一样 2. 参数的类型不一样, 只要有一个就可以) 方法名一样，参数类型一样，只有返回值不一样，这个不构成重载 理解: 多重加载，不同样式的加载 二. 方法的覆盖(override)指覆盖了一个方法并且对其重写，以求达到不同的作用,也可以叫做 重写 范例 对 接口方法 的实现 在 继承 中也可能会在 子类覆盖父类 中的方法 注意 覆盖的方法的标志必须要和被覆盖的方法的 标志 (相同的名字和相同的参数)完全匹配，才能达到覆盖的效果； 覆盖的方法的返回值必须和被覆盖的方法的返回一致； 覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类； 被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖 参考博文 java中的方法覆盖（Overriding）和方法重载（Overloading）是什么意思？重写跟重载的区别？ 对比Java语言中的覆盖和重载]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---修饰符]]></title>
    <url>%2F2019%2F03%2F11%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[一. Java 修饰符Java语言提供了很多修饰符，主要分为以下两类： 访问修饰符 非访问修饰符 修饰符用来定义类、方法或者变量，通常放在语句的最前端。 123456789public class className &#123; // ...&#125;private boolean myFlag;static final double weeks = 9.5;protected static final int BOXWIDTH = 42;public static void main(String[] arguments) &#123; // 方法体&#125; 二. 访问控制修饰符Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。 default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法 即是“包访问权限” private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） 表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可以使用 public : 对所有类可见。使用对象：类、接口、变量、方法 表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类） protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private 详细 作用域 自身 同包子类 不同包子类 同包类 其他类 总结(所属) private 访问(√) 继承(×) 继承(×) 访问(×) 访问(×) 只有自己 package 访问(√) 继承(√) 继承(×) 访问(√) 访问(×) 同包 protected 访问(√) 继承(√) 继承(√) 访问(√) 访问(×) 同包+子类 public 访问(√) 继承(√) 继承(√) 访问(√) 访问(√) 所有 如何使用 属性 通常使用private封装起来 方法 一般使用public用于被调用 会 被子类继承 的方法，通常使用protected 总结 如果一个成员需要被外部包所访问，则必须使用public修饰符； 如果一个成员需要被定义在不同包下的子类所访问，则可以使用public或protected修饰符； 如果一个成员需要被本包下的其他类所访问，则可以不用写任何的修饰符，使用public或者protected也行 若一个成员想使用同类中其他成员，则使用任意一个修饰符即可；若一个成员不想被任何一个外部的类所访问，则使用private关键字比较恰当 三. 非访问修饰符为了实现一些其他的功能，Java 也提供了许多非访问修饰符。 static 修饰符 : 用来修饰类方法和类变量。 final 修饰符 : 用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract 修饰符用来创建抽象类和抽象方法。 synchronized 和 volatile 修饰符 : 主要用于线程的编程 详细的见其他文章 参考博客​ Java中private、public、default、protected的区别]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间词话---ZJ]]></title>
    <url>%2F2019%2F03%2F09%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---ZJ%2F</url>
    <content type="text"><![CDATA[没有人会拒绝微笑, 也没有人会拒绝真诚. 逢山开路, 遇水架桥.]]></content>
      <categories>
        <category>人间词话</category>
      </categories>
      <tags>
        <tag>人间词话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间词话---送给自己]]></title>
    <url>%2F2019%2F03%2F09%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E9%80%81%E7%BB%99%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[勇者愤怒, 抽刃向更强者.怯者愤怒, 却抽刀向更弱者 扬在脸上的微笑, 长在心里的善良,融进血液的骨气, 刻在生命里的坚强. 礼仪最重要的是在昭告自我,真正的宣誓是对自己说的话. —陈果 对一切人,一切西乡都保持一种开放二友善的胸襟和气度的时候,才真正成为名副其实的大学生. —陈果 挫折能使强者更强,弱者更弱,强者在面对中锻炼了自己,弱者在逃避中越发脆弱 最善言谈者就是最善于倾听的人]]></content>
      <categories>
        <category>人间词话</category>
      </categories>
      <tags>
        <tag>人间词话</tag>
        <tag>送给自己</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间词话---网易云评论]]></title>
    <url>%2F2019%2F03%2F09%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%84%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[卿卿我我 写歌的人假正经, 听歌的人最无情.人要是桥请起来,听什么都像在唱自己. 校服是我和她唯一穿过的情侣装, 毕业照是我和她唯一的合影. 和暗恋的对人对视一眼或者说一句话，都能有一天的内心戏. 情怀 愿走出半生, 归来仍是少年. 你小时候相当科学家，想当超人，想拯救世界，但后来你慢慢变了，变成那个只想给爸妈安稳的生活，给她一个美好的未来，给你们的孩子一个温馨的住所。。。你不再是超人，但你撑起了一个家]]></content>
      <categories>
        <category>人间词话</category>
      </categories>
      <tags>
        <tag>人间词话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---Filter(1)]]></title>
    <url>%2F2019%2F03%2F08%2FJavaWeb---Filter(1)%2F</url>
    <content type="text"><![CDATA[一、Filter简介 Filter也称之为过滤器，WEB开发人员通过Filter技术，对web服务器管理的所有web资源：例如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。 Servlet API中提供了一个Filter接口，开发web应用时，如果编写的Java类实现了这个接口，则把这个java类称之为过滤器Filter。通过Filter技术，开发人员可以实现用户在访问某个目标资源之前，对访问的请求和响应进行拦截. 二、Filter是如何实现拦截的？ Filter接口中有一个doFilter方法，当我们编写好Filter，并配置对哪个web资源进行拦截后，WEB服务器每次在调用web资源的service方法之前，都会先调用一下filter的doFilter方法，因此，在该方法内编写代码可达到如下目的： 调用目标资源之前，让一段代码执行。 是否调用目标资源（即是否让用户访问web资源）。 调用目标资源之后，让一段代码执行。 web服务器在调用doFilter方法时，会传递一个filterChain对象进来，filterChain对象是filter接口中最重要的一个对象，它也提供了一个doFilter方法，开发人员可以根据需求决定是否调用此方法，调用该方法，则web服务器就会调用web资源的service方法，即web资源就会被访问(根据所要访问的网址去寻找资源)，否则web资源不会被访问(可能会跳转到其他的界面,然后return返回)。 三、Filter开发入门3.1、Filter开发步骤Filter开发分为二个步骤： 编写java类实现Filter接口，并实现其doFilter方法。 在 web.xml 文件中使用&lt;filter&gt;和&lt;filter-mapping&gt;元素对编写的filter类进行 注册和映射，并设置它所能拦截的资源。 过滤器范例1234567891011121314151617181920212223242526272829303132/*** @Description:filter的三种典型应用：* 1.可以在filter中根据条件决定是否调用chain.doFilter(request, response)方法，即是否让目标资源执行* 2.在让目标资源执行之前，可以对request\response作预处理，再让目标资源执行* 3.在目标资源执行之后，可以捕获目标资源的执行结果，从而实现一些特殊的功能*/ public class FilterDemo01 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println("----过滤器初始化----"); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // 对request和response进行一些预处理 request.setCharacterEncoding("UTF-8"); response.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); System.out.println("FilterDemo01执行前！！！"); chain.doFilter(request, response); //让目标资源执行，放行 System.out.println("FilterDemo01执行后！！！"); &#125; @Override public void destroy() &#123; System.out.println("----过滤器销毁----"); &#125;&#125; 在web. xml中配置过滤器(详细内容见五)12345678910111213&lt;!--配置过滤器--&gt;&lt;!--注册过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;FilterDemo01&lt;/filter-name&gt; &lt;filter-class&gt;me.gacl.web.filter.FilterDemo01&lt;/filter-class&gt;&lt;/filter&gt;&lt;!--映射过滤器--&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;FilterDemo01&lt;/filter-name&gt; &lt;!--“/*”表示拦截所有的请求 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 四. Filter的生命周期4.1、Filter的创建 Filter的创建和销毁由WEB服务器负责。 web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其 init 方法 ，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作，filter对象只会创建一次，init方法也只会执行一次。通过 init 方法的参数，可获得代表当前filter配置信息的FilterConfig对象。 4.2、Filter的销毁 Web容器调用destroy方法销毁Filter。destroy方法在Filter的生命周期中仅执行一次。在destroy方法中，可以释放过滤器使用的资源。 4.3、FilterConfig接口 用户在配置filter时，可以使用 &lt;init-param&gt; 为filter配置一些初始化参数，当web容器实例化Filter对象，调用其 init 方法时 ，会把封装了filter初始化参数的filterConfig对象传递进来。因此开发人员在编写filter时，通过filterConfig对象的方法，就可获得： String getFilterName()：得到filter的名称。 String getInitParameter(String name)： 返回在部署描述中指定名称的初始化参数的值。如果不存在返回null. Enumeration getInitParameterNames()：返回过滤器的所有初始化参数的名字的枚举集合。 public ServletContext getServletContext()：返回Servlet上下文对象的引用。 五、Filter的部署 Filter的部署分为两个步骤： 注册Filter 映射Filter 5.1 注册Filter 开发好Filter之后，需要在web.xml文件中进行注册，这样才能够被web服务器调用 在web.xml文件中注册Filter范例： 123456789101112131415161718&lt;filter&gt; &lt;!--&lt;description&gt;用于添加描述信息，该元素的内容可为空，&lt;description&gt;可以不配置。--&gt; &lt;description&gt;FilterDemo02过滤器&lt;/description&gt; &lt;!--&lt;filter-name&gt;用于为过滤器指定一个名字，该元素的内容不能为空--&gt; &lt;filter-name&gt;FilterDemo02&lt;/filter-name&gt; &lt;!--&lt;filter-class&gt;元素用于指定过滤器的完整的限定类名--&gt; &lt;filter-class&gt;me.gacl.web.filter.FilterDemo02&lt;/filter-class&gt; &lt;!--配置FilterDemo02过滤器的初始化参数--&gt; &lt;!--&lt;init-param&gt;元素用于为过滤器指定初始化参数，它的子元素&lt;param-name&gt;指定参数的名字，&lt;param-value&gt;指定参数的值。在过滤器中，可以使用FilterConfig接口对象来访问初始化参数。如果过滤器不需要指定初始化参数，那么&lt;init-param&gt;元素可以不配置--&gt; &lt;init-param&gt; &lt;description&gt;配置FilterDemo02过滤器的初始化参数&lt;/description&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;gacl&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt; 5.2 映射Filter 在web.xml文件中注册了Filter之后，还要在web.xml文件中映射Filter 12345678910111213141516&lt;!--映射过滤器--&gt;&lt;!--&lt;filter-mapping&gt;元素用于设置一个 Filter 所负责拦截的资源。一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径--&gt; &lt;filter-mapping&gt; &lt;!--&lt;filter-name&gt;子元素用于设置filter的注册名称。该值必须是在&lt;filter&gt;元素中声明过的过滤器的名字--&gt; &lt;filter-name&gt;testFilter&lt;/filter-name&gt; &lt;!--&lt;url-pattern&gt;设置 filter 所拦截的请求路径(过滤器关联的URL样式)--&gt; &lt;!--“/*”表示拦截所有的请求 --&gt; &lt;url-pattern&gt;/index.jsp&lt;/url-pattern&gt; &lt;!--&lt;dispatcher&gt;指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是REQUEST,INCLUDE,FORWARD和ERROR之一，默认REQUEST。用户可以设置多个&lt;dispatcher&gt; 子元素用来指定 Filter 对资源的多种调用方式进行拦截。--&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;&lt;/filter-mapping&gt; &lt;dispatcher&gt; 子元素可以设置的值及其意义： REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。 INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。 FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。 ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。 参考博文​ javaweb学习总结(四十二)——Filter(过滤器)学习]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---面向对象(2)]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(2)%2F</url>
    <content type="text"><![CDATA[一. Java类的定义1.1 关键字​ 使用 class 关键字定义一个类 12345678910class Person &#123; // 成员变量(属性)定义 private int id; private int age = 10; //方法定义 public int getAge() &#123; return age; &#125; public void setAge(int i) &#123; age = i; &#125;&#125; 二. 成员变量2.1 注意 成员变量的作用范围为 整个类体 定义成员变量可以对其初始化, 如果 不对其初始化 , Java 使用默认的值 对其初始化(若不记得Java对成员变量默认的初始化是多少的话，定义一个成员变量，不给它初始化，然后直接打印这个成员变量,进行查看) 在 Java 里面的任何变量首先应该要声明，然后再赋值，然后再使用 2.2 成员变量和局部变量的区别: 成员变量 局部变量 不进行初始化 默认给初始化 不默认给初始化, 在方法里面声明一个局部变量如果不给它初始化时就会出错 实例12345678910111213package test;public class TestChushihua &#123; private static int aa; public static void main(String[] args) &#123; int bb; // aa 必须是 static, 因为要不然需要 new 对象 System.out.println(aa); // 报错,要求要赋值 // System.out.println(bb); &#125;&#125;// 打印结果: aa的值为:0 三. 基本概念 — 引用​ Java语言中 除基本类型之外 的变量类型都称之为引用类型, Java中的对象是通过引用对其操作的 3.1 基本类型与引用类型的区别 基本类型 引用类型 实现 当声明一个int i=0时，系统会马上给这个i分配一个内存空间（在 栈内存 里面分配一小块区域用来装数字0），里面装着一个值为0，以后使用i这个名字马上就可以访问这个内存空间里面的值 定义好这个类之后，需要使用new关键字把这个类的对象实例化出来，也就是真真正正造出一个对象出来才能使用这个对象 内存 占 一块 内存 占 两块 内存 存放位置 栈内存 栈内存: 引用对象 堆内存: 真正的内容(new出来的东西) 不论是基本数据类型还是引用类型，都会先在栈中分配一块内存 ，对于基本类型来说，这块区域包含的是 基本类型的内容；而对于引用类型来说，这块区域包含的是 指向真正内容的指针(存放真正内容的地址) ，真正的内容被手动的分配在堆上。 实例123456789101112131415161718public class Hero &#123; String name; float hp; public static void main(String[] args) &#123; //代表创建了一个Hero对象 //但是也仅仅是创建了一个对象，没有办法访问它 //为了访问这个对象，会使用引用来代表这个对象 new Hero(); //"h"这个变量是Hero类型，叫做引用(也叫 引用对象,对象的引用) //"="的意思指的h这个引用代表右侧创建的对象 //“代表” 在面向对象里，又叫做“指向” //引用h指向了新建的Hero对象 Hero h = new Hero(); &#125; &#125; 3.2 多个引用，一个对象，一个引用，多个对象区别答: 多个引用指向一个对象，操作的都是同一个对象 一个引用多个对象，之前的对象就没有办法访问了, 这个引用就指向了另一个对象 四. 类和对象的关系4,1 如何在内存中区分类和对象 类是 静态 的概念, 在代码区 对象是new出来的, 位于 堆内存 , 类的每个成员变量在不同的对象中都有不同的值 (除了静态变量,static),而方法只有一分,执行的时候才占用内存 . 五. 构造方法(函数) 主要作用 :完成对象的初始化工作，(如果写的类里面没有构造函数,那么编译器会默认加上一个无参数且方法体为空的构造函数) 5.1 特点 使用 new + 构造方法创建一个新的对象 构造函数是定义在 Java类中的一个用来 初始化对象 的函数,(new一个东西的时候，实际上你调用的是一个构造方法，构造方法就是把自己构造成一个新的对象，所以叫构造方法，构造一个新对象用的方法叫构造方法) 构造函数与类同名, 且没有返回值(构造方法的名字必须和类的名字完全一模一样，包括大小写,这个方法的名字和类名完全相同，并且没有返回值，也就是在这个方法前面不能写任何的方法的返回类型修饰符，连void都不可以写) 范例12345678910111213141516public class Person &#123; int id; //在person这类里面定义两个成员变量id和age, int age=20; //给成员变量age赋了初值为20 /**这里就是person这个类的一个构造方法 * 构造方法的规则很简单，和类名要完全一样，一点都不能错，包括大小写。 * 并且没有返回值，不能写void在它前面修饰 * @param _id * @param _age */ public Person(int _id,int _age ) &#123; id = _id; age = _age; &#125;&#125;//内存分析见 孤傲苍狼博客 注意 如果类已经有了一个有参数有方法体的构造函数,这时编译器就不会再给它默认加上一个无参且方法体为空的构造函数.可以理解为无参的构造函数被覆盖了.这种情况称为没有默认构造函数 ### 补:数据区、代码区、栈区、堆区 区别: 栈区(stack)：由系统的编译器自动的释放， 主要用来存放方法中的参数，一些临时的局部变量等 ，并且方法中的参数一般在操作完后，会由编译器自动的释放掉。 堆区(heap):由程序员决定，在Java中，如果程序员不释放的话，一般会由垃圾回收机制自动的清理掉。此区域主要用来 存放我们经常创建的对象、动态的申请的临时空间等 。 数据区(data seg):也称全局区或者静态区，根据名称我们就应该知道用来存放一些全局的东西，比如我们经常用到的 静态变量、全局变量等 都会存放到数据区，此区域上的东西都被全局所共享。比如我们可以采取类名.的方式就可以访问到方法，这就是所谓的静态方法，存放到数据区的。 代码区：存放 程序编译后可以执行代码的地方 。比如执行代码时写的While语句、if条件语句等，都会存放到此 理解了内存，就理解了一切，就理解了各种各样的语言。所有的语言无非都是这样：局部变量分配内存永远在栈里面，new出来的东西分配内存永远是在堆里，静态的东西分配内存永远是在数据区。剩下的代码肯定是在代码区 参考博文:how2J 类和对象 孤傲苍狼 Java基础学习总结——面向对象2 Java基本数据类型与引用数据类型 及在堆栈中内存的存储原理 数据区、代码区、栈区、堆区]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---HttpServletRequest对象]]></title>
    <url>%2F2019%2F03%2F08%2FJavaWeb---HttpServletRequest%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[一. HttpServletRequest介绍 HttpServletRequest对象代表 客户端的请求 ，当 客户端通过HTTP协议访问服务器 时，HTTP请求头中的 所有信息都封装在这个对象中 ，通过这个对象提供的方法，可以获得客户端请求的所有信息 。 二. Request常用方法2.1. 获得客户机信息 getRequestURL方法返回客户端发出请求时的完整URL。 getRequestURI方法返回请求行中的资源名部分。 getQueryString 方法返回请求行中的参数部分。 getPathInfo方法返回请求URL中的额外路径信息。额外路径信息是请求URL中的位于Servlet的路径之后和查询参数之前的内容，它以“/”开头。 getRemoteAddr方法返回发出请求的客户机的IP地址。等 2.2 获得客户机请求头略 2.3 获得客户机请求参数(客户端提交的数据) getParameter(String)方法(常用) getParameterValues(String name)方法(常用) getParameterNames()方法(不常用) getParameterMap()方法(编写框架时常用) 详细代码见参考博客 在服务器端使用getParameter方法和getParameterValues方法接收表单参数，代码如下: 1234567891011121314151617181920212223/** * 获取客户端通过Form表单提交上来的参数 */public class RequestDemo03 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 客户端是以 UTF-8 编码提交表单数据的，所以需要设置服务器端以UTF-8 的编码进行接收，否则对于中文数据就会产生乱码 request.setCharacterEncoding("UTF-8"); /** * 用户名(文本框)：&lt;input type="text" name="username" value="请输入用户名"&gt; * 获取填写的用户名 */ String username = request.getParameter("username"); // 获取选中的性别 String sex = request.getParameter("sex"); // 获取选中的兴趣，因为可以选中多个值，所以获取到的值是一个字符串数组，因此需要使用 getParameterValues 方法来获取 // &lt;input type="checkbox" name="inst" value="唱歌"&gt;唱歌 String[] insts = request.getParameterValues("inst"); String hiddenField = request.getParameter("hiddenField");//获取隐藏域的内容 &#125;&#125; 2.4 获取路径方法与作用 序号 方法 功能 1 getServletPath() 获取能够与“url-pattern”中匹配的路径，注意是完全匹配的部分，* 的部分不包括 2 getPageInfo() 与getServletPath()获取的路径互补，能够得到的是“url-pattern”中 * 的路径部分 3 getContextPath() 获取项目的根路径 (getContextPath() 与 req.getServletContext().getContextPath()获取到内容的是相同的,都是项目的根路径) 4 getRequestURI() 获取根路径到地址结尾 5 getRequestURL() 获取请求的地址链接（浏览器中输入的地址） 6 getServletContext().getRealPath(“/”) 获取“/”在机器中的实际地址 7 getScheme() 获取的是使用的协议(http 或https) 8 getProtocol() 获取的是协议的名称(HTTP/1.11) 9 getServerName() 获取的是域名(xxx.com) 10 getLocalName() 获取到的是IP 范例请求 http://localhost:8080/testweb/abc/def/ghi/test.html (url-pattern=/abc/def/*)打印的值为： 1234561. servletPath: /abc/def 2. pageInfo: /ghi/test.html3. contextPath: /testweb4. uri: /testweb/abc/def/ghi/test.html5. url: http://localhost:8080/testweb/abc/def/ghi/test.html6. realPath:G:\java\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\testweb\ 2.5 传参setAttribute和getAttribute可以用来在进行服务端跳转的时候，在不同的Servlet之间进行数据共享 三. request接收表单提交中文参数乱码问题3.1 以POST方式提交表单中文参数的乱码问题例如有如下的form表单页面1234567&lt;body&gt; &lt;!--提交方式为 POST--&gt; &lt;form action="&lt;%=request.getContextPath()%&gt;/servlet/RequestDemo04" method="post"&gt; 用户名：&lt;input type="text" name="userName"/&gt; &lt;input type="submit" value="post方式提交表单"&gt; &lt;/form&gt;&lt;/body&gt; servlet 中的代码12345678public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String username = request.getParameter("username"); System.out.println("userName:" + userName);&#125;// 打印结果: userName: 佷粈涔?灏辨暣// 是乱码 3.2. post方式提交中文数据乱码产生的原因和解决办法 之所以会产生乱码，就是因为服务器和客户端沟通的编码不一致造成的，因此解决的办法是：在客户端和服务器之间设置一个统一的编码，之后就按照此编码进行数据的传输和接收。 由于客户端是以UTF-8字符编码 将表单数据传输到服务器端的，因此服务器也需要设置以UTF-8字符编码进行接收，要想完成此操作，服务器可以直接使用从ServletRequest接口继承而来的setCharacterEncoding(charset) 方法进行统一的编码设置。修改后的代码如下： 12345678public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 客户端是以 UTF-8 编码传输数据到服务器端的，所以需要设置服务器端以UTF-8的编码进行接收，否则对于中文数据就会产生乱码 request.setCharacterEncoding("UTF-8"); String userName = request.getParameter("userName"); System.out.println("userName："+userName);&#125; 3.3 以GET方式提交表单中文参数的乱码问题例如有如下的form表单页面1234567&lt;body&gt; &lt;!--提交方式为 GET--&gt; &lt;form action="$&#123;pageContext.request.contextPath&#125;/servlet/RequestDemo04" method="get"&gt; 姓名：&lt;input type="text" name="name"/&gt; &lt;input type="submit" value="get方式提交表单"&gt; &lt;/form&gt;&lt;/body&gt; 此时在服务器端接收中文参数时就会出现中文乱码3.4. get方式提交中文数据乱码产生的原因和解决办法 ​ 默认的还是 使用ISO8859-1 这个字符编码来接收数据，客户端以UTF-8的编码传输数据到服务器端，而服务器端的request对象使用的是ISO8859-1这个字符编码来接收数据，服务器和客户端沟通的编码不一致因此才会产生中文乱码的。 解决办法： 在接收到数据后 获取request对象以ISO8859-1字符编码接收到的原始数据的字节数组 通过字节数组以指定的编码构建字符串，解决乱码问题。代码如下： 123456789public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String name = request.getParameter("name"); // 获取request对象以ISO8859-1字符编码接收到的原始数据的字节数组，然后通过字节数组以指定的编码构建字符串，解决乱码问题 name = new String(name.getBytes("ISO8859-1"), "UTF-8") ; System.out.println("name：" + name);&#125; 3.5 以超链接形式传递中文参数的乱码问题通过超链接后面加参数的形式，例如： 1&lt;a href="$&#123; pageContext.request.contextPath &#125;/servlet/RequestDemo05?userName=gacl&amp;name=徐达沛"&gt;点击&lt;/a&gt; 点击超链接，数据是以 get的方式 传输到服务器的，所以接收中文数据时也会产生中文乱码问题 解决中文乱码问题的方式与 上述的以get方式提交表单中文数据乱码处理问题的方式一致 , 如下所示： 12String name = request.getParameter("name");name =new String(name.getBytes("ISO8859-1"), "UTF-8"); 另外，需要提的一点就是 URL地址后面如果跟了中文数据，那么中文参数最好使用URL编码进行处理 , 如下所示： 1&lt;a href="$&#123;pageContext.request.contextPath&#125;/servlet/RequestDemo05?userName=gacl&amp;name=&lt;%=URLEncoder.encode("徐达沛", "UTF-8")%&gt;"&gt;点击&lt;/a&gt; 3.6 提交中文数据乱码问题总结提交方式为 POST​ 只需要在服务器端设置request对象的编码即可，客户端以哪种编码提交的，服务器端的request对象就以对应的编码接收，比如客户端是以UTF-8编码提交的 提交方式为GET​ 设置request对象的编码是无效的，request对象还是以默认的ISO8859-1编码接收数据，因此要想不乱码，只能在接收到数据后再 手工转换, 步骤如下： 12345678// 1.获取获取客户端提交上来的数据，得到的是乱码字符串,data="???è?????"String data = request.getParameter("paramName"); // 2.查找ISO8859-1码表，得到客户机提交的原始数据的字节数组byte[] source = data.getBytes("ISO8859-1"); // 3.通过字节数组以指定的编码构建字符串，解决乱码data = new String(source, "UTF-8"); // 或者一步进行data = new String(data.getBytes("ISO8859-1"), "UTF-8") ; 通过字节数组以 指定的编码 构建字符串，这里 指定的编码 -是根据客户端那边提交数据时使用的字符编码来定的，如果是GB2312，那么就设置成data = new String(source, “GB2312”) 四.Request 对象实现请求转发4.1 请求转发的基本概念​ 请求转发: 指一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理。 请求转发的应用场景: MVC设计模式 在Servlet中实现请求转发的两种方式： 通过 ServletContext 的 getRequestDispatcher(String path) 方法，该方法返回一个 RequestDispatcher 对象，调用这个对象的 forward 方法可以实现请求转发。 例如：将请求转发的test.jsp页面 123RequestDispatcher reqDispatcher = this.getServletContext().getRequestDispatcher("/test.jsp");reqDispatcher.forward(request, response); 通过 request对象 提供的 getRequestDispatche(String path) 方法，该方法返回一个RequestDispatcher对象，调用这个对象的 forward 方法可以实现请求转发。 例如：将请求转发的test.jsp页面 1request.getRequestDispatcher("/test.jsp").forward(request, response); request对象同时也是一个域对象(Map容器)，开发人员通过request对象在实现转发时，把数据通过request对象带给其它web资源处理。 request对象作为一个域对象(Map容器)使用时，主要是通过以下的四个方法来操作,如下: 123456789101112131415// 方法: setAttribute(String name,Object o);// 将数据作为request对象的一个属性存放到request对象中request.setAttribute("data", data);// 方法: getAttribute(String name);// 获取request对象的name属性的属性值，request.getAttribute("data");// 方法: removeAttribute(String name);// 移除request对象的name属性request.removeAttribute("data")// 方法: getAttributeNames()// 获取request对象的所有属性名，返回的是一个Enumeration&lt;String&gt; attrNames = request.getAttributeNames(); 4.2 请求重定向和请求转发的区别一个web资源收到客户端请求后 通知服务器去调用另外一个web资源进行处理，称之为请求转发/307 通知浏览器去访问另外一个web资源进行处理，称之为请求重定向/302 五. request 设置参数存储代码1234567891011public class HeroEditServlet extends HttpServlet &#123; protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; int id = Integer.parseInt(request.getParameter("id")); Hero hero = new HeroDAO().get(id); // 存进来 request.setAttribute("hero", hero); request.getRequestDispatcher("editHero.jsp").forward(request, response); &#125;&#125; 拿出来1234567891011&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" import="java.util.*,bean.*,java.sql.*"%&gt; &lt;form action='updateHero' method='post'&gt; &lt;!-- 将信息提取出来 --&gt; 名字 ： &lt;input type='text' name='name' value='$&#123;hero.name&#125;'&gt; &lt;br&gt; 血量 ：&lt;input type='text' name='hp' value='$&#123;hero.hp&#125;'&gt; &lt;br&gt; 伤害： &lt;input type='text' name='damage' value='$&#123;hero.damage&#125;'&gt; &lt;br&gt; &lt;input type='hidden' name='id' value='$&#123;hero.id&#125;'&gt; &lt;input type='submit' value='更新'&gt;&lt;/form&gt; 可以在拂去端跳转后的.jsp文件取出来 参考博文​ javaweb学习总结(十)——HttpServletRequest对象(一)]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---HttpResponse对象]]></title>
    <url>%2F2019%2F03%2F08%2FJavaWeb---HttpServletResponse%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[一. HttpServletResponse 对象介绍​ HttpServletResponse对象 代表服务器的响应。这个对象中封装了向客户端发送数据、发送响应头，发送响应状态码的方法。查看 HttpServletResponse 的API，可以看到这些相关的方法。 1.1 响应状态码的常量 HttpServletResponse 定义了很多状态码的常量(具体可以查看Servlet的API)，当需要向客户端发送响应状态码时，可以使用这些常量，避免了直接写数字，常见的状态码对应的常量： 状态码404对应的常量 状态码200对应的常量 状态码500对应的常量 二. HttpServletResponse常见应用——设置响应头控制浏览器的行为通过response实现请求重定向 请求重定向指：一个web资源收到客户端请求后，通知客户端去访问另外一个web资源，这称之为请求重定向。 应用场景：用户登陆，用户首先访问登录页面，登录成功后，就会跳转到某个页面，这个过程就是一个请求重定向的过程 实现方式： ==response.sendRedirect(String location)==，即调用response对象的sendRedirect方法实现请求重定向 sendRedirect内部的实现原理：使用response设置 302状态码和设置location响应头实现重定向 范例1234567891011121314151617181920212223242526public class ResponseDemo04 extends HttpServlet &#123; // 方法: doGet public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;/*** 1. 调用sendRedirect方法实现请求重定向, sendRedirect方法内部调用了* ① response.setHeader("Location",* "/JavaWeb_HttpServletResponse_Study_20140615/index.jsp");* ② response.setStatus(HttpServletResponse.SC_FOUND);//设置302状态码，等同于response.setStatus(302);*/ response.sendRedirect("/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"); /*** 2.使用response设置302状态码和设置location响应头实现重定向实现请求重定向* response.setHeader("Location", "/JavaWeb_HttpServletResponse_Study_20140615/index.jsp");* response.setStatus(HttpServletResponse.SC_FOUND);* 设置302状态码，等同于response.setStatus(302);*/ &#125; // 方法: doPost public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 3.2 /代表 webapps目录 的常见应用场景使用sendRedirect实现请求重定向1response.sendRedirect("/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"); 服务器发送一个URL地址给浏览器，浏览器拿到URL地址之后，再去请求服务器，所以这个”/“是给浏览器使用的，此时 /代表的就是webapps目录 ​ /JavaWeb_HttpServletResponse_Study_20140615/index.jsp这个地址指的就是 webapps\JavaWeb_HttpServletResponse_Study_20140615\index.jsp response.sendRedirect(“/项目名称/文件夹目录/页面”);这种写法是将项目名称 写死在程序中 的做法，不灵活，万一哪天项目名称变了，此时就得改程序，所以推荐使用下面的灵活写法： 将 1response.sendRedirect("/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"); 这种写法改成 1response.sendRedirect(request.getContextPath()+"/index.jsp"); request.getContextPath() 获取到的内容就是 /JavaWeb_HttpServletResponse_Study_20140615，这样就比较灵活了，使用request.getContextPath()代替”/项目名称”，推荐使用这种方式，灵活方便！ 使用超链接跳转1&lt;a href="/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"&gt;跳转到首页&lt;/a&gt; 这是客户端浏览器使用的超链接跳转，这个 / 是给浏览器使用的 ，此时 / 代表的就是webapps目录。 使用超链接访问web资源，绝对路径的写法推荐使用下面的写法改进 1&lt;a href="$&#123;pageContext.request.contextPath&#125;/index.jsp"&gt;跳转到首页&lt;/a&gt; 这样就可以避免在路径中出现项目的名称，使用 ${pageContext.request.contextPath} 取代 /JavaWeb_HttpServletResponse_Study_20140615 Form表单提交123&lt;form action="/JavaWeb_HttpServletResponse_Study_20140615/servlet/CheckServlet" method="post"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 这是客户端浏览器将form表单提交到服务器，所以这个 / 是给浏览器使用的，此时 / 代表的就是webapps目录。 对于form表单提交中action属性绝对路径的写法，也推荐使用如下的方式改进： 123&lt;form action="$&#123;pageContext.request.contextPath&#125;/servlet/CheckServlet" method="post"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; ${pageContext.request.contextPath} 得到的就是 /JavaWeb_HttpServletResponse_Study_20140615 ${pageContext.request.contextPath}的效果等同于request.getContextPath()，两者获取到的都是“/项目名称” js脚本和css样式文件的引用123456&lt;%--使用绝对路径的方式引用js脚本--%&gt; &lt;script type="text/javascript" src="$&#123;pageContext.request.contextPath&#125;/js/index.js"&gt;&lt;/script&gt; &lt;%--$&#123;pageContext.request.contextPath&#125;与request.getContextPath()写法是得到的效果是一样的--%&gt; &lt;script type="text/javascript" src="&lt;%=request.getContextPath()%&gt;/js/login.js"&gt;&lt;/script&gt; &lt;%--使用绝对路径的方式引用css样式--%&gt; &lt;link rel="stylesheet" href="$&#123;pageContext.request.contextPath&#125;/css/index.css" type="text/css"/&gt; 总结​ ==只要是浏览器向服务器提交的, / 给浏览器使用, 都可以修改成推荐的方式== 参考博文​ javaweb学习总结(八)——HttpServletResponse对象(二)]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---static关键字]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---static%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Static 关键字 static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途 基本作用: 方便在 没有创建对象 的情况下来进行调用(方法/变量),被static修饰的变量和方法其随着类的加载而被加载 . 只要类被加载了，就可以通过类名去进行访问. 1. 静态变量 在类中用static声明的成员变量为 静态成员变量 (也叫类变量), 其为该类的公共变量, 在第一次使用时被初始化, 这个成员变量 只有一份 ，而且这一份是这个类 所有的对象 共享, 属于整个类的，它不属于专门的某个对象 非静态成员专属于某一个对象，想访问非静态成员必须new一个对象出来才能访问 static成员变量的初始化顺序按照定义的顺序进行初始化 注意: 注意不能把 任何方法体内的变量声明为静态 2. 静态方法 用static 声明的方法为静态方法(也叫类方法) 在静态方法里只能直接调用同类中其他的静态成员（包括变量和方法），而不能直接访问类中的非静态成员 。这是因为，对于非静态的方法和变量，需要先创建类的实例对象后才可使用，而静态方法在使用前不用创建任何对象。 对于非静态成员方法，它访问静态成员方法/变量显然是毫无限制的 静态方法不能以任何方式引用this和super关键字 因为静态方法在使用前不用创建任何实例对象，当静态方法调用时，this所引用的对象根本没有产生。 由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了 范例​ 想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。 ​ 最常见的static方法就是main方法。因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。 3. 静态代码块 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。 为什么说static块可以用来优化程序性能​ 是因为它的特性:只会在类加载的时候执行一次。 初始化的顺序 对象属性的初始化有三种方式 声明时初始化 静态代码块初始化 构造函数初始化 故意把初始化块，放在构造方法下面， 问题：这三种方式，谁先执行？谁后执行？ 代码演示12345678910111213141516171819202122232425public class StaticOrder &#123; // 声明时初始化 public String name = StaticOrder.getName("属性声明"); // 构造函数初始化 public StaticOrder() &#123; name = StaticOrder.getName("构造方法"); &#125; // 静态代码块初始化 &#123; name = StaticOrder.getName("初始化块"); &#125; // 被调用的 getName() 方法 public static String getName(String name) &#123; System.out.println("初始化: " + name); return name; &#125; public static void main(String[] args) &#123; new StaticOrder(); &#125;&#125;// 打印结果:// 初始化: 属性声明// 初始化: 初始化块// 初始化: 构造方法 所以顺序为: 声明时初始化 静态代码块初始化 构造函数初始化 杂:​ static可以修饰内部类，但是不能修饰普通类。静态内部类的话可以直接调用静态构造器（不用对象）。 参考博文:​ java基础学习总结——static关键字 ​ 优质答案 ​ java中静态代码块的用法 static用法详解 ​ Java中的static关键字解析]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---面向对象(1)]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(1)%2F</url>
    <content type="text"><![CDATA[一. 面向过程的思想和面向对象的思想1. 面向过程 自顶向下,逐步细化 ​ 面向解决问题的过程进行编程​ 按照步骤化解决问题.(一个问题,分析这个问题如何去解决,第一步做什么, 第二步什么…), 当我们用面向过程的思想去编程或解决问题时，首先一定要把详细的实现过程弄清楚。一旦过程设计清楚，代码的实现简直轻而易举。 2. 面向对象 Java 中万物皆对象，模拟真实的现实世界 ​ 在编程的时候尽可能的去模拟真实的现实世界，按照现实世界中的逻辑去处理一个问题，分析问题中参与其中的有哪些实体，这些实体应该有什么属性和方法，我们如何通过调用这些实体的属性和方法去解决问题。拿到一个问题,应该分析: 这个问题里面有哪些类和对象 在分析这些类和对象应该具有哪些属性和方法 分析类和类之间具有什么关系 设计思维: 合适的方法应该出现在合适的类里面 二. 类和对象1. 类一类事物的抽象包括属性(静态)和方法(动态) 属性: 用来描述这一个对象（类）的特征 ,比如一个人的属性有身高，肤色，体重等等， 方法: 可以完成一个特定的功能，方法就像是动作, 比如人可以吃饭，跑步，学习，都可以是方法 Java中属性就是成员变量,方法就是函数, 不同的叫法 2. 对象一类事物的具体的某一个东西(符合这类事物的具体特征) 在Java中, 对象就是类的实例化 随笔: 对象和类是分不开的，必须首先定义类才能有对象类和对象的关系，类就是模板，里面定义着属性和方法，而对象就是实例，通过类来创建（new）对象，叫类的实例化 三. 面向过程与面向对象的比较 都可以实现代码重用和模块化编程，但是面对对象的模块化更深，数据更封闭，也更安全！因为面向对象的封装性更强！ 面对对象的思维方式更加贴近于现实生活，更容易解决大型的复杂的业务逻辑 从前期开发角度上来看，面对对象远比面向过程要复杂，但是从维护和扩展功能的角度上来看，面对对象远比面向过程要简单！ 当我们的业务逻辑比较简单时，使用面向过程能更快的实现当我们的业务逻辑比较复杂时，为了将来的维护和扩展，还是面向对象更为靠谱 参考博文​ 编程思想：面向对象和面向过程]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言---指针]]></title>
    <url>%2F2019%2F03%2F08%2FC%E8%AF%AD%E8%A8%80---%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[前言: 复杂类型说明1. int p;一个普通的整型变量 2. int *p; 从 p 处开始, p 先与*结合,所以说明 P 是一个指针 然后再与 int 结合 , 说明指针所指向的内容的类型为int 型. 所以 p 是一个返回整型数据的指针 3. int p[3]; 从P 处开始,先与[]结合,说明P 是一个数组 然后与 int 结合,说明数组里的元素是整型的 所以 p 是一个由整型数据组成的数组 4. int *p[3]; 首先从 p 处开始,先与 [ ] 结合 (因为 [ ] 优先级比 * 高), 所以 p 是一个数组 然后再与 * 结合,说明数组里的元素是指针类型 再与 int 结合,说明指针所指向的内容的类型是整型的 所以 p 是一个由返回整型数据的指针所组成的数组 5. int **p; 从 p 开始,先与 * 结合,说是 p 是一个指针 然后再与 * 结合,说明 指针所指向的元素是指针 再与 int 结合,说明该指针(**p)所指向的元素是整型数据 由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针 1234// 还未整理int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据 Int (*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针 int *(*p(int))[3]; //可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数. 一. 细说指针指针变量是一个 特殊的变量 ，它里面 存储的数值 被解释成为 内存里的一个地址 指针 ( = 变量的值) 指针变量 ( = 变量) 含义 地址 存放另一个变量地址的变量 指针与指针变量的关系类似于变量的值与变量的区别. 指针变量习惯上简称为 指针 , 一下统称指针变量为指针 要搞清一个指针需要搞清指针的四方面的内容： 指针的类型 指针所指向的类型 指针的值或者叫指针所指向的内存区 指针本身所占据的内存区。 1.1 指针的类型​ 这个指针是什么类型的 从语法的角度看, 把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型 范例12345int * ptr; // 指针的类型是int*char * ptr; // 指针的类型是char*int ** ptr; // 指针的类型是int**int (* ptr)[3]; // 指针的类型是int(*)[3]int * (* ptr)[4]; // 指针的类型是int*(*)[4] 1.2 指针所指向的类型​ 当通过指针来 访问指针所指向的内存区时 ，指针所指向的类型决定了编译器将把 那块内存区里的内容当做什么来看待 (指针所指向的类型就是指针指向的内存内面存储的地址的这块内存里面存储的值是什么类型) ​ 从语法的角度看，你只须把指针声明语句中的指针名字和名字左边的指针声明符去掉，剩下的就是指针所指向的类型 范例12345int * ptr; // 指针所指向的类型是intchar * ptr; // 指针所指向的类型是charint ** ptr; // 指针所指向的类型是int*int (*ptr)[3]; // 指针所指向的类型是int()[3]int (ptr)[4]; // 指针所指向的类型是int*()[4] 指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C 越来越熟悉时，你会发现，把与指针搅和在一起的”类型”这个概念分成”指针的类型”和”指针所指向的类型”两个概念，是精通指针的关键点之一 1.3 指针的值 (或者叫指针所指向的内存区或地址)​ 指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值 1234567891011121314int main()&#123; int a, * p; p = &amp;a; // "&amp;a" 代表a的地址的值 a = 3; printf("p的值为 %d\n", p); // p中存放的是 a 的地址 printf("*p的值为 %d", *p); // * 号在 引用时表示"指向"操作, *p 代表 a, // "*"仅起到标志的作用, 表示该变量为指针变量, 不是变量名的一部分, 及指针变量名不包括 * return 0 ;&#125; // 打印结果:// p的值为 6487620// *p的值为 3 指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为 sizeof (指针所指向的类型)的一片内存区 说一个指针的值是 XX，就相当于说该指针指向了以XX 为首地址的一片内存区域 说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。 指针所指向的内存区和指针所指向的类型是两个完全不同的概念 指针所指向的内存区 : 指针中存储的这块内存 指针所指向的类型 : 这块内存里面存储的值是什么类型 以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？ 1.4 指针本身所占据的内存区指针本身占了多大的内存？ 只要用函数 sizeof (指针的类型)测一下就知道了。在32 位平台里，指针本身占据了4 个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式（后面会解释）是否是左值时很有用 二. 指针的算术运算指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的，以单元为单位 范例1234567891011121314int main() &#123; int a = 2; int *ptr = &amp;a; printf("%d\n", ptr); ptr++; printf("%d\n", ptr); return 0;&#125;/** * 打印结果: * p的值为: 6487620 * p的值为: 6487624 */ 三. 运算符 &amp; 和 *&amp; 是取地址运算符，* 是间接运算符&amp;a 的运算结果是一个指针，指针所指向的地址，就是a 的地址。 *p 的运算结果就五花八门了。总之*p 的结果是 p 所指向的东西，这个东西有这些特点：它的类型是p 指向的类型，它所占用的地址是p所指向的地址。 1234567int a = 12; int b; int *p; int **ptr; p = &amp;a; // &amp;a 的结果是一个指针，p 类型是 int*，指向的类型是int，p指向的地址是a的地址// 等价于a = 24*p = 24; // *p 的结果，在这里它的类型是int，它所占用的地址是p所指向的地址，*p就是变量a, 还未整理 12345678// 下面的还有有看懂ptr=&amp;p; //&amp;p 的结果是个指针，该指针的类型是p 的类型加个*, 在这里是int **。该指针所指向的类 //型是p的类型，这里是int*。该指针所指向的地址就是指针p 自己的地址。 *ptr=&amp;b; //*ptr 是个指针，&amp;b 的结果也是个指针，且这两个指针 //的类型和所指向的类型是一样的，所以用&amp;b 来给*ptr 赋 //值就是毫无问题的了。 **ptr=34; //*ptr 的结果是ptr 所指向的东西，在这里是一个指针， //对这个指针再做一次*运算，结果是一个int 类型的变量。 四. 指针表达式一个表达式的结果如果是一个指针，那么这个表达式就叫指针表式。 五. 数组和指针的关系六. 指针和结构类型的关系范例1234567891011121314151617181920212223242526struct MyStruct &#123; int a; int b;&#125;; int main() &#123; // 声明了结构对象s, 并把 s 的成员初始化为20，30 struct MyStruct s = &#123;20,30,40&#125;; // 声明了一个指向结构对象 s 的指针p。它的类型是MyStruct *,它指向的类型是MyStruct struct MyStruct *p = &amp;s; printf("通过ss访问: %d\n", s.a); // 指向运算符,通过指针p来访问s的成员变量 printf("通过p访问: %d\n", p-&gt;a); // *p 等价于s, 不建议使用 printf("通过p访问: %d\n", (*p).a); return 0;&#125;/** * 打印结果: * 通过ss访问: 20 * 通过p访问: 20 * 通过p访问: 20 */ 七. 指针和函数的关系指针传入的是地址,会改变主函数中变量的值,是实参,而非指针是形参 实例1234567891011121314151617void prin(int a, int *b) &#123; a = 5; *b = 5; return;&#125;int main() &#123; int a = 1; int b = 1; prin(a, &amp;b); printf("调用函数之后:a的值为:%d, b的值为: %d", a, b); return 0;&#125;/** * 打印结果: * 调用函数之后:a的值为:1, b的值为: 5 */ 八. 二级指针二级指针就是指向指针的指针(n级指针就是…), 二级指针中存放的是指针的地址 二级指针的使用范例1234567891011121314151617int main() &#123; int a = 1 ; // a为普通变量 int *b = &amp;a; // b为一级指针，b的值是a的地址, 一级指针存放变量的地址 int **c = &amp;b; // c为二级指针，c的值是b的地址, 二级指针存放指针的地址 printf("a的值为:%d\n",a); printf("&amp;a的值为:%d\n",&amp;a); printf("b的值为:%d\n",b); printf("*b的值为:%d\n",*b); printf("&amp;b的值为:%d\n",&amp;b); printf("c的值为:%d\n",c); printf("*c的值为:%d\n",*c); printf("**c的值为:%d\n",**c); printf("&amp;c的值为:%d\n",&amp;c); return 0;&#125; 打印结果1234567891011/** * a的值为:1 * &amp;a的值为:6487628 * b的值为:6487628 * *b的值为:1 * &amp;b的值为:6487616 * c的值为:6487616 * *c的值为:6487628 * **c的值为:1 * &amp;c的值为:6487608 */ 分析结果123456789**c = *b = a = 1 *c = b = &amp;a = 6487628 c = &amp;b = 6487616 &amp;c = 6487608/*a 为普通变量b 为一级指针, b 的值是 a 的地址, *b 为 ac 为二级指针, c 的值是 b 的地址, *c 为 b , **c 为 *b [**c = *(*c) = *b = a]*/ 如图 参考文章​ C语言指针详解(经典,非常详细) ​ 指针与函数]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言基础知识]]></title>
    <url>%2F2019%2F03%2F08%2FC%E8%AF%AD%E8%A8%80---%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1. 结构体:定义​ 将一些已知的数据类型放在一起来定义的一种 新的数据类型 结构体并没有创造出新的数据类型。C语言的结构体和其他高级语言的类有点相似的概念，可以完成对一种事物的抽象。 实现1234567891011121314151617// 规则struct 结构名 // 结构名是结构的标识符不是变量名&#123; 类型 变量名; 类型 变量名;&#125; 结构变量;// 实例struct student &#123; char name[8]; int age; float wage1, wage2, wage3, wage4, wage5; &#125; Mike, Marry; // 定义了两个 struct student 类型的变量 Mike, Marrystruct student John; // struct student:类型说明符, John: 变量名 2. typedef定义​ 使用 typedef 关键字 来定义自己习惯的数据类型名称，来 替代 系统默认的基本类型名称、数组类型名称、指针类型名称与用户自定义的结构型名称、共用型名称、枚举型名称等。 规则1. 为基本类型数据定义新的类型名12345678#include&lt;stdio.h&gt;typedef int COUNT; // COUNT 等价于 intint main() &#123; COUNT a = 88; printf("结果为: %d", a); return 0;&#125;// 打印结果: 结果为: 88 2. 为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称12345678910111213141516#include&lt;stdio.h&gt;// 以结构体为例，定义一个名为 Point 的结构体struct Point&#123; double a; double b;&#125;;// 在调用这个结构体时，我们必须像下面的代码这样来调用这个结构体int main() &#123; struct Point point1; point1.a = 3.3; printf("%f", point1.a); return 0;&#125;// 打印结果: 3.300000 简写1234567891011121314151617#include&lt;stdio.h&gt;// 相当于 1. typedef x Point// 2. x = struct tagPoint &#123; …&#125;typedef struct tagPoint&#123; double a; double b;&#125; Point;int main() &#123; Point point1; point1.a = 3.3; printf("%f", point1.a); return 0;&#125; 参考文章​ typedef的用法，C语言typedef详解]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---基础语法(2)]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95(2)%2F</url>
    <content type="text"><![CDATA[一. 语句1.1 条件语句 if 语句 switch 语句 1.2 循环语句 for 循环语句 while 循环与do while 循环 1.3 break 和 continue 语句 二. 方法​ 一段用来完成特定功能的代码片段 1234[修饰符1 修饰符2 ...] 返回值类型 方法名(形式参数列表) &#123; java 语句; ...&#125; 方法可以有返回值，但可以不用这个返回值。方法首先要定义，然后才能调用 三. 变量的作用域​ 变量的作用域只在“{ }”有效，出了这个“{ }”就没有作用了 四. 递归调用​ 递归：在一个方法内部对自身的调用就称为递归 具体的参考 孤傲苍狼 五. 程序的执行过程 参考博文​ java基础学习总结——基础语法2]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构---线性表之单链表]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[一. 特点线性表的链接存储结构成为链表 1. 特点 用一组任意的存储单元存储线性表的数据结构(存储单元可以是连续的,也可以是不连续的 数据元素的逻辑次序和物理次序 ==不一定一致== 2. 常见的链表 单链表(每个结点有一个指针域的链表) 循环链表 双链表(每个结点有两个指针域的链表) 3. 相关概念 结点: 基本单元,由两部分组成 数据域: 用来存放结点本身的信息 指针域:用来存放本结点的直接后继结点的地址 空指针: 链表中最后一个结点的指针域不指向任何结点(通常用”∧”或者”NULL”表示 头指针: 指向单链表第一个结点的指针(head) 空表: 指针 head 为空指针,即 head = NULL 表头结点: 第一个结点之前再增加一个类型相同的结点(为了便于实现链表的各种运算, 其他结点成为表结点) 表结点: 除了表头结点其他的结点 在表结点中,第一个结点称为 首结点 ,最后一个结点称为 尾结点 二. 实现方式​ 链表单链表示意图 三. 链表的优缺点优点 不需要事先估计容量 插入和删除 运算方便,效率高,时间复杂度为O(1) 缺点 查询速度慢 四. 基本操作的实现0. 准备1234567typedef int ElementType; // 定义数据类型,可根据需要进行其他类型定义// 链表结点的定义typedef struct ListNode &#123; ElementType Element; // 数据域，存放数据 ListNode* Next; // 指向下一个链表结点&#125; Node, *PNode; 1. 初始化单链表123456789101112131415161718192021222324252627282930313233343536// 初始化单链表 PNode initList(void) &#123; int len ; // 用于定义链表长度 int val ; // 用于存放结点数值 PNode PHead = (PNode)malloc(sizeof(Node)); // 创建分配一个头结点内存空间 // 头结点相当于链表的哨兵，不存放数据，指向首结点（第一个结点） if (NULL == PHead) &#123; printf("空间分配失败 \n"); exit(-1); &#125; PNode PTail = PHead; // 链表的末尾结点，初始指向头结点 PTail-&gt;Next = NULL; // 最后一个结点指针置为空 printf("请输入结点个数："); scanf("%d", &amp;len); for (int i = 0; i &lt; len; i++) &#123; // 分配一个新结点 PNode pNew = (PNode)malloc(sizeof(Node)); if (pNew == NULL) &#123; printf("分配新结点失败\n"); exit(-1); &#125; printf("请输入第 %d 个结点的数据：", i + 1); scanf("%d", &amp;val); // 输入链表结点的数据 pNew-&gt;Element = val; // 把数据赋值给结点数据域 PTail-&gt;Next = pNew; // 末尾结点指针指向下一个新结点 pNew-&gt;Next = NULL; // 新结点指针指向为空 PTail = pNew; // 将新结点复制给末尾结点 &#125; printf("创建链表成功\n"); return PHead; // 返回头结点&#125; 2. 遍历链表元素1234567891011121314151617// 遍历链表元素 void TraverseList(PNode List) &#123; // 就是传过来的是一个指针 // 首结点 赋值给临时结点 P PNode P = List-&gt;Next; printf("遍历链表的值为："); if (P == NULL) printf("链表为空"); // 尾结点的 p-&gt;Next == NULL while (P != NULL) &#123; printf("%d ", P-&gt;Element); P = P-&gt;Next; &#125; printf("\n");&#125; 3. 查询指定元素1234567891011121314151617181920// 查询指定元素 PNode findList(PNode List) &#123; PNode P = List-&gt;Next; // 定义临时指针P指向首结点的地址 int num = 0; // 用于记录链表结点位置 int val = 0; // 用于存放要查询的值 printf("请输入要查询的数："); scanf("%d", &amp;val); // 输入要查询的数值 while (P != NULL &amp;&amp; P-&gt;Element != val) &#123; P = P-&gt;Next; num++; &#125; if (P != NULL) printf("找到的结点位置为：%d", num + 1); else printf("找不到该结点"); printf("\n"); return P;&#125; 4. 指定位置插入元素1234567891011121314151617181920212223// 指定位置插入元素void insertList(PNode List, int pos, int val) &#123; printf("位置: %d 插入元素: %d\n", pos, val); int position = 0; PNode P = List; // 定义结点p指向头结点 // 寻找 pos结点的前驱结点 while (P != NULL &amp;&amp; position &lt; pos-1) &#123; P = P-&gt;Next; position++; &#125; PNode Temp = (PNode)malloc(sizeof(Node)); // 分配一个临时结点用来存储要插入的数据 if (Temp == NULL) &#123; printf("内存分配失败！"); exit(-1); &#125; // 插入结点 Temp-&gt;Element = val; Temp-&gt;Next = P-&gt;Next; P-&gt;Next = Temp;&#125; 5. 销毁单链表123456789101112// 销毁单链表 void DeleteTheList(PNode List) &#123; PNode P, Tmp; P = List-&gt;Next; // 定义指针 P指向链表要删除的链表 List的第一个点结点 List-&gt;Next = NULL; while (P != NULL) &#123; Tmp = P-&gt;Next; // 临时Tmp指向要删除的结点的下个结点 free(P); // 释放指针P指向的结点 P = Tmp; // 重新赋值 &#125; printf("删除链表成功！\n");&#125; 6. 删除指定位置的元素123456789101112131415161718// 删除指定位置的元素void deleteList(PNode List, int pos) &#123; printf("位置: %d 删除元素!\n", pos); int position = 0; PNode P = List; // 定义一个指针p指向链表头结点 // 找 pos结点位置的前驱结点, 循环几次很重要,可以手写试试 while (P != NULL &amp;&amp; position &lt; pos-1) &#123; P = P-&gt;Next; position++; &#125; // 删除结点 PNode Tmp = P-&gt;Next; // 定义临时指针Tmp指向要删除的结点 P-&gt;Next = Tmp-&gt;Next; // 使要删除结点的前驱结点指向其后驱结点 free(Tmp); // 释放删除结点的内存空间，防止内存泄漏 Tmp = NULL; // 使q指向空指针，防止产生野指针&#125; 7. 链表末尾添加元素1234567891011121314151617181920// 链表末尾添加元素void append(PNode List, int val) &#123; printf("链表尾添加元素: %d\n", val); PNode p = List; PNode pre; while (NULL != p) &#123; // 获取当前的 p元素 pre = p; // p 指向 p的下一个结点 p = p-&gt;Next; &#125; PNode pNew = (PNode)malloc(sizeof(Node)); pNew-&gt;Element = val; pNew-&gt;Next = NULL; pre-&gt;Next = pNew; return;&#125; 8. 反转单链表123456789101112131415161718192021// 反转单链表void reverseList(PNode List) &#123; if (NULL == List || NULL == List-&gt;Next) &#123; printf("反转失败!\n"); return; &#125; printf("反转单链表:\n"); PNode prev = NULL; PNode cur = List-&gt;Next; PNode next = NULL; // 需要在纸上好好分析 while (cur) &#123; next = cur-&gt;Next; // 使箭头反转 cur-&gt;Next = prev; prev = cur; cur = next; &#125; List-&gt;Next = prev;&#125; 五. 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221// 操作系统 win 8.1// 编译环境 Visual Stuido 2017#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include&lt;stdlib.h&gt;typedef int ElementType; // 定义数据类型,可根据需要进行其他类型定义// 链表结点的定义typedef struct ListNode &#123; ElementType Element; // 数据域，存放数据 ListNode* Next; // 指向下一个链表结点&#125; Node, *PNode;// 初始化单链表 PNode initList(void) &#123; int len ; // 用于定义链表长度 int val ; // 用于存放结点数值 PNode PHead = (PNode)malloc(sizeof(Node)); // 创建分配一个头结点内存空间 // 头结点相当于链表的哨兵，不存放数据，指向首结点（第一个结点） if (NULL == PHead) &#123; printf("空间分配失败 \n"); exit(-1); &#125; PNode PTail = PHead; // 链表的末尾结点，初始指向头结点 PTail-&gt;Next = NULL; // 最后一个结点指针置为空 printf("请输入结点个数："); scanf("%d", &amp;len); for (int i = 0; i &lt; len; i++) &#123; // 分配一个新结点 PNode pNew = (PNode)malloc(sizeof(Node)); if (pNew == NULL) &#123; printf("分配新结点失败\n"); exit(-1); &#125; printf("请输入第 %d 个结点的数据：", i + 1); scanf("%d", &amp;val); // 输入链表结点的数据 pNew-&gt;Element = val; // 把数据赋值给结点数据域 PTail-&gt;Next = pNew; // 末尾结点指针指向下一个新结点 pNew-&gt;Next = NULL; // 新结点指针指向为空 PTail = pNew; // 将新结点复制给末尾结点 &#125; printf("创建链表成功\n"); return PHead; // 返回头结点&#125;// 遍历链表元素 void TraverseList(PNode List) &#123; // 就是传过来的是一个指针 // 首结点 赋值给临时结点 P PNode P = List-&gt;Next; printf("遍历链表的值为："); if (P == NULL) printf("链表为空"); // 尾结点的 p-&gt;Next == NULL while (P != NULL) &#123; printf("%d ", P-&gt;Element); P = P-&gt;Next; &#125; printf("\n");&#125;// 查询指定元素 PNode findList(PNode List) &#123; PNode P = List-&gt;Next; // 定义临时指针P指向首结点的地址 int num = 0; // 用于记录链表结点位置 int val = 0; // 用于存放要查询的值 printf("请输入要查询的数："); scanf("%d", &amp;val); // 输入要查询的数值 while (P != NULL &amp;&amp; P-&gt;Element != val) &#123; P = P-&gt;Next; num++; &#125; if (P != NULL) printf("找到的结点位置为：%d", num + 1); else printf("找不到该结点"); printf("\n"); return P;&#125;// 指定位置插入元素void insertList(PNode List, int pos, int val) &#123; printf("位置: %d 插入元素: %d\n", pos, val); int position = 0; PNode P = List; // 定义结点p指向头结点 // 寻找 pos结点的前驱结点 while (P != NULL &amp;&amp; position &lt; pos-1) &#123; P = P-&gt;Next; position++; &#125; PNode Temp = (PNode)malloc(sizeof(Node)); // 分配一个临时结点用来存储要插入的数据 if (Temp == NULL) &#123; printf("内存分配失败！"); exit(-1); &#125; // 插入结点 Temp-&gt;Element = val; Temp-&gt;Next = P-&gt;Next; P-&gt;Next = Temp;&#125;// 销毁单链表 void DeleteTheList(PNode List) &#123; PNode P, Tmp; P = List-&gt;Next; // 定义指针 P指向链表要删除的链表 List的第一个点结点 List-&gt;Next = NULL; while (P != NULL) &#123; Tmp = P-&gt;Next; // 临时Tmp指向要删除的结点的下个结点 free(P); // 释放指针P指向的结点 P = Tmp; // 重新赋值 &#125; printf("删除链表成功！\n");&#125;// 删除指定位置的元素void deleteList(PNode List, int pos) &#123; printf("位置: %d 删除元素!\n", pos); int position = 0; PNode P = List; // 定义一个指针p指向链表头结点 // 找 pos结点位置的前驱结点, 循环几次很重要,可以手写试试 while (P != NULL &amp;&amp; position &lt; pos-1) &#123; P = P-&gt;Next; position++; &#125; // 删除结点 PNode Tmp = P-&gt;Next; // 定义临时指针Tmp指向要删除的结点 P-&gt;Next = Tmp-&gt;Next; // 使要删除结点的前驱结点指向其后驱结点 free(Tmp); // 释放删除结点的内存空间，防止内存泄漏 Tmp = NULL; // 使q指向空指针，防止产生野指针&#125;// 链表末尾添加元素void append(PNode List, int val) &#123; printf("链表尾添加元素: %d\n", val); PNode p = List; PNode pre; while (NULL != p) &#123; // 获取当前的 p元素 pre = p; // p 指向 p的下一个结点 p = p-&gt;Next; &#125; PNode pNew = (PNode)malloc(sizeof(Node)); pNew-&gt;Element = val; pNew-&gt;Next = NULL; pre-&gt;Next = pNew; return;&#125;// 反转单链表void reverseList(PNode List) &#123; if (NULL == List || NULL == List-&gt;Next) &#123; printf("反转失败!\n"); return; &#125; printf("反转单链表:\n"); PNode prev = NULL; PNode cur = List-&gt;Next; PNode next = NULL; // 需要在纸上好好分析 while (cur) &#123; next = cur-&gt;Next; // 使箭头反转 cur-&gt;Next = prev; prev = cur; cur = next; &#125; List-&gt;Next = prev;&#125;// 主函数测试 int main() &#123; // 创建一个指针，使其指向新创建的链表的头指针 PNode list = initList(); TraverseList(list); // 链表尾增加元素 printf("\n"); append(list, 9999); TraverseList(list); // 寻找元素 printf("\n"); findList(list); // 插入元素 printf("\n"); insertList(list, 1, 100); TraverseList(list); // 删除元素 printf("\n"); deleteList(list, 1); TraverseList(list); // 反转单链表 printf("\n"); reverseList(list); TraverseList(list); return 0;&#125; 打印结果 参考文章​ 单链表的算法]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构---线性表]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[线性表定义​ 由 n(n≥0) 个数据特性相同的元素构成的 有限序列 特点 存在唯一的一个被称为”第一个”的数据元素 存在唯一的一个被称为”最后一个”的数据元素 除第一个之外, 结构中的每个数据元素均只有一个前驱元素 除最后一个之外, 结构中的每个数据元素均只有一个后继元素 存储结构及运算 存储结构方式: 顺序存储方式(顺序表), 链接存储方式(链表) 运算: 线性表的初始化 求表的长度 取出表的元素 查找运算 相关概念 空表 : 线性表的长度 n=0 前驱元素 : 如果 a~i~ 和a~i+1~ 是相邻的具有前后关系的两个元素, 则 a~i~ 称为 a~i+1~ 的前驱元素 后继元素 : 如果 a~i~ 和a~i+1~ 是相邻的具有前后关系的两个元素, 则 a~i+1~ 称为 a~i~ 的前驱元素 随笔 线性表中的数据元素之间的逻辑关系就是其相互位置上的 邻接关系 ,该关系是线性的,因此,线性表是一种线性结构 常见例子: 学生成绩表, 列车时刻表, 英文字母表 参考文章​ 数据结构 — 严蔚敏 ​ 数据结构 — 田鲁怀]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[涂磊老师语录]]></title>
    <url>%2F2019%2F03%2F07%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E6%88%91%E6%88%90%E9%95%BF---%E6%B6%82%E7%A3%8A%2F</url>
    <content type="text"><![CDATA[我们总是善于去伤害那些爱我们的人， 因为我们根本伤害不了那些不爱我们的人;我们总是甘愿被那些我们爱的人伤害，那是因为我爱他们 喜欢可以心动，而爱一定会心痛；喜欢可以舍得，但爱一定舍不得；喜欢一个人，冬天不过是冬天，不过是漂亮一点而已；但是爱一个人，冬天可以变成春天；爱一个人，她落泪你就会跟着她一起落泪；而喜欢一个人，她落泪你只不过是安慰；喜欢是可以变成爱的，但如果爱了就说不出喜欢；喜欢是不排她的，而爱一定是排她的，唯一的；喜欢与责任无关，而爱一定要负责任，这就是喜欢和爱的区别 春风得意的浪子回头最珍贵，穷途末路的认错悔改最虚伪 你曾经买了一件很喜欢的衣裳却舍不得穿，郑重地供奉在衣柜里；许久之后，当你再看见它的时候，却发现它已经过时了。所以，你就这样与它错过了。你也曾经买了一块漂亮的蛋糕却舍不得吃，郑重地供奉在冰箱里；许久之后，当你再看见它的时候，却发现它已经过期了。所以，你也这样与它错过了。没有在最喜欢的时候上身的衣裳，没有在最可口的时候品尝的蛋糕，就像没有在最想做的时候去做的事情，都是遗憾。生命也有保存期限，想做的事该趁早去做。如果你只是把你的心愿郑重地供奉在心里，却未曾去实行，那么唯一的结果，就是与它错过，一如那件过时的衣裳，一如那块过期的蛋糕 有些人注定是你生命中的过客，却总是成为你记忆中的常客，但永远也仅止于做客 你以为责任是什么？你以为责任就是终身相守，扔几个钱在家里。真正的责任是要在乎你所爱的人的每一分每一秒的感受 男人无事献殷勤非奸即盗，女人对爱来者不拒不是欺就是爱 人最伟大的力量不是创造，而是自省！如果不能自我反省，不能看到自身的错误和不足，即使有非凡的力量，创造出的一切都只是埋没自己的坟墓！ 越是嘴上说自己有原则的人，越是圆滑，因为他们的原则便是永远不说负责任的话，永远模棱两可！狡猾的眼神中永远透露的是欺骗，向下的嘴角代表的永远是严肃。 在我看来，绝大多数现代人的虚荣来自于虚伪，虚伪来自于自卑！在日常生活中衣着光鲜、牛逼哄哄的家伙其实内心很恐慌！]]></content>
      <categories>
        <category>人间词话</category>
      </categories>
      <tags>
        <tag>人间词话</tag>
        <tag>人生</tag>
        <tag>智慧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[陈果老师语录]]></title>
    <url>%2F2019%2F03%2F07%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E6%88%91%E6%88%90%E9%95%BF---%E9%99%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[只有心灵才能洞察一切，世界上真正重要的东西要用心去看 你使用什么样的双眼观世界，就印证了你有怎样的心眼，如果心眼大，你所见的世界宽广无边，如果你心眼小，充满羡慕嫉妒恨，所见的世界也是偏狭丑陋 选择之所以称之为选择，一定是痛苦的，因为选项是不相上下的，能轻松做决定的，都不叫选择，选择意味着舍弃一种美好，承受一种痛苦，不安 回忆是一种重逢, 忘记是一份自由.]]></content>
      <categories>
        <category>人间词话</category>
      </categories>
      <tags>
        <tag>人间词话</tag>
        <tag>人生</tag>
        <tag>智慧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---基础语法(1)]]></title>
    <url>%2F2019%2F03%2F07%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95(1)%2F</url>
    <content type="text"><![CDATA[一.标识符​ 对于各种变量, 方法和类等要素 命名时使用的字符序列 称为标识符 凡是自己可以命名的地方都叫标识符, 都遵循标识符的规则 二.关键字​ 一些赋以特定的含义, 用作专门用途的字符串 成为关键字 大部分编辑会将关键字用特殊方式标出所有Java关键字都是小写英文 三. java基础数据类型3.1 Java常量​ eg: 整型常量: 123, 字符常量: ‘a’ 注意: 区分字符常量和字符串常量注意: “常量”这个名词还会用在另外其它语境中表示 值不可变的变量 3.2 Java变量1234// 变量i(变量的名字)中存放常量100(变量的值)int i = 100; float f = 3.14;String s = "hello"; 变量是 内存 中的一小块区域, 使用 变量名 来访问这块区域因此,每一个变量使用前必须要先 声明, 然后必须进行 赋值 (填充内容), 才能使用 补充(本质上理解): 一个程序在运行的时候，实际上这个程序是位于内存里面，然后才开始运行。一个.exe文件 存放在硬盘上是无法运行的 ，在硬盘上看到的.exe文件无非就是一个文件而已，当我们双击这个.exe文件时，运行起来的时候实际上是 整个.exe文件被放在了在内存里面 ，然后操作系统找到main方法，也就是程序的入口，然后就开始执行了。执行的过程之中，会不断地在内存里面分配一些区域 变量在内存里面就是一小块区域，变量有两个概念，一个是变量的名字，另一个是变量的值即这一小块区域是有名字的，里面装着一个值，因此以后要想访问这小块区域里面的内容就可以根据这小块区域的名字来访问了。因此，变量的本质就是一小块内存区域 。变量在内存里面分配多大的存储空间呢？ 答: 不同的变量类型分配不同大小的存储空间，每一个变量都是属于特定的数据类型的，声明成不同的数据类型，它就在内存里面分配不同的存储空间。 Java变量的分类:按被声明的 位置 划分: 局部变量: 方法或语句块内部定义的变量 成员变量: 方法外部, 类的内部定义的变量 类外面不能有变量的声明 按所属数据的 数据类型 划分: 基本数据类型变量 引用数据类型变量 3.3 Java数据类型3.3.1 基本数据类型 整数型: byte, short, int, long, 浮动型: float, double 布尔型: bool 字符型: char 3.3.2 基本数据类型的转换 boolean 类型不可以转换为其他的数据类型 容量小的类型自动转换为容量大的数据类型 容量大的类型转换为容量小的数据类型时, 要加上强制转换符,可能造成精度降低或溢出 有多种类型的数据混合运算时,系统首先自动的将所有数据类型转换成 容量最大 的那一种数据类型,然后在进行计算 范例1234567891011121314151617181920public class TestConvert &#123; public static void main(String arg[]) &#123; int i1 = 123; int i2 = 456; double d1 = (i1+i2)*1.2;//系统将转换为double型运算 float f1 = (float)((i1+i2)*1.2);//需要加强制转换符 byte b1 = 67; byte b2 = 89; byte b3 = (byte)(b1+b2);//系统将转换为int型运算，需要强制转换符 System.out.println(b3); double d2 = 1e200; float f2 = (float)d2;//会产生溢出 System.out.println(f2); float f3 = 1.23f;//必须加f long l1 = 123; long l2 = 30000000000L;//必须加l float f = l1+l2+f3;//系统将转换为float型计算 long l = (long)f;//强制转换会舍去小数部分（不是四舍五入） &#125;&#125; 3.3.3 引用数据类型 类(class) 接口(interface) 数组 四. 表达式以 ; 结尾的一段代码，即为一个表达式 范例123// 下面是两个表达式int a = 6;int b = a; 三目运算符条件运算符由两个符号组成”?“和”:“, 要求有3个操作对象,所以也叫它三目运算符 一般形式为 : 表达式1?表达式2:表达式3; 范例1234567if(a&lt;b) min = a;else mi n= b;// 可以用下面的条件运算符来处理// 执行过程: 如果 a&lt;b 为真,则表达式取a值, 否则取b值.min = (a&lt;b)?a:b; 参考博文:​ java基础学习总结——基础语法1 ​ Java中的三目运算符 详解]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo---常用命令]]></title>
    <url>%2F2019%2F03%2F07%2FHexo---%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. 写文章 写文章 你可以执行下列命令来创建一篇新文章。 hexo new #新建文章，可以改成中文的，如“新文章”，如果标题包含空格的话，请使用引号括起来。 删除文章 先删除目标文章，然后重新运行 hexo clean # 清除缓存文件 (db.json) 和已生成的静态文件 (public) hexo g -d # 文件生成后立即部署网站 hexo s -d # 本地测试,加上 -d可以进行debug 写完文章后，你可以使用 hexo g # 全称hexo generate , 生成静态文件（generate：产生） hexo s # 全称hexo server , 启动服务器，默认情况下，访问网址为http://localhost:4000/在本地预览效果 hexo d # 全称hexo deploy, 部署网站，同步到github上（deploy：部署） 2. 分类和标签 Front-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说： 12title: Hello Worlddate: 2013/7/13 20:46:25 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 分类和标签 只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 123456categories:- Diarytags:- PS3- Games# 会使分类Games成为PS3的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试经典题目（1-5题）]]></title>
    <url>%2F2019%2F03%2F07%2FJava%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE(1-5%E9%A2%98)%2F</url>
    <content type="text"><![CDATA[1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？答案： 运行原理：Java源程序经过javac 编译器编译成二进制的xx.class 字节码文件, xx.class 在jvm（各平台装有不同的jvm）上运行，Java解释器（jvm的一部分）会将相同的字节码解释成对应平台的机器码，进而执行。 知识： 一份 xx.class 文件(不会变化）被 不同的jvm 解释成 相对应的机器码 机器码: 依附于硬件，根本不存在跨平台行，不同型号的CPU给相同的指令（eg：10011110）,解析成不同的结果 题外知识： JDK (Java Development Kit): Java开发工具包，针对于Java开发员的产品，JDK是整个Java的核心，包括了JRE, Java工具（Javac【编译Java源码的编译器】，Java程序调试和分析的工具）和Java基础的类库（即Java API) JRE (Java runtime environment)：Java运行环境 ,针对于使用Java程序的用户，Java程序运行做需要的软件环境，不是一个开发环境, 包含jvm，Java基础类库, 不包含任何开发工具（如编译器和调试器）。 JVM (Java Virtual Machine): Java虚拟机，实现Java跨平台的最核心的部分，JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行 2. JDK和JRE的区别是什么？答案： 详细区别见第一题 如果需要运行Java程序，只需要安装JRE（JRE根据不同操作系统有很多不同的版本） 如果需要编写Java程序，需要安装JDK 补充知识： JRE和JVM的区别是什么？ JRE包括JVM和lib（Jvm所需要的类库），JRE里有运行xx.class 的Java.exe 只有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库 时间：2019.3.7 3. ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？答案: static 表示静态的意思, 可用于修饰 成员变量和 方法 , 静态是随着类的加载而加载, 因此可以直接用类进行访问 private私有的方法不能被继承，子类就没有访问权限 覆盖 覆盖基于运动时动态绑定的 指覆盖了一个方法并且对其重写，以求达到不同的作用,，但是子类中的访问权限要不低于父类中的访问权限,重写的前提是必须要继承. Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。 私有的方法不能被继承，子类就没有访问权限，肯定也是不能别覆盖的。 12345678910111213141516171819202122232425262728class Super&#123; // 静态方法 static String greeting()&#123; return "Good night"; &#125; String name()&#123; return "Richard"; &#125; &#125; class Sub extends Super&#123; //子方法,继承Super //重写(覆盖)父类当中的静态方法 static String greeting()&#123; return "Hello"; &#125; String name()&#123; return "Dick"; &#125; &#125;class Test&#123; public static void main(String[] args)&#123; Super s = new Sub(); System.out.println(s.greeting()+","+s.name()); &#125; &#125;//运行结果：Good night,Dick (静态方法打印的是父类中的)//这个例子说明“实例方法被覆盖，静态方法被隐藏” 4. 是否可以在static环境中访问非static变量？答案: 不可以 因为静态的成员属于类，随着类的加载而加载到静态方法区内存，当类加载时，此时不一定有实例创建，没有实例，就不可以访问非静态的成员。 静态变量属于类变量，随着类的加载而加载，当调用类变量时Java虚拟机会对类的静态变量，静态方法进行初始化，此时如果静态方法中有非静态变量，由于非静态变量是随着实例的创建而创建，此时还没有实例创建，所以非静态变量还没有创建，所以会出现编译错误。 参考博文:​ 牛客网优质答案 时间: 2019.3.11 5. Java支持的数据类型有哪些？什么是自动拆装箱？答案: 基本数据类型 整数型: byte, short, int, long, 浮动型: float, double 布尔型: bool 字符型: char 整数默认int型，小数默认是double型。Float和long类型的必须加后缀。 引用类型 引用类型也就是我们常说的对象，在Java中每个基础类型的数据都有其包装类，对应上面分别是：Byte, Short, Int, Long, Float, Double, Char, Boolean 引用类型包括类、数组、接口, String等 自动装箱和拆箱就是基本类型和引用类型之间的转换 装箱：将基本类型转换成引用类型，如 Integer i = 10; 拆箱：将引用类型转换成基础类型，如 Integer i = 10; int j = i; 转化为引用类型之后，就可以new一个对象，从而就可以调用包装类型中的封装好的方法，方便使用 参考博客​ 牛客网优质答案 时间: 2019.3.12]]></content>
      <categories>
        <category>java面试常考题目</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java面试常考题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间词话---文章]]></title>
    <url>%2F2019%2F03%2F06%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[感谢困难​ 林清玄​ 我做了一个梦。 梦见我在街上问人：“请问您可不可以给我一些困难、一些挫折，一些痛苦?” 所有的人都拒绝我，我着急地恳求别人：“那么，我雇用您，每小时五百元，请您给我一些折磨!” 那些陌生人摇摇头，沉默地离开，我因找不到愿意折磨我的人而惊醒。 我坐在床上发呆，是呀!困难，折磨，痛苦是多么珍贵!如果一切平顺，谁会静下来沉思，谁会生起智慧，谁又能在平凡安逸的日子中超越自我、登上高峰呢? 如果没有困难，谁又会谦卑地跪下来祈祷?谁又能相信有无边的宇宙?谁又能寄情于来生呢? 我深深地感谢着困难、挫折与痛苦。 也深深地感恩那些曾经折磨过我的人，他们是多么慈悲呀!我并未花钱聘雇他们，他们却以宝贵的时间来考验我、提升我，为了增长我的智慧。 真正的高贵​ 海明威 ​ 在风平浪静的大海，每个人都是领航员。 ​ 但是，只有阳光而无阴影，只有欢乐而无痛苦，那就不是人生。以最幸福的人的生活为例.他的生活也是一团缠结在一起的乱麻。痛苦与幸福交替出现,使得我们一会悲伤，一会高兴，甚至死亡本身也会使生命更加可爱。在人生的清醒的时刻，在悲伤与失落的阴影之下，人们与真实的自我最接近。 ​ 在生活和事业的种种事物中，性格比才智更能指导我们, 心灵比头脑更能引导我们,而由判断获得的克制, 耐心和教养比天分更能让我们受益。 ​ 我始终相信，内心生活开始更为严谨的人，他的外在生活也会变得更为简朴。在一个物欲横流的年代，但愿我能向世人表明，人类真正需求少得多么可怜。 ​ 反思自己的过错不至于重蹈覆辙才是真正的悔悟, 高人一等并没有什么值得夸耀的。真正的高贵是优于过去的自己。]]></content>
      <categories>
        <category>人间词话</category>
      </categories>
      <tags>
        <tag>人间词话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间词话---惊艳的文字]]></title>
    <url>%2F2019%2F03%2F06%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E6%83%8A%E8%89%B3%E7%9A%84%E6%96%87%E5%AD%97%2F</url>
    <content type="text"><![CDATA[现代诗 酒入豪肠，七分酿成了月光，余下的三分啸成剑气，绣口一吐，就半个盛唐。 —余光中《寻李白》 古诗 少年不知愁滋味,爱上层楼,爱上层楼.为赋新词强说愁.而今识尽愁滋味,欲说还休,欲说还休,却道天凉好个秋. —辛弃疾《丑奴儿》 十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。料得年年肠断处，明月夜，短松冈。 —苏轼 古文 斯是陋室,惟吾德馨. —刘禹锡《陋室铭》 夏虫不可语冰 —孔子 文章摘要 我知道我很大胆冒昧, 听说你朋友很多, 我不配高攀, 可是很想在你的朋友里凑个数目. —钱钟书《围城》 别客气,我求你明天来.我想去吃,对自己没有好借口,借你的名义,自己享受一下,你就体贴下情,答应了吧. —钱钟书《围城》]]></content>
      <categories>
        <category>人间词话</category>
      </categories>
      <tags>
        <tag>人间词话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常见简写]]></title>
    <url>%2F2019%2F02%2F28%2FJava%E5%B8%B8%E8%A7%81%E7%AE%80%E5%86%99%2F</url>
    <content type="text"><![CDATA[ORM Object Relational Mapping 对象关系映射 对象和关系数据库的映射简单说，一个对象，对应数据库里的一条记录 DAOData Access Object的缩写，这些类专门用于进行数据库访问的操作]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曾仕强教授语录]]></title>
    <url>%2F2019%2F01%2F10%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E6%88%91%E6%88%90%E9%95%BF---%E6%9B%BE%E4%BB%95%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[很多事情，从不同的角度看，才能体会到其中的奥妙 做一个领导者，一定要充分了解下属的特性是什么，及时的下达合理的命令，而且效果要非常的良好，此为将才 事事都透露着一个人的能力 顾全大局，大局的前提底下，很多细小的事情，不用太过于考虑 一件事，从不同的角度看，都有道理，怎么讲都对，不是对不对的事，是价值观的体现 得意勿忘形，人在得意时，千万不能忘形，做事情随他爱怎样怎样，变为得意忘形，当一个人处于逆境的时候，他还会谨慎一点，当一个人处顺境的时候，他就开始沉不住气 形势比人强 人生的理想在于不断提升自己的层次 有智慧没知识容易陷入空想，一事无成。有知识没智慧，就不要埋怨被人当做工具使用，用毕即弃。要善用智慧来运用知识，以求合理的表现 处逆境容易，正因留意，处顺境很难，正因大意 你要很谨慎地去保留你独特的地方，这个独特之处就是你之所以为人的地方。能够自我成全，才是人最伟大的地方]]></content>
      <categories>
        <category>人间词话</category>
      </categories>
      <tags>
        <tag>人间词话</tag>
        <tag>人生</tag>
        <tag>智慧</tag>
      </tags>
  </entry>
</search>
