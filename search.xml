<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F27%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[一．数组的基本概念 数组可以看成是多个相同类型数据组合，对这些数据的统一管理。 数组变量属于引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。 数组的元素可以是任何数据类型，包括基本类型和引用类型。 C 和 C++ 中的数组都可以分配在栈上面，而JAVA中的数组是只能分配在堆上面的，因为JAVA中的数组是引用类型 二．一维数组一维数组的声明方式有两种 格式一：数组元素类型 数组名[ ]; 格式二：数组元素类型[ ] 数组名; 例如： 12345int a1[ ]; int[ ] a2;String[ ] s1; String s1[ ]; 注意：**JAVA语言中声明数组时不能指定其长度(数组中的元素个数)** ​ 如：int a[5]; 这样声明一维数组是非法的。 三．数组的模型 一维数组：一维数组就是一行，一行小格。 二维数组：二维数组就是一行加一列组成的一个平面分成的小格，有行有列。 三维数组：三维数组就是一个立方体。 人类对最多认识到三维空间。 参考博文​ java基础学习总结——数组]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算机知识---绝对路径与相对路径]]></title>
    <url>%2F2019%2F03%2F26%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86---%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[一. 基本概念 相对路径 : 顾名思义，相对路径就是相对于当前文件的路径。网页中一般表示路径使用这个方法。 绝对路径 : 绝对路径就是你的主页上的文件或目录在硬盘上真正的路径。 硬盘上 : 你的Perl 程序是存放在 c:/apache/cgi-bin 下的，那么 c:/apache/cgi-bin就是cgi-bin目录的绝对路径 网络中 : 以http开头的链接都是绝对路径，绝对路径就是你的主页上的文件或目录在硬盘上真正的路径，绝对路径一般在CGI程序的路径配置中经常用到，而在制作网页中实际很少用到。 二、相对路径使用的特殊符号相对路径使用的特殊符号 ./：代表目前所在的目录 ../ : 代表上一层目录 / : 代表根目录 根目录下有Site1和Image/Image.jpg，Site1下有Page1.html文件和Site2文件夹。Site2下有Page2.html和Page2Image.jpg图片文件。 1、文件在当前目录 12Page2.html访问Page2Image.jpg&lt;img src=”./Page2Image.jpg”&gt;或者&lt;img src=”Page2Image. jpg”&gt; 三. 绝对路径与相对路径的比较3.1 绝对路径的优点A、如果有人抄袭你的网站内容，里面的链接还会指向你的网站，有些抄袭的人比较懒，根本不会去改内容。其实也不局限于被抄袭，如果有人将你的网页保存到本地电脑中，里面的链接、图片、css、以及js仍然会连接到你的网站。 B、如果网页位置改变，里面的链接还是指向正确的URL。 3.2 绝对路径的缺点A、在编码编写时不方便使用绝对路径，因为链接应该指向真正的域名而不是开发站点。 相对路径的优缺点和绝对路径几乎相反。 3.3 相对路径的优点：A、容易移动内容，可以整个目录移动。 B、测试方法比较灵活，本机测试时比较方便。 3.4 相对路径的缺点：A、部分内容页面换了位置时，链接容易失效。 B、容易被人大面积采集抄袭。 相对路径和绝对路径在系统文件中与在网络中类似，文件的路径符号是斜线 “/”，而网络路径却是和它相反的反斜线“/” 四. 路径分割符在目录中的分隔符 在Windows中分隔符为 \ 在Unix/Linux中分隔符为 / 浏览器地址栏网址使用 / 有时我们会看到这样的路径写法，&quot;C:\\Windows\\System&quot;，也就是用两个反斜杠来分隔路径 这种写法在网络应用或编程中经 常看到，事实上，上面这个路径可以用 &quot;C:/Windows/System&quot; 来代替，不会出错。但是如果写成了 &quot;C:\Windows\System&quot; ， 那就可能会出现各种奇怪的错误了 在 Java程序中 反斜杠 \ 与不同的字符会组成不同的转义字符,如 \n 代表换行, 在字符串中要表示字符 \ , 需要写成 \\ ​ 字符串解析不仅仅局限于C编译器，Java编译器、一些配置文件的解析、Web服务器等等，都会遇到对字符串进行解析的这个问题，由于传统的 Windows采用的是单个反斜杠的路径分隔形式，导致在对文件路径进行解析的时候可能发生不必要的错误，所以就出现了用双反斜杠”\\”分隔路径的形式。 不管解析引擎是否将反斜杠解析成转义字符，最终在内存中得到的都是”\”，结果也就不会出问题了。 参考博文​ 关于绝对路径和相对路径 ​ 编程中常见的斜杠（”/“和”\”）问题 ​]]></content>
      <categories>
        <category>计算机知识</category>
      </categories>
      <tags>
        <tag>计算机知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---File]]></title>
    <url>%2F2019%2F03%2F26%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---File%2F</url>
    <content type="text"><![CDATA[一. 初识 File1.1 File类说明​ 存储在变量,数组和对象中的数据是暂时的,当程序终止时他们就会丢失. ​ 为了能够永久的保存程序中创建的数据,需要将他们存储到硬盘或光盘的文件中.这些文件可以移动,传送,亦可以被其他程序使用.由于数据存储在文件中,所以我们需要学习一个和文件有密切关系的类,叫做File类,将要掌握获取文件的属性以及删除和重命名文件.最终如何向文件中写入数据和从文件中读取数据. 那么File类关心的是在磁盘上文件的存储. 说明 File类描述的是一个文件或文件夹。（文件夹也可以称为目录） 该类的出现是对文件系统的中的文件以及文件夹进行对象的封装。可以通过对象的思想来操作文件以及文件夹。 可以用面向对象的处理问题，通过该对象的方法，可以得到文件或文件夹的信息方便了对文件与文件夹的属性信息进行操作。 文件包含很多的信息:如文件名、创建修改时间、大小、可读可写属性等。 1.2 体验File类检验指定路径下是否存在指定的目录或者文件. 123456789// 检验指定路径下是否存在指定的目录或者文件.File file = new File("c:\\a.txt");System.out.println(file.exists());// File对象是否是目录System.out.println(file.isDirectory());// 对象是否是文件System.out.println(file.isFile()); 结论： File对象也可以表示不存在的文件。其实代表了一个抽象路径 构建一个File类的实例并不会在机器上创建一个文件.不管文件是否存在都可以创建任意文件名的File实例,可以调用File实例的exists方法判断文件或目录是否存在 1.3 创建File类12345678910// 通过将给定路径来创建一个新File实例。new File(String pathname);// 根据parent路径名字符串和child路径名创建一个新File实例。// parent是指上级目录的路径，完整的路径为parent+child.new File(String parent, String child);// 根据parent抽象路径名和child路径名创建一个新File实例。// parent是指上级目录的路径，完整的路径为parent.getPath()+child.new File(File parent, String child); 如果指定的路径不存在（没有这个文件或是文件夹），不会抛异常，这时file.exists()返回false 新建File对象File file=new File(); 12345678910public static void main(String[] args) &#123; // file01 是一个文件对象 String path01 = "c:/a.txt"; File file01 = new File(path); // file02 是一个文件夹 String path02 = "c:/test"; File file02 = new File(path);&#125; 注意 创建File对象需要导包, import java.io.File File对象没有无参数构造.创建对象需要传参. 根据API文档提示,传入一个文件的字符串路径. String path=&quot;c:/a.txt&quot;; (a.txt 文件在c盘下已经存在) File类的对象，既可以代表文件也可以代表文件夹 二. 路径​ 路径就是文件或文件夹所在的位置。 2.1 绝对路径与相对路径： 对于UNIX平台，绝对路径名的前缀是”/“。相对路径名没有前缀。 对于Windows平台，绝对路径名的前缀由驱动器号和一个”:”组成，例”c:\…”。相对路径没有盘符前缀。 一般在使用时，建议用绝对路径，因为相对路径容易出问题，不好确定到底在什么地方 实例1234567891011public class TestFile &#123; public static void main(String[] args) &#123; // 绝对路径 File f1 = new File("d:/LOLFolder"); System.out.println("f1的绝对路径：" + f1.getAbsolutePath()); // 相对路径,相对于工作目录，如果在eclipse中，就是项目目录 File f2 = new File("LOL.exe"); System.out.println("f2的绝对路径：" + f2.getAbsolutePath()); &#125;&#125; 2.2 路径分割符上下级文件夹之间使用分隔符分开 在Windows中分隔符为 \ 在Unix/Linux中分隔符为 / 跨平台的目录分隔符​ 更专业的做法是使用File.separatorChar，这个值就会根据系统得到的相应的分割符。例如: 1new File("c:" + File.separatorChar + "a.txt"); 注意 : 如果是使用”\”，则需要进行转义，写为”\“才可以，如果是两个”\”，则写为”\\“ 三. 操作文件的相关方法1) 创建 序号 方法名称 描述 14 public boolean createNewFile() throws IOException 在指定位置创建一个空文件，成功就返回true，如果已存在就不创建然后返回false 21 public boolean mkdir() 在指定位置创建目录，这只会创建最后一级目录，如果上级目录不存在就抛异常 22 public boolean mkdirs() 在指定位置创建目录，这会创建路径中所有不存在的目录 23 public boolean renameTo(File dest) 重新命名此抽象路径名表示的文件 2)获取文件相关 序号 方法名称 描述 1 public String getName() 返回由此抽象路径名表示的文件或目录的名称。 2 public String getParent() 返回此抽象路径名的父路径名的路径名字符串 3 public File getParentFile() 返回此抽象路径名的父路径名的抽象路径名 4 public String getPath() 将此抽象路径名转换为一个路径名字符串 6 public String getAbsolutePath() 返回抽象路径名的绝对路径名字符串 12 public long lastModified() 返回此抽象路径名表示的文件最后一次被修改的时间 13 public long length() 返回由此抽象路径名表示的文件的长度 文件夹相关 序号 方法名称 描述 3) 判断 序号 方法名称 描述 5 public boolean isAbsolute() 测试此抽象路径名是否为绝对路径名 7 public boolean canRead() 测试应用程序是否可以读取此抽象路径名表示的文件 9 public boolean exists() 测试此抽象路径名表示的文件或目录是否存在 10 public boolean isDirectory() 测试此抽象路径名表示的文件是否是一个目录 11 public boolean isFile() 测试此抽象路径名表示的文件是否是一个标准文件 参考博文​ java File类 ​ Java 关于File使用 ​ Java File类]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---Iterator迭代器]]></title>
    <url>%2F2019%2F03%2F26%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一. 迭代器概述1.1 迭代器模式​ 提供一种方法对一个容器对象中的各个元素进行访问，而又不暴露该对象容器的内部细节 1.2 什么是迭代器？ Java集合框架的集合类，我们有时候称之为容器。容器的种类有很多种，比如ArrayList、LinkedList、HashSet…，每种容器都有自己的特点，每种容器都有自己特有的数据结构。 因为容器的内部结构不同，很多时候可能不知道该怎样去遍历一个容器中的元素。所以为了使对容器内元素的操作更为简单，Java引入了迭代器模式！ 二. java.util.Iterator 在Java中Iterator为一个接口，它只提供了迭代的基本规则。 ​ 在JDK中它是这样定义的：对Collection进行迭代的迭代器。迭代器取代了Java Collection Framework中的Enumeration。 迭代器与枚举有两点不同: 迭代器在迭代期间可以从集合中移除元素。 方法名得到了改进，Enumeration的方法名称都比较长。 接口定义123456package java.util;public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); void remove();&#125; 三个方法解释 hasNext() : 如判断是否存在下一个对象元素.有仍有元素可以迭代,则返回true next() : 返回迭代的下一个元素 remove() : 从迭代器指向 collenction 中移除元素 三. java.util.Iterable Java中还提供了一个Iterable接口，Iterable接口实现后的功能是 “”返回“ 一个迭代器，我们常用的实现了该接口的子接口有:Collection、List、Set等。该接口的iterator()方法返回一个标准的Iterator实现。实现Iterable接口允许对象成为Foreach语句的目标。就可以通过foreach语句来遍历你的底层序列。 Iterable接口包含一个能产生Iterator对象的方法，并且Iterable被foreach用来在序列中移动。因此如果创建了实现Iterable接口的类，都可以将它用于foreach中。 接口定义123456Package java.lang;import java.util.Iterator;public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator();&#125; 四. 使用迭代器遍历集合12345678910111213141516171819202122public static void main(String[] args)&#123; List&lt;String&gt; list=new ArrayList&lt;&gt;(); list.add("abc"); list.add("edf"); list.add("ghi"); // 方式一, 不常用 for(Iterator&lt;String&gt; iterator = list.iterator(); it.hasNext(); ) &#123; System.out.println(iterator.next()); &#125; // 方式二, 常用 Iterator&lt;Person&gt; iterator = array.iterator(); while(iterator.hasNext() ) &#123; System.out.println(iterator.next().getName()); //输出的是wang，而不是tom &#125; // 使用forEach遍历 for(String string : List) &#123; System.out.println(string); &#125;&#125; 使用 foreach 遍历集合的优势在于代码更加的简洁，更不容易出错，不用关心下标的起始值和终止值。 参考博文​ 深入理解Java中的迭代器 ​ Java集合Iterator迭代器的实现 ​ Java迭代器(iterator详解以及和for循环的区别)]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---文件上传与下载]]></title>
    <url>%2F2019%2F03%2F26%2FJavaWeb---%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[​ 在web应用系统开发中，文件上传和下载功能是非常常用的功能， ​ 对于文件上传，浏览器在上传的过程中是将文件以流的形式提交到服务器端的，如果直接使用Servlet获取上传文件的输入流然后再解析里面的请求参数是比较麻烦 ​ 一般选择采用apache的开源工具common-fileupload这个文件上传组件 一. 开发环境搭建创建一个 FileUploadAndDownLoad 项目，加入Apache的 commons-fileupload 文件上传组件的相关Jar包 12commons-io-1.4.jarcommons-fileupload-1.2.2.jar 二. 实现文件上传2.1 文件上传页面和消息提示页面upload.jsp 页面 12345678910111213&lt;%@ page language="java" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath&#125;/servlet/UploadHandleServlet" enctype="multipart/form-data" method="post"&gt; 上传用户：&lt;input type="text" name="username"&gt;&lt;br/&gt; 上传文件1：&lt;input type="file" name="file1"&gt;&lt;br/&gt; 上传文件2：&lt;input type="file" name="file2"&gt;&lt;br/&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 注意 form 的 method 必须是 post 的，get不能上传文件。 还需要加上 enctype=&quot;multipart/form-data&quot; 表示提交的数据是二进制文件 需要提供 type=&quot;file&quot; 的字段进行上传 2.2 处理文件上传的ServletUploadHandleServlet 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class UploadHandleServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 得到上传文件的保存目录，将上传的文件存放于WEB-INF目录下，不允许外界直接访问，保证上传文件的安全 String savePath = this.getServletContext().getRealPath("/WEB-INF/upload"); File file = new File(savePath); // 判断上传文件的保存目录是否存在 if (!file.exists() &amp;&amp; !file.isDirectory()) &#123; System.out.println(savePath + "目录不存在，需要创建"); // 创建目录 file.mkdir(); &#125; // 消息提示 String message = ""; try&#123; // 使用Apache文件上传组件处理文件上传步骤： // 1、创建一个DiskFileItemFactory工厂 DiskFileItemFactory factory = new DiskFileItemFactory(); // 2、创建一个文件上传解析器 ServletFileUpload upload = new ServletFileUpload(factory); // 解决上传文件名的中文乱码 upload.setHeaderEncoding("UTF-8"); // 3、判断提交上来的数据是否是上传表单的数据 if(!ServletFileUpload.isMultipartContent(request))&#123; // 按照传统方式获取数据 return; &#125; // 4、使用ServletFileUpload解析器解析上传数据，解析结果返回的是一个List&lt;FileItem&gt;集合，每一个FileItem对应一个Form表单的输入项 List&lt;FileItem&gt; list = upload.parseRequest(request); for(FileItem item : list)&#123; // 如果fileitem中封装的是普通输入项的数据 if(item.isFormField())&#123; String name = item.getFieldName(); // 解决普通输入项的数据的中文乱码问题 String value = item.getString("UTF-8"); // value = new String(value.getBytes("iso8859-1"),"UTF-8"); System.out.println(name + "=" + value); &#125; else &#123; // 如果fileitem中封装的是上传文件 // 得到上传的文件名称， String filename = item.getName(); System.out.println(filename); if(filename==null || filename.trim().equals(""))&#123; continue; &#125; // 注意：不同的浏览器提交的文件名是不一样的，有些浏览器提交上来的文件名是带有路径的，如： c:\a\b\1.txt，而有些只是单纯的文件名，如：1.txt // 处理获取到的上传文件的文件名的路径部分，只保留文件名部分 filename = filename.substring(filename.lastIndexOf("\\")+1); // 获取item中的上传文件的输入流 InputStream in = item.getInputStream(); // 创建一个文件输出流 FileOutputStream out = new FileOutputStream(savePath + "\\" + filename); //创建一个缓冲区 byte buffer[] = new byte[1024]; //判断输入流中的数据是否已经读完的标识 int len = 0; //循环将输入流读入到缓冲区当中，(len=in.read(buffer))&gt;0就表示in里面还有数据 while((len=in.read(buffer))&gt;0)&#123; //使用FileOutputStream输出流将缓冲区的数据写入到指定的目录(savePath + "\\" + filename)当中 out.write(buffer, 0, len); &#125; //关闭输入流 in.close(); //关闭输出流 out.close(); //删除处理文件上传时生成的临时文件 item.delete(); message = "文件上传成功！"; &#125; &#125; &#125;catch (Exception e) &#123; message= "文件上传失败！"; e.printStackTrace(); &#125; request.setAttribute("message",message); request.getRequestDispatcher("/message.jsp").forward(request, response); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 参考博文​ JavaWeb学习总结(五十)——文件上传和下载 ​ Java文件上传功能代码 —— 普遍适用 ​ JavaWeb开发之网站实现文件上传功能]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery---常用方法]]></title>
    <url>%2F2019%2F03%2F26%2FJQuery---%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一. 理解 $(function(){})1234567$();function()&#123;&#125;$(function()&#123;&#125;); 二. 通过id获取元素与javascript 通过id获取元素节点 的方式(document.getElementById )不同通过 $(&quot;#id&quot;) 获取 注意document.getElementById 获取到的是 DOM里的 元素节点$(“#id”) 获取到的是一个 JQuery 对象 12345678&lt;script &gt; $(function()&#123; document.write( $("#d") ); document.close(); &#125;);&lt;/script&gt;&lt;div id="d"&gt;Hello JQuery&lt;/div&gt; 三. 增加监听器JQuery增加click事件的监听 实例12345678$(function()&#123; $("#b1").click(function()&#123; alert("点击了按钮"); &#125;);&#125;);&lt;/script&gt; &lt;button id="b1"&gt;按钮&lt;/button&gt; 解释 b1按钮的点击事件 1$("#b1").click(); 弹出对话框的函数 123function()&#123; alert("点击了按钮");&#125;]]></content>
      <categories>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript---函数]]></title>
    <url>%2F2019%2F03%2F26%2FJavaScript---%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一. 定义 名称 作用 function 关键字 print 函数名称 (message) 参数列表,参数为message { 函数开始 返回结果 } 函数结束 实例123456789&lt;script&gt; function print(message)&#123; document.write("这一句话是由一个自定义函数打印"); return message + "!!!!" &#125; &lt;!-- 光有函数的定义，还不够，它不会自动执行,需要调用--&gt; print();&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---流]]></title>
    <url>%2F2019%2F03%2F25%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%B5%81%2F</url>
    <content type="text"><![CDATA[一. JAVA流式输入/输出原理1) 流是用来==读写==数据的​ Java有一个类叫File，它封装的是文件的文件名，只是内存里面的一个对象，真正的文件是在硬盘上的一块空间，在这个文件里面存放着各种各样的数据. 2) 如何读文件里面的数据？​ 通过流的方式来读 ​ 咱们要想从程序读数据，对于计算机来说，无论读什么类型的数据都是以010101101010这样的形式读取的。可以把文件想象成一个桶，文件里面的数据就相当于是这个桶里面的水 怎么从这个桶里面取水 (怎么从这个文件读取数据) 取水办法 : 用一根管道插到桶上面，然后在管道的另一边打开水龙头，桶里面的水就开始哗啦哗啦地从水龙头里流出来了，桶里面的水是通过这根管道流出来的，因此这根管道就叫流 JAVA里面的 流式输入/输出 跟水流的原理一模一样，当你要从文件读取数据的时候，一根管道插到文件里面去，然后文件里面的数据就顺着管道流出来，这时你在管道的另一头就可以读取到从文件流出来的各种各样的数据了。当你要往文件写入数据时，也是通过一根管道，让要写入的数据通过这根管道哗啦哗啦地流进文件里面去。 除了从文件去取数据以外，还可以通过网络，比如用一根管道把我和你的机子连接起来，我说一句话，通过这个管道流进你的机子里面，你马上就可以看得到，而你说一句话，通过这根管道流到我的机子里面，我也马上就可以看到。 有的时候，一根管道不够用，比方说这根管道流过来的水有一些杂质，我们就可以在这个根管道的外面再包一层管道，把杂质给过滤掉。从程序的角度来讲，从计算机读取到的原始数据肯定都是010101这种形式的，一个字节一个字节地往外读，当你这样读的时候你觉得这样的方法不合适，没关系，你再在这根管道的外面再包一层比较强大的管道，这个管道可以把010101帮你转换成字符串。这样你使用程序读取数据时读到的就不再是010101这种形式的数据了，而是一些可以看得懂的字符串了。 理解 原始 类比成 文件 一个桶 文件中的数据 桶中的水 Java 流式输入/输出 接水的管道 更强大的管道 过滤杂质 二. 输入输出流分类io包里面定义了所有的流，所以一说流指的就是 io 包 里面的 用一根管道一端插进文件里程序里面，然后开始读数据，那么这是输入还是输出呢？ 在文件的角度上，这叫输出 在程序的角度上，这叫输入 以后说输入流和输出流都是站在==程序==的角度上来说 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer ​ 这4个类都是抽象类，可以把这4个类想象成4根不同的管道，一端接着你的程序，另一端接着数据源，你可以通过输出管道从数据源里面往外读数据，也可以通过输入管道网数据源里面输入数据，总之通过这4根管道可以让数据流进来和流出去. 所有类型位于 java.io 内部都分别继承这4种抽象流类型 从不同的角度进行分类 按数据流的方向不同，可以分为输入流和输出流 按处理数据单位不同可以分为字节流和字符流 字符流 : 一个字符, 一个字符的往外读数据，一个字符是两个字节 字节流 : 一个字节, 一个字节的往外读数据, 一个字节是八位 按功能不同可以分为节点流和处理流 三. 节点流和处理流3.1 节点流类型 类型 字符流 字节流 File(文件) FileReader / FileWriter FileInputStream / FileOutputStream Memory Array CharArrayReader / CharArrayWriter ByteArrayInputStream / ByteArrayOutputStream Memory String StringReader / StringWriter — Pipe(管道) PipedReader / PipedWriter PipedInputStream / PipedOutputStream 可以从一个特定的数据源 (节点) 读写数据 (如: 文件, 内存) 就像一根管道直接插到数据源上面，直接读数据源里面的数据，或者是直接往数据源里面写入数据。，这根管道就叫做节点流 典型的节点流是文件流： 文件的字节输入流（FileInputStream），文件的字节输出流（FileOutputStream） 文件的字符输入流（FileReader），文件的字符输出流（FileWriter） 3.2 处理流类型 处理流是包在别的流上面的流，相当于是包到别的管道上面的管道 (通过对数据的处理为程序提供更为强大的读写功能) 为什么需要处理流呢？ 这就跟水流里面有杂质，你要过滤它，你可以再套一层管道过滤这些杂质一样。 四. InputStream(输入流)继承自 inputStream 的流都是用于向程序中输入数据且数据的单位为字节 凡是以 inputStream 结尾的管道，都是以字节的形式向我们的程序输入数据 基本方法12345678910111213// 读取一个字节并以整数的形式返回 (ASCII 0~255)// 如果返回 -1 已到输入流的末尾int read() throws IOException// 读取一个字节，并存到一个数组 buffer// 返回实际读取的字节数，如果读取前已到输入流的末尾返回-1int read(byte[] buffer) throws IOException// 关闭流释放内存资源void close() throws IOException// 跳过n个字节不读，返回实际跳过的字节数long skip(long n) throws IOException 总结 read() 的方法是一个字节，一个字节的往外读，每读取一个字节就处理一个字节. read(byte[] buffer) 方法读取数据时先把读取到的数据填满这个 byte[] 的buffer (buffer是内存里面一块缓冲区), 然后再处理数组里面的数据 这就跟我们取水一样，先用一个桶去接，等桶接满后再处理桶里面的水，如果是每读取一个字节就处理一个字，这样读取也太累了 五. OutputStream(输出流)继承自outputStream 的流是用于程序中输入数据, 且数据的单位为字节(8 bit) 基本方法123456789101112131415// 将输出流中写入一个字节的数据，该字节数据为参数b的低8位void write(int b) throws IOException// 将一个字节类型的数据中的数据写入输出流int write(byte[] buffer) throws IOException// 将一个字节类型的数组中的从指定位置(off)开始// len 个字节写入到输出流void write(byte[] b, int off, int len) throws IOException// 关闭流释放内存资源void close() throws IOException// 将输出流中缓冲区的数据全部写出到目的地void flush() throws IOException 六. Reader流一个字符也就是两个字节，使用 Reader 流读取数据时都是两个字节，两个字节的往外读 为什么还要有这种两个字节的读取方式呢？ 因为有些字符是占两个字节的，如我们中文字符在Java里面就是占两个字节的，如果采用一个字节一个字节往外读的方式，那么读出来的就是半个汉子，这样Java是没有办法正确显示中文字符的所有必要存在这种留一个字符，一个字符的往外读， 和 inputStream 一模一样，唯一的区别就是在于读的数据单位不同 基本方法1234567891011121314151617// 读取一个字节并以整数的形式返回(0~255)// 如果返回 -1 已到输入流的末尾int read() throws IOException// 读取一个字节，并存到一个数组 buffer// 返回实际读取的字节数，如果读取前已到输入流的末尾返回-1int read(char[] cbuf) throws IOException// 读取length个字符并存储到一个数组buffer// 从length位置开始,返回实际读取的字符数,如果读取前已到输入流的末尾返回-1int read(char[] cbuf, int offset, int length) throws IOException// 关闭流释放内存资源void close() throws IOException// 跳过n个字节不读，返回实际跳过的字节数long skip(long n) throws IOException 七. Writer流继承自writer的流都是用于程序中输出数据, 且数据的单位为字符(16 bit) 基本方法123456789101112131415// 将输出流中写入一个字节的数据，该字节数据为参数b的低 16 位void write(int b) throws IOException// 将一个字符类型的数据中的数据写入输出流int write(byte[] buffer) throws IOException// 将一个字符类型的数组中的从指定位置(offset)开始// len 个字节写入到输出流void write(char[] cbuf, int offset, int length) throws IOException// 关闭流释放内存资源void close() throws IOException// 将输出流中缓冲区的数据全部写出到目的地void flush() throws IOException 八. 节点流讲解 以File(文件)这个类型作为讲解节点流的典型代表 范例：使用 FileInputStream 流来读取文件的内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class TestFileInputStream &#123; public static void main(String args[]) &#123; // 使用变量b来装调用read()方法时返回的整数 int b = 0; // 使用FileInputStream流来读取有中文的内容时，读出来的是乱码 FileInputStream in = null; //使用FileReader流来读取内容时，中英文都可以正确显示 // FileReader in = null; try &#123; in = new FileInputStream("G:\\test.txt"); // in = new FileReader("G:/test.txt"); &#125; catch (FileNotFoundException e) &#123; System.out.println("系统找不到指定文件！"); System.exit(-1); // 系统非正常退出 &#125; // 使用变量num来记录读取到的字符数 long num = 0; try &#123; // 调用read()方法时会抛异常，所以需要捕获异常 // 循环结束的条件就是返回一个值-1，表示此时已经读取到文件的末尾了 while ((b = in.read()) != -1) &#123; // 如果没有使用“(char)b”进行转换，那么直接打印出来的b就是数字，而不是英文和中文了 // System.out.print(b+" "); // “char(b)”把使用数字表示的汉字和英文字母转换成字符输入 System.out.print((char) b); num++; &#125; // 关闭输入流 in.close(); System.out.println(); System.out.println("总共读取了" + num + "个字节的文件"); &#125; catch (IOException e1) &#123; System.out.println("文件读取错误！"); &#125; &#125;&#125;// 打印结果// 104 101 108 108 111 32 119 111 114 108 100 32 33 33// hello world !!// 总共读取了14个字节的文件 范例：使用 FileOutputStream 流往一个文件里面写入数据1234567891011121314151617181920212223242526public class TestFileOutputStream &#123; public static void main(String args[]) &#123; int b = 0; FileInputStream in = null; FileOutputStream out = null; try &#123; in = new FileInputStream("D:\\Java\\MyEclipse 10\\Workspaces\\AnnotationTest\\src\\cn\\galc\\test\\MyMouseAdapter.java"); out = new FileOutputStream("D:/java/TestFileOutputStream1.java"); // 指明要写入数据的文件，如果指定的路径中不存在TestFileOutputStream1.java这样的文件，则系统会自动创建一个 while ((b = in.read()) != -1) &#123; out.write(b); // 调用write(int c)方法把读取到的字符全部写入到指定文件中去 &#125; in.close(); out.close(); &#125; catch (FileNotFoundException e) &#123; System.out.println("文件读取失败"); System.exit(-1);// 非正常退出 &#125; catch (IOException e1) &#123; System.out.println("文件复制失败！"); System.exit(-1); &#125; System.out .println("TestFileInputStream.java文件里面的内容已经成功复制到文件TestFileOutStream1.java里面"); &#125;&#125; FileInputStream 和 FileOutputStream 这两个流都是字节流，都是以一个字节为单位进行输入和输出的.所以对于占用2个字节存储空间的字符来说读取出来时就会显示成乱码 范例：使用FileWriter（字符流）向指定文件中写入数据有点问题,回头在补充 12 九. 处理流讲解9.1 第一种处理流——缓冲流(Buffering)缓冲流就要嵌套在相应的节点流上，对读写的数据提供了缓冲的功能，提高了读写的效率，同时增加了一些新的方法 J2SDK 提供了四种缓冲流，其常用的构造方法为 12345678BufferReader(Reader in)BufferReader(Reader in, int sz) // sz 为自定义缓存区的大小BufferReader(Writer out)BufferReader(Writer out, int sz)BufferReader(InputStream in)BufferReader(InputStream in, int size)BufferReader(OutputStream out)BufferReader(OutputStream out, int size) 注意 缓冲输入流支持其父类的Mark和reset方法 BufferedReader 提供流 readLine 方法用于读取一行字符串(以\r或\n分隔) BufferedWriter提供了newLine用于写入一个行分隔符 对于输出的缓冲流写出的数据会先在内存中缓存, 使用 flush 方法将会使内存中的数据立刻写出 ​ 带有缓冲区的，缓冲区(Buffer)就是内存里面的一小块区域，读写数据时都是先把数据放到这块缓冲区域里面，减少 io 对硬盘的访问次数，保护我们的硬盘。 ​ 可以把缓冲区想象成一个小桶，把要读写的数据想象成水，每次读取数据或者是写入数据之前，都是先把数据装到这个桶里面，装满了以后再做处理。这就是所谓的缓冲。先把数据放置到缓冲区上，等到缓冲区满了以后，再一次把缓冲区里面的数据写入到硬盘上或者读取出来，这样可以有效地减少对硬盘的访问次数，有利于保护我们的硬盘 缓冲流读取1234567891011121314151617181920212223242526272829303132public class TestBufferStream &#123; public static void main(String args[]) &#123; FileInputStream fis = null; try &#123; fis = new FileInputStream("D:/java/TestFileInputStream.java"); // 在FileInputStream节点流的外面套接一层处理流BufferedInputStream BufferedInputStream bis = new BufferedInputStream(fis); int c = 0; System.out.println((char) bis.read()); System.out.println((char) bis.read()); // 在第100个字符处做一个标记 bis.mark(100); for (int i = 0; i &lt;= 10 &amp;&amp; (c = bis.read()) != -1; i++) &#123; System.out.print((char) c); &#125; System.out.println(); // 重新回到原来标记的地方 bis.reset(); for (int i = 0; i &lt;= 10 &amp;&amp; (c = bis.read()) != -1; i++) &#123; System.out.print((char) c); &#125; bis.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (Exception e1) &#123; e1.printStackTrace(); &#125; &#125;&#125; 缓冲流写入12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TestBufferStream1 &#123; public static void main(String args[]) &#123; try &#123; /* * 往文件 dat2.txt 写入数据的时候,直接从节点流FilterWriter写入觉得不好写， * 因此在节点流外部包了一层处理流 BufferedWriter， * 这样写入数据时是先通过处理流把数据写入到缓冲区(Buffer)里面， * 再通过节点流写入到文件 dat2.txt */ BufferedWriter bw = new BufferedWriter(new FileWriter("G:\\dat.txt")); // 在节点流FileWriter的外面再套一层处理流BufferedWriter String s = null; for (int i = 0; i &lt; 5; i++) &#123; // Math.random() 将会生成一系列介于0～1之间的随机数。 // static String valueOf(double d) // 这个valueOf()方法的作用就是把一个double类型的数转换成字符串 s = String.valueOf(Math.random()); /* *读出来的文件的内容是装在了s这个字符串变量里面了， * 也就是存放在内存里面名字为s的那块区域里面， * 即读取到的文件内容是纯处在内存里面的 */ bw.write(s);// 把随机数字符串写入到指定文件中 bw.newLine();// 调用newLine()方法使得每写入一个随机数就换行显示 &#125; // 调用flush()方法清空缓冲区 bw.flush(); /* * 读取这个文件里面的数据是通过节点流直接读取数据，是一个字符一个字符的读取， * 这样读取的效率太慢了，因此在节点流 FileReader 外部包了一层处理流 BufferedReader, * 先要把读取的数据通过 BufferedReader 处理流存放到内存的缓冲区里面， * 然后再使用方法 flush() 把缓冲区里面的数据立刻写出来， * */ BufferedReader br = new BufferedReader(new FileReader("G:\\dat.txt")); // 在节点流FileReader的外面再套一层处理流BufferedReader while ((s = br.readLine()) != null) &#123; // 使用BufferedReader处理流里面提供String readLine()方法读取文件中的数据时是一行一行读取的 // 循环结束的条件就是使用readLine()方法读取数据返回的字符串为空值后则表示已经读取到文件的末尾了。 System.out.println(s); &#125; bw.close(); br.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; ​ 程序的输入指的是把从文件读取到的内容存储到为程序分配的内存区域里面去。 9.2 转换流 InputStreamReader和 OutputStreamWriter用于字节数据到字符数据之间的转换 InputStreamReader 需要和 InputStream “套接” OutStreamWriter 需要和 OutputStream “套接” InputStream isr = InputStreamReader(System.in, &quot;ISO8859_1&quot;) 转换流非常的有用，它可以把一个字节流转换成一个字符流 转换流有两种， InputStreamReader : 把 InputStream 转换成 Reader OutputStreamWriter : 把 OutputStream 转换成 Writer, 而且还可以写入字符串 12345678910111213141516171819202122232425262728293031public class TestTransform1 &#123; public static void main(String args[]) &#123; try &#123; // 使用了转换流之后就可以字符串的形式写入文件里面， // 提高了写入的速度，也减少了对硬盘的访问次数 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("G:\\char.txt")); // 把字符串写入到指定的文件中去 osw.write("My name is 小明."); // 使用getEncoding()方法取得当前系统的默认字符编码 System.out.println(osw.getEncoding()); osw.close(); // 这里如果不写true，那么前面的数据将会被后面写入的数据给替换掉， // 如果写了true,那么后面写出的数据就会跟在前面写入的数据后面不会替换掉前面写入的数据 // 在调用构造方法时指定了字符的编码 osw = new OutputStreamWriter(new FileOutputStream("G:\\char.txt", true), "ISO8859_1"); // 再次向指定的文件写入字符串，新写入的字符串加入到原来字符串的后面 osw.write("My name is 小明."); System.out.println(osw.getEncoding()); osw.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;// char.txt 里面的内容// My name is 小明.My name is ??. 范例2(接受键盘输入的数据)1234567891011121314151617181920212223242526public class TestTransform2 &#123; public static void main(String args[]) &#123; try &#123; // System.in这里的in是一个标准的输入流，用来接收从键盘输入的数据 InputStreamReader isr = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(isr); String s = null; // 使用readLine()方法把读取到的一行字符串保存到字符串变量s中去 s = br.readLine(); while (s != null) &#123; System.out.println(s.toUpperCase()); // 在循环体内继续接收从键盘的输入 s = br.readLine(); // 只要输入exit循环就结束，就会退出 if (s.equalsIgnoreCase("exit")) &#123; break; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 9.3 数据流9.4 打印流—Print9.5 对象流—Object十. IO流总结 参考博文​ java基础学习总结——流 ​ JAVA基础知识之IO——Java IO体系及常用类 ​ Java中IO流，输入输出流概述与总结https://blog.csdn.net/yczz/article/details/38761237]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML---input属性]]></title>
    <url>%2F2019%2F03%2F25%2FHTML---input%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[一. input 属性 name : 元素的名称；这个不需要多解释了，也就是name的取值代表为当前input元素起个名字 width : 当 input type=”image”时，通过width属性控制元素的宽度； height : 当 input type=”image”时，通过width属性控制元素的高度； type : 该属性是input标签里唯一的必须输入的属性，默认为type = “text” size : 元素的宽度；很多人都知道在HTML中，常见的宽度是用 width 表示的，而在input中 width 属性只使用与 type=&quot;image&quot; 时使用，input元素的宽度需要通过size属性来设定，size的值为 数字 step : 和max min类似，作用是提供一个可以上下点的按钮，比如当前数字是1，你设置了step = “5”，点一下上的按钮，就变成6了。 placeholder : 该属性不多说，大家应该都很熟悉，一般是用来提示用户输入的，当用户真的输入了文字之后，会被输入的文字覆盖。 readonly : 顾名思义，该属性会让表单空控件不可编辑。这里的不可编辑不是禁用，只是不能编辑文本而已，比如像单选框radio，复选框checkbox这种，本来就是不可编辑的，所以这个属性对它们来说毫无意义 disabled : 该属性会禁用一个表单元素。这里是禁用，完全禁用掉除了 &lt;output&gt; 之外的所有表单元素 maxlength : 该属性用于限制用户输入的最大字数限制。 autocomplete : 顾名思义，自动完成，用户输入一部分，后面的自动补全。需要浏览器保存用户输入的内容，以便下一次自动补全。 autofocus : 该属性指的是表示这个表单控件在页面载入的时候自动获得焦点。 二. input中的type属性&lt;input type=&quot;text&quot;&gt; : 如果一个input没有type属性，那么它会是默认type=”text”。允许输入文本&lt;input type=&quot;password&quot;&gt; : 用户输入的文字将会变成 * ,传给后台会是用户输入的文本。&lt;input type=&quot;checkbox&quot;&gt; : 复选框，默认是小方格，可以选择多个。&lt;input type=&quot;radio&quot;&gt; : 单选框，默认是小圆圈，只能选择一个。 &lt;input type=&quot;submit&quot;&gt;：提交按钮，当点击此按钮时，提交本表单的数据。&lt;input type=&quot;file&quot;&gt;：用于从本地硬盘中上传文件并提交 input的file类型的accept属性的值 值 描述 audio/* 接受所有的声音文件。 video/* 接受所有的视频文件。 image/* 接受所有的图像文件。 MIME_type 一个有效的 MIME 类型，不带参数 &lt;input type=&quot;hidden&quot;&gt; : 隐藏域在页面上不显示，用来存储与传递表单的值，当用户提交表单时，隐藏域的内容会一起提交给处理程序&lt;input type=&quot;image&quot;&gt; : 图像按钮, 该属性接受所有，将会像submit一样提交图片，如果想上传图片，照片，不妨使用这个属性。&lt;input type=&quot;reset&quot;&gt; ：重置按钮，点了这个按钮，表单的数据全部重置，也就是清空的意思&lt;input type=&quot;button&quot;&gt; ：表单按钮，和单纯的元素相比，没有&lt;button&gt;使用CSS方便，所以如果你不是想用这个按钮去重置（reset）或者提交（submit），并且为了和传统的表单风格相比配的话，建议你都使用而不是 以上的都是HTML5以前都有的属性，下面是新增的（跟键盘有关的都是要配合手机端使用才有效果）： ：该属性外观上和文本栏相似，用于指定一个电子邮箱地址。在web端没有什么差别，但是在手机端就不一样了，输入键盘会自动的变成有@ 数字 A-Z .等，与输入邮箱有关的字符，用户体验直线上升，有木有？ ：外观功能和 类似，用于指定一个web地址。在手机端上会自动转换成有类似于.com \等方便用户输入web地址的键盘。 ：用于指定输入的是电话号码。键盘就会变成输入电话号码的键盘。当然，也可以自己定义一些格式什么的，比如023-1235····之类的，需要与pattern属性连用。 ：用于指定输入的是数字，键盘为输入数字的键盘。 ：变成一个滑动条，不同的客户端显示出默认的样式是不一样的。用户可以左右滑动。webkit中可以使用CSS：input[type=range]{=webkit-appearance:slider-vertical}让滑动条竖起来。 ：提供一个搜索栏。如果有文本输入的话，很多浏览器会在最右边提供一个清空搜索栏的小叉，点了就清空该搜索栏。 ：在浏览器支持的情况下，提供一个拾色器，虽然功能没有PS里面的那么强大，不过感觉和window自带的图画功能里面的拾色器差不多。 ：顾名思义，日期选择器，可以用来选择年月日。 ：该属性提供两个栏，一个年月日，一个用于时分秒。时区被设置成了UTC。 ：和 几乎完全一样，只是不是UTC时间。 ：只包括了年，月的时间选择器。 ：只包括了时分秒的时间选择器，而且是24小时制。 ：该属性是输入多少年的多少周，你可以选择日期，但是返回的是XXXX年XX周。 参考博文​ input标签 各属性解释 ​ html5的input类型和所有属性详解]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用类---基本类型之间的转换]]></title>
    <url>%2F2019%2F03%2F25%2FJava%E5%B8%B8%E7%94%A8%E7%B1%BB---%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[一. 装箱与拆箱1.1 概述​ 虽然 Java 语言是典型的面向对象编程语言，但其中的八种基本数据类型并不支持面向对象编程，基本类型的数据不具备“对象”的特性——不携带属性、没有方法可调用。 沿用它们只是为了迎合人类根深蒂固的习惯，并的确能简单、有效地进行常规数据处理。 这种借助于非面向对象技术的做法有时也会带来不便，比如引用类型数据均继承了 Object 类的特性，要转换为 String 类型（经常有这种需要）时只要简单调用 Object 类中定义的 toString() 即可，而基本数据类型转换为 String 类型则要麻烦得多。为解决此类问题 ，Java为每种基本数据类型分别设计了对应的类，称之为包装类(Wrapper Classes) 1.2 基本数据类型及对应的包装类 基本数据类型 对应的包装类 byte Byte short Short int Integer long Long char Character float Float double Double boolean Boolean 每个包装类的对象可以封装一个相应的基本类型的数据，并提供了其它一些有用的方法。包装类对象一经创建，其内容（所封装的基本类型数据值）不可改变。 基本类型和对应的包装类可以相互装换 由基本类型向对应的包装类转换称为装箱，例如把 int 包装成 Integer 类的对象； 包装类向对应的基本类型转换称为拆箱，例如把 Integer 类的对象重新简化为 int 1.3 自动拆箱和装箱在进行基本数据类型和对应的包装类转换时，系统将自动进行，这将大大方便程序员的代码书写。 实例12345678910111213public class Demo &#123; public static void main www.120xh.cn (String[] args) &#123; int m = 500; Integer obj = m; // 自动装箱 int n = obj; // 自动拆箱 System.out.println("n = " + n); Integer obj1 = 500; System.out.println("obj 等价于 obj1？" + obj.equals(obj1)); &#125;&#125;// 运行结果// n = 500// obj 等价于 obj1？true 二. 基本类型之间的转换1. 将字符串转化为整型12int i = Integer.parseInt(String str);int i = Integer.valueOf(String str).intValue(); 注意 Integer.parseInt 和 Integer.valueOf 不同，前者生成的是整型，而后者是一个对象，所以要通过intValue()来获得对象的值； 字串转成 Double, Float, Long 的方法大同小异 2. 整型转化为字符串123String str = String.valueOf(int i);String str = Integer.toString(int i);String str = “” + i ; 注意 : Double, Float, Long 的方法大同小异. 3. Long 转化为 date SimpleDateFormat sf = new SimpleDateFormat(“yyyy/MM/dd HH:mm:ss”); //tieml,timef是long,前面转化过来的 Date date = new Date(timel - timef); String time = sf.parse(date); 1、float型转换为double型： float f1=100.00f; Float F1=new Float(f1); //F1.doubleValue()为Float类的返回double值型的方法 double d1=F1.doubleValue(); 2、double型转换为int型： double d1=100.00; Double D1=new Double(d1); int i1=D1.intValue(); 3、int型转换为double型： int i1=200; double d1=i1; (2). 字符串与其它数据类型的转换 4、字符串与其它类型间的转换： ⑴其它类型向字符串的转换 ①调用类的串转换方法:X.toString(); ②自动转换:X+“”; ③使用String的方法:String.valueOf(X); ⑵字符串作为值,向其它类型的转换 ①先转换成相应的封装器实例,再调用对应的方法转换成其它类型 例如，字符中“32.1”转换double型的值的格式为:new Float(“32.1”).doubleValue()。 也可以用:Double.valueOf(“32.1”).doubleValue() ②静态parseXXX方法 String s = “1”; byte b = Byte.parseByte( s ); short t = Short.parseShort( s ); int i = Integer.parseInt( s ); long l = Long.parseLong( s ); Float f = Float.parseFloat( s ); Double d = Double.parseDouble( s ); ③Character的getNumericValue(char ch)方法 返回指定的 Unicode 字符表示的 int 值。 参考博文​ java的常见类型转换 ​ JAVA数据类型转换大全]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java常用类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---XML详解(1)]]></title>
    <url>%2F2019%2F03%2F25%2FJavaWeb---XML%E8%AF%A6%E8%A7%A3(1)%2F</url>
    <content type="text"><![CDATA[一. XML 概念1.1 什么是 XML ?​ XML是指可扩展标记语言(eXtensible Markup Language)，它是一种标记语言，很类似HTML。它被设计的宗旨是传输数据，而非显示数据。 XML标签没有被预定义，需要用户自行定义标签。 XML技术是W3C组织(World Wide Web Consortium万维网联盟)发布的，目前遵循的是W3C组织于2000年发布的XML1.0规范。 1.2 XML技术用于解决什么问题？ XML语言出现的根本目的在于 描述树状图等关系的数据 XML是一种通用的数据交换格式 在XML语言中，它允许用户自定义标签。一个标签用于描述一段数据；一个标签可分为开始标签和结束标签，在起始标签之间，又可以使用其它标签描述其它数据，以此来实现数据关系的描述。 XML中的数据必须通过软件程序来解析执行或显示，如IE；这样的解析程序称之为Parser(解析器)。 实例123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;中国&gt; &lt;北京&gt; &lt;海淀&gt;&lt;/海淀&gt; &lt;丰台&gt;&lt;/丰台&gt; &lt;/北京&gt; &lt;山东&gt; &lt;济南&gt;&lt;/济南&gt; &lt;青岛&gt;&lt;/青岛&gt; &lt;/山东&gt; &lt;湖北&gt; &lt;武汉&gt;&lt;/武汉&gt; &lt;荆州&gt;&lt;/荆州&gt; &lt;/湖北&gt;&lt;/中国&gt; 1.3 XML常见应用：XML技术除用于保存有关系的数据之外，它还经常用作软件配置文件，以描述程序模块之间的关系。(如后面将要学习到的Struts、Spring和Hibernate都是基于XML作为配置文件的) 在一个软件系统中，通过 XML 配置文件可以提高系统的灵活性。即程序的行为是通过XML文件来配置的，而不是硬编码。 数据交换：不同语言之间用来交换数据 小型数据库：用来当数据库存储数据 二. XML 语法一个XML文件分为如下几部分内容： 文档声明 元素 属性 注释 CDATA区 、特殊字符 处理指令（PI:Processing Instruction） 1.1 文档声明​ 在编写XML文档时，需要先使用文档声明来声明XML文档。且必须出现在文档的第一行。并且必须指定 实例12345678&lt;!-- 最简单的语法: --&gt;&lt;?xml version=“1.0”?&gt;&lt;!-- 用encoding属性说明文档所使用的字符编码。保存在磁盘上的文件编码要与声明的编码一致 --&gt;&lt;?xml version=“1.0” encoding=“GB2312”?&gt;&lt;!-- 用standalone属性说明文档是否独立，即是否依赖其他文档, yes不用引入外部的文件，no需要引入。（不常用） --&gt;&lt;?xml version=“1.0” standalone=“yes”?&gt; 1.2 元素1) 标签XML元素指XML文件中出现的标签。 一个标签分为起始和结束标签(不能省略)。一个标签有如下几种书写形式： 包含标签主体：&lt;mytag&gt;some content&lt;/mytag&gt; 不含标签主体：&lt;mytag/&gt; 一个标签中可以嵌套若干子标签，但所有标签必须合理的嵌套，不允许有交叉嵌套。 &lt;mytag1&gt;&lt;mytag2&gt;&lt;/mytag1&gt;&lt;/mytag2&gt; WRONG！ 一个XML文档必须有且仅有一个根标签，其他标签都是这个根标签的子标签或孙标签。 2) 标签的空格、换行对于XML标签中出现的所有空格和换行，XML解析程序都会当作标签内容进行处理。例如：下面两段内容的意义是不一样的。 1234567&lt;!-- 第一个 --&gt;&lt;网址&gt;www.baidu.com&lt;/网址&gt;&lt;!-- 第二个 --&gt;&lt;网址&gt; www.baidu.com&lt;/网址&gt; 由于在XML中，空格和换行都作为原始内容被处理，所以，在编写XML文件时，使用换行和缩进等方式来让原文件中的内容清晰可读的“良好”书写习惯可能要被迫改变 3) 命名规范一个XML元素可以包含字母、数字以及其它一些可见字符，但必须遵守下面的一些规范： 区分大小写，例如，和是两个不同的标记。 不能以数字或“-” (中划线)开头。 不能以xml(或XML、或Xml 等)开头。 不能包含空格。 名称中间不能包含冒号（:）。 4) 属性一个元素可以有多个属性，每个属性都有它自己的名称和取值 例如: &lt;mytag name=“value” …/&gt; 注意 属性值一定要用引号(单引号或双引号)引起来。 属性名称的命名规范与元素的命名规范相同 元素中的属性是不允许重复的 在XML技术中，标签属性所代表的信息也可以被改成用子元素的形式来描述，例如： 123456&lt;mytag&gt; &lt;name&gt; &lt;firstName/&gt; &lt;lastName/&gt; &lt;/name&gt;&lt;/mytag&gt; 5) 注释XML中的注释语法为：&lt;!--这是注释--&gt; 注意： XML声明之前不能有注释 注释不能嵌套 6) 转义字符 特殊字符 代替字符 &amp; &amp;amp; &lt; &amp;lt; &gt; &amp;gt; “ &amp;quot; ‘ apos; 实体必须以符号”&amp;”开头，以符号”;”结尾 只有”&lt;” 字符和”&amp;”字符对于XML来说是严格禁止使用的。剩下的都是合法的，为了减少出错，使用实体是一个好习惯。 7) CDATA区CDATA是Character Data的缩写 作用 : 把标签当做普通文本内容； 语法 : &lt;![CDATA[内容]]&gt; 123&lt;![CDATA[ &lt;itcast&gt;www.itcast.cn&lt;/itcast&gt;]]&gt; &lt;itcast&gt;www.itcast.cn&lt;/itcast&gt; 被当做普通文本而不是标签 8) 处理指令处理指令，简称 PI (Processing Instruction)。 作用 : 用来指挥软件如何解析XML文档。 语法 : 必须以“&lt;?”作为开头，以“?&gt;”作为结尾。 常用处理指令： 常用处理指令： XML声明： &lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312”?&gt; xml-stylesheet指令： 作用：指示XML文档所使用的CSS样式XSL。 &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;some.css”?&gt; 注：对中文命名的标签元素不起作用 XML语法规则总结 所有 XML 元素都须有关闭标签 XML 标签对大小写敏感 XML 必须正确地嵌套顺序 XML 文档必须有根元素(只有一个) XML 的属性值须加引号 特殊字符必须转义 — CDATA XML 中的空格、回车换行会解析时被保留 三. XML 约束略 参考博文​ JavaWeb之XML详解]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---XML详解(1)]]></title>
    <url>%2F2019%2F03%2F25%2FJavaWeb---XML%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一. XML 概念1.1 什么是 XML ?​ XML是指可扩展标记语言(eXtensible Markup Language)，它是一种标记语言，很类似HTML。它被设计的宗旨是传输数据，而非显示数据。 XML标签没有被预定义，需要用户自行定义标签。 XML技术是W3C组织(World Wide Web Consortium万维网联盟)发布的，目前遵循的是W3C组织于2000年发布的XML1.0规范。 1.2 XML技术用于解决什么问题？ XML语言出现的根本目的在于 描述树状图等关系的数据 XML是一种通用的数据交换格式 在XML语言中，它允许用户自定义标签。一个标签用于描述一段数据；一个标签可分为开始标签和结束标签，在起始标签之间，又可以使用其它标签描述其它数据，以此来实现数据关系的描述。 XML中的数据必须通过软件程序来解析执行或显示，如IE；这样的解析程序称之为Parser(解析器)。 实例123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;中国&gt; &lt;北京&gt; &lt;海淀&gt;&lt;/海淀&gt; &lt;丰台&gt;&lt;/丰台&gt; &lt;/北京&gt; &lt;山东&gt; &lt;济南&gt;&lt;/济南&gt; &lt;青岛&gt;&lt;/青岛&gt; &lt;/山东&gt; &lt;湖北&gt; &lt;武汉&gt;&lt;/武汉&gt; &lt;荆州&gt;&lt;/荆州&gt; &lt;/湖北&gt;&lt;/中国&gt; 1.3 XML常见应用：XML技术除用于保存有关系的数据之外，它还经常用作软件配置文件，以描述程序模块之间的关系。(如后面将要学习到的Struts、Spring和Hibernate都是基于XML作为配置文件的) 在一个软件系统中，通过 XML 配置文件可以提高系统的灵活性。即程序的行为是通过XML文件来配置的，而不是硬编码。 数据交换：不同语言之间用来交换数据 小型数据库：用来当数据库存储数据 二. XML 语法一个XML文件分为如下几部分内容： 文档声明 元素 属性 注释 CDATA区 、特殊字符 处理指令（PI:Processing Instruction） 1.1 文档声明​ 在编写XML文档时，需要先使用文档声明来声明XML文档。且必须出现在文档的第一行。并且必须指定 实例12345678&lt;!-- 最简单的语法: --&gt;&lt;?xml version=“1.0”?&gt;&lt;!-- 用encoding属性说明文档所使用的字符编码。保存在磁盘上的文件编码要与声明的编码一致 --&gt;&lt;?xml version=“1.0” encoding=“GB2312”?&gt;&lt;!-- 用standalone属性说明文档是否独立，即是否依赖其他文档, yes不用引入外部的文件，no需要引入。（不常用） --&gt;&lt;?xml version=“1.0” standalone=“yes”?&gt; 1.2 元素1) 标签XML元素指XML文件中出现的标签。 一个标签分为起始和结束标签(不能省略)。一个标签有如下几种书写形式： 包含标签主体：&lt;mytag&gt;some content&lt;/mytag&gt; 不含标签主体：&lt;mytag/&gt; 一个标签中可以嵌套若干子标签，但所有标签必须合理的嵌套，不允许有交叉嵌套。 &lt;mytag1&gt;&lt;mytag2&gt;&lt;/mytag1&gt;&lt;/mytag2&gt; WRONG！ 一个XML文档必须有且仅有一个根标签，其他标签都是这个根标签的子标签或孙标签。 2) 标签的空格、换行对于XML标签中出现的所有空格和换行，XML解析程序都会当作标签内容进行处理。例如：下面两段内容的意义是不一样的。 1234567&lt;!-- 第一个 --&gt;&lt;网址&gt;www.baidu.com&lt;/网址&gt;&lt;!-- 第二个 --&gt;&lt;网址&gt; www.baidu.com&lt;/网址&gt; 由于在XML中，空格和换行都作为原始内容被处理，所以，在编写XML文件时，使用换行和缩进等方式来让原文件中的内容清晰可读的“良好”书写习惯可能要被迫改变 3) 命名规范一个XML元素可以包含字母、数字以及其它一些可见字符，但必须遵守下面的一些规范： 区分大小写，例如，和是两个不同的标记。 不能以数字或“-” (中划线)开头。 不能以xml(或XML、或Xml 等)开头。 不能包含空格。 名称中间不能包含冒号（:）。 4) 属性一个元素可以有多个属性，每个属性都有它自己的名称和取值 例如: &lt;mytag name=“value” …/&gt; 注意 属性值一定要用引号(单引号或双引号)引起来。 属性名称的命名规范与元素的命名规范相同 元素中的属性是不允许重复的 在XML技术中，标签属性所代表的信息也可以被改成用子元素的形式来描述，例如： 123456&lt;mytag&gt; &lt;name&gt; &lt;firstName/&gt; &lt;lastName/&gt; &lt;/name&gt;&lt;/mytag&gt; 5) 注释XML中的注释语法为：&lt;!--这是注释--&gt; 注意： XML声明之前不能有注释 注释不能嵌套 6) 转义字符 特殊字符 代替字符 &amp; &amp;amp; &lt; &amp;lt; &gt; &amp;gt; “ &amp;quot; ‘ apos; 实体必须以符号”&amp;”开头，以符号”;”结尾 只有”&lt;” 字符和”&amp;”字符对于XML来说是严格禁止使用的。剩下的都是合法的，为了减少出错，使用实体是一个好习惯。 7) CDATA区CDATA是Character Data的缩写 作用 : 把标签当做普通文本内容； 语法 : &lt;![CDATA[内容]]&gt; 123&lt;![CDATA[ &lt;itcast&gt;www.itcast.cn&lt;/itcast&gt;]]&gt; &lt;itcast&gt;www.itcast.cn&lt;/itcast&gt; 被当做普通文本而不是标签 8) 处理指令处理指令，简称 PI (Processing Instruction)。 作用 : 用来指挥软件如何解析XML文档。 语法 : 必须以“&lt;?”作为开头，以“?&gt;”作为结尾。 常用处理指令： 常用处理指令： XML声明： &lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312”?&gt; xml-stylesheet指令： 作用：指示XML文档所使用的CSS样式XSL。 &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;some.css”?&gt; 注：对中文命名的标签元素不起作用 XML语法规则总结 所有 XML 元素都须有关闭标签 XML 标签对大小写敏感 XML 必须正确地嵌套顺序 XML 文档必须有根元素(只有一个) XML 的属性值须加引号 特殊字符必须转义 — CDATA XML 中的空格、回车换行会解析时被保留 三. XML 约束略 参考博文​ JavaWeb之XML详解]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---XML详解(2)]]></title>
    <url>%2F2019%2F03%2F25%2FJavaWeb---XML%E8%AF%A6%E8%A7%A3(2)%2F</url>
    <content type="text"><![CDATA[一. web.xml 的加载过程​ 当启动一个WEB项目时，容器包括 (JBoss、Tomcat等) 首先会读取项目web.xml配置文件里的配置，当这一步骤没有出错并且完成之后，项目才能正常地被启动起来 启动WEB项目的时候，容器首先会去它的配置文件web.xml读取两个节点 : &lt;listener&gt;&lt;/listener&gt; 和 &lt;context-param&gt;&lt;/context-param&gt; 紧接着，容器创建一个ServletContext（Application），这个WEB项目所有部分都将共享这个上下文。 容器以 &lt;context-param&gt;&lt;/context-param&gt; 的 name 作为键，value 作为值，将其转化为键值对，存入ServletContext 容器创建 &lt;listener&gt;&lt;/listener&gt; 中的类实例，根据配置的class类路径来创建监听，在监听中会有contextInitialized(ServletContextEvent args)初始化方法，启动Web应用时，系统调用Listener的该方法，在这个方法中获得：ServletContext application = ServletContextEvent.getServletContext(); context-param的值 = application.getInitParameter(“context-param的键”); 得到这个context-param的值之后，你就可以做一些操作了。 举例：你可能想在项目启动之前就打开数据库，那么这里就可以在中设置数据库的连接方式（驱动、url、user、password），在监听类中初始化数据库的连接。这个监听是自己写的一个类，除了初始化方法，它还有销毁方法，用于关闭应用前释放资源。比如:说数据库连接的关闭，此时，调用contextDestroyed(ServletContextEvent args)，关闭Web应用时，系统调用Listener的该方法。 接着，容器会读取，根据指定的类路径来实例化过滤器。 以上都是在WEB项目还没有完全启动起来的时候就已经完成了的工作。如果系统中有Servlet，则Servlet是在第一次发起请求的时候被实例化的，而且一般不会被容器销毁，它可以服务于多个用户的请求。所以，Servlet的初始化都要比上面提到的那几个要迟。 总的来说，web.xml的加载顺序是:-&gt;-&gt;-&gt;。其中，如果web.xml中出现了相同的元素，则按照在配置文件中出现的先后顺序来加载。 对于某类元素而言，与它们出现的顺序是有关的。以为例，web.xml中当然可以定义多个，与相关的一个元素是，注意，对于拥有相同的和元素而言，必须出现在之后，否则当解析到时，它所对应的还未定义。web容器启动初始化每个时，按照出现的顺序来初始化的，当请求资源匹配多个时，拦截资源是按照元素出现的顺序来依次调用doFilter()方法的。同类似，此处不再赘述。 二. web.xml标签详解2.1 XML文档有效性检查1&lt;!DOCTYPE web-app PUBLIC"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN""http://java.sun.com/dtd/web-app_2_3.dtd" &gt; 这段代码指定文件类型定义（DTD），可以通过它检查XML文档的有效性。下面显示的&lt;!DOCTYPE&gt;元素有几个特性，这些特性告诉我们关于DTD的信息： web-app定义该文档（部署描述符，不是DTD文件）的根元素 PUBLIC意味着DTD文件可以被公开使用 -//Sun Microsystems, Inc.//DTD Web Application 2.3//EN”意味着DTD由Sun Microsystems, Inc.维护。该信息也表示它描述的文档类型是DTD Web Application 2.3，而且DTD是用英文书写的。 URL “http://java.sun.com/dtd/web-app_2_3.dtd” 表示D文件的位置。 2.2 &lt;web-app&gt;&lt;/web-app&gt;部署描述符的根元素是 &lt;web-app&gt; ，DTD文件规定 &lt;web-app&gt; 元素的子元素的语法如下： 1&lt;!ELEMENT web-app (icon?, display-name?, description?,distributable?, context-param*, filter*, filter-mapping*,listener*, servlet*, servlet-mapping*, session-config?,mime-mapping*, welcome-file-list?,error-page*, taglib*, resource-env-ref*, resource-ref*,security-constraint*, login-config?, security-role*,env-entry*,ejb-ref*, ejb-local-ref*)&gt; 正如您所看到的，这个元素含有23个子元素，而且子元素都是可选的。问号（?）表示子元素是可选的，而且只能出现一次。星号（*）表示子元素可在部署描述符中出现零次或多次。有些子元素还可以有它们自己的子元素。web.xml文件中元素声明的是下面每个子元素的声明。下面讲述部署描述符中可能包含的所有子元素。 注意：在Servlet 2.3中，子元素必须按照DTD文件语法描述中指定的顺序出现。比如：如果部署描述符中的元素有和两个子元素，则子元素必须出现在子元素之前。在Servlet2.4中，顺序并不重要。 3. &lt;display-name&gt;&lt;/display-name&gt;&lt;display-name&gt;test-hwp-web-application&lt;/display-name&gt; 定义了web应用的名称，可以在 &lt;http://localhost:8080/manager/html&gt; 中显示 参考博文​ Web.xml详解]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[街舞---popping]]></title>
    <url>%2F2019%2F03%2F24%2F%E8%A1%97%E8%88%9E---popping%2F</url>
    <content type="text"><![CDATA[一. popping由来​ 比较为大众所知的是一个名叫 Boogaloo Sam 的人，在看到电视节目 Soul Train 上 locker 的表演后激发出来的，然后他在1977年建立了一个舞团, 叫做 The Electric boogaloos(EB舞团) 1.1 EB舞团的成员 Popin Pete Robot Dane Boogaloo Sam Puppet Boozer Creeping Sidney Scarecrow Scalley Skeeter Rabbit(中期加入) Sugar Pop(后期加入) Mr.Wigles(后期加入) 有趣的是即使在同一个舞团内,每个人对于popping的想法却都有差异 Boogaloo Sampopping 只是他的Boogaloo style里头14种style的其中一种，然后每一种都是由他自己受到启发，想出来的 14 种Style 1. popping 8. Master Flex 2. Secrecrow 9. Creeping 3. Puppet 10. Toy Man 4. Ticking 11. Backslide 5. Tidal Wave 12. Moon walk 6. Old Man 13. Romeo Twist 7. Twist O/ Neck O Flex 14. Egyptian Twisst Petepopping就是把肌肉瞬间收缩(pop), 对应到音乐之中，对他来说算是一种技术.就是一种 style , popping 就是dance + pop 作者观点同意大多数其他团员的观点,毕竟像 tuttin 或者是 moon walk 等舞步早在 Sam 之前就已经存在，更重要的是在之后的 popping 发展中，已经不再只是14种舞步了(Tickin Deck/Twist O Flex Don/ Tickin Will) 1.2 popping命名的由来Sam在跳舞的时候每震(摇动)一次肌肉肌肉就说一次pop，所以popping这个名称就是这样来的(没有争议) 1.3 G Style舞者: greenteck(加拿大)、 babybang和spazm（挪威 ）、cocopops（很像是瑞典）、 poppin ten 、 gstyle australia, :john gt kite madoka G Style:这个派别的出现，它并不是一种popping中的舞风，基本上它只是一个类似组织的派别，唯一比较能够确定的是G Style的舞者，喜欢用大量的waving 和 animation 等等比较细微控制的舞步，但也不是用animation和waving比较多的，就是G style 舞者，Slick dogg 算是创始人，而且他早在声称popping早在Sam之前就已经有了(认为Sam跳的不是popping),不能算是Boogaloo Sam 所发明的. 这也变成著名的 G Style 跟 Boogaloo style决赛斗争，其实原本他们是关系不错的，只是不知道为什么就突然吵起来 二. popping的种类现在来讲讲发展到近时所拥有的舞步种类 2.1 pop/hit(震动)1) Fresno​ 重心右移，右手平抬强震,重心左移,左手平抬强震，这是我们常常看见的 popping 基础 2) Sac Walk(空军踏步)​ 左脚上前半步, 右脚后退半步，二步于一个拍子间同时完成, 3) lift​ 类似爬楼梯的动作，左右手呈90度一朝上朝下，然后重复 2.2 wave 电流1) snake​ 用胸部做转动 roll 的动作，若双手放置于前方，像蛇一般 2) king snake (snake的强化版)3)October(章鱼)​ 从手开始带到全身的电流 2.3 Slide 滑步1) 向后滑2) 向侧边滑3) 原地滑4) 转圈圈的滑行方式(加上膝盖的滑行变成膝盖的滑步)2.4 Boogaloo style基本上是以身体各个点为轴心作圆的风格，Roll在其中是很重要的元素 1) boogaloo​ 下半身左右脚互换，上身不动，身体有牵引的感觉 2) work out​ 大步朝前迈出,记得 的是画圆的轨迹，然后身体在跟着扭过去 3) Boogaloo Walk Out跟 work out 差不多, 多了身体的 wave 和连带动作 4) Filmore做交通指挥一般的动作, 5) Neck-O-Flex​ 头转向一侧,固定,转动身体，给人感觉脑袋没动，身体动 6) Twist-O-Flex头,身体,脚,分开转动, 7) master-O-Flex​ 和 Twist-O-Flex 差不多，不过脚步往后跨了一个步,类似work out 的步法 8) Flex Walk​ 手成架构姿势,左右横摆,往前走 9) Botom First​ 手脚抬成90度，类似lift, 然后脚后转, 有点像是被人从肚子往后推了一下 10) Botom Boogaloo First​ 跟 bottom first 差不多，但是往后跨了一步,类似walk out 的步法 11) Egyption Twist 埃及步​ 双脚并拢，微屈膝盖，45度侧移脚掌,反复，头一定要看反方向， 12) Romeo Twist​ 造成内八字外八字状，侧向移动，又名 toe&amp;heel walk, 脚尖脚跟移动的步伐 13) crazy legs(疯狂的腿)​ 脚步的左右roll，让人眼花缭乱, 2.5 style 风格1) robot机器人2)Toy Man 玩具人3) Puppet 木偶4) Scarecrow 稻草人5) Spider Man 蜘蛛人​ 手像蜘蛛一样在身上各个部位爬行的动作 6) KingTut/Tutting 埃及手​ 手腕, 手肘, 手背, 各成90度 7) Strutting 阔步​ 一格一格的动作，头部要上下左右分格看， 8) Strobing 快门​ 像照相时不断闪光所出现的间断的动作 9) Ticking 连震10) Strobing + pop11) AirPose 滞空​ 加上感觉像在月球上一样，动作被吸的一张一合 12) Shadow Box​ Skeeter Rabbit 的独创分割，这个用语言很难表达 13) Senthapeed​ 一整套的连续动作，身体每一个部分都像是被手带过去的 2.6 Body Contral 身体控制1) animation(动画)​ 像早期的电影一般, 帧数不足24帧时快速分格动作 2) Slow Move 慢动作​ 做之前先加速，然后突然变慢 3) Isolation​ 身体各个部位关节肢体能够独立运动，而不会牵连其他部分 三. 著名Popper很多舞者钻研单一舞步的Popper练到极致会变得相当不像人类所能做的动作 3.1 EB元老3.2 杨文昊属于偏向使用大量 waving 和 animation 的舞者 3.3 田一德基本上是以 Boogaloo style 为主 3.4 Nonstop本命Marquese scott, 把waving,slow motion, animation, tutting 做到极致. 加上他那瘦弱的身形，竟然能做出一些匪夷所思的失去平衡感的动作，他的特色是跳 dubstep 这种音乐，而且会使用快速地连震 dubstep 在 popping中 算是一个很爱被使用的音乐类型, 3.5 Popping John常与Nonstop上镜头的舞者,比较常用的 waving 还有 robot 去表现， 3.6 Greenteck使用了许多 waving 还有 crazy legs在他的舞蹈中 3.7 Salah虽然他是一位Popper，但是他会很多popping之外的舞风，拥有很多独门绝活，甚至在battle的时候会使出魔术把戏，而他又有强烈的表演风格，跳舞的时候即使在白头也像是在演戏，会有很多的表情动作，所以有人会认为他是actor,不是dancer , 但他也是 battle 上的常胜军 3.8 Jaja最著名的就是它在Robot还有Puppet的舞步，超强的控制力搭配时不时的加入krump的元素.也在&lt;舞力全开&gt;中担任女机器人的角色 3.9 Madd Chadd与其说他是proper不如说它已经是完整的机器人 3.10 Dytto一位有奇怪技能的nvpopper, 经常使用她的头发到舞步当中，再搭配上特有的tutting, 3.11 Fik Shun特色除了waving之外,还会再加上一些非 popping 的动作，配上他很喜欢的脚尖站立，搭配他的幽默表情是他的一大卖点. 他跟 Les twins 一样，是受火影忍者荼毒很深的舞者，甚至跳舞的时候还使用螺旋丸当舞步 四. 著名的舞团4.1 Elektro Botz (三人团体)4.2 Robot boys (曾与 popping John)都是很喜欢用很多机械音效的音乐去呈现他们的robot style的舞团，他们在对音乐都可以对得到很细微的程度 4.3 Roreotics很有趣的舞团，曾在ABDC上获得冠军，也由于ABDC给了许多考验，使他们晋升为带有很多其他风格的popping舞团，他们的 animation 和 Strobing 加上他们常使用的速度差是他们的特色，搭配一定要带个墨镜跟不知道为什么让你好像很有特色的发型，是他们舞团的卖点 4.4 World Fame Us 虽然是较新的韩国舞团，但成员全部都是battle 的常胜军, popping J, Boogaloo Kin, hozin, hoan, Jaygee 个人风格跟战力都是无可挑剔的, 看他们的排舞有种很纯正的popping的感觉，没有混什么其他的舞风在里头，几乎是是纯popping，卖点大概是每个人的粉丝都很多吧，毕竟每个都是 battle 届赫赫有名的人物 参考视频​ 【这！就是街舞】特輯六Popping震爆眼珠的田一德與視覺震撼的楊文昊]]></content>
      <categories>
        <category>街舞</category>
      </categories>
      <tags>
        <tag>街舞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---泛型]]></title>
    <url>%2F2019%2F03%2F22%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一. 概述泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。 什么是泛型？为什么要使用泛型？ 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 一个被举了无数次的例子12345678List arrayList = new ArrayList();arrayList.add("aaaa");arrayList.add(100);for(int i = 0; i&lt; arrayList.size();i++)&#123; String item = (String)arrayList.get(i); Log.d("泛型测试","item = " + item);&#125; 毫无疑问，程序的运行结果会以崩溃结束： 1java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String ArrayList 可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。 我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。 123List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();...// arrayList.add(100); 在编译阶段，编译器就会报错 Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 二. 泛型的使用泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法 2.1 泛型类范例123456789101112131415public class TestGeneric &#123; public static void main(String[] args) &#123; ArrayList&lt;Hero&gt; heros = new ArrayList&lt;Hero&gt;(); // 简写, 后面可以只用 &lt;&gt; ArrayList&lt;Hero&gt; heros2 = new ArrayList&lt;&gt;(); // 只有作为Hero的子类可以放进去 heros.add(new APHero()); heros.add(new ADHero()); // 和 Hero无关的类型Item还是放不进去 // heros.add(new Item()); &#125;&#125; 三. 通配符3.1 ? extendsArrayList heroList&lt;? extends Hero&gt;表示这是一个Hero泛型或者其子类泛型 heroList 的泛型可能是Hero heroList 的泛型可能是APHero heroList 的泛型可能是ADHero 所以 可以确凿的是，从heroList取出来的对象，一定是可以转型成Hero的 但是，不能往里面放东西，因为 放APHero就不满足 放ADHero又不满足 123456789101112131415public class TestGeneric &#123; public static void main(String[] args) &#123; ArrayList&lt;APHero&gt; apHeroList = new ArrayList&lt;APHero&gt;(); apHeroList.add(new APHero()); ArrayList&lt;? extends Hero&gt; heroList = apHeroList; //可以确凿的是，从heroList取出来的对象，一定是可以转型成Hero的 Hero h= heroList.get(0); // 但是，不能往里面放东西 heroList.add(new ADHero()); // 编译错误，因为heroList的泛型 有可能是APHero &#125; &#125; 3.2 ? superArrayList heroList&lt;? super Hero&gt; 表示这是一个Hero泛型或者其父类泛型 heroList的泛型可能是Hero heroList的泛型可能是Object 可以往里面插入Hero以及Hero的子类但是取出来有风险，因为不确定取出来是Hero还是Object 123456789101112131415public class TestGeneric &#123; public static void main(String[] args) &#123; ArrayList&lt;? super Hero&gt; heroList = new ArrayList&lt;Object&gt;(); // 所以就可以插入Hero heroList.add(new Hero()); // 也可以插入Hero的子类 heroList.add(new APHero()); heroList.add(new ADHero()); // 但是，不能从里面取数据出来,因为其泛型可能是Object,而Object是强转Hero会失败 Hero h= heroList.get(0); &#125;&#125; 3.3 ?泛型通配符? 代表任意泛型,这个容器什么泛型都有可能 所以只能以Object的形式取出来 并且不能往里面放对象，因为不知道到底是一个什么泛型的容器 1234567891011121314151617public class TestGeneric &#123; public static void main(String[] args) &#123; ArrayList&lt;APHero&gt; apHeroList = new ArrayList&lt;APHero&gt;(); // ?泛型通配符，表示任意泛型 ArrayList&lt;?&gt; generalList = apHeroList; // ?的缺陷1： 既然?代表任意泛型，那么换句话说，你就不知道这个容器里面是什么类型 // 所以只能以Object的形式取出来 Object o = generalList.get(0); // ?的缺陷2： 既然?代表任意泛型，那么既有可能是Hero,也有可能是Item // 所以，放哪种对象进去，都有风险，结果就什么什么类型的对象，都不能放进去 generalList.add(new Item()); //编译错误 因为?代表任意泛型，很有可能不是Item generalList.add(new Hero()); //编译错误 因为?代表任意泛型，很有可能不是Hero &#125;&#125; 3.4 总结 如果希望只取出，不插入，就使用? extends Hero 如果希望只插入，不取出，就使用? super Hero 如果希望，又能插入，又能取出，就不要用通配符？ 参考博文​ java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一 ​ 泛型]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---集合框架]]></title>
    <url>%2F2019%2F03%2F22%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[一. 集合框架图 ​ 所有集合类都位于java.util包下。Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。 Collection : 接口，是高度抽象出来的集合(一组允许重复的对象)，它包含了集合的基本操作和属性。Collection包含了List和Set两大分支 List : 接口, 继承 Collection, 有序集合, 允许重复，每一个元素都有它的索引, 访问集合中的元素可以根据元素的索引来访问。 Set : 接口, 继承 Collection, 无序集合，集合中的元素不可以重复, 访问集合中的元素只能根据元素本身来访问 Map : 接口是键－值对象(Key-value对形式) , 访问时只能根据每项元素的key来访问其value，与Collection接口没有什么关系。 Set、List和Map可以看做集合的三大类 Iterator。它是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。ListIterator是专门为遍历List而存在的。 Enumeration，它是JDK 1.0引入的抽象类。作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。在上面的框图中，Enumeration只能在Hashtable, Vector, Stack中使用。 Arrays和Collections。它们是操作数组、集合的两个工具类。 二. Collection接口​ Collection接口是处理对象集合的 根接口 ，其中定义了很多对元素进行操作的方法。Collection接口有两个主要的子接口List和Set 注意Map不是Collection的子接口，这个要牢记。 常用方法 add() : 添加一个元素到集合中 addAll() : 将指定集合中的所有元素添加到集合中 contains() : 检测集合中是否包含指定的元素 toArray() : 返回一个表示集合的数组。 另外，Collection中有一个iterator()函数，它的作用是返回一个Iterator接口。通常，我们通过Iterator迭代器来遍历集合。ListIterator是List接口所特有的，在List接口中，通过ListIterator()返回一个ListIterator对象。 2.1 List 接口​ List接口继承于Collection接口，它可以定义一个允许重复的有序集合。因为List中的元素是有序的，所以我们可以通过使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。 ​ List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。 ArrayList​ ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。 ​ size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）. ArrayList擅长于随机访问。同时ArrayList是非同步的。 2. Set接口​ Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。Set接口有三个具体实现类，分别是散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet。 ​ Set是一种不包含重复的元素的Collection，无序，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。需要注意的是:虽然Set中元素没有顺序，但是元素在set中的位置是由该元素的HashCode决定的，其具体位置其实是固定的。 ​ 此外需要说明一点，在set接口中的不重复是有特殊要求的。​ 举一个例子:对象A和对象B，本来是不同的两个对象，正常情况下它们是能够放入到Set里面的，但是如果对象A和B的都重写了hashcode和equals方法，并且重写后的hashcode和equals方法是相同的话。那么A和B是不能同时放入到Set集合中去的，也就是Set集合中的去重和hashcode与equals方法直接相关。 三. Map接口​ Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。 ​ 遍历Map 1.HashMap ​ 以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。 参考博文​ Java 集合框架 ​ java集合框架综述 ​]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---Servlet跳转]]></title>
    <url>%2F2019%2F03%2F21%2FJavaWeb---Servlet%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[一. Servlet跳转1.1 redirect 方式 (客户端跳转)1response.sendRedirect("/index.jsp"); 页面的路径是相对路径 , sendRedirect可以将页面跳转到任何页面，不一定局限于本web应用中 跳转后浏览器地址栏变化 称之为请求重定向/302 1.2 forward方式 (服务器端跳转)1234RequestDispatcher dispatcher = request.getRequestDispatcher("/index.jsp"); dispatcher.forward(request, response); // 简写request.getRequestDispatcher("/index.jsp").forward(request, response); 页面的路径是相对路径 , forward方式只能跳转到本web应用中的页面上 跳转后浏览器地址栏不会变化 请求转发/307称为 参考博文​ java学习心得——servlet的两种跳转方式]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---final关键字]]></title>
    <url>%2F2019%2F03%2F21%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---final%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1. 修饰类 当用final修饰一个类时，表明这个类不能被继承。 如果一个类你永远不会让他被继承，就可以用final进行修饰。 final类中的成员变量可以根据需要设为final，但是要注意 final类中的所有成员方法都会被隐式地指定为final方法 在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类 范例123456final class People &#123; // 默认为 final 方法 public People() &#123; &#125;&#125; 2. 修饰方法使用 final 方法的原因有两个 把方法锁定，以防任何继承类修改它的含义； 效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。 如果只有在想 明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。即父类的final方法是不能被子类所覆盖的，也就是说子类是不能够存在和父类一模一样的方法 12345678910111213141516171819202122public class B extends A &#123; public static void main(String[] args) &#123; &#125; public void getName() &#123; &#125;&#125;class A &#123; /** * 因为private修饰，子类中不能继承到此方法，因此，子类中的getName方法是重新定义的、 * 属于子类本身的方法，编译正常 */ private final void getName() &#123; &#125; /* 因为pblic修饰，子类可以继承到此方法，导致重写了父类的final方法，编译出错 public final void getName() &#123; &#125; */&#125; 3. 修饰变量final成员变量表示常量，只能被赋值一次，赋值后值不再改变。 当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化； 如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。 初始化方式final修饰一个成员变量（属性），必须要显示初始化。这里有两种初始化方式 在变量声明的时候初始化； 1在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。 当函数的参数类型声明为final时，说明该参数是只读型的。即你可以读取使用该参数，但是无法改变该参数的值。 12345678class Man &#123; private final int i = 0; public Man() &#123; i = 1; // 报错 final Object obj = new Object(); obj = new Object(); // 报错 &#125;&#125; 二、深入理解final关键字 在了解了final关键字的基本用法之后，这一节我们来看一下final关键字容易混淆的地方。 类的final变量和普通变量有什么区别？ 2、被final修饰的引用变量指向的对象内容可变吗？123456789101112131415public class TestFinal &#123; public static void main(String[] args) &#123; final MyClass myClass = new MyClass(); for(int i=0; i&lt;4; i++) &#123; myClass.i++; &#125; System.out.println(myClass.i); &#125; &#125;class MyClass &#123; public int i = 0; &#125; // 打印结果: 4 这段代码可以顺利编译通过并且有输出结果，输出结果为4。这说明引用变量被final修饰之后，虽然不能再指向其他对象，但是它指向的对象的内容是可变的 参考博文​ 浅谈Java中的final关键字]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---异常处理]]></title>
    <url>%2F2019%2F03%2F21%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[一. 异常的概念​ 异常指的是运行期出现的错误，也就是当程序开始执行以后执行期出现的错误。出现错误时观察错误的名字和行号最为重要。 Java 异常是 Java 提供的用于处理程序中错误的一种机制 所谓错误是指在程序运行的过程中发生的一些异常事件(eg: 除0溢出, 数组下标越界, 所要读取的文件不存在) 设计良好的程序应该在异常发生时提供处理这些错误的方法,是的程序不会因为异常的发生而阻断或产生不可预见的结果 Java 程序的执行过程中,如出现异常事件,可以生成一个异常类对象。该异常类对象封装了异常事件的信息并将提交给Java运行时系统(Java 运行时系统默认处理是直接把这个异常对象里面包装的信息打印出来)。这个过程称为抛出(throw)异常 当 Java 运行时系统接收到的异常对象时, 会寻找能处理这一异常的代码，并将当前异常对象交给其处理,这一过程称为捕获(catch)异常 二. 异常的分类 Error : 称为错误，由Java虚拟机生成并抛出，包括动态链接失效，虚拟机错误的，程序对其不作处理 Exception : 所有异常类的父类，其子类对应了各种各样可能出现的异常事件，一般需要用户显示的声明或捕获 Runtime Exception : 一类特殊的异常, 如被0除，数组下标超范围等，其产生比较频繁处理麻烦，如果显示的声明或捕获会对程序可读性和运行效率影响很大，因此由系统自动检测并将他们交给缺省的异常处理程序，用户可不必对其处理 三、异常的捕获和处理Java异常处理的五个关键字：try、catch、finally、throw、throws 3.1 try-catch-finally语句 try{...}：负责捕获异常，一旦try中发现异常，程序的控制权将被移交给catch块中的异常处理程序,如果没有异常产生,所有的catch代码段都被略过不执行。 【try语句块不可以独立存在，必须与 catch 或者 finally 块同存】 catch{...} ：对异常进行处理,比如发出警告：提示、检查配置、网络连接，记录错误等。执行完catch块之后程序跳出catch块，继续执行后面的代码。 【编写catch块的注意事项：多个catch块处理的异常类，要按照先catch子类后catch父类的处理方式，因为会”就近处理”异常(由上自下)】 finally{...} : 最终执行的代码，用于关闭和释放资源。无论是否抛出异常,finally所指定的代码都要被执行. 【通常在finally语句中可以惊醒资源的清除工作,如:关闭打开的文件,删除临时文件】 语法格式12345678910111213try&#123; //一些会抛出的异常&#125;catch（Exception e）&#123; //第一个catch //处理该异常的代码块&#125;catch（Exception2 e）&#123; //第二个catch，可以有多个catch //处理该异常的代码块 e.printStackTrace(); System.out.println("异常抛出了！！");&#125;finally&#123; //最终要执行的代码&#125; 总结： finally中最好不要包含return，否则程序会提前退出，返回会覆盖try或catch中保存的返回值。 printStackTrace()可以输出异常信息。 return值为-1为抛出异常的习惯写法。 如果方法中try,catch,finally中没有返回语句，则会调用这三个语句块之外的return结果。 finally 在try中的return之后 在返回主调函数之前执行。 3.2 throw和throws关键字Java中的 异常抛出 通常使用throw和throws关键字来实现。 3.3 throw将产生的异常抛出，是抛出异常的一个动作 一般会用于程序出现某种逻辑时程序员主动抛出某种特定类型的异常 语法格式 throw (异常对象)12345678public static void main(String[] args) &#123; String s = "abc"; if(s.equals("abc")) &#123; throw new NumberFormatException(); &#125; else &#123; System.out.println(s); &#125; &#125; 3.4 throws声明将要抛出何种类型的异常(声明),一个方法可以导致一个异常但不处理它，它必须指定这种行为以使方法的调用者可以保护它们自己而不发生异常 语法格式123public void person(String name) throws (Exception1, Exception2)&#123; ...&#125; throw与throws的比较 throws 出现在方法头；而throw出现在方法体。 throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。 两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。 范例12345678910111213void doA(int a) throws (Exception1,Exception2,Exception3)&#123; try &#123; ...... &#125; catch(Exception1 e) &#123; throw e; &#125; catch(Exception2 e) &#123; System.out.println("出错了！"); &#125; if(a!=b) throw new Exception3("自定义异常");&#125; 分析: 代码块中可能会产生3个异常，(Exception1,Exception2,Exception3)。 如果产生Exception1异常，则捕获之后再抛出，由该方法的调用者去处理。 如果产生Exception2异常，则该方法自己处理了（即System.out.println(“出错了！”);）。所以该方法就不会再向外抛出Exception2异常了，void doA() throws Exception1,Exception3 里面的Exception2也就不用写了。因为已经用try-catch语句捕获并处理了。 Exception3异常是该方法的某段逻辑出错，程序员自己做了处理，在该段逻辑错误的情况下抛出异常Exception3，则该方法的调用者也要处理此异常。这里用到了自定义异常 使用throw和throws关键字需要注意以下几点： throws的异常列表可以是抛出一条异常，也可以是抛出多条异常，每个类型的异常中间用逗号隔开 方法体中调用会抛出异常的方法或者是先抛出一个异常：用throw new Exception（） throw写在方法体里，表示“抛出异常”这个动作。 如果某个方法调用了抛出异常的方法，那么必须添加try catch语句去尝试捕获这种异常， 或者添加声明，将异常抛出给更上一层的调用者进行处理 四. 自定义异常略 五. 习惯​ 当捕获到异常以后一定要做出处理，哪怕是把这个异常的错误信息打印出来，这是一种良好的编程习惯。如果不处理，那就是把这个错误悄悄地隐藏起来了，可是这个错误依然是存在的，只不过看不到了而已。这是一种非常危险的编程习惯，绝对不能这样做，捕获到异常就一定要做出处理，实在处理不了就把异常抛出去，让别的方法去处理。总之就是不能捕获到异常之后却又不做出相应的处理，这是一种非常不好的编程习惯。 任何方法往外抛能处理的异常的时候都有一种简单的写法：“throws Exception”，因为Exception类是所有能处理的异常类的根基类，因此抛出Exception类就会抛出所有能够被处理的异常类里了。使用“throws Exception”抛出所有能被处理的异常之后，这些被抛出来的异常就是交给JAVA运行时系统处理了，而处理的方法是把这些异常的相关错误堆栈信息全部打印出来。除了在做测试以外，在实际当中编程的时候，在main方法里抛Exception是一个非常不好的编程习惯，应该使用try……catch去捕获异常并处理掉捕获后的异常。不能直接在main方法里把Exception抛出去交给JAVA运行时系统出力就完事了，这是一种不负责任的表现。如果想把程序写得特别健壮，使用try……catch去捕获异常并处理掉捕获后的异常是必不可少的做法。 参考博文​ JAVA异常与异常处理详解 ​ 异常处理 ​ java基础学习总结——异常处理]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typoro快捷键]]></title>
    <url>%2F2019%2F03%2F20%2Ftypero%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[功能 快捷键 插入表格 Ctrl+T 关闭 Ctrl+W 下划线 Ctrl+U 斜体 Ctrl+I Ctrl+O 标题 Ctrl+数字 插入链接 Ctrl+K 参考博文​ Typora快捷键 ​ typora 快捷键[补充] ​ typora]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---String类(深入理解)]]></title>
    <url>%2F2019%2F03%2F20%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---String%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[一. String类1.1 源码(String成员属性)123456789public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence&#123; /** The value is used for character storage. */ private final char value[]; /** The offset is the first index of the storage that is used. */ private final int offset;&#125; 可以看出 String类是 final 类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法 上面列举出了String类中一些的成员属性，从上面可以看出String类其实是通过char数组来保存字符串的 1.2 源码(String方法)123456789101112131415161718192021222324public String substring(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex &gt; count) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; if (beginIndex &gt; endIndex) &#123; throw new StringIndexOutOfBoundsException(endIndex - beginIndex); &#125; return ((beginIndex == 0) &amp;&amp; (endIndex == count)) ? this : new String(offset + beginIndex, endIndex - beginIndex, value);&#125;public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; char buf[] = new char[count + otherLen]; getChars(0, count, buf, 0); str.getChars(0, otherLen, buf, count); return new String(0, count + otherLen, buf);&#125; 可以看出 无论是sub操做还是concat都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。也就是说进行这些操作后，最原始的字符串并没有被改变。 在这里要永远记住一点：“String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”。 二. 字符串常量池​ 我们知道字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。 ​ JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串（这点对理解上面至关重要）。 ​ Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。 静态常量池，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。 运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。 范例12345String a = "chenssy";String b = "chenssy";String c = new String("chenssy"); a, b(保存在栈中)和字面上的chenssy都是指向JVM字符串常量池中的”chenssy”对象，他们指向同一个对象 ​ new关键字一定会产生一个对象chenssy（注意这个chenssy和上面的chenssy不同），同时这个对象是存储在堆中。所以上面应该产生了两个对象：保存在栈中的c和保存堆中chenssy。但是在Java中根本就不存在两个完全一模一样的字符串对象。故堆中的chenssy应该是引用字符串常量池中chenssy。所以c、chenssy、池chenssy的关系应该是：c —&gt; chenssy —&gt; 池chenssy。所以我们修改内存中的值，他变化的是所有。 总结： 栈: a, b, c 堆: chenssy(c指向的对象) JVM字符串常量: chenssy 虽然a、b、c、chenssy是不同的对象，但是从String的内部结构我们是可以理解上面的。String c = new String(“chenssy”);虽然c的内容是创建在堆中，但是他的内部value还是指向JVM常量池的chenssy的value，它构造chenssy时所用的参数依然是chenssy字符串常量。 例子11234567// 采用字面值的方式赋值public void test1()&#123; String str1="aaa"; String str2="aaa"; System.out.println(str1==str2);// true 可以看出str1跟str2是指向同一个对象 &#125; 执行上述代码，结果为：true分析： 当执行 String str1=&quot;aaa&quot; 时，JVM首先会去字符串池中查找是否存在”aaa”这个对象 如果不存在，则在字符串池中创建”aaa”这个对象然后将池中”aaa”这个对象的引用地址返回给字符串常量str1，这样str1会指向池中”aaa”这个字符串对象； 如果存在，则不创建任何对象，直接将池中”aaa”这个对象的地址返回，赋给字符串常量。 当创建字符串对象str2时，字符串池中已经存在”aaa”这个对象，直接把对象”aaa”的引用地址返回给str2，这样str2指向了池中”aaa”这个对象，也就是说str1和str2指向了同一个对象，因此语句 System.out.println(str1 == str2) 输出：true 例子21234567// 采用new关键字新建一个字符串对象public void test2()&#123; String str3 = new String("aaa"); String str4 = new String("aaa"); System.out.println(str3==str4);// false 可以看出用new的方式是生成不同的对象 &#125; 执行上述代码，结果为：false 分析： 采用new关键字新建一个字符串对象时，JVM首先在字符串池中查找有没有”aaa”这个字符串对象， 如果有，则不在池中再去创建”aaa”这个对象了，直接在堆中创建一个”aaa”字符串对象，然后将堆中的这个”aaa”对象的地址返回赋给引用str3，这样，str3就指向了堆中创建的这个”aaa”字符串对象； 如果没有，则首先在字符串池中创建一个”aaa”字符串对象，然后再在堆中创建一个”aaa”字符串对象，然后将堆中这个”aaa”字符串对象的地址返回赋给str3引用，这样，str3指向了堆中创建的这个”aaa”字符串对象。 当执行 String str4=new String(&quot;aaa&quot;) 时， 因为采用 new 关键字创建对象时，每次new出来的都是一个新的对象，也即是说引用str3和str4指向的是两个不同的对象，因此语句 System.out.println(str3 == str4) 输出：false 例子312345678910// 编译期确定public void test3()&#123; String s0 = "helloworld"; String s1 = "helloworld"; String s2 = "hello"+"world"; System.out.println(s0==s1); //true 可以看出s0跟s1是指向同一个对象 System.out.println(s0==s2); //true 可以看出s0跟s2是指向同一个对象 &#125; 执行上述代码，结果为：true、true 分析： s0和s1中的”helloworld”都是字符串常量，它们在编译期就被确定了，所以 s0==s1 为true； “hello” 和 “world” 也都是字符串常量，当一个字符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以s2也同样在编译期就被解析为一个字符串常量，所以s2也是常量池中”helloworld”的一个引用。所以我们得出 s0==s1==s2 例子412345678910// 编译期无法确定public void test4()&#123; String s0 = "helloworld"; String s1 = new String("helloworld"); String s2 = "hello" + new String("world"); System.out.println( s0==s1 ); // false System.out.println( s0==s2 ); // false System.out.println( s1==s2 ); // false&#125; 执行上述代码，结果为：false、false、false 分析： 用 new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间(在堆中,堆中的对象又指向常量池中的字符串) s0 还是常量池中”helloworld”的引用，s1因为无法在编译期确定，所以是运行时创建的新对象”helloworld”的引用，s2因为有后半部分new String(”world”)所以也无法在编译期确定，所以也是一个新创建对象”helloworld”的引用 例子5123456789// 继续-编译期无法确定public void test5()&#123; String str1="abc"; String str2="def"; String str3=str1+str2; System.out.println(str3=="abcdef"); // false&#125; 执行上述代码，结果为：false 分析： 因为str3指向堆中的“abcdef”对象，而”abcdef”是字符串池中的对象，所以结果为false JVM 对 String str=&quot;abc&quot; 对象放在常量池中是在编译时做的，而 String str3=str1+str2 是在运行时刻才能知道的。new对象也是在运行时才做的 + 运算符会在堆中建立来两个String对象，这两个对象的值分别是”abc”和”def”，也就是说从字符串池中复制这两个值，然后在堆中创建两个对象，然后再建立对象str3,然后将”abcdef”的堆地址赋给str3。 步骤： 栈中开辟一块中间存放引用str1，str1指向池中String常量”abc”。 栈中开辟一块中间存放引用str2，str2指向池中String常量”def”。 栈中开辟一块中间存放引用str3。 str1 + str2通过StringBuilder的最后一步toString()方法还原一个新的String对象”abcdef”，因此堆中开辟一块空间存放此对象。 引用str3指向堆中(str1 + str2)所还原的新String对象。 str3指向的对象在堆中，而常量”abcdef”在池中，输出为false。 最后: 栈中: 3个, str1, str2, str3 字符串池中: 3个, “abc”, “def”, “abcdef” 堆中: 3个, str1, str2, (str1+str2) 参考博文​ 深入理解Java中的String]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---String类(2)]]></title>
    <url>%2F2019%2F03%2F20%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---String%E7%B1%BB(2)%2F</url>
    <content type="text"><![CDATA[一. String常用方法1.1 基本操作 int length() : 获取字符串的长度 int index(int ch) : 返回指定字符串在此字符串中第一次出现的索引 int lastIndexOf(int ch) : 返回指定字符在此字符串中最后一次出现的索引 char charAt(int index) : 返回字符串中index位置上的字符,其中index的取值范围是:0 ~ (length-1) 1.2 转换操作1.3 替换与去除1.4 截取和分割 String[] split(String reges) : 根据参数regex将原来的字符串分割为若干个字符串 String substring(int beginIndex): 截取从索引 beginIndex后的所有字符 String substring(int beginIndex, int endIndex): 截取从索引 beginIndex 到 endIndex 索引之间字符 1.5 判断操作 boolean startWith(String prefix) : 判断此字符串是否以指定的字符串开始 boolean endWith(String prefix) : 判断此字符串是否以指定的字符串j结束 其他 Remove(int startIndex)：删除此字符串中从指定位置到最后位置的所有字符 StringUtilsStringUtils类常用方法：转换、移除、替换、反转 参考博文​ Java常用类（二）String类详解]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---String类(深入理解)]]></title>
    <url>%2F2019%2F03%2F20%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---String%E7%B1%BB(%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3)%2F</url>
    <content type="text"><![CDATA[一. String类1.1 源码(String成员属性)123456789public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence&#123; /** The value is used for character storage. */ private final char value[]; /** The offset is the first index of the storage that is used. */ private final int offset;&#125; 可以看出 String类是 final 类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法 上面列举出了String类中一些的成员属性，从上面可以看出String类其实是通过char数组来保存字符串的 1.2 源码(String方法)123456789101112131415161718192021222324public String substring(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex &gt; count) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; if (beginIndex &gt; endIndex) &#123; throw new StringIndexOutOfBoundsException(endIndex - beginIndex); &#125; return ((beginIndex == 0) &amp;&amp; (endIndex == count)) ? this : new String(offset + beginIndex, endIndex - beginIndex, value);&#125;public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; char buf[] = new char[count + otherLen]; getChars(0, count, buf, 0); str.getChars(0, otherLen, buf, count); return new String(0, count + otherLen, buf);&#125; 可以看出 无论是sub操做还是concat都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。也就是说进行这些操作后，最原始的字符串并没有被改变。 在这里要永远记住一点：“String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”。 二. 字符串常量池​ 我们知道字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。 ​ JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串（这点对理解上面至关重要）。 ​ Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。 静态常量池，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。 运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。 范例12345String a = "chenssy";String b = "chenssy";String c = new String("chenssy"); a, b(保存在栈中)和字面上的chenssy都是指向JVM字符串常量池中的”chenssy”对象，他们指向同一个对象 ​ new关键字一定会产生一个对象chenssy（注意这个chenssy和上面的chenssy不同），同时这个对象是存储在堆中。所以上面应该产生了两个对象：保存在栈中的c和保存堆中chenssy。但是在Java中根本就不存在两个完全一模一样的字符串对象。故堆中的chenssy应该是引用字符串常量池中chenssy。所以c、chenssy、池chenssy的关系应该是：c —&gt; chenssy —&gt; 池chenssy。所以我们修改内存中的值，他变化的是所有。 总结： 栈: a, b, c 堆: chenssy(c指向的对象) JVM字符串常量: chenssy 虽然a、b、c、chenssy是不同的对象，但是从String的内部结构我们是可以理解上面的。String c = new String(“chenssy”);虽然c的内容是创建在堆中，但是他的内部value还是指向JVM常量池的chenssy的value，它构造chenssy时所用的参数依然是chenssy字符串常量。 例子11234567// 采用字面值的方式赋值public void test1()&#123; String str1="aaa"; String str2="aaa"; System.out.println(str1==str2);// true 可以看出str1跟str2是指向同一个对象 &#125; 执行上述代码，结果为：true分析： 当执行 String str1=&quot;aaa&quot; 时，JVM首先会去字符串池中查找是否存在”aaa”这个对象 如果不存在，则在字符串池中创建”aaa”这个对象然后将池中”aaa”这个对象的引用地址返回给字符串常量str1，这样str1会指向池中”aaa”这个字符串对象； 如果存在，则不创建任何对象，直接将池中”aaa”这个对象的地址返回，赋给字符串常量。 当创建字符串对象str2时，字符串池中已经存在”aaa”这个对象，直接把对象”aaa”的引用地址返回给str2，这样str2指向了池中”aaa”这个对象，也就是说str1和str2指向了同一个对象，因此语句 System.out.println(str1 == str2) 输出：true 例子21234567// 采用new关键字新建一个字符串对象public void test2()&#123; String str3 = new String("aaa"); String str4 = new String("aaa"); System.out.println(str3==str4);// false 可以看出用new的方式是生成不同的对象 &#125; 执行上述代码，结果为：false 分析： 采用new关键字新建一个字符串对象时，JVM首先在字符串池中查找有没有”aaa”这个字符串对象， 如果有，则不在池中再去创建”aaa”这个对象了，直接在堆中创建一个”aaa”字符串对象，然后将堆中的这个”aaa”对象的地址返回赋给引用str3，这样，str3就指向了堆中创建的这个”aaa”字符串对象； 如果没有，则首先在字符串池中创建一个”aaa”字符串对象，然后再在堆中创建一个”aaa”字符串对象，然后将堆中这个”aaa”字符串对象的地址返回赋给str3引用，这样，str3指向了堆中创建的这个”aaa”字符串对象。 当执行 String str4=new String(&quot;aaa&quot;) 时， 因为采用 new 关键字创建对象时，每次new出来的都是一个新的对象，也即是说引用str3和str4指向的是两个不同的对象，因此语句 System.out.println(str3 == str4) 输出：false 例子312345678910// 编译期确定public void test3()&#123; String s0 = "helloworld"; String s1 = "helloworld"; String s2 = "hello"+"world"; System.out.println(s0==s1); //true 可以看出s0跟s1是指向同一个对象 System.out.println(s0==s2); //true 可以看出s0跟s2是指向同一个对象 &#125; 执行上述代码，结果为：true、true 分析： s0和s1中的”helloworld”都是字符串常量，它们在编译期就被确定了，所以 s0==s1 为true； “hello” 和 “world” 也都是字符串常量，当一个字符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以s2也同样在编译期就被解析为一个字符串常量，所以s2也是常量池中”helloworld”的一个引用。所以我们得出 s0==s1==s2 例子412345678910// 编译期无法确定public void test4()&#123; String s0 = "helloworld"; String s1 = new String("helloworld"); String s2 = "hello" + new String("world"); System.out.println( s0==s1 ); // false System.out.println( s0==s2 ); // false System.out.println( s1==s2 ); // false&#125; 执行上述代码，结果为：false、false、false 分析： 用 new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间(在堆中,堆中的对象又指向常量池中的字符串) s0 还是常量池中”helloworld”的引用，s1因为无法在编译期确定，所以是运行时创建的新对象”helloworld”的引用，s2因为有后半部分new String(”world”)所以也无法在编译期确定，所以也是一个新创建对象”helloworld”的引用 例子5123456789// 继续-编译期无法确定public void test5()&#123; String str1="abc"; String str2="def"; String str3=str1+str2; System.out.println(str3=="abcdef"); // false&#125; 执行上述代码，结果为：false 分析： 因为str3指向堆中的“abcdef”对象，而”abcdef”是字符串池中的对象，所以结果为false JVM 对 String str=&quot;abc&quot; 对象放在常量池中是在编译时做的，而 String str3=str1+str2 是在运行时刻才能知道的。new对象也是在运行时才做的 + 运算符会在堆中建立来两个String对象，这两个对象的值分别是”abc”和”def”，也就是说从字符串池中复制这两个值，然后在堆中创建两个对象，然后再建立对象str3,然后将”abcdef”的堆地址赋给str3。 步骤： 栈中开辟一块中间存放引用str1，str1指向池中String常量”abc”。 栈中开辟一块中间存放引用str2，str2指向池中String常量”def”。 栈中开辟一块中间存放引用str3。 str1 + str2通过StringBuilder的最后一步toString()方法还原一个新的String对象”abcdef”，因此堆中开辟一块空间存放此对象。 引用str3指向堆中(str1 + str2)所还原的新String对象。 str3指向的对象在堆中，而常量”abcdef”在池中，输出为false。 最后: 栈中: 3个, str1, str2, str3 字符串池中: 3个, “abc”, “def”, “abcdef” 堆中: 3个, str1, str2, (str1+str2) 参考博文​ 深入理解Java中的String]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用类---StringUtils]]></title>
    <url>%2F2019%2F03%2F20%2FJava%E5%B8%B8%E7%94%A8%E7%B1%BB---StringUtils%2F</url>
    <content type="text"><![CDATA[一. 转换 StringUtils 中涉及大小写转换以及判断字符串大小写的方法 1.1 字符串首字母大小写转换12345StringUtils.capitalize(null)); // null (注意此处不会报异常)StringUtils.capitalize("china")); // China (首字母转大写)StringUtils.uncapitalize(null)); // null StringUtils.uncapitalize("CHINA")); // cHINA (首字母转小写) 1.2 字符串整体大小写转换1234567StringUtils.upperCase(null)); // nullStringUtils.upperCase("china")); // CHINA (全部转为大写)StringUtils.upperCase("china", Locale.ENGLISH)); // CHINA (按照指定规则转换为大写)StringUtils.lowerCase(null)); // nullStringUtils.lowerCase("CHINA")); // china (全部转换为小写)StringUtils.lowerCase("CHINA", Locale.ENGLISH)); // china (按照指定转换规则转换为小写) 1.3 字符串大小写互换12StringUtils.swapCase(null)); // nullStringUtils.swapCase("chINA")); // CHina 1.4 判断字符串是否全部是大写或小写(空或空白符均为false)12345678StringUtils.isAllUpperCase(null)); // falseStringUtils.isAllUpperCase("")); // falseStringUtils.isAllUpperCase(" ")); // falseStringUtils.isAllUpperCase("CHINA")); // trueStringUtils.isAllLowerCase(null)); // falseStringUtils.isAllLowerCase("")); // falseStringUtils.isAllLowerCase(" ")); // falseStringUtils.isAllLowerCase("china")); // true 二. 移除 从字符串中移除匹配的字符或字符序列，如果要移除的字符或字符序列在字符串中不存在，即无匹配，则不进行移除 2.1 移除单个字符1234StringUtils.remove(null, 'a')); // null (注意此处及下一行为null)StringUtils.remove('china', null) // china StringUtils.remove("china", 'i')); // chnaStringUtils.remove("china", 'b')); // china (如果要移除的字符不存在，则返回原字符串 2.2 移除指定字符序列12StringUtils.remove("china", "in")); // chaStringUtils.remove("china", "nin")); // 没有匹配到字符串, china 2.3 移除开头匹配的字符序列12StringUtils.removeStart("china", "ch")); // inaStringUtils.removeStartIgnoreCase("china", "CHI")); // na (忽略大小写) 2.4 移除结尾匹配的字符序列12StringUtils.removeEnd("china", "na")); // chiStringUtils.removeEndIgnoreCase("china", "NA")); // chi (忽略大小写) 2.5 移除空白字符12StringUtils.deleteWhitespace(null)); // nullStringUtils.deleteWhitespace(" c h i\tn\ra")); // china 三. 替换四. 反转五. 截取字符串5.1 截取指定位置的字符串12StringUtils.substring("hello", 1); // 结果是：ello, 截取的字符串包括前面的(起始是0)StringUtils.substring("hello", 1, 3); // 结果是：el, 截取的字符串不包括后面的,[1,3) 5.2 截取指定字符串之前/之后的内容123456StringUtils.substringBefore("helloWorld", "o"); // 结果是：hellStringUtils.substringBeforeLast("helloWorld", "o"); // 结果是：helloW,一直找到最后一个指定的字符串StringUtils.substringAfter("helloWorld", "o"); // 结果是：WorldStringUtils.substringAfterLast("helloWorld", "o"); // 结果是：rld// 总结: 带有 Last 的都是找到最后一个字符 5.3 截取参数2和参数3中间的字符1234StringUtils.substringBetween("hello_world_I_love_you", "_", "_");// 结果是: worldStringUtils.substringsBetween("hello_world_I_love_you", "_", "_");// 返回的是一个数组,循环遍历,打印结果为: world love 参考博文​ java StringUtils截取字符串]]></content>
      <categories>
        <category>java常用类</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java常用类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---线程(3)]]></title>
    <url>%2F2019%2F03%2F19%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E7%BA%BF%E7%A8%8B(3)%2F</url>
    <content type="text"><![CDATA[一. 一个典型的 Java 线程安全例子范例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class ThreadTest &#123; public static void main(String[] args) &#123; Account account = new Account("123456", 1000); DrawMoneyRunnable drawMoneyRunnable = new DrawMoneyRunnable(account, 700); Thread myThread1 = new Thread(drawMoneyRunnable); Thread myThread2 = new Thread(drawMoneyRunnable); myThread1.start(); myThread2.start(); &#125;&#125;class DrawMoneyRunnable implements Runnable &#123; private Account account; // 取钱数目 private double drawAmount; public DrawMoneyRunnable(Account account, double drawAmount) &#123; super(); this.account = account; this.drawAmount = drawAmount; &#125; public void run() &#123; // 如果取钱数小于余额 if (account.getBalance() &gt;= drawAmount) &#123; //1 System.out.println("取钱成功， 取出钱数为：" + drawAmount); double balance = account.getBalance() - drawAmount; // 更新余额 account.setBalance(balance); System.out.println("余额为：" + balance); &#125; &#125;&#125;class Account &#123; // 银行卡密码 private String accountNo; // 银行卡余额 private double balance; // 两个构造方法 public Account() &#123; &#125; public Account(String accountNo, double balance) &#123; this.accountNo = accountNo; this.balance = balance; &#125; // get/set 方法 public String getAccountNo() &#123; return accountNo; &#125; public void setAccountNo(String accountNo) &#123; this.accountNo = accountNo; &#125; public double getBalance() &#123; return balance; &#125; public void setBalance(double balance) &#123; this.balance = balance; &#125;&#125; 上面例子很容易理解，有一张银行卡，里面有1000的余额，程序模拟你和你老婆同时在取款机进行取钱操作的场景。多次运行此程序，可能具有多个不同组合的输出结果。其中一种可能的输出为： 1234取钱成功， 取出钱数为：700.0余额为：300.0取钱成功， 取出钱数为：700.0余额为：-400.0 对于一张只有1000余额的银行卡，你们一共可以取出1400，这显然是有问题的。 ​ 问题在于 Java多线程环境下的执行的不确定性。CPU可能随机的在多个处于就绪状态中的线程中进行切换 ​ 因此，很有可能出现如下情况：当thread1执行到//1处代码时，判断条件为true，此时CPU切换到thread2，执行//1处代码，发现依然为真，然后执行完thread2，接着切换到thread1，接着执行完毕。 讲到线程安全问题，其实是指多线程环境下对共享资源的访问可能会引起此共享资源的不一致性。因此，为避免线程安全问题，应该避免多线程环境下对此共享资源的并发访问。 二. 同步方法对共享资源进行访问的方法定义中加上synchronized关键字修饰，使得此方法称为同步方法。 可以简单理解成对此方法进行了加锁，其锁对象为当前方法所在的对象自身。多线程环境下，当执行此方法时，首先都要获得此同步锁（且同时最多只有一个线程能够获得），只有当线程执行完此同步方法后，才会释放锁对象，其他的线程才有可能获取此同步锁，以此类推… 只有一个对象可以执行此方法,其他的都要在后面排队,等他使用完,其他的对象才可以使用,次方法只能同时被一个对象使用 在上例中，共享资源为account对象，当使用同步方法时，可以解决线程安全问题。只需在run()方法前加上synshronized关键字即可。 123public synchronized void run() &#123; // ....&#125; 三. 同步代码块解决线程安全问题其实只需限制对共享资源访问的不确定性即可。使用同步方法时，使得整个方法体都成为了同步执行状态，会使得可能出现同步范围过大的情况，于是，针对需要同步的代码可以直接另一种同步方式—同步代码块来解决。 同步代码块的格式为： 123synchronized (obj) &#123; //...&#125; 其中，obj 为锁对象，因此，选择哪一个对象作为锁是至关重要的。一般情况下，都是选择此共享资源对象作为锁对象。 如上例中，最好选用account对象作为锁对象. (当然，选用this也是可以的，那是因为创建线程使用了runnable 方式，如果是直接继承Thread方式创建的线程，使用this对象作为同步锁会其实没有起到任何作用，因为是不同的对象了。因此，选择同步锁时需要格外小心…) 四.Lock 对象同步锁上面我们可以看出，正因为对同步锁对象的选择需要如此小心，有没有什么简单点的解决方案呢？ 以方便同步锁对象与共享资源解耦，同时又能很好的解决线程安全问题。 使用 Lock对象同步锁 可以方便的解决此问题，唯一需要注意的一点是Lock对象需要与资源对象同样具有一对一的关系。Lock对象同步锁一般格式为： 12345678910111213class X &#123; // 显示定义Lock同步锁对象，此对象与共享资源具有一对一关系 private final Lock lock = new ReentrantLock(); public void m()&#123; // 加锁 lock.lock(); //... 需要进行线程安全同步的代码 // 释放Lock锁 lock.unlock(); &#125;&#125; 五. wait()/notify()/notifyAll()线程通信任何Object对象都可以作为这三个方法的主调，在实际的多线程编程中，只有同步锁对象调这三个方法，才能完成对多线程间的线程通信。Obj.wait() , 与 Obj.notify() 必须要与 synchronized(Obj) 一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作. wait()： 导致==当前线程等待==并使其进入到等待阻塞状态。直到其他线程==调用该同步锁对象==的notify()或notifyAll()方法来唤醒此线程。 wait()方法执行后，当前线程立即进入到等待阻塞状态，其后面的代码不会执行 当wait线程唤醒后并执行时，是接着上次执行到的wait()方法代码后面继续往下执行的 notify()： 唤醒在此同步锁对象上等待的单个线程，如果有多个线程都在此同步锁对象上等待，则会任意选择其中某个线程进行唤醒操作 如果notify()/notifyAll()后面还有代码，还会继续进行，直到当前线程执行完毕才会释放同步锁对象 notify()/notifyAll()执行后，如果右面有sleep()方法，则会使当前线程进入到阻塞状态，但是同步对象锁没有释放，依然自己保留，那么一定时候后还是会继续执行此线程,接下来同上 notifyAll()： 唤醒在此同步锁对象上等待的所有线程，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程 解释wait()中的当前线程​ jdk的解释中，说wait()的作用是让“当前线程”等待, 而“当前线程”是指正在cpu上运行的线程！而不是这个对象进行等待. 范例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TestWait implements Runnable &#123; private String name; private Object prev; private Object self; private TestWait(String name, Object prev, Object self) &#123; this.name = name; this.prev = prev; this.self = self; &#125; @Override public void run() &#123; int count = 10; while (count &gt; 0) &#123; synchronized (prev) &#123; synchronized (self) &#123; System.out.print(name + " "); count--; self.notify(); &#125; try &#123; prev.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; Object a = new Object(); Object b = new Object(); Object c = new Object(); TestWait pa = new TestWait("A", c, a); TestWait pb = new TestWait("B", a, b); TestWait pc = new TestWait("C", b, c); new Thread(pa).start(); Thread.sleep(1000); //确保按顺序A、B、C执行, 很重要 new Thread(pb).start(); Thread.sleep(1000); new Thread(pc).start(); Thread.sleep(1000); &#125; &#125; /* * 打印结果: A B C A B C A B C A B C A B C A B C A B C A B C A B C A B C */ 整体思路从大的方向上来讲，该问题为三线程间的同步唤醒操作，主要的目的就是 ThreadA -&gt; ThreadB -&gt; ThreadC -&gt; ThreadA 循环执行三个线程。 为了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能继续执行。一个对象锁是prev，就是前一个线程所持有的对象锁。还有一个就是自身对象锁。 主要的思想就是，为了控制执行的顺序，必须要先持有prev锁，也就前一个线程要释放自身对象锁，再去申请自身对象锁，两者兼备时打印，之后首先调用self.notify()释放自身对象锁，唤醒下一个等待线程，再调用prev.wait()释放prev对象锁，终止当前线程，等待循环结束后再次被唤醒。 看起来似乎没什么问题，但如果你仔细想一下，就会发现有问题，就是初始条件，三个线程按照A,B,C的顺序来启动，按照前面的思考，A唤醒B，B唤醒C，C再唤醒A。但是这种假设依赖于JVM中线程调度、执行的顺序。所以需要在main方法中设置sleep()方法,保证创建的顺序. 为什么notify(), wait()等函数定义在Object中，而不是Thread中notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。 参考博文​ Java多线程系列–“基础篇”05之 线程等待与唤醒 ​ Java多线程学习（总结很详细！！！） ​ Java总结篇系列：Java多线程（三）]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git---将本地项目上传到Github]]></title>
    <url>%2F2019%2F03%2F19%2FGit---%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0Github%2F</url>
    <content type="text"><![CDATA[一. 关键步骤 在本地创建一个版本库（即文件夹），通过git init把它变成Git仓库； git init 把项目复制到这个文件夹里面，再通过git add .把项目添加到仓库； git add . 再通过git commit -m “注释内容”把项目提交到仓库； git commit -m “first commit” 在Github上设置好SSH密钥 后，新建一个远程仓库，通过 git remote add origin https://github.com/sladning/test 将本地仓库和远程仓库进行关联； git remote add origin https://github.com/sladning/test 最后通过 git push -u origin master 把本地仓库的项目推送到远程仓库（也就是Github）上；（若新建远程仓库的时候自动创建了README文件会报错，解决办法看下面）。 git push -u origin master 由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了 git push origin master 二. 注关于 README.md 创建远程仓库的时候，如果你勾选了Initialize this repository with a README（就是创建仓库的时候自动给你创建一个README文件） 那么到了将本地仓库内容推送到远程仓库的时候就会报一个failed to push some refs to https://github.com/guyibang/TEST2.git的错 这是由于你新创建的那个仓库里面的README文件不在本地仓库目录中，这时我们可以通过以下命令先将内容合并以下：git pull --rebase origin master 再push就能成功了。 参考博文: ​ Git的使用–如何将本地项目上传到Github]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---EL表达式]]></title>
    <url>%2F2019%2F03%2F19%2FJavaWeb---EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一. EL表达式简介 EL 全名为 Expression Language。 EL主要作用： 获取数据EL表达式主要用于替换 JSP 页面中的脚本表达式，以从各种类型的web域中检索 java 对象、获取数据。(某个web域 中的对象，访问javabean的属性、访问list集合、访问map集合、访问数组) 执行运算利用 EL 表达式可以在JSP页面中执行一些基本的关系运算、逻辑运算和算术运算，以在JSP页面中完成一些简单的逻辑运算。${user==null} 获取web开发常用对象EL 表达式定义了一些隐式对象，利用这些隐式对象，web开发人员可以很轻松获得对web常用对象的引用，从而获得这些对象中的数据。 调用Java方法EL表达式允许用户开发自定义EL函数，以在JSP页面中通过EL表达式调用Java类的方法。 二. 获取数据 使用EL表达式获取数据语法：${标识符} EL表达式语句在执行时，会调用 pageContext.findAttribute 方法，用 标识符 为关键字，分别从page、request、session、application四个域中查找相应的对象，找到则返回相应对象，找不到则返回 ”” （注意，不是null，而是空字符串）。 EL表达式可以很轻松获取JavaBean的属性，或获取数组、Collection、Map类型集合的数据 2.1 获取 JavaBean 的属性通过 . 符号操作就可以了。 如${hero.name} ， 如果属性是非boolean类型, 会自动调用 getXXX 方法 如果属性是boolean类型，会自动调用 isXXX 方法 范例1234567891011121314151617181920212223242526// person 的 JavaBeanpublic class Person &#123; // 姓名 String类型 private String name; //是否已婚 boolean类型 private boolean married; public Person() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public boolean isMarried() &#123; return married; &#125; public void setMarried(boolean married) &#123; this.married = married; &#125;&#125; 获取12345678910&lt;body&gt;&lt;!-- 在jsp页面中，使用el表达式可以获取bean的属性 --&gt; &lt;% Person p = new Person(); p.setName("Mike"); p.setMarried(True); request.setAttribute("person",p); %&gt; 使用el表达式可以获取bean的属性：$&#123;person.name&#125;, $&#123;person.married&#125;&lt;/body&gt; el表达式获取数据范例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;body&gt; &lt;% request.setAttribute("name","孤傲苍狼"); %&gt; &lt;%--$&#123;name&#125;等同于pageContext.findAttribute("name") --%&gt; 使用EL表达式获取数据：$&#123;name&#125; &lt;hr&gt; &lt;hr&gt; &lt;!-- 在jsp页面中，使用el表达式可以获取bean中的。。。。。。。。。的属性 --&gt; &lt;% Person person = new Person(); Address address = new Address(); person.setAddress(address); request.setAttribute("person",person); %&gt; $&#123;person.address.name&#125; &lt;hr&gt; &lt;!-- 在jsp页面中，使用el表达式获取list集合中指定位置的数据 --&gt; &lt;% Person p1 = new Person(); p1.setName("孤傲苍狼"); Person p2 = new Person(); p2.setName("白虎神皇"); List&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); list.add(p1); list.add(p2); request.setAttribute("list",list); %&gt; &lt;!-- 取list指定位置的数据 --&gt; $&#123;list[1].name&#125; &lt;!-- 迭代List集合 --&gt; &lt;c:forEach var="person" items="$&#123;list&#125;"&gt; $&#123;person.name&#125; &lt;/c:forEach&gt; &lt;hr&gt; &lt;!-- 在jsp页面中，使用el表达式获取map集合的数据 --&gt; &lt;% Map&lt;String,String&gt; map = new LinkedHashMap&lt;String,String&gt;(); map.put("a","aaaaxxx"); map.put("b","bbbb"); map.put("c","cccc"); map.put("1","aaaa1111"); request.setAttribute("map",map); %&gt; &lt;!-- 根据关键字取map集合的数据 --&gt; $&#123;map.c&#125; $&#123;map["1"]&#125; &lt;hr&gt; &lt;!-- 迭代Map集合 --&gt; &lt;c:forEach var="me" items="$&#123;map&#125;"&gt; $&#123;me.key&#125;=$&#123;me.value&#125;&lt;br/&gt; &lt;/c:forEach&gt; &lt;hr&gt;&lt;/body&gt; 1.7、EL注意事项 EL表达式是JSP 2.0规范中的一门技术 。因此，若想正确解析EL表达式，需使用支持Servlet2.4/JSP2.0技术的WEB服务器。注意：有些Tomcat服务器如不能使用EL表达式 （1）升级成tomcat6 （2）在 JSP 中加入&lt;%@ page isELIgnored=”false” %&gt; 1.8、EL表达式保留关键字 And eq gt true Or ne le false No lt ge null instanceof empty div mod ​ 保留字的意思是指变量在命名时，应该避开上述的名字，以免程序编译时发生错误，关于EL表达式的内容的总结就这么多。 参考博文​ javaweb学习总结(二十九)——EL表达式]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JSTL标签库之核心标签]]></title>
    <url>%2F2019%2F03%2F19%2FJavaWeb---JSTL%E6%A0%87%E7%AD%BE%E5%BA%93%E4%B9%8B%E6%A0%B8%E5%BF%83%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[一. JSTL标签库介绍 JSTL标签库的使用是为弥补 html 标签的不足，规范自定义标签的使用而诞生的,是一个 JSP 的标签集合, 使用 JSLT 标签的目的就是 不希望在 jsp 页面中出现 java 逻辑代码 二. JSTL标签库的分类 核心标签(用得最多) 国际化标签(I18N格式化标签) 数据库标签(SQL标签，很少使用) XML标签(几乎不用) JSTL函数(EL函数) 三. 核心标签库使用说明 JSTL 的核心标签库标签共13个，使用这些标签能够完成 JSP 页面的基本功能，减少编码工作。 从功能上可以分为 4 类 表达式控制标签： out 标签、set 标签、remove 标签、catch 标签。 流程控制标签： if 标签、choose 标签、when 标签、otherwise 标签 循环标签： forEach 标签、forTokens 标签 URL操作标签： import 标签、url 标签、redirect 标签、param 标签 在JSP页面引入核心标签库的代码为： ​ &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 3.1 表达式控制标签1) &lt;c:out&gt; 标签主要是用来输出数据对象（字符串、表达式）的内容或结果 语法格式1&lt;c:out value="&lt;string&gt;" default="&lt;string&gt;" escapeXml="&lt;true|false&gt;"/&gt; 属性 属性 描述 是否必要 默认值 value 要输出的内容 是 无 default 输出的默认值 否 主体中的内容 escapeXml 是否忽略XML特殊字符 否 true 实例12345&lt;body&gt; &lt;c:out value="&amp;lt 未使用转义字符 &amp;gt" escapeXml="true" default="默认值"&gt;&lt;/c:out&gt;&lt;br/&gt; &lt;c:out value="&amp;lt 使用转义字符 &amp;gt" escapeXml="false" default="默认值"&gt;&lt;/c:out&gt;&lt;br/&gt; &lt;c:out value="$&#123;null&#125;" escapeXml="false"&gt;使用的表达式结果为null，则输出该默认值&lt;/c:out&gt;&lt;/body&gt; 打印结果123&amp;lt 未使用转义字符 &amp;gt&lt; 使用转义字符 &gt;使用的表达式结果为null，则输出该默认值 3.2 表达式控制标签1) &lt;c:if&gt; 标签判断表达式的值，如果表达式的值为 true 则执行其主体内容 语法格式123&lt;c:if test="&lt;boolean&gt;" var="&lt;string&gt;" scope="&lt;string&gt;"&gt; ...&lt;/c:if&gt; 属性 属性 描述 是否必要 默认值 test 条件 是 无 var 用于存储条件结果的变量 否 无 scope var属性的作用域 否 page 实例 (模拟 if-else )12345678&lt;c:set var="salary" scope="session" value="$&#123;2000*2&#125;"/&gt;&lt;c:if test="$&#123;salary &gt; 2000&#125;" var="flag" scope="session"&gt; &lt;p&gt;我的工资为: &lt;c:out value="$&#123;salary&#125;"/&gt;&lt;p&gt;&lt;/c:if&gt;&lt;c:if test="$&#123;not flag&#125;"&gt; &lt;p&gt;我的工资为: &lt;c:out value="$&#123;salary&#125;"/&gt;&lt;p&gt;&lt;/c:if&gt; 3.3 循环标签forEach 语法格式1234567&lt;c:forEach items="&lt;object&gt;" begin="&lt;int&gt;" end="&lt;int&gt;" step="&lt;int&gt;" var="&lt;string&gt;" varStatus="&lt;string&gt;" &gt; 属性 属性 描述 是否必要 默认值 items 要被循环的信息 否 无 begin 开始的元素（0=第一个元素，1=第二个元素） 否 0 end 最后一个元素（0=第一个元素，1=第二个元素） 否 Last element step 每一次迭代的步长 否 1 var 代表当前条目的变量名称 否 无 varStatus 代表循环状态的变量名称 否 无 实例 (表格隔行背景色变化,)12345&lt;c:forEach var="item" items="&#123;contents&#125;" varStatus="status"&gt; &lt;tr &lt;c:if test="&#123;status.count%2==0&#125;"&gt;bgcolor="#CCCCFE"/c:if align="left"&gt; xxx &lt;/tr&gt;&lt;/c:forEach&gt; 参考博文​ javaweb学习总结(二十八)——JSTL标签库之核心标签 ​ 菜鸟教程]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---线程(2)]]></title>
    <url>%2F2019%2F03%2F18%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E7%BA%BF%E7%A8%8B(2)%2F</url>
    <content type="text"><![CDATA[四. 线程控制的基本方法 isAlive() : 判断线程是否还”活着”, 即线程是否还未终止 getPriority() : 获得线程的优先级数值 setPriority() : 设置线程的优先级数值 Thread.sleep() : 将当前线程睡眠指定毫秒数 join() 调用某线程的该方法,将当前线程与该线程 “合并”, 即等待该线程结束, 再回复当前线程的运行 yield() : 让出CPU, 当前线程进入就绪队列等待调度 wait() : 当前线程进入对象的 wait pool notify()\notigyAll() : 唤醒对象的 wait pool 中的一个/所有等待线程 3.3 sleep/join/yield 方法介绍主线程的概念所有进程，至少会有一个线程即主线程，即main方法开始执行，就会有一个看不见的主线程存在。 sleep() 方法​ 让当前的正在执行的线程暂停指定的时间，并进入阻塞状态。在其睡眠的时间段内，该线程由于不是处于就绪状态，因此不会得到执行的机会。即使此时系统中没有任何其他可执行的线程，出于sleep()中的线程也不会执行。因此sleep()方法常用来暂停线程执行。 注意 可以调用Thread的静态方法 public static void sleep(long millis) throws InterruptedEcception 使得当前线程休眠(暂时停止执行 millis 毫秒) 因为是静态方法, sleep可以有类名直接调用, Thread.sleep(…) Thread.sleep(1000); 表示当前线程暂停1000毫秒 ，其他线程不受影响 范例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class TestSleep &#123; public static void main(String args[])&#123; MyThread thread = new MyThread(); // 调用start()方法启动新开辟的线程 thread.start(); try &#123; System.out.println("主线程开始启动"); // 静态方法的调用可以直接使用“类名.静态方法名”或者“对象的引用.静态方法名”的方式来调用 Thread.sleep(4000); System.out.println("主线程睡眠了4秒种后再次启动了"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 使用interrupt()方法去结束掉一个线程的执行并不是一个很好的做法 // thread.interrupt(); // 改变循环条件，结束死循环 thread.flag = false; /** * 当发生InterruptedException时，直接把循环的条件设置为false即可退出死循环， * 继而结束掉子线程的执行，这是一种比较好的结束子线程的做法 */ /** * 调用interrupt()方法把正在运行的线程打断相当于是主线程一盆凉水泼上去把正在执行分线程打断了 * 分线程被打断之后就会抛InterruptedException异常，这样就会执行return语句返回， * 结束掉线程的执行所以这里的分线程在执行完4秒钟之后就结束掉了线程的执行 */ &#125;&#125;class MyThread extends Thread &#123; boolean flag = true;// 定义一个标记，用来控制循环的条件 public void run() &#123; /* * 注意：这里不能在run()方法的后面直接写throw Exception来抛异常， * 因为现在是要重写从Thread类继承而来的run()方法,重写方法不能抛出比被重写的方法的不同的异常。 * 所以这里只能写try……catch()来捕获异常 */ while (flag) &#123; System.out.println("==========" + new Date().toLocaleString() + "==========="); try &#123; // 在本类中声明的静态方法时调用时直接写静态方法名即可 // 这里是让这个新开辟的线程每隔一秒睡眠一次，然后睡眠一秒钟后再次启动该线程 sleep(1000); // 睡眠的时如果被打断就会抛出InterruptedException异常 &#125; catch (InterruptedException e) &#123; // 睡眠的时一盘冷水泼过来就有可能会打断睡眠 // 因此让正在运行线程被一些意外的原因中断的时候有可能会抛被打扰中断(InterruptedException)的异常 // 线程被中断后就返回，相当于是结束线程 return; &#125; &#125; &#125;&#125;// 打印结果:/*主线程开始启动==========2019-3-19 16:54:53=====================2019-3-19 16:54:54=====================2019-3-19 16:54:55=====================2019-3-19 16:54:56===========主线程睡眠了4秒种后再次启动了*/ join() 方法合并某个线程 让一个线程等待另一个线程完成才继续执行。如A线程线程执行体中调用B线程的join()方法，则A线程被阻塞，直到B线程执行完为止，A才能得以继续执行 范例12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class TestJoin &#123; public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName() + "主线程运行开始!"); Thread1 mTh1 = new Thread1("A"); Thread1 mTh2 = new Thread1("B"); mTh1.start(); mTh2.start(); try &#123; // 加入main()方法中 mTh1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; // 加入main()方法中 mTh2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "主线程运行结束!"); &#125;&#125;class Thread1 extends Thread &#123; private String name; public Thread1(String name) &#123; super(name); this.name = name; &#125; public void run() &#123; System.out.println(Thread.currentThread().getName() + " 线程运行开始!"); for (int i = 0; i &lt; 3; i++) &#123; System.out.println("子线程" + name + "运行 : " + i); try &#123; // 睡眠时间随机 sleep((int) Math.random() * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + " 线程运行结束!"); &#125;&#125; 应用​ 在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到 join() 方法了 yield() 方法​ 暂停当前正在执行的线程对象(让出CPU)，并执行其他线程 注意 yield()从未导致线程转到等待/睡眠/阻塞状态 yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。当调用线程的 yield() 方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。 范例12345678910111213141516171819202122232425class ThreadYield extends Thread&#123; public ThreadYield(String name) &#123; super(name); &#125; @Override public void run() &#123; for (int i = 1; i &lt;= 50; i++) &#123; System.out.println("" + this.getName() + "-----" + i); // 当i为30时，该线程就会把CPU时间让掉，让其他或者自己的线程执行（也就是谁先抢到谁执行） if (i ==30) &#123; this.yield(); &#125; &#125; &#125; &#125; public class Main &#123; public static void main(String[] args) &#123; ThreadYield yt1 = new ThreadYield("张三"); ThreadYield yt2 = new ThreadYield("李四"); yt1.start(); yt2.start(); &#125; &#125; 运行结果： 第一种情况: 李四 (线程) 当执行到30时会CPU时间让掉，这时张三(线程)抢到CPU时间并执行。 第二种情况: 李四 (线程) 当执行到30时会CPU时间让掉，这时李四 (线程) 抢到CPU时间并执行。 sleep() 和 yield() 的区别 sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。 sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的 实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程 sleep 方法允许较低优先级的线程获得运行机会，但 yield() 方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。 在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行 4. 改变线程的优先级/setPriority()：每个线程在执行时都具有一定的优先级，优先级高的线程具有较多的执行机会。每个线程默认的优先级都与创建它的线程的优先级相同。main线程默认具有普通优先级。 设置线程优先级：setPriority(int priorityLevel) 参数 priorityLevel 范围在1-10之间，常用的有如下三个静态常量值： MAX_PRIORITY: 10 MIN_PRIORITY: 1 NORM_PRIORITY: 5 获取线程优先级：getPriority() 范例1234567891011121314151617181920212223public class TestPriority &#123; public static void main(String[] args) &#123; Thread myThread = new MyThread03(); for (int i = 0; i &lt; 30; i++) &#123; System.out.println("main thread i = " + i); if (i == 5) &#123; // 当 i=5 时,将myThread的优先级设为最高 myThread.setPriority(Thread.MAX_PRIORITY); myThread.start(); &#125; &#125; &#125;&#125;class MyThread03 extends Thread &#123; public void run() &#123; for (int i = 0; i &lt; 30; i++) &#123; System.out.println("i = " + i); &#125; &#125;&#125; 注意​ 具有较高线程优先级的线程对象仅表示此线程具有较多的执行机会，而非优先执行。]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---super关键字]]></title>
    <url>%2F2019%2F03%2F18%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---super%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[一. super 关键字作用 主要存在于子类方法中，用于指向子类对象中父类对象 访问父类的属性 访问父类的函数 访问父类的构造函数 二. super 注意的地方 this 和 super 很像，this指向的是当前对象的调用，super指向的是当前调用对象的父类。 类加载完毕，创建对象，父类的构造方法会被调用（默认自动无参），然后执行子类相应构造创建了一个子类对象，该子类对象还包含了一个父类对象。该父类对象在子类对象内部。 this super 只能在有对象的前提下使用，不能在static方法内使用。 三. super关键字的使用1. 子类隐式调用父类构造函数子类的构造函数默认第一行会默认调用父类无参的构造函数，隐式语句 super(); 范例123456Son(int y) &#123; // super();隐式语句 this.y = y + x; System.out.println("这是子类的有参构造");&#125; 2. 子类显式调用父类构造函数​ 在子类构造函数 第一行 通过super关键字调用父类任何构造函数。如果显式调用父类构造函数，编译器自动添加的调用父类无参数的构造就消失。构造函数间的调用只能放在第一行，只能调用一次 。super()和this()不能同时存在构造函数第一行 。 12345Son(int y) &#123; super(y);// 子类显式调用父类构造函数 this.y = y + x; System.out.println("这是子类的有参构造");&#125; 实例1234567891011121314151617181920212223242526272829303132333435363738394041424344class Father &#123; public int value; public void method() &#123; value = 100; System.out.println("父类的value属性值 = " + value); &#125;&#125;class Son extends Father &#123; // 子类除了继承父类所具有的valu属性外，自己又另外声明了一个value属性，此时的子类拥有两个value属性。 public int value; // 在子类ChildClass里面重写了从父类继承下来的method()方法里面的实现，即重写(覆盖)了method()方法 public void method() &#123; // 使用super作为父类对象的引用对象来调用父类对象里面的f()方法 super.method(); // 这个value是子类自己定义的那个value，不是从父类继承下来的那个value value = 200; System.out.println("子类的value属性值=" + value); System.out.println("修改父类的value之前,值为: " + super.value); super.value = 300; System.out.println("修改父类的value之后,值为: " + super.value); &#125;&#125;public class TestSuper &#123; public static void main(String[] args) &#123; Son son = new Son(); son.method(); &#125;&#125;/** 打印结果: * 父类的value属性值 = 100 * 子类的value属性值=200 * 修改父类的value之前,值为: 100 * 修改父类的value之后,值为: 300 * */ 详细的内存分析见 参考博文 四. super思考如果开发者自定义了一个类，没有显示的进行类的继承，那么该类中成员函数是否可以使用super关键字？ 答: 可以使用，继承了Object类，Object类是所有类的父类 参考博文​ Java super关键字详解 ​ java基础学习总结——super关键字]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---this关键字]]></title>
    <url>%2F2019%2F03%2F18%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---this%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[一. 概念​ this 关键字代表自身 注意 this关键字必须放在非静态方法里面 当必须指出 当前使用方法的对象是谁 时要使用 this 有时使用 this 可以处理方法中 成员变量和参数重名的现象 this 可以看做是 一个变量, 它的值是当前对象的引用 二. 在程序中使用用途: 使用this关键字 引用成员变量 使用this关键字在 自身构造方法内部引用其它构造方法 使用this关键字代表 自身类的对象 使用this关键字引用成员方法 1. 使用 this 引用成员变量​ 在一个类的方法或构造方法内部，可以使用“this.成员变量名”这样的格式来引用成员变量名，有些时候可以省略，有些时候不能省略。 1234567891011public class ReferenceVariable &#123; private int a; public ReferenceVariable(int a)&#123; this.a = a; &#125; public void setA(int a)&#123; this.a = a; &#125;&#125; 在该代码的构造方法和setA方法内部，都是用this.a引用类的成员变量。因为无论在构造方法还是setA方法内部，都包含2个变量名为a的变量，一个是参数a，另外一个是成员变量a。按照Java语言的变量作用范围规定，参数a的作用范围为构造方法或方法内部，成员变量a的作用范围是类的内部，这样在构造方法和setA方法内部就存在了变量a的冲突，Java语言规定当变量作用范围重叠时，作用域小的变量覆盖作用域大的变量。所以在构造方法和setA方法内部，参数a起作用。 这样需要访问成员变量a则必须使用this进行引用。当然，如果变量名不发生重叠，则this可以省略。 但是为了增强代码的可读性，一般将参数的名称和成员变量的名称保持一致，所以this的使用频率在规范的代码内部应该很多。 2. 引用构造方法​ 在一个类的构造方法内部，也可以使用this关键字引用其它的构造方法，这样可以降低代码的重复，也可以使所有的构造方法保持统一，这样方便以后的代码修改和维护，也方便代码的阅读。 1234567891011public class ReferenceConstructor &#123; int a; public ReferenceConstructor()&#123; this(0); &#125; public ReferenceConstructor(int a)&#123; this.a = a; &#125;&#125; 这里在不带参数的构造方法内部，使用this调用了另外一个构造方法，其中0是根据需要传递的参数的值 当一个类内部的构造方法比较多时，可以只书写一个构造方法的内部功能代码，然后其它的构造方法都通过调用该构造方法实现，这样既保证了所有的构造是统一的，也降低了代码的重复。 在实际使用时，需要注意的是，在构造方法内部使用this关键字调用其它的构造方法时，调用的代码只能出现在构造方法内部的第一行可执行代码。这样，在构造方法内部使用this关键字调用构造方法最多会出现一次。 3. 代表自身对象​ 在一个类的内部，也可以使用this代表自身类的对象，或者换句话说，每个类内部都有一个隐含的成员变量，该成员变量的类型是该类的类型，该成员变量的名称是this，实际使用this代表自身类的对象的 解释​ 假设我们在堆内存new了一个对象，在这个对象里面你有一个引用 this，this 指向这个对象自己，所以这就是this，这个new出来的对象名字是什么，我们不知道，不知道也没关系，因为这并不影响这个对象在内存里面的存在，这个对象只要在内存中存在，他就一定有一个引用this ,在 类的方法定义中 使用的 this 关键字代表 使用该方法的==对象的引用== 示例代码如下： 123456789public class ReferenceObject &#123; ReferenceObject instance; public ReferenceObject()&#123; instance = this; &#125; public void test()&#123; System.out.println(this); &#125;&#125; ​ 构造方法内部，将对象this的值赋值给instance，在test方法内部，输出对象this的内容，这里的this都代表自身类型的对象。 4. 引用成员方法 在一个类的内部，成员方法之间的互相调用时也可以使用“this.方法名(参数)”来进行引用，只是所有这样的引用中this都可以省略，所以这里就不详细介绍了 三. 内存中的分析范例12345678910111213141516171819202122232425// 如何区分两个 ipublic class Leaf &#123; // 在 Leaf 类里面定义一个成员变量 i int i = 0; // 定义 Leaf 这个类的构造方法,构造方法里面有一个局部变量i,这个i与成员变量i同名 // public Leaf(int i) &#123; // this.i 中使用this就是为了却分开成员变量i和形参i,如果这里不写this,而是直接写"i=i",这样就不好区分了,因此有时使用this可以处理方法中成员变量和参数重名的情况 // 后面这个 i 是构造方法里面声明的形参i,在这里有一个原则,当你确定不了一个参数到时指的是哪一个变量的时候,赵丽这个参数最近的声明(就近声明原则) this.i = i; &#125; Leaf increament() &#123; i++; // 这个方法要求的返回类型是Leaf本身的类型,也就是指向Leaf的一个引用,既然是要指向Leaf的一个引用,return this,this指向自身,自身又是Leaf.因此使用 return this 返回的值就是 Leaf本身 return this; &#125; void print() &#123; System.out.println("i = " + i); &#125; public static void main(String[] args) &#123; Leaf leaf = new Leaf(100); leaf.increament().increament().print(); &#125;&#125; 在内存中分析main方法的执行过程* Leaf leaf = new Leaf(100); 程序执行到这里的时候，栈空间里面有一个变量leaf，它指向了我们new出来的在堆空间里面的Leaf对象。new这个Leaf对象的时候，调用了构造方法Leaf(),这个构造方法里面有一个形参 i，所以在栈空间里面给构造方法分配有一小块内存，名字叫i用来装传递过来的实参。这里传过来的实参是100，所以 i 里面装的值就是100。得到这个值之后，构造方法继续执行，执行 this.i = i; 这里就是把栈空间里面的 i 的值通过值传递给Leaf对象里面的成员变量i，所以成员变量 i 的值也变成了100。 leaf.increament().increament().print(); 详情见参考博文 四. 总结​ this一般出现在方法里面，当这个方法还没有调用的时候，this指的是谁并不知道。但是实际当中，你如果new了一个对象出来，那么this指的就是当前这个对象。对哪个对象调用方法，this指的就是调用方法的这个对象（你对哪个对象调用这个方法，this指的就是谁）。如果再new一个对象，这个对象他也有自己的this，他自己的this就当然指的是他自己了。 参考博文​ JAVA中this的三种用法的详解 ​ java基础学习总结——this关键字]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---多态]]></title>
    <url>%2F2019%2F03%2F15%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[一. 概念多态是同一个行为具有多个不同表现形式或形态的能力(同一个事件发生在不同的对象上会产生不同的结果) 例子 现实中，比如我们按下 F1 键这个动作: 1. 如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档; 2. 如果当前在 Word 下弹出的就是 Word 帮助; 3. 在 Windows 下弹出的就是 Windows 帮助和支持。 Java中操作符 +: 1. 可以作为算数运算; 2. 可以作为字符串连接 Java中类的多态: 父类引用指向子类对象 二. 观察类的多态现象范例MagicPotion.java12345public class MagicPotion extends Item&#123; public void effect()&#123; System.out.println("蓝瓶使用后，可以回魔法"); &#125;&#125; LifePotion.java12345public class LifePotion extends Item &#123; public void effect()&#123; System.out.println("血瓶使用后，可以回血"); &#125;&#125; Item.java1234567891011121314151617181920public class Item &#123; public void effect() &#123; System.out.println("物品使用后，可以有效果 "); &#125; public static void main(String[] args) &#123; Item i1= new LifePotion(); Item i2 = new MagicPotion(); System.out.print("i1 是Item类型，执行effect打印:"); i1.effect(); System.out.print("i2 也是Item类型，执行effect打印:"); i2.effect(); &#125;&#125;/** * 打印结果: * i1 是Item类型，执行effect打印:血瓶使用后，可以回血 * i2 也是Item类型，执行effect打印:蓝瓶使用后，可以回魔法 */ 观察类的多态现象 i1和i2都是Item类型 都调用effect方法 输出不同的结果 多态: 都是同一个类型，调用同一个方法，却能呈现不同的状态 三. 多态存在的三个必要条件3.1 继承类的多态发生在父类调用指向子类对象, 所以一定有子类继承父类 3.2 重写子类对父类中某些方法进行重新定义 父类调用相同的方法, 实现却不一样,所以必定有重写 3.3 向上转型将子类的引用赋给父类对象(父类引用指向子类对象) 四. 多态的实现方式4.1 重写子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。 4.2 接口 生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。 java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。 4.3 抽象类和抽象方法五. 深入理解多态也叫动态绑定 : 动态绑定是指在 执行期间 (而非编译期间) 判断所引用对象的实际类型，根据其实际的类型调用其相应的方法 总结动态绑定（多态）动态绑定是指在“执行期间”（而非编译期间）判断所引用的实际对象类型，根据其实际的类型调用其相应的方法。所以实际当中找要调用的方法时是动态的去找的，new的是谁就找谁的方法，这就叫动态绑定。动态绑定帮助我们的程序的可扩展性达到了极致 六. 多态存在的意义范例1假设你要设计一个通用框架，这个框架会涉及到数据库的操作，但是你不能限定用户用哪个数据库，这个时候你就可以用到多态。 你可以设计一个接口：DataBaseDao 然后，每个不同的数据库，你可以编写接口的实现类，比如：SQLServerDao, MySqlDao, DB2Dao等等当用户使用你框架的时候，他就可以用多态，实现自己的数据库连接功能： 123 // 针对SQLServer的接口实现，这里dao就是多态DaoBaseDao dao = new SQLServerDao(); dao.connect(); 范例2实例: 【超经典】Java多态有什么好处？怎样用？ 参考博文​ java基础学习总结——多态(动态绑定) ​ Java 多态 ​ 接口与继承 ​ java提高篇(四)—–理解java的三大特性之多态]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---反射]]></title>
    <url>%2F2019%2F03%2F15%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[一. 什么是反射​ 反射之中包含了一个「反」字，所以想要解释反射就必须先从「正」开始解释。 1.1 正射​ 一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。 正射范例1234// 进行类对象的初始化，可以理解为「正」。Apple apple = new Apple(); //直接初始化，「正射」apple.setPrice(5);System.out.println("Apple Price:" + apple.getPrice()); 1.2 反射​ 反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。 这时候，我们使用 JDK 提供的反射 API 进行反射调用 反射范例123456789101112131415// 使用反射获取一个对象的步骤：// 1. 获取类的 Class 对象, 类对象Class clz = Class.forName("how2j10.Apple");// 2. 根据 Class 对象实例获取 Constructor 对象, 构造器Constructor appleConstructor = clz.getConstructor();// 3. 使用 Constructor 对象的 newInstance 方法获取反射类对象, 通过构造器实例化Object appleObj = appleConstructor.newInstance();// 如果要调用某一个方法，则需要经过下面的步骤// 1. 获取方法的 Method 对象Method setPriceMethod = clz.getMethod("setPrice", int.class);// 2. 利用 invoke 方法调用方法setPriceMethod.invoke(appleObj, 14);Method getPriceMethod = clz.getMethod("getPrice");System.out.println("Apple Price:" + getPriceMethod.invoke(appleObj)); ​ 上面两段代码的执行结果，其实是完全一样的。 ​ 但是其思路完全不一样，第一段代码在未运行时就已经确定了要运行的类（Apple），而第二段代码则是在运行时通过字符串值才得知要运行的类（com.chenshuyi.reflect.Apple）。 什么是反射？ 反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。 二. 获取反射中的 Class 对象(类对象)2.1 类对象​ 概念: 类对象用于提供类本身的信息，比如有几种构造方法， 有多少属性，有哪些普通方法 什么是类对象 对象之间的区别: garen和teemo都是Hero对象，他们的区别在于，各自有不同的名称，血量，伤害值。 类之间的区别: Hero和Item都是类，他们的区别在于有不同的方法，不同的属性。 ==类对象，就是用于描述这种类，都有什么属性，什么方法的== 在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。 2.2 获取class对象(类对象) 在 Java API 中，获取 Class 类对象有三种方法 在一个JVM中，一种类，只会有一个类对象存在。所以三种方式取出来的class对象，都是一样的。 方法范例1234567891011121314// how2j10 是包名, Apple 是类名String className = "how2j10.Apple";// 1. 使用 Class.forName 静态方法。当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。Class clz = Class.forName(className);// 2. 使用 .class 方法。 这种方法只适合在编译前就知道操作的 Class。Class clz = Apple.class;// 3. 第三种，使用类对象的 getClass() 方法。Class clz = new Apple().getClass();System.out.println("clz的值为:" + clz);// 打印结果: clz的值为:class how2j10.Apple 2.3 注意:​ 获取类对象的时候，会导致类属性被初始化 ​ 无论什么途径获取类对象，都会导致静态属性被初始化，而且只会执行一次。（除了直接使用 Class c = Hero.class 这种方式，这种方式不会导致静态属性被初始化） 三. 通过反射获取构造方法并使用3.1 获取单个的构造方法，并调用： public Constructor getConstructor(Class... parameterTypes) : 获取单个的”公有的”构造方法： public Constructor getDeclaredConstructor(Class... parameterTypes): 获取“某个构造方法”可以是私有的，或受保护、默认、公有 范例12// 获取构造器Constructor appleConstructor = clz.getConstructor(); 3.3 调用构造方法：​ newInstance是 Constructor类的方法（管理构造函数的类） api的解释为： newInstance(Object... initargs) : 使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。 它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象。并为之调用 范例12// 通过构造器实例化,使用 Constructor 对象的 newInstance 方法获取反射类对象Object appleObj = appleConstructor.newInstance(); 四. 获取成员变量4.1 获取成员变量并调用 批量的 Field[] getFields(): 获取所有的”公有字段” Field[] getDeclaredFields(): 获取所有字段，包括：私有、受保护、默认、公有 获取单个的 public Field getField(String fieldName) : 获取某个”公有的”字段； public Field getDeclaredField(String fieldName) : 获取某个字段***(可以是私有的) 4.2 设置字段的值​ Field --&gt; public void set(Object obj,Object value) 参数说明： obj : 要设置的字段所在的对象； value : 要为字段设置的值； 范例12345678910111213141516171819public class Fields &#123; public static void main(String[] args) throws Exception &#123; // 1.获取Class对象 Class stuClass = Class.forName("fanshe.field.Student"); // 2.获取字段 System.out.println("********获取公有字段**并调用*********"); Field f = stuClass.getField("name"); System.out.println(f); // 3.获取一个对象 // 产生Student对象 --&gt; Student stu = new Student(); Object obj = stuClass.getConstructor().newInstance(); // 4.为字段设置值 // 为Student对象中的name属性赋值 --&gt; stu.name = "刘德华" f.set(obj, "刘德华"); &#125;&#125; 五. 获取成员方法并调用5.1 获取成员方法： 批量的批量的 public Method[] getMethods() : 获取所有”公有方法”；（包含了父类的方法也包含Object类） public Method[] getDeclaredMethods() : 获取所有的成员方法，包括私有的(不包括继承的) 获取单个的： public Method getMethod(String name,Class&lt;?&gt;... parameterTypes) 参数说明 name : 方法名； Class … : 形参的Class类型对象 public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes) 5.2 成员方法调用​ Method --&gt; public Object invoke(Object obj,Object... args) 参数说明 obj : 要调用方法的对象； args : 调用方式时所传递的实参； 12345678910111213141516171819202122public class MethodClass &#123; public static void main(String[] args) throws Exception &#123; // 1.获取Class对象 Class stuClass = Class.forName("fanshe.method.Student"); System.out.println("***************获取公有的show1()方法*******************"); //2. 获取方法 Method m = stuClass.getMethod("show1", String.class); System.out.println(m); // 3.实例化一个Student对象 Object obj = stuClass.getConstructor().newInstance(); // 4.方法的调用,一个是要调用的对象（获取有反射），一个是实参 m.invoke(obj, "刘德华"); System.out.println("***************获取私有的show4()方法******************"); m = stuClass.getDeclaredMethod("show4", int.class); System.out.println(m); m.setAccessible(true);//解除私有限定 Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参 System.out.println("返回值：" + result); &#125;&#125; 六. 通过反射运行配置文件内容6.1 反射的作用 我们利用反射和配置文件，可以使：应用程序更新时，对源码无需进行任何修改 我们只需要将新类发送给客户端，并修改配置文件即可 代码实现student类12345public class Student &#123; public void show()&#123; System.out.println("is show()"); &#125;&#125; 配置文件以 txt 文件为例子（pro.txt） 12className = cn.fanshe.StudentmethodName = show 测试类1234567891011121314151617181920public class Demo &#123; public static void main(String[] args) throws Exception &#123; // 1.通过反射获取Class对象 Class stuClass = Class.forName(getValue("className")); //"cn.fanshe.Student" // 2.获取 show()方法 Method m = stuClass.getMethod(getValue("methodName")); //show // 3.调用show()方法 m.invoke( stuClass.getConstructor().newInstance()); &#125; // 此方法接收一个 key，在配置文件中获取相应的 value public static String getValue(String key) throws IOException&#123; Properties pro = new Properties();//获取配置文件的对象 FileReader in = new FileReader("pro.txt");//获取输入流 pro.load(in);//将流加载到配置文件对象中 in.close(); return pro.getProperty(key);//返回根据key获取的value值 &#125;&#125;// 打印结果: is show() 需求​ 当我们升级这个系统时，不要Student类，而需要新写一个Student2的类时，这时只需要更改pro.txt的文件内容就可以了。代码就一点不用改动 要替换的student2类12345public class Student2 &#123; public void show2()&#123; System.out.println("is show2()"); &#125;&#125; 配置文件更改为12className = cn.fanshe.Student2methodName = show2 控制台输出：1// 打印结果: is show2() 参考博文​ 大白话说Java反射：入门、使用、原理 ​ Java基础之—反射（非常重要） ​ how2j ​ Java 反射机制]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---对象转型]]></title>
    <url>%2F2019%2F03%2F15%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一. 对象转型介绍1.1 解释把一种形式转成另外一种形式就叫转型 基础数据类型的转型, (例如: 把 float 类型转成 int 类型，把 float 类型转成 double 类型) 对象领域里面对象之间的转型。 对象转型分为两种： 向上转型 向下转型 二. 向上转型2.1 定义:​ 子类引用的对象转换为父类类型称为向上转型, 通俗地说就是是将子类对象转为父类对象.父类对象可以是接口 2.2 解释​ 比如说我有两个类，一个是父类Animal，另一个是Dog类为子类. Animal c = new Dog(); 2.3 实例12345678910public class TestObjectShift &#123; public static void main(String[] args)&#123; Animal a = new Animal("name"); Dog d = new Dog("dogname", "black"); // 向上转型, a这个引用不指向Animal类的实例对象了，而是指向了Dog这个类的一个实例对象 a = new Dog("bigyellow", "yellow"); &#125;&#125; 注意 一个父类(基类)对象的引用是不可以访问其子类对象新增加的成员(属性和方法)的。 三. 对象的向下转型3.1 定义父类引用的对象转换为子类类型成为向下转型 3.2 解释​ 比如说我有两个类，一个是父类Animal，另一个是Dog类为子类. Dog d1 = (Dog) a; 3.3 实例123456789101112131415161718public class TestObjectShift &#123; public static void main(String[] args)&#123; Animal a = new Animal("AnimalName"); Dog d = new Dog("dogName", "black"); // 向下转型 // 父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错， // 但是运行时会出现java.lang.ClassCastException错误 // Dog dd = (Dog) a; // 向下转型,父类引用的对象如果引用的是指向的子类对象，那么在向下转型的过程中是安全的。也就是编译是不会出错误的 // 这里使用强制转换，把指向Animal类的引用对象a转型成指向Dog类对象的引用， // 这样转型后的引用对象d1就可以直接访问Dog类对象里面的新增的成员了。 a = new Dog("bigyellow", "yellow"); Dog d1 = (Dog) a; &#125;&#125; 注意 如果父类引用的对象如果引用的是指向的子类对象，那么在向下转型的过程中是安全的。也就是编译是不会出错误的。 如果父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，但是运行时会出现java.lang.ClassCastException错误。它可以使用instanceof来避免出错此类错误。 四. 完整实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package test;class Animal &#123; public String name; public Animal(String name) &#123; this.name = name; &#125;&#125;class Cat extends Animal &#123; public String eyeColor; public Cat(String n, String c) &#123; super(n); // 调用父类Animal的构造方法 this.eyeColor = c; &#125;&#125;class Dog extends Animal &#123; // Dog类添加自己特有的属性 public String furColor; public Dog(String n, String c) &#123; super(n); // 调用父类Animal的构造方法 this.furColor = c; &#125;&#125;public class TestObjectShift &#123; public static void main(String[] args) &#123; Animal a = new Animal("AnimalName"); Cat c = new Cat("catName", "blue"); Dog d = new Dog("dogName", "black"); // a instanceof Animal这句话的意思是a是一只动物吗？ // a是Animal这个类里面的是一个实例对象，所以a当然是一只动物，其结果为true。 System.out.println(String.format("a instanceof Animal的结果是%s", a instanceof Animal)); // true // c是Cat类的实例对象的引用，即c代表的就是这个实例对象，所以“c是一只动物”打印出来的结果也是true。 System.out.println(String.format("c instanceof Animal的结果是%s", c instanceof Animal)); // true // 这里判断说“动物是一只猫”，不符合逻辑，所以打印出来的结果是false。 System.out.println(String.format("a instanceof Cat的结果是%s", a instanceof Cat)); // 向下转型 // 父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错， // 但是运行时会出现java.lang.ClassCastException错误 // Dog dd = (Dog) a; /** * 向上转型 a这个引用不指向Animal类的实例对象了，而是指向了Dog这个类的一个实例对象 * 这里也就是父类对象的引用指向了子类的一个实例对象。 */ a = new Dog("bigyellow", "yellow"); System.out.println(a.name); // bigyellow /** * 这里的furColor属性是子类在继承父类的基础上新增加的一个属性，是父类没有的。 * 因此这里使用父类的引用对象a去访问子类对象里面新增加的成员变量是不允许的， * 因为在编译器眼里，你a就是Animal类对象的一个引用对象，你只能去访问Animal类对象里面所具有的name属性， * 除了Animal类里面的属性可以访问以外，其它类里面的成员变量a都没办法访问。 * 这里furColor属性是Dog类里面的属性，因此你一个Animal类的引用是无法去访问Dog类里面的成员变量的， * 尽管你a指向的是子类Dog的一个实例对象，但因为子类Dog从父类Animal继承下来， * 所以new出一个子类对象的时候，这个子类对象里面会包含有一个父类对象， * 因此这个a指向的正是这个子类对象里面的父类对象，因此尽管a是指向Dog类对象的一个引用， * 但是在编译器眼里你a就是只是一个Animal类的引用对象，你a就是只能访问Animal类里面所具有的成员变量， 别的你都访问不了。 * 因此一个父类(基类)对象的引用是不可以访问其子类对象新增加的成员(属性和方法)的。 */ // System.out.println(a.furColor); // 这里判断说“a是一只Dog”是true。 因为instanceof探索的是实际当中你整个对象到底是什么东西， // 并不是根据你的引用把对象看出什么样来判断的。 System.out.println(String.format("a instanceof Dog的结果是%s", a instanceof Dog));// true // 向下转型,父类引用的对象如果引用的是指向的子类对象，那么在向下转型的过程中是安全的。也就是编译是不会出错误的 // 这里使用强制转换，把指向Animal类的引用对象a转型成指向Dog类对象的引用， // 这样转型后的引用对象d1就可以直接访问Dog类对象里面的新增的成员了。 Dog d1 = (Dog) a; System.out.println(d1.furColor); // yellow &#125;&#125; 详细解释见 参考博文 总结对象转型可以使父类对象的引用可以指向子类对象，给程序带来了比较好的可扩展性：我们可以在一个方法的参数里面定义父类的引用，然后实际当中传的时候传的是子类的对象，然后我们再在方法里面判断这个传过来的子类对象到底属于哪个子类，然后再去执行这个子类里面的方法或者调用这个子类里面的成员变量，因此程序的可扩展性比单独定义好多个方法要好一些。不过这个可扩展性还没有达到最好，使用多态就可以让程序的扩展性达到极致。 参考博文​ java上转型和下转型（对象的多态性）]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---框架图解]]></title>
    <url>%2F2019%2F03%2F14%2FJavaWeb-%E6%A1%86%E6%9E%B6%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. MVC 模式 2. sevlet]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JSP指令]]></title>
    <url>%2F2019%2F03%2F14%2FJavaWeb---JSP%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一、JSP 指令简介 JSP指令（directive）是为 JSP 引擎而设计的，它们并不直接产生任何可见输出，而只是告诉引擎 如何处理JSP页面中的其余部分。 在 JSP 2.0规范中共定义了三个指令： page指令 Include指令 taglib指令 JSP指令的基本语法格式：&lt;%@ 指令 属性名=”值” %&gt; 例如12345678&lt;%@ page contentType="text/html;charset=gb2312"%&gt;&lt;!--如果一个指令有多个属性，这多个属性可以写在一个指令中，也可以分开写--&gt;&lt;%@ page contentType="text/html;charset=gb2312"%&gt;&lt;%@ page import="java.util.Date"%&gt;&lt;!--也可以写作--&gt;&lt;%@ page contentType="text/html;charset=gb2312" import="java.util.Date"%&gt; 二、Page指令​ page指令 用于定义 JSP 页面的==各种属性== ，无论page指令出现在JSP页面中的什么地方，它作用的都是整个JSP页面，为了保持程序的可读性和遵循良好的编程习惯，page指令最好是放在整个JSP页面的起始位置。 范例123456789101112131415161718&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!--指令完整语法--&gt;&lt;%@ page [ language="java" ] [ extends="package.class" ] [ import="&#123;package.class | package.*&#125;, ..." ] [ session="true | false" ] [ buffer="none | 8kb | sizekb" ] [ autoFlush="true | false" ] [ isThreadSafe="true | false" ] [ info="text" ] [ errorPage="relative_url" ] [ isErrorPage="true | false" ] [ contentType="mimeType [ ;charset=characterSet ]" | "text/html ; charset=ISO-8859-1" ] [ pageEncoding="characterSet | ISO-8859-1" ] [ isELIgnored="true | false" ] &lt;!--是否忽略 EL 表达式--&gt;%&gt; 三. include指令在JSP中对于包含有两种语句形式： @include 指令 &lt;jsp:include&gt; 指令 3.1 @include指令 @include可以包含任意的文件，当然，只是把文件的内容包含进来。 include指令用于引入其它JSP页面，如果使用include指令引入了其它JSP页面，那么JSP引擎将把这两个JSP翻译成一个servlet。所以include指令引入通常也称之为静态引入。 语法： 12&lt;!--其中的file属性用于指定被引入文件的路径。路径以“/”开头，表示代表当前web应用。--&gt;&lt;%@ include file="relativeURL"%&gt; include指令细节注意问题： 被引入的文件必须遵循 JSP 语法。 被引入的文件可以使用任意的扩展名，即使其扩展名是html，JSP引擎也会按照处理jsp页面的方式处理它里面的内容，为了见明知意，JSP规范建议使用 .jspf（JSP fragments(片段)）作为静态引入文件的扩展名。 由于使用include指令将会涉及到2个JSP页面，并会把2个JSP翻译成一个servlet，所以这2个JSP页面的指令不能冲突(除了pageEncoding和导包除外)。 范例 新建head.jspf页面和foot.jspf页面，分别作为jsp页面的头部和尾部，存放于WebRoot下的jspfragments文件夹中，代码如下： head.jspf代码： 12&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;h1 style="color:red;"&gt;网页头部&lt;/h1&gt; foot.jspf代码： 12&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;h1 style="color:blue;"&gt;网页尾部&lt;/h1&gt; 在WebRoot文件夹下创建一个IncludeTagTest.jsp页面，在IncludeTagTest.jsp页面中使用@include指令引入head.jspf页面和foot.jspf页面，代码如下： 1234567891011121314&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;jsp的Include指令测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%--使用include标签引入引入其它JSP页面--%&gt; &lt;%@include file="/jspfragments/head.jspf" %&gt; &lt;h1&gt;网页主体内容&lt;/h1&gt; &lt;%@include file="/jspfragments/foot.jspf" %&gt; &lt;/body&gt;&lt;/html&gt; 3.2 总结 @include 指令 使用@include可以包含任意的内容，文件的后缀是什么都无所谓。这种把别的文件内容包含到自身页面的@include语句就叫作静态包含，作用只是把别的页面内容包含进来，属于静态包含 3.3 jsp:include指令 jsp:include指令为动态包含，如果被包含的页面是JSP，则先处理之后再将结果包含，而如果包含的是非*.jsp文件，则只是把文件内容静态包含进来，功能与@include类似。后面再具体介绍 四. taglib 指令4.1 引入Taglib 指令是定义一个标签库以及其自定义标签的前缀.需要导入standard.jar ; jsp-api.jar 两个包 在 JSP 页面中使用第三方的标签库时，需要使用 taglib 指令来 “导包”。例如： 1&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt; 解释 prefix : 标签库别名 uri : 是由第三方标签库定义的，所以你需要知道第三方定义的uri 4.2 标签库引入 jsp 文件时 uri 有两种写法 自定义 标准定义 当打开一个tld文件时，在文件的头部会有一个uri节点，里面的内容即为uri的标准定义。 使用标准定义的优点在于，不用在web.xml下加上上面的代码 源码 Referenced Library/standard.jar/META-INF/c.tld12&lt;short-name&gt;c&lt;/short-name&gt;&lt;uri&gt;http://java.sun.com/jsp/jstl/core&lt;/uri&gt; jsp12345678910111213&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt; &lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt; &lt;!DOCTYPE&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;collection&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 参考博文​ javaweb学习总结(十六)——JSP指令]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JSP基础语法]]></title>
    <url>%2F2019%2F03%2F14%2FJavaWeb---JSP%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[​ 任何语言都有自己的语法，JAVA 中有，JS P虽然是在JAVA上的一种应用，但是依然有其自己扩充的语法，而且在 JSP 中，所有的 JAVA 语句都可以使用。 一. JSP 模版元素 JSP 页面中的 HTML 内容 称之为 JSP 模版元素 。 JSP 模版元素定义了网页的 基本骨架 ，即定义了页面的结构和外观。 二、JSP表达式 JSP 脚本表达式（expression）用于将程序数据输出到客户端 ​ 语法：&lt;%= 变量或表达式 %&gt; 举例：输出当前系统时间: 1&lt;%= new java.util.Date() %&gt; JSP引擎在翻译脚本表达式时，会将程序数据转成字符串，然后在相应位置用out.print(…) 将数据输给客户端。 JSP脚本表达式中的变量或表达式后面不能有分号（;）。 三、JSP脚本片断 JSP脚本片断(scriptlet)用于在JSP页面中编写多行Java代码。 语法1234&lt;!-- 在&lt;% %&gt;中可以定义变量、编写语句，不能定义方法--&gt;&lt;% 多行java代码 %&gt; 范例: 在Scriptlet中定义变量、编写语句 123456789&lt;% int sum=0;//声明变量 /*编写语句*/ for (int i=1;i&lt;=100;i++)&#123; sum+=i; &#125; out.println("&lt;h1&gt;Sum="+sum+"&lt;/h1&gt;");%&gt; 注意事项 JSP脚本片断中只能出现java代码，不能出现其它模板元素， JSP引擎在翻译JSP页面中，会将JSP脚本片断中的Java代码将被原封不动地放到Servlet的_jspService方法中。 JSP脚本片断中的Java代码必须严格遵循Java语法，例如，每执行语句后面必须用分号（;）结束。 在一个 JSP 页面中可以有多个脚本片断，在两个或多个脚本片断之间可以嵌入文本、HTML标记和其他JSP元素。 四、JSP声明JSP页面中编写的所有代码，默认会翻译到 servlet 的 service 方法中， 而 JSP 声明中的 java代码 被翻译到 _jspService方法的外面。 语法123&lt;%！ java代码%&gt; ​ 所以，JSP声明可用于定义JSP页面转换成的Servlet程序的静态代码块、成员变量和方法 。 多个静态代码块、变量和函数可以定义在一个JSP声明中，也可以分别单独定义在多个JSP声明中。JSP隐式对象的作用范围仅限于Servlet的 _jspService 方法，所以在 JSP 声明中不能使用这些隐式对象。 范例1234567891011121314151617&lt;%! static &#123; System.out.println("loading Servlet!"); &#125; private int globalVar = 0; public void jspInit()&#123; System.out.println("initializing jsp!"); &#125;%&gt;&lt;%! public void jspDestroy()&#123; System.out.println("destroying jsp!"); &#125;%&gt; 五. JSP注释在 JSP 中，注释有两大类： 显式注释：直接使用HTML风格的注释：&lt;!- - 注释内容**- -&gt; 隐式注释：直接使用JAVA的注释：//、/*……***/** JSP自己的注释：&lt;%- -注释内容- -%&gt; 范例1234567891011&lt;!--这个注释可以看见--&gt;&lt;% //JAVA中的单行注释 /* JAVA中的多行注释 */%&gt;&lt;%--JSP自己的注释--%&gt; 区别 ​ HTML的注释在浏览器中查看源文件的时候是可以看得到的，而JAVA注释和JSP注释在浏览器中查看源文件时是看不到注释的内容 参考博文​ javaweb学习总结(十五)——JSP基础语法]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JavaWeb开发入门]]></title>
    <url>%2F2019%2F03%2F14%2FJavaWeb---JavaWeb%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[一. 基本概念1.1 WEB 开发的相关知识 WEB，在英语中web即表示网页的意思，它用于表示Internet主机上供外界访问的资源。 Internet上供外界访问的Web资源分为： 静态web资源（如html 页面）：指web页面中供人们浏览的数据始终是不变的。 动态web资源：指web页面中供人们浏览的数据是** 由程序产生的，不同时间点访问web页面看到的内容各不相同**。 静态web资源开发技术：Html 常用动态web资源开发技术：JSP/Servlet、ASP、PHP等 在 Java 中，动态web资源开发技术统称为 ==Javaweb==。 1.2 WEB应用程序 WEB应用程序指供浏览器访问的程序，通常也简称为web应用。例如有a.html 、b.html…..多个web资源，这多个web资源用于对外提供服务，此时应把这多个web资源放在一个目录中，以组成一个web应用（或web应用程序） 一个web应用由多个静态web资源和动态web资源组成，如:html、css、js文件，Jsp文件、java程序、支持jar包、配置文件等等。 Web应用开发好后，若想供外界访问，需要把web应用所在目录交给web服务器管理，这个过程称之为虚似目录的映射 二. WEB服务器2.1 WEB服务器简介 1. Web服务器是指驻留于因特网上某种类型计算机的程序，是可以向发出请求的浏览器提供文档的程序。当Web浏览器（客户端）连到服务器上并请求文件时，服务器将处理该请求并将文件反馈到该浏览器上，附带的信息会告诉浏览器如何查看该文件（即文件类型）。 2、服务器是一种被动程序：只有当Internet上运行在其他计算机中的浏览器发出请求时，服务器才会响应。 2.2、常见的Web服务器介绍1. WebLogic2. WebSphere3. Tomcat TomcatTomcat是一个实现了JAVA EE标准的最小的WEB服务器，是Apache 软件基金会的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。因为Tomcat 技术先进、性能稳定，而且开源免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。学习JavaWeb开发一般都使用Tomcat服务器，该服务器支持全部JSP以及Servlet规范，启动界面如图： 4. IIS 学习web开发，需要先安装一台web服务器，然后再在web服务器中开发相应的web资源，供用户使用浏览器访问。 三. 搭建JavaWeb应用开发环境——Tomcat服务器3.1 疑问：学习web开发，为什么必须要先装一个WEB服务器？ 在本地计算机上随便创建一个 web 页面，用户是无法访问到的，但是如果启动 tomcat 服务器，把 web 页面放在 tomcat 服务器中，用户就可以访问了。这说明什么问题？ 1. 不管什么 web 资源，想被远程计算机访问，都必须有一个与之对应的网络通信程序，当用户来访问时，这个网络通信程序读取 web 资源数据，并把数据发送给来访者。 2. WEB 服务器就是这样一个程序，它用于完成底层网络通迅。使用这些服务器，We应用的开发者只需要关注web资源怎么编写，而不需要关心资源如何发送到客户端手中，从而极大的减轻了开发者的开发工作量。 3.2、下载和安装Tomcat服务器见参考博客参考博文​ JavaWeb学习总结(一)——JavaWeb开发入门]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JSP原理]]></title>
    <url>%2F2019%2F03%2F14%2FJavaWeb---JSP%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[一. 什么是 JSP？ JSP全称是 Java Server Pages ，它和 servle 技术一样，都是SUN公司定义的一种用于开发动态web资源的技术。 JSP 这门技术的最大的特点在于，写 jsp 就像在写 html ，但它相比 html 而言，html 只能为用户提供静态数据，而 Jsp 技术允许在页面中嵌套java代码，为用户提供动态数据。 二. JSP原理2.1 Web服务器是如何调用并执行一个jsp页面的？ 浏览器向服务器发请求，不管访问的是什么资源，其实都是在访问Servlet，所以当访问一个jsp页面时，其实也是在访问一个Servlet ​ 服务器在执行jsp的时候，首先==把jsp翻译成一个Servlet==，所以我们访问 jsp 时，其实不是在访问 jsp，而是在访问 jsp 翻译过后的那个Servlet 当我们通过浏览器访问index.jsp时，服务器首先将 index.jsp 翻译成一个index_jsp.class index_jsp 这个类是继承 org.apache.jasper.runtime.HttpJspBase 这个类的 HttpJspBase 类是继承 HttpServlet 的，所以index_jsp类也是一个Servlet，所以当浏览器访问服务器上的 index.jsp 页面时，其实就是在访问index_jsp 这个Servlet，index_jsp 这个 Servlet 使用_jspService 这个方法处理请求。 2.2 Jsp页面中的java代码服务器是如何执行的？ 在 jsp 中编写的 java 代码会被翻译到 _jspService 方法中去，当执行 _jspService方法处理请求时，就会执行在jsp编写的java代码了，所以Jsp页面中的java代码服务器是通过调用_jspService方法处理请求时执行的。 参考博文​ javaweb学习总结(十四)——JSP原理]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试经典题目(11-15题)]]></title>
    <url>%2F2019%2F03%2F14%2FJava%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE(11-15%E9%A2%98)%2F</url>
    <content type="text"><![CDATA[11. 进程和线程的区别是什么？答案: 通俗解释什么是进程和线程: 开个QQ，开了一个进程；开了迅雷，开了一个进程。 在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。 所以运行某个软件，相当于开了一个进程。在这个软件运行的过程里（在这个进程里），多个工作支撑的完成QQ的运行，那么这“多个工作”就是多个线程。 所以一个进程管着多个线程。 专业解释1. 进程是执行着的应用程序 2. 线程是进程内部的一个执行序列。 3. 一个进程可以有多个线程。线程又叫做轻量级进程。 线程与进程的区别归纳优质答案一 进程是运行中的程序，线程是进程的内部的一个执行序列 进程是资源分配的单元，线程是执行行单元(进程是资源分配的基本单位, 线程是调度的基本单位) 进程间切换代价大，线程间切换代价小 进程拥有资源多，线程拥有资源少 多个线程共享进程的资源 优质答案二 a.地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。 b.通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。 c.调度和切换：线程上下文切换比进程上下文切换要快得多。 d.在多线程OS中，进程不是一个可执行的实体。 知识补充1. 进程是什么？程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。 2. 进程和线程的并发层次不同：进程属于在处理器这一层上提供的抽象；线程则属于在进程这个层次上再提供了一层并发的抽象。 参考博文​ 进程与线程的一个简单解释 ​ 进程篇：进程和线程的本质和区别 ​ 深入理解进程和线程 ​ 线程与进程的区别 12. 创建线程有几种不同的方式？你喜欢哪一种？为什么？1. 方式 继承Thread类，重写run方法； 实现Runnable接口，重写run方法，但是比继承Thread类好用，实现接口还可以继承类，避免了单继承带来的局限性； 实现callable接口，重写call方法，有返回值。 使用实现了Executor接口的ThreadPoolExecutor来创建线程池。 2. 选择 一般情况下，常见的是第二种。 Runnable接口有如下好处： 避免点继承的局限，一个类可以继承多个接口。 适合于资源的共享 线程详细见: xxxxxx 参考博文​ 牛客网优质答案 时间: 2019.3.14 13. 概括的解释下线程的几种可用状态答: 新建(new)：新创建了一个线程对象。 可运行(runnable)：线程对象创建后，其他线程(比如main线程) 调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权。 运行(running)：可运行状态(runnable)的线程获得了 cpu 时间片(timeslice), 执行程序代码。 阻塞(block)：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，即让出了cpu 时间片(timeslice), 暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu 时间片(timeslice)转到运行(running)状态。阻塞的情况分三种： 等待阻塞：运行(running)的线程执行o.wait()方法, JVM会把该线程放入等待队列( waitting queue )中。 同步阻塞： 运行(running)的线程在获取对象的同步锁时, 若该同步锁被别的线程占用，则 JVM会把该线程放入锁池(lock pool)中。 其他阻塞: 运行(running)的线程执行 Thread.sleep(longms)或t.join() 方法，或者发出了I/O 请求时，JVM会把该线程置为阻塞状态。当 sleep() 状态超时、join() 等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 死亡(dead)：线程run()、 main()方法执行结束，或者因异常退出了 run() 方法，则该线程结束生命周期。死亡的线程不可再次复生。 14. 同步方法和同步代码块的区别是什么？答: 同步方法(粗粒度锁):由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用给方法前，要获取内置锁，否则处于阻塞状态。 修饰一般方法: 获取的是当前调用对象 this 上的锁, 代码: 123public synchronized void method ()&#123; // ...&#125; 修饰静态方法: 获取当前类的字节码对象上的锁, 代码: 123public static synchronized void method ()&#123; // ...&#125; 注: synchronized修饰静态方法，如果调用该静态方法，将锁住整个类 同步代码块(细粒度锁):即有synchronized修饰符修饰的语句块，被该关键词修饰的语句块，将加上内置锁。实现同步。 同步代码块可以指定获取哪个对象上的锁, obj 任意, 代码: 123synchronized (obj) &#123; //...&#125; 总结 同步是高开销的操作，因此尽量减少同步的内容。通常没有必要同步整个方法，同步部分代码块即可。 同步方法默认用this或者当前类class对象作为锁。 同步代码块可以选择以什么来加锁，比同步方法要更颗粒化，我们可以选择只同步会发生问题的部分代码而不是整个方法。 补: 为何使用同步？ java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（增删改查），将会导致数据的不准确，相互之间产生冲突。类似于在atm取钱，银行数据确没有变，这是不行的，要存在于一个事务中。因此加入了同步锁，以避免在该线程没有结束前，调用其他线程。从而保证了变量的唯一性，准确性。]]></content>
      <categories>
        <category>java面试常考题目</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java面试常考题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---Servlet开发(2)]]></title>
    <url>%2F2019%2F03%2F13%2FJavaWeb---Servlet%E5%BC%80%E5%8F%91(2)%2F</url>
    <content type="text"><![CDATA[一. ServletConfig讲解1.1. 配置Servlet初始化参数 在Servlet的配置文件 web.xml 中，可以使用一个或多个 &lt;init-param&gt; 标签为servlet配置一些初始化参数。 代码实例12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;ServletConfigDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;gacl.servlet.study.ServletConfigDemo1&lt;/servlet-class&gt; &lt;!--配置ServletConfigDemo1的初始化参数 --&gt; &lt;init-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;gacl&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;123&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; 1.2、通过 ServletConfig 获取 Servlet 的初始化参数 当 servle t配置了初始化参数后，web 容器在创建 servlet 实例对象时，会自动将这些初始化参数封装到 ServletConfig 对象中，并在调用 servlet 的 init 方法时，将 ServletConfig 对象传递给servlet。进而，我们通过 ServletConfig 对象就可以得到当前servlet的初始化参数信息。 例如： 123456789101112131415161718192021222324public class ServletConfigDemo1 extends HttpServlet &#123; // 定义ServletConfig对象来接收配置的初始化参数 private ServletConfig config; @Override public void init(ServletConfig config) throws ServletException &#123; this.config = config; &#125; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获取在 web.xml 中配置的初始化参数 // 获取指定的初始化参数 String paramVal = this.config.getInitParameter("name"); // 获取所有的初始化参数 Enumeration&lt;String&gt; e = config.getInitParameterNames(); while(e.hasMoreElements())&#123; String name = e.nextElement(); String value = config.getInitParameter(name); response.getWriter().print(name + "=" + value + "&lt;br/&gt;"); &#125; &#125;&#125; 二、ServletContext对象 WEB容器在启动时，它会为每个WEB应用程序都创建一个对应的 ServletContext 对象，它代表当前web应用。 ServletConfig 对象中维护了 ServletContext 对象的引用，开发人员在编写servlet时，可以通过ServletConfig.getServletContext 方法获得 ServletContext 对象。 由于一个 WEB 应用中的 所有 Servlet共享同一个 ServletContext 对象 ，因此 Servlet 对象之间可以通过ServletContext 对象来实现通讯 。ServletContext 对象通常也被称之为 context 域对象 三、ServletContext的应用 3.1、多个Servlet通过ServletContext对象实现数据共享范例: Demo1 和 Demo2 通过 ServletContext 对象实现数据共享 Demo112345678910111213141516/* * ServletConfig对象中维护了ServletContext对象的引用，开发人员在编写servlet时， * 可以通过ServletConfig.getServletContext方法获得ServletContext对象。 */public class ServletContextDemo1 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String data = "xdp_gacl"; // 获得ServletContext对象 ServletContext context = this.getServletConfig().getServletContext(); //将data存储到ServletContext对象中 context.setAttribute("data", data); &#125;&#125; Demo212345678910111213public class ServletContextDemo2 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获得ServletContext对象 ServletContext context = this.getServletContext(); // 从ServletContext对象中取出数据 String data = (String) context.getAttribute("data"); response.getWriter().print("data = " + data); &#125;&#125; 浏览器上输出结果: data = xdp_gacl 3.2 获取WEB应用的初始化参数在web.xml文件中使用标签配置WEB应用的初始化参数，如下所示： 范例 12345678910public class ServletContextDemo3 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; ServletContext context = this.getServletContext(); // 获取整个web站点的初始化参数 String contextInitParam = context.getInitParameter("name"); response.getWriter().print(contextInitParam); &#125;&#125; 3.3 用servletContext实现请求转发范例12345678910111213141516public class ServletContextDemo4 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String data = "&lt;h1&gt;&lt;font color='red'&gt;abcdefghjkl&lt;/font&gt;&lt;/h1&gt;"; response.getOutputStream().write(data.getBytes()); // 获取ServletContext对象 ServletContext context = this.getServletContext(); // 获取请求转发对象(RequestDispatcher) RequestDispatcher rd = context.getRequestDispatcher("/servlet/ServletContextDemo5"); rd.forward(request, response);//调用forward方法实现请求转发 &#125;&#125; 3.4利用ServletContext对象读取资源文件略 四. 在客户端缓存Servlet的输出略 参考博文​ javaweb学习总结(六)——Servlet开发(二)]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---Servlet开发(1)]]></title>
    <url>%2F2019%2F03%2F13%2FJavaWeb---Servlet%E5%BC%80%E5%8F%91(1)%2F</url>
    <content type="text"><![CDATA[一. Servlet简介Servlet是sun公司提供的一门用于 开发动态web资源的技术 若想开发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤： 编写一个 Java 类，实现 servlet 接口。 把开发好的 Java类部署到 web 服务器中。 按照一种约定俗成的称呼习惯，通常我们也把实现了servlet接口的java程序，称之为Servlet 二. Servlet的运行过程Servlet程序是由 WEB服务器 调用，web服务器 收到客户端的 Servlet 访问请求后: ​ ① Web服务器首先 检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第②步。 ​ ② 装载并创建该Servlet的一个实例对象。 ​ ③ 调用Servlet实例对象的 init()方法。 ​ ④ 创建一个用于封装 HTTP请求消息的 HttpServletRequest 对象 和一个 代表HTTP响应消息的 HttpServletResponse 对象 ，然后调用Servlet的service()方法并将 请求和响应对象 作为参数传递进去 ​ ⑤ WEB应用程序被 停止或重新启动之前，Servlet引擎将 卸载Servlet ，并在卸载之前调用Servlet的destroy()方法。 三. Servlet调用图 四. Servlet接口实现类 Servlet接口SUN公司定义了两个默认实现类，分别为：GenericServlet、HttpServlet。 ==HttpServlet== 指能够处理HTTP请求的servlet，它在原有Servlet接口上添加了一些与HTTP协议处理方法，它比Servlet接口的功能更为强大。因此开发人员在编写Servlet时，通常应继承这个类，而避免直接去实现Servlet接口。 HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。因此，开发人员在编写Servlet时，通常只需要覆写doGet或doPost方法，而不要去覆写service方法 五. Servlet开发注意细节4.1 Servlet访问URL映射配置 由于客户端是通过URL地址访问web服务器中的资源，所以Servlet程序若想被外界访问，必须把servlet程序映射到一个URL地址上，这个工作在==web.xml文件==中使用&lt;servlet&gt;元素和&lt;servlet-mapping&gt;元素完成。 &lt;servlet&gt;元素用于注册Servlet，它包含有两个主要的子元素：&lt;servlet-name&gt;和&lt;servlet-class&gt;，分别用于设置Servlet的注册名称和Servlet的完整类名。 &lt;servlet-mapping&gt;元素用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：&lt;servlet-name&gt;和&lt;url-pattern&gt;，分别用于指定Servlet的注册名称和Servlet的对外访问路径。 都是成对出现的 有注册,有映射 web.xml 是什么 web.xml文件用来初始化配置信息：比如Welcome页面、servlet、servlet-mapping、filter、listener、启动加载级别等 每个xml文件都有定义它书写规则的Schema文件，也就是说javaEE的定义 web.xml 所对应的 xml Schema 文件中定义了多少种标签元素，web.xml中就可以出现它所定义的标签元素，也就具备哪些特定的功能。 范例123456789&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;gacl.servlet.study.ServletDemo1&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/ServletDemo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 同一个Servlet可以被映射到多个URL上，即多个元素的子元素的设置值可以是同一个Servlet的注册名。 4.2 Servlet与普通Java类的区别 Servlet是一个供其他Java程序（Servlet引擎）调用的Java类，不能独立运行，它的运行完全由Servlet引擎来控制和调度。 针对客户端的多次Servlet请求，通常情况下，服务器只会创建一个Servlet实例对象，也就是说Servlet实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至web容器退出，servlet实例对象才会销毁。 在Servlet的整个生命周期内，Servlet的init()方法只被调用一次。而对一个Servlet的每次访问请求都导致Servlet引擎调用一次servlet的service()方法。对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。 参考博文​ javaweb学习总结(五)——Servlet开发(一) ​ web.xml文件的作用]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---继承]]></title>
    <url>%2F2019%2F03%2F13%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[一. 概念 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的 一些属性或方法 二. 类的继承格式123456// Java继承的关键字是：extendsclass 父类 &#123;&#125; class 子类 extends 父类 &#123;&#125; 需要注意的是 Java 不支持多继承，但支持多重继承(接口) 三. 继承的特性 子类拥有父类非 private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差） 四. 为什么需要继承 提高代码的 复用性 (复用性主要是可以多次使用，不用再多次写同样的代码）)。 提高程序的扩展性。 五. Java中子类能继承父类的私有属性吗答: 不能 Java官方文档的解释 : 子类 不能继承父类的私有属性，但是如果子类中公有的方法影响到了父类私有属性，那么私有属性是能够被子类使用的 12345678910111213141516171819202122232425class Father_ &#123; private String name;// 私有属性 public void tell() &#123; System.out.println(name + "is telling!"); &#125; private void speak() &#123; System.out.println(name + "is speaking!"); &#125;&#125;class Child extends Father_ &#123;&#125;public class TestJicheng &#123; public static void main(String[] args) &#123; Child c = new Child(); // tell方法是可以用的 c.tell(); //报错，父类的私有方法不可见 // c.speak(); &#125;&#125; 从继承的概念来说​ private和final不被继承 从内存的角度来说​ 类的一切都被继承(从父类构造方法被调用就知道了，因为new一个对象，就会调用构造方法，子类被 new 的时候就会调用父类的构造方法，所以从内存的角度来说，子类拥有一个完整的父类)。子类对象所引用的内存中有父类对象。 ​ 子类的对象是给父类的私有属性分配了空间的，但是没有访问的权限，不算是继承. 参考博文​ Java继承总结 ​ 菜鸟教程 ​ Java中子类能继承父类的私有属性吗？ ​ 知乎答案]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---抽象]]></title>
    <url>%2F2019%2F03%2F13%2Fjava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%8A%BD%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[一. 抽象的出现​ 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类 ​ 在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口 二.抽象方法​ 一种特殊的方法：它只有声明，而没有具体的实现 123// 声明格式// 抽象方法必须用abstract关键字进行修饰abstract void fun(); 抽象方法必须定义在抽象类中。 三. 抽象类2.1 概念​ 抽象方法的类(一个类含有抽象方法，则称这个类为抽象类), 抽象类必须在类前用 abstract关键字 修饰。 一个类不包含抽象方法，只是用abstract修饰的话也是抽象类。也就是说抽象类不一定必须含有抽象方法。 2.2 特点 子类继承父类时，如果这个父类里面有抽象方法，并且子类觉得可以去实现父类的所有抽象方法，那么子类必须去实现父类的所有抽象方法, 父类里面的抽象方法，子类如果觉得实现不了，那么把就子类也声明成一个抽象类 因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。父类里面的方法是抽象的，那么对于整个类来说，它就有一个没有实现的方法，这个方法不知道怎么去实现，那么这个类是就是残缺不全的，因此这个类应该被定义为一个抽象类 含有抽象方法的类必须被声明为抽象类 不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法 抽象类必须被继承 抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情 抽象方法必须被重写 从某种意义上来说，抽象方法就是被用来重写的，所以在父类声明的抽象方法一定要在子类里面重写 范例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * 父类Animal * 在class的前面加上abstract，即声明成这样：abstract class Animal * 这样Animal类就成了一个抽象类了 */abstract class Animal &#123; public String name; public Animal(String name) &#123; this.name = name; &#125; /** * 抽象方法 * 这里只有方法的定义，没有方法的实现。 */ public abstract void enjoy(); &#125;/** * 这里的子类Cat从抽象类Animal继承下来，自然也继承了Animal类里面声明的抽象方法enjoy()， * 但子类Cat觉得自己去实现这个enjoy()方法也不合适，因此它把它自己也声明成一个抽象的类， * 那么，谁去实现这个抽象的enjoy方法，谁继承了子类，那谁就去实现这个抽象方法enjoy()。 */abstract class Cat extends Animal &#123; // Cat添加自己独有的属性 public String eyeColor; public Cat(String n, String c) &#123; super(n);//调用父类Animal的构造方法 this.eyeColor = c; &#125;&#125;/** * 子类BlueCat继承抽象类Cat，并且实现了从父类Cat继承下来的抽象方法enjoy */class BlueCat extends Cat &#123; public BlueCat(String n, String c) &#123; super(n, c); &#125; // 实现了抽象方法enjoy @Override public void enjoy() &#123; System.out.println("蓝猫叫..."); &#125; &#125;/** * 子类Dog继承抽象类Animal，并且实现了抽象方法enjoy */class Dog extends Animal &#123; // Dog类添加自己特有的属性 public String furColor; public Dog(String n, String c) &#123; super(n);//调用父类Animal的构造方法 this.furColor = c; &#125; @Override public void enjoy() &#123; System.out.println("狗叫...."); &#125;&#125;public class TestAbstract &#123; public static void main(String[] args) &#123; /** * 把Cat类声明成一个抽象类以后，就不能再对Cat类进行实例化了， * 因为抽象类是残缺不全的，缺胳膊少腿的，因此抽象类不能被实例化。 */ //Cat c = new Cat("Catname","blue"); Dog d = new Dog("dogname","black"); d.enjoy();//调用自己实现了的enjoy方法 BlueCat c = new BlueCat("BlueCatname","blue"); c.enjoy();//调用自己实现了的enjoy方法 &#125;&#125; 2.3 抽象类和普通类的区别： 抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法,没有意义），缺省情况下默认为public 抽象类不能用来创建对象 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。 参考博文​ Java抽象类与接口的区别 ​ java基础学习总结——抽象类 ​ 深入理解Java的接口和抽象类]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---接口]]></title>
    <url>%2F2019%2F03%2F13%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[一. 概念 官方解释: Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能） 通俗理解: 接口可以理解为一种特殊的抽象类(100%的抽象类, 所有的方法都是抽象方法)，里面全部是由全局常量和公共的抽象方法(方法的定义)所组成,而没有变量和方法的实现 范例123456789101112131415/** * java中定义接口 * 把一个类定义成一个接口的格式是把声明类的关键字class用声明接口的关键字interface替换掉即可 */public interface JavaInterfaces &#123; // 常量的声明格式, 都是公共的、静态的，不能改变的 // 下面两种都可以,因为在接口里面默认的属性声明都是“public static final”的 public static final int id=10; int id=10; //方法的声明 // 在接口里面的声明的方法都是抽象方法,默认是抽象的，因此在接口里面的抽象方法都会把abstract关键字省略掉 // 在接口里面声明的抽象方法默认是“public(公共的) public void start();&#125; 二. 特点 接口指明了一个类必须要做什么和不能做什么，相当于类的蓝图 接口可以继承其他的接口,并添加新的属性和抽象方法. 抽象方法只能存在于抽象类或者接口中，但抽象类中却能存在非抽象方法，即有方法体的方法。接口是百分之百的抽象类 接口是解决Java无法使用多继承的一种手段,, 实际中更多的作用是制定标准的。 一个类可以实现多个接口, 接口里面的成员变量不专属于某个对象，都是静态的成员变量，是属于整个类的,不会存在对象之间互相冲突的问题。实现多个接口，也就实现了多重继承 见范例 接口和接口之间可以相互继承，类和类之间可以相互继承，类和接口之间，只能是类来实现接口 三. 重点 一个类如果要实现某个接口的话，那么它必须要实现这个接口中的所有方法。 不能直接去实例化一个接口，因为接口中的方法都是抽象的，是没有方法体的. 但是，我们可以使用接口类型的引用指向一个实现了该接口的对象，并且可以调用这个接口中的方法(Java多态的特性). 四. 接口的进一步理解​ 如果某个设备需要向电脑中读取或者写入某些东西，这些设备一般都是采用USB方式与电脑连接的，我们发现，只要带有USB功能的设备就可以插入电脑中使用了，那么我们可以认为USB就是一种功能，这种功能能够做出很多的事情（实现很多的方法），其实USB就可以看做是一种标准，一种接口，只要实现了USB标准的设备我就认为你已经拥有了USB这种功能。（因为你实现了我USB标准中规定的方法） 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344// 先声明USB接口：其中规定了要实现USB接口就必须实现接口规定实现的read( )和write( )这两个方法。interface USB &#123; void read(); void write();&#125;// 一个USB类实现USB接口。（实现其中的方法）class YouPan implements USB &#123; @Override public void read() &#123; System.out.println("U盘正在通过USB功能读取数据"); &#125; @Override public void write() &#123; System.out.println("U盘正在通过USB功能写入数据"); &#125;&#125;// 一个键盘类实现USB接口。（实现其中的方法）class JianPan implements USB &#123; @Override public void read() &#123; System.out.println("键盘正在通过USB功能读取数据"); &#125; @Override public void write() &#123; System.out.println("键盘正在通过USB功能写入数据"); &#125;&#125;// 测试public class Main &#123; public static void main(String[] args) &#123; // 生成一个实现可USB接口（标准）的U盘对象 YouPan youPan = new YouPan(); // 调用U盘的read( )方法读取数据 youPan.read(); // 调用U盘的write( )方法写入数据 youPan.write(); // 生成一个实现可USB接口（标准）的键盘对象 JianPan jianPan = new JianPan(); // 调用键盘的read( )方法读取数据 jianPan.read(); // 调用键盘的write( )方法写入数据 jianPan.write(); &#125;&#125; 参考博文​ java基础学习总结——接口 ​ JAVA基础——接口（全网最详细教程）]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试经典题目(6-10题)]]></title>
    <url>%2F2019%2F03%2F12%2FJava%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE(6-10%E9%A2%98)%2F</url>
    <content type="text"><![CDATA[6. Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？ 答案: 方法覆盖(重写)的原则： 重写方法的方法名称、参数列表必须与原方法的相同，返回类型可以相同也可以是原类型的子类型(从Java SE5开始支持)。 重写方法不能比原方法访问性差（即访问权限不允许缩小）。 重写方法不能比原方法抛出更多的异常。 被重写的方法 不能为final类型 ，因为final修饰的方法是无法重写的。 被重写的方法 不能为private ，否则在其子类中只是新定义了一个方法，并没有对其进行重写。 被重写的方法 不能为static 。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足重写条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足重写条件，但是仍然不会发生重写，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。 重写是 发生在运行时的 ，因为编译期编译器不知道并且没办法确定该去调用哪个方法，JVM会在代码运行的时候作出决定。 方法重载的原则： 方法名称必须相同。 参数列表必须不同（个数不同、或类型不同、参数类型排列顺序不同等）。 方法的返回类型可以相同也可以不相同。 仅仅返回类型不同不足以成为方法的重载。 重载是 发生在编译时的 ，因为编译器可以根据参数的类型来选择使用哪个方法。 重写和重载的不同： 方法重写要求参数列表必须一致，而方法重载要求参数列表必须不一致。 方法重写要求返回类型必须一致(或为其子类型)，方法重载对此没有要求。 方法重写只能用于子类重写父类的方法(覆盖者可能不会限制它所覆盖的方法的访问)，方法重载用于同一个类中的所有方法。 方法重写对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。 父类的一个方法只能被子类重写一次，而一个方法可以在所有的类中可以被重载多次。 重载是编译时多态，重写是运行时多态。 参考博客​ 牛客网优质答案 7. Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？答案: 什么是构造方法？主要作用:** 完成对象的初始化工作(如果写的类里面没有构造函数,那么编译器会默认加上一个无参数且方法体为空的构造函数) 特点 使用 new + 构造方法创建一个新的对象 构造函数是定义在 Java类中的一个用来 初始化对象 的函数 (new一个东西的时候，实际上你调用的是一个构造方法，构造方法就是把自己构造成一个新的对象，所以叫构造方法，构造一个新对象用的方法叫构造方法) 构造函数与类同名, 且没有返回值(构造方法的名字必须和类的名字完全一模一样，包括大小写,这个方法的名字和类名完全相同，并且没有返回值，也就是在这个方法前面不能写任何的方法的返回类型修饰符，连void都不可以写) 什么是构造方法重载？Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己 唯一的参数列表 。 什么是复制构造方法？复制构造函数C++中的复制构造函数通常有三种作用: 对象作为函数参数 对象作为函数返回值 使用一个对象对另一个对象初始化。 C++语法允许用户定义自己的复制构造函数以实现自定义的复制，比如说进行深复制。Java并不支持这样的复制构造函数。但是这并不代表Java中没有这种机制，在Java中Object类的clone()方法就是这种机制的体现 Java中不支持构造函数的复制。构造函数的复制属于C++的内容。 时间: 2019.3.12 8. Java支持多继承么？答案: Java中类不支持多继承，只支持单继承（即一个类只有一个父类）. Java中的 接口 支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能） 9. 接口和抽象类的区别是什么？答案: 相同点 类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。 接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。 抽象类可以在不提供接口方法实现的情况下实现接口。 语法层面上的区别 抽象类可以提供成员方法的实现细节(成员函数可以是private，protected或者是public)，而接口中只能存在public abstract 方法(默认是public的) 抽象类中的成员变量可以是各种类型的(包含非final的变量)，而接口中的成员变量只能是public static final类型的； 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法； 接口中所有的方法默认的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 设计层面上的区别 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 抽象类是对一种事物的抽象，即 对类抽象 ，而接口是 对行为的抽象 。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。 举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将飞行这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系 。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。 什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。 参考博文​ 牛客网优质答案 ​ Java抽象类与接口的区别 ​ 深入理解Java的接口和抽象类 时间: 2019.3.13 10. 什么是值传递和引用传递？答案: 一般认为,Java内的基础类型数据传递都是值传递. Java中实例对象的传递是引用传递 值传递，顾名思义传递的是其值，也可以理解为副本给你，任意修改，原本不变。 引用传递，顾名思义传递本身，或者说传递的是地址，修改的是本身或者是原本地址里的内容。 值传递，原本不改变，引用传递，原本改变 详细解析见：知乎答案参考博文: ​ 牛客网答案 时间: 2019.3.14]]></content>
      <categories>
        <category>java面试常考题目</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java面试常考题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构---顺序表的概念及实现]]></title>
    <url>%2F2019%2F03%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[顺序表特点​ 逻辑关系相邻的两个结点在 物理位置 上也相邻, 结点的逻辑次序和物理次序一致 实现方式​ 数组 数组的优缺点优点 存取速度快 O(1) 可以直接根据下标找到内存位置 缺点 浪费存储空间. 要求实现估计容量,比较困难,需要的空间过大,造成浪费,过小将导致溢出 插入和删除 运算不方便,效率低,时间复杂度为O(n) 顺序表的存储空间不容易扩充. 基本操作的实现 初始化数组 判断数组是否为空 判断数组是否满 显示数组内容 向数组中追加元素 向数组中指定的位置插入元素 删除指定元素 数组进行倒置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include&lt;stdbool.h&gt;// 首先定义结构体typedef struct Arr&#123; int len; // 数组能存取的最大元素个数 int currentNum; // 当前元素的个数 int * pBase; // 存储指向数组元素的指针 &#125; Arr;/** * 初始化数组* 所需要的参数: 结构体, 数组长度 * 让指针指向分配的数组* 判断判断内存是否分配失败,如果没有失败,其他两个参数进行赋值 */void initArr(Arr * pArr, int len) &#123; // 分配4*len字节长度的内存,这是pBase可以指向数组中的第一个元素，可以作为数组变量名称使用。 pArr-&gt;pBase = (int *)malloc(sizeof(int)*len); // 判断内存是否分配失败 if(NULL == pArr-&gt;pBase)&#123; printf("动态内存分配失败!") ; &#125; else &#123; // pArray 中的值进行初始化 pArr-&gt;len = len; pArr-&gt;currentNum = 0; &#125; &#125;/*** 判断数组是否为空* 判断条件应该是当前数组中的元素是不是 0 个 * 参数: 数组*/bool isEmpty(Arr * pArr) &#123; if(0 == pArr-&gt;currentNum)&#123; // 若数组为空,返回true return true; &#125; else &#123; return false; &#125;&#125;/*** 判断数组是否满了* 判断条件应该是 len 和 currentNum 是否相等*/bool isFull(Arr * pArr) &#123; // 如果满了,返回 true if(pArr-&gt;len == pArr-&gt;currentNum) &#123; return true; &#125; else &#123; return false; &#125;&#125;/*** 显示数组内容* 先判断数组是否为空,若为空,打印数组为空* 若不为空,则利用指针循环遍历,全部打印出来 */void showArr(Arr * pArr) &#123; if(isEmpty(pArr)) &#123; printf("数组为空!\n"); &#125; else &#123; printf("\t\t此时数组中的所有元素为: \n"); // 注意应该是 i &lt; pArr-&gt;currentNum // 不是 i &lt; pArr-&gt;len for(int i = 0; i &lt; pArr-&gt;currentNum; i++) &#123; // 是数组,所以是 pArr-&gt;pBase[i] printf("%d \t", pArr-&gt;pBase[i]); &#125; printf("\n------------------------------------------------\n"); &#125;&#125; /*** 向数组中追加元素* 参数:数组, 追加的值 * 先判断数组是否已经满了* 如果满了,则不可以追加元素,打印追加失败* 如果未满,进行追加 */void append(Arr * pArr, int val) &#123; if( isFull(pArr) ) &#123; printf("数组已经满了,无法添加!\n"); &#125; else &#123; printf("添加元素为 %d\t", val); pArr-&gt;pBase[pArr-&gt;currentNum] = val; // 当前个数+1 pArr-&gt;currentNum++; &#125;&#125;/*** 向数组中指定的位置插入元素* 参数: 数组地址, 位置, 值* 首先判断数组是否满 * 再判断插入的位置是否合法 * 将插入位置后面的元素向后移动一个 * 再插入到相应的位置 */ bool insert(Arr * pArr, int pos, int val) &#123; if( isFull(pArr) ) &#123; printf("数组已经满了,无法插入!\n"); return false; &#125; // 插入的位置不能小于1，同时不能比最后一个元素位置大一 // 注意是 pos &gt; pArr-&gt;len+1 if (pos &lt; 1 || pos &gt; pArr-&gt;len+1) &#123; return false; &#125; else &#123; // 移动范围是从第pos个到底cnu个 // 注意判断条件 i = pArr-&gt;currentlen for(int i = pArr-&gt;currentNum; i &gt; pos; i--) &#123; // 若以i表示要移动元素的位置，从一开始的。右边都是i-1,若左移，左边是i-2,右移，左边是i pArr-&gt;pBase[1] = pArr-&gt;pBase[i-1]; &#125; //进行插入的值的赋值 pArr-&gt;pBase[pos-1] = val; printf("在第%d的位置插入元素: %d", pos, val); pArr-&gt;currentNum++; return true; &#125; &#125;/*** 向数组中指定的位置插入元素* 参数: 数组地址, 位置, 值(地址,将返回去) * 先判断位置是否合法* 在进行删除 */ bool delete_(Arr * pArr, int pos, int *val) &#123; if(pos&lt;1 || pos&gt;pArr-&gt;currentNum) &#123; printf("删除失败，位置不合法\n"); return false; &#125; else &#123; // 获取删除元素的值 *val = pArr-&gt;pBase[pos-1]; // 注意循环条件 for(int i=pos; i&lt;pArr-&gt;currentNum; i++)&#123; pArr-&gt;pBase[i-1] = pArr-&gt;pBase[i]; &#125; pArr-&gt;currentNum--; return true; &#125;&#125;/*** 数组元素进行倒置* 首先判断数组是否为空 */bool inverse(Arr * pArr) &#123; if( isEmpty(pArr) ) &#123; printf("倒置失败，因数组为空"); return false; &#125; int start = 0; // 数组的第一个元素 int end = pArr-&gt;currentNum-1; // 数组的最后一个元素 printf("数组元素进行倒置"); while(start &lt; end)&#123; // 利用一个 temp 临时数据进行数据交换 int temp = pArr-&gt;pBase[start]; pArr-&gt;pBase[start] = pArr-&gt;pBase[end]; pArr-&gt;pBase[end] = temp; // 下一组 start++; end--; &#125; return true; &#125;/*** 代码测试 */ int main() &#123; Arr arr; // 将结构体的地址作为实参，这样才能修改结构体中的值 // 如果传的是结构体变量，那么将进行拷贝，不会改变值 initArr(&amp;arr, 6); // 进行追加 append(&amp;arr, 1); append(&amp;arr, 2); append(&amp;arr, 3); append(&amp;arr, 4); // 进行显示 showArr(&amp;arr); // 插入元素 insert(&amp;arr, 5, 88); showArr(&amp;arr); // 删除元素 int val; delete_(&amp;arr, 1, &amp;val); printf("删除了元素 %d", val); showArr(&amp;arr); // 进行倒置 inverse(&amp;arr); showArr(&amp;arr); return 0;&#125; 参考博文:​ 数据结构基础（1）–数组C语言实现–动态内存分配]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言---常用函数]]></title>
    <url>%2F2019%2F03%2F12%2FC%E8%AF%AD%E8%A8%80---%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[C语言常用函数sizeof用法 如何使用]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JDBC(1)]]></title>
    <url>%2F2019%2F03%2F12%2FJavaWeb---JDBC(1)%2F</url>
    <content type="text"><![CDATA[一、JDBC相关概念介绍1.1、数据库驱动 这里的驱动的概念和平时听到的那种驱动的概念是一样的，比如平时购买的声卡，网卡直接插到计算机上面是不能用的，必须要安装相应的驱动程序之后才能够使用声卡和网卡，同样道理，我们安装好数据库之后，我们的应用程序也是不能直接使用数据库的，必须要通过相应的数据库驱动程序，通过驱动程序去和数据库打交道 1.2、JDBC介绍 SUN公司为了简化、统一对数据库的操作，定义了一套Java操作数据库的规范（接口），称之为JDBC 。这套接口由数据库厂商去实现，这样，开发人员只需要学习jdbc接口，并通过jdbc加载具体的驱动，就可以操作数据库。 JDBC全称为：Java Data Base Connectivity（java数据库连接），它主要由接口组成。组成JDBC的２个包： java.sql javax.sql 开发JDBC应用需要以上2个包的支持外，还需要 导入相应JDBC的数据库实现(即数据库驱动) 。 二、编写JDBC程序2.1. 搭建实验环境 在mysql中创建一个库，并 创建user表和插入表的数据 。 新建一个Java工程，并 导入数据驱动 编写程序从user表中读取数据，并打印在命令行窗口中 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Statement;public class JdbcConn &#123; public static void main(String[] args) throws Exception &#123; //要连接的数据库URL String url = "jdbc:mysql://localhost:3306/jdbcStudy"; //连接的数据库时使用的用户名 String username = "root"; //连接的数据库时使用的密码 String password = "XDP"; //1.加载驱动 //DriverManager.registerDriver(new com.mysql.jdbc.Driver());不推荐使用这种方式来加载驱动 Class.forName("com.mysql.jdbc.Driver");//推荐使用这种方式来加载驱动 //2.获取与数据库的链接 Connection conn = DriverManager.getConnection(url, username, password); //3.获取用于向数据库发送sql语句的statement Statement st = conn.createStatement(); String sql = "select id,name,password,email,birthday from users"; //4.向数据库发sql,并获取代表结果集的resultset ResultSet rs = st.executeQuery(sql); //5.取出结果集的数据 while(rs.next())&#123; System.out.println("id=" + rs.getObject("id")); System.out.println("name=" + rs.getObject("name")); System.out.println("password=" + rs.getObject("password")); System.out.println("email=" + rs.getObject("email")); System.out.println("birthday=" + rs.getObject("birthday")); &#125; //6.关闭链接，释放资源 rs.close(); st.close(); conn.close(); &#125;&#125;//详细解析见原博文 2.2 释放资源 Jdbc程序运行完后，切记要释放程序在运行过程中，创建的那些与数据库进行交互的对象，这些对象通常是ResultSet, Statement和Connection对象，特别是Connection对象，它是非常稀有的资源，用完后必须马上释放，如果Connection不能及时、正确的关闭，极易导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。 为确保资源释放代码能运行，资源释放代码也一定要放在finally语句中。 参考博文:​ javaweb学习总结(三十二)——JDBC学习入门]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---JavaBean]]></title>
    <url>%2F2019%2F03%2F12%2FJavaWeb---JavaBean%2F</url>
    <content type="text"><![CDATA[一、什么是JavaBean JavaBean是一个遵循特定写法的Java类，它通常具有如下特点： 这个Java类必须具有一个无参的构造函数 属性必须私有化 私有化的属性必须通过public类型的方法暴露给其它程序，并且方法的命名也必须遵守一定的命名规范(getter和setter) 如果属性是boolean,那么就对应is和setter方法 javaBean范例： 123456789101112131415161718192021222324252627282930313233/** * Person类就是一个最简单的JavaBean */public class Person &#123; //------------------Person类封装的私有属性------------------------------------- // 姓名 String类型 private String name; //是否已婚 boolean类型 private boolean married; //------------------Person类的无参数构造方法----------------------------------- // 无参数构造方法 public Person() &#123; &#125; //------------------Person类对外提供的用于访问私有属性的public方法---------------- public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public boolean isMarried() &#123; return married; &#125; public void setMarried(boolean married) &#123; this.married = married; &#125;&#125; JavaBean在J2EE开发中，通常用于封装数据，对于遵循以上写法的JavaBean组件，其它程序可以通过反射技术实例化JavaBean对象，并且通过反射那些遵守命名规范的方法，从而获知JavaBean的属性，进而调用其属性保存数据 二、JavaBean的属性 JavaBean的属性可以是任意类型，并且一个JavaBean可以有多个属性。每个属性通常都需要具有相应的setter、 getter方法，setter方法称为属性修改器，getter方法称为属性访问器。 属性修改器必须以小写的set前缀开始，后跟属性名，且属性名的第一个字母要改为大写，例如，name属性的修改器名称为setName，password属性的修改器名称为setPassword。 属性访问器通常以小写的get前缀开始，后跟属性名，且属性名的第一个字母也要改为大写，例如，name属性的访问器名称为getName，password属性的访问器名称为getPassword。 一个JavaBean的某个属性也可以只有set方法或get方法，这样的属性通常也称之为只写、只读属性。 参考博文:javaweb学习总结(二十)——JavaBean总结]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how2J天猫整站---笔记]]></title>
    <url>%2F2019%2F03%2F12%2Fhow2J%E5%A4%A9%E7%8C%AB%E6%95%B4%E7%AB%99J2EE---%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一.关于表表与表之间的关系，基本上是3种 一对一 一对多 多对一 表的杂谈 修改表结构是代价最大的改动 在建表过程中，会设置外键约束，所以表和表之间有依赖关系。 因此会先建立被外键指向的表 一般说来，对于一个新项目，建表的时候，会把sql语句都准备好，一次性执行]]></content>
      <categories>
        <category>how2J</category>
      </categories>
      <tags>
        <tag>how2J</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse---快捷键]]></title>
    <url>%2F2019%2F03%2F12%2Feclipse%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[eclipse快捷键eclipse配置折叠/展开代码快捷键​ 如何设置]]></content>
      <categories>
        <category>eclipse</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---线程(1)]]></title>
    <url>%2F2019%2F03%2F12%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E7%BA%BF%E7%A8%8B(1)%2F</url>
    <content type="text"><![CDATA[一. 线程的基本概念线程是一个程序里面不同的执行路径 每一个分支都叫做一个线程，main()叫做主分支，也叫主线程 程序的执行过程​ 首先把程序的代码放到内存的代码区里面，代码放到代码区后并没有马上开始执行，但这时候说明了一个进程准备开始，进程已经产生了，但还没有开始执行，这就是进程，所以进程其实是一个静态的概念，它本身就不能动。 进程: 机器上的一个.class文件，机器上的一个.exe文件，这个叫做一个进程 平常所说的进程的执行指的是进程里面主线程开始执行了，也就是main()方法开始执行了。 ==进程是一个静态的概念，在我们机器里面实际上运行的都是线程。== 知识补充: CPU难道真的很神通广大，能够同时执行那么多程序吗？ 不是的，CPU的执行是这样的：CPU的速度很快，一秒钟可以算好几亿次，因此CPU把自己的时间分成一个个小时间片，我这个时间片执行你一会，下一个时间片执行他一会，再下一个时间片又执行其他人一会，虽然有几十个线程，但一样可以在很短的时间内把他们通通都执行一遍，但对我们人来说，CPU的执行速度太快了，因此看起来就像是在同时执行一样，但实际上在一个时间点上，CPU只有一个线程在运行。 小总结(学习线程首先要理清楚三个概念): 进程：进程是一个静态的概念 线程：一个程序里面的，一个进程里面不同的执行路径 (一个进程里面有一个主线程叫main()方法)。 在同一个时间点上，一个CPU只能支持一个线程在执行。因为CPU运行的速度很快，因此我们看起来的感觉就像是多线程一样。 什么才是真正的多线程？ 答: 如果你的机器是双CPU，或者是双核，这确确实实是多线程。 二. 线程的创建和启动​ 在 JAVA 里面，JAVA的线程是通过java.lang.Thread类来实现的，每一个Thread对象代表一个新的线程。 创建一个新线程出来有两种方法： 从Thread类继承 实现接口 2.1 继承Thread类继承Thread类，重写该类的run()方法12345678910111213141516171819202122232425262728293031323334353637/** * @Description: 定义Thread的子类并实现run()方法 * 并发进行 */public class TestThread3 &#123; public static void main(String args[]) &#123; // 创建一个新的线程 r3, 此线程进入新建(new)状态 Runner3 r3 = new Runner3(); // 调用start()方法使得线程进入就绪状态(runnable),此时此线程并不一定会马上得以执行，这取决于CPU调度时机 r3.start(); for (int i = 0; i &lt;= 4; i++) &#123; System.out.println("mainMethod：" + i); &#125; &#125;&#125;class Runner3 extends Thread &#123; // 重写run()方法的实现 public void run() &#123; for (int i = 0; i &lt;= 4; i++) &#123; System.out.println("Runner3：" + i); &#125; &#125;&#125;/*打印结果: mainMethod：0 Runner3：0 mainMethod：1 Runner3：1 Runner3：2 Runner3：3 Runner3：4 mainMethod：2 mainMethod：3 mainMethod：4*/ 注意 start() 方法的调用后并不是立即执行多线程代码，而是使得该线程变为就绪状态(Runnable)，什么时候运行是由操作系统决定的 多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。 所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的 2.2 使用实现 Runnable 接口创建和启动新线程实现Runnable接口，并重写该接口的run()方法 该 run() 方法同样是线程执行体，创建Runnable实现类的实例，并以此实例作为Thread类的target来创建Thread对象，该Thread对象才是真正的线程对象 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @Description: 开辟一个新的线程来调用run方法 * 程序执行到 t.start() 后开辟了一条新的线程,主线程继续向下执行 * t.start() 这条线程是 run() 方法执行的线程, * run() 方法和 main() 方法再在交替进行,或者说叫并行执行 */public class TestThread1 &#123; public static void main(String args[]) &#123; // 创建一个新的线程对象r1, 此线程进入新建状态 Runner1 r1 = new Runner1(); // 这里使用的是Thread(Runnable target)构造方法 Thread t = new Thread(r1); // 调用start()方法使得线程进入就绪状 t.start(); for (int i = 0; i &lt; 4; i++) &#123; System.out.println("maintheod：" + i); &#125; &#125;&#125;// 定义一个类用来实现 Runnable 接口，实现Runnable接口就表示这个类是一个线程类 class Runner1 implements Runnable &#123; // 每个线程都是方法run()来完成其操作的，方法run()称为线程体 public void run() &#123; for (int i = 0; i &lt; 4; i++) &#123; System.out.println("Runner1：" + i); &#125; &#125;&#125;/*打印结果: maintheod：0 maintheod：1 Runner1：0 maintheod：2 Runner1：1 maintheod：3 Runner1：2 Runner1：3*/ 补:不开辟新线程直接调用run() 方法首先进入主程序, 子程序 r2 执行完之后主程序 main() 在继续执行 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @Description: 不开辟新线程直接调用run方法 * 首先进入主程序, 子程序 r2 执行完之后主程序 main() 在继续执行 * @author zn * */public class TestThread2 &#123; public static void main(String args[]) &#123; // 这里new了一个线程类的对象出来 Runner2 r2 = new Runner2(); // 这个称为方法调用，方法调用的执行是run()方法执行完之后才会继续执行main()方法 r2.run(); // Thread t = new Thread(r2); // t.start(); for (int i = 0; i &lt; 4; i++) &#123; System.out.println("maintheod：" + i); &#125; &#125;&#125;// 定义一个类用来实现 Runnable 接口，实现Runnable接口就表示这个类是一个线程类class Runner2 implements Runnable &#123; // 每个线程都是方法run()来完成其操作的，方法run()称为线程体 public void run() &#123; for (int i = 0; i &lt; 4; i++) &#123; System.out.println("Runner2：" + i); &#125; &#125;&#125;/*打印结果: Runner2：0 Runner2：1 Runner2：2 Runner2：3 maintheod：0 maintheod：1 maintheod：2 maintheod：3*/ Thread和Runnable之间到底是什么关系呢？范例123456789101112131415161718192021222324252627282930313233343536373839404142public class ThreadTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + " " + i); if (i == 30) &#123; Runnable myRunnable = new MyRunnable(); Thread thread = new MyThread(myRunnable); thread.start(); &#125; &#125; &#125;&#125;class MyRunnable implements Runnable &#123; private int i = 0; @Override public void run() &#123; System.out.println("in MyRunnable run"); for (i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + " " + i); &#125; &#125;&#125;class MyThread extends Thread &#123; private int i = 0; public MyThread(Runnable runnable)&#123; super(runnable); &#125; @Override public void run() &#123; System.out.println("in MyThread run"); for (i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + " " + i); &#125; &#125;&#125; 与实现Runnable接口创建线程方式相似，不同的地方在于 1Thread thread = new MyThread(myRunnable); 那么这种方式可以顺利创建出一个新的线程么？ 答案是肯定的。至于此时的线程执行体到底是MyRunnable接口中的run()方法还是MyThread类中的run()方法呢？通过输出我们知道线程执行体是MyThread类中的 run() 方法。其实原因很简单，因为Thread类本身也是实现了Runnable接口，而 run() 方法最先是在Runnable接口中定义的方法 123public interface Runnable &#123; public abstract void run();&#125; Thread类中对Runnable接口中run()方法的实现： 123456@Override public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; 当执行到Thread类中的run()方法时，会首先判断target是否存在，存在则执行target中的run()方法，也就是实现了Runnable接口并重写了run()方法的类中的run()方法。 但是上述给到的列子中，由于多态的存在，根本就没有执行到Thread类中的run()方法，而是直接先执行了运行时类型即MyThread类中的run()方法 2.3 两种方法的选择优先选择实现Runnable接口 去开辟一个新的线程。 实现Runnable接口比继承Thread类所具有的优势： 适合多个相同的程序代码的线程去处理同一个资源 可以避免java中的单继承的限制 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立 线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类 注意 main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。 三. 线程状态转换 新建(new)：新创建了一个线程对象。 可运行(runnable)：线程对象创建后，其他线程(比如main线程) 调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权。 运行(running)：可运行状态(runnable)的线程获得了 cpu 时间片(timeslice), 执行程序代码。 阻塞(block)：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，即让出了cpu 时间片(timeslice), 暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu 时间片(timeslice)转到运行(running)状态。阻塞的情况分三种： 等待阻塞：运行(running)的线程执行o.wait()方法, JVM会把该线程放入等待队列( waitting queue )中。 同步阻塞： 运行(running)的线程在获取对象的同步锁时, 若该同步锁被别的线程占用，则 JVM会把该线程放入锁池(lock pool)中。 其他阻塞: 运行(running)的线程执行 Thread.sleep(longms)或t.join() 方法，或者发出了I/O 请求时，JVM会把该线程置为阻塞状态。当 sleep() 状态超时、join() 等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 死亡(dead)：线程run()、 main()方法执行结束，或者因异常退出了 run() 方法，则该线程结束生命周期。死亡的线程不可再次复生。 参考博文​ java基础学习总结——线程(一) ​ Java总结篇系列：Java多线程（二） ​ Java多线程学习（总结很详细！！！） ​ how2j ​ 牛客网]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql语句]]></title>
    <url>%2F2019%2F03%2F11%2Fsql%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[参考博文: 一. 基础 创建数据库 1CREATE DATABASE database-name 删除数据库 1DROP DATABASE database-name 创建新表 1CEEATE DATABASE database-name 1CEEATE DATABASE database-name 1CEEATE DATABASE database-name 1CEEATE DATABASE database-name 参考博文: 经典SQL语句大全(绝对的经典) how2J]]></content>
      <tags>
        <tag>sql语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---修饰符]]></title>
    <url>%2F2019%2F03%2F11%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[一. Java 修饰符Java语言提供了很多修饰符，主要分为以下两类： 访问修饰符 非访问修饰符 修饰符用来定义类、方法或者变量，通常放在语句的最前端。 123456789public class className &#123; // ...&#125;private boolean myFlag;static final double weeks = 9.5;protected static final int BOXWIDTH = 42;public static void main(String[] arguments) &#123; // 方法体&#125; 二. 访问控制修饰符Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。 default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法 即是“包访问权限” private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） 表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可以使用 public : 对所有类可见。使用对象：类、接口、变量、方法 表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类） protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private 详细 作用域 自身 同包子类 不同包子类 同包类 其他类 总结(所属) private 访问(√) 继承(×) 继承(×) 访问(×) 访问(×) 只有自己 package 访问(√) 继承(√) 继承(×) 访问(√) 访问(×) 同包 protected 访问(√) 继承(√) 继承(√) 访问(√) 访问(×) 同包+子类 public 访问(√) 继承(√) 继承(√) 访问(√) 访问(√) 所有 如何使用 属性 通常使用private封装起来 方法 一般使用public用于被调用 会 被子类继承 的方法，通常使用protected 总结 如果一个成员需要被外部包所访问，则必须使用public修饰符； 如果一个成员需要被定义在不同包下的子类所访问，则可以使用public或protected修饰符； 如果一个成员需要被本包下的其他类所访问，则可以不用写任何的修饰符，使用public或者protected也行 若一个成员想使用同类中其他成员，则使用任意一个修饰符即可；若一个成员不想被任何一个外部的类所访问，则使用private关键字比较恰当 三. 非访问修饰符为了实现一些其他的功能，Java 也提供了许多非访问修饰符。 static 修饰符 : 用来修饰类方法和类变量。 final 修饰符 : 用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract 修饰符用来创建抽象类和抽象方法。 synchronized 和 volatile 修饰符 : 主要用于线程的编程 详细的见其他文章 参考博客​ Java中private、public、default、protected的区别]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---方法的重载和覆盖]]></title>
    <url>%2F2019%2F03%2F11%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[一. 方法的重载(overload)指一个类中可以定义有 相同的名字 ,但 参数不同 的多个方法. 调用时, 会根据 不同的参数表 选择对应的方法 范例 构造方法 注意 方法名一样, 但参数不一样,就是重载(overload) 参数不一样 (1.参数的个数不一样 2. 参数的类型不一样, 只要有一个就可以) 方法名一样，参数类型一样，只有返回值不一样，这个不构成重载 理解: 多重加载，不同样式的加载 二. 方法的覆盖(override)指覆盖了一个方法并且对其重写，以求达到不同的作用,也可以叫做 重写 范例 对 接口方法 的实现 在 继承 中也可能会在 子类覆盖父类 中的方法 注意 覆盖的方法的标志必须要和被覆盖的方法的 标志 (相同的名字和相同的参数)完全匹配，才能达到覆盖的效果； 覆盖的方法的返回值必须和被覆盖的方法的返回一致； 覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类； 被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖 参考博文 java中的方法覆盖（Overriding）和方法重载（Overloading）是什么意思？重写跟重载的区别？ 对比Java语言中的覆盖和重载]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间词话---ZJ]]></title>
    <url>%2F2019%2F03%2F09%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---ZJ%2F</url>
    <content type="text"><![CDATA[没有人会拒绝微笑, 也没有人会拒绝真诚. 逢山开路, 遇水架桥.]]></content>
      <categories>
        <category>人间词话</category>
      </categories>
      <tags>
        <tag>人间词话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间词话---网易云评论]]></title>
    <url>%2F2019%2F03%2F09%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%84%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[卿卿我我 写歌的人假正经, 听歌的人最无情.人要是桥请起来,听什么都像在唱自己. 校服是我和她唯一穿过的情侣装, 毕业照是我和她唯一的合影. 和暗恋的对人对视一眼或者说一句话，都能有一天的内心戏. 情怀 愿走出半生, 归来仍是少年. 你小时候相当科学家，想当超人，想拯救世界，但后来你慢慢变了，变成那个只想给爸妈安稳的生活，给她一个美好的未来，给你们的孩子一个温馨的住所。。。你不再是超人，但你撑起了一个家]]></content>
      <categories>
        <category>人间词话</category>
      </categories>
      <tags>
        <tag>人间词话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间词话---送给自己]]></title>
    <url>%2F2019%2F03%2F09%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E9%80%81%E7%BB%99%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[勇者愤怒, 抽刃向更强者.怯者愤怒, 却抽刀向更弱者 扬在脸上的微笑, 长在心里的善良,融进血液的骨气, 刻在生命里的坚强. 礼仪最重要的是在昭告自我,真正的宣誓是对自己说的话. —陈果 对一切人,一切西乡都保持一种开放二友善的胸襟和气度的时候,才真正成为名副其实的大学生. —陈果 挫折能使强者更强,弱者更弱,强者在面对中锻炼了自己,弱者在逃避中越发脆弱 最善言谈者就是最善于倾听的人]]></content>
      <categories>
        <category>人间词话</category>
      </categories>
      <tags>
        <tag>人间词话</tag>
        <tag>送给自己</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---Filter(1)]]></title>
    <url>%2F2019%2F03%2F08%2FJavaWeb---Filter(1)%2F</url>
    <content type="text"><![CDATA[一、Filter简介 Filter也称之为过滤器，WEB开发人员通过Filter技术，对web服务器管理的所有web资源：例如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。 Servlet API中提供了一个Filter接口，开发web应用时，如果编写的Java类实现了这个接口，则把这个java类称之为过滤器Filter。通过Filter技术，开发人员可以实现用户在访问某个目标资源之前，对访问的请求和响应进行拦截. 二、Filter是如何实现拦截的？ Filter接口中有一个doFilter方法，当我们编写好Filter，并配置对哪个web资源进行拦截后，WEB服务器每次在调用web资源的service方法之前，都会先调用一下filter的doFilter方法，因此，在该方法内编写代码可达到如下目的： 调用目标资源之前，让一段代码执行。 是否调用目标资源（即是否让用户访问web资源）。 调用目标资源之后，让一段代码执行。 web服务器在调用doFilter方法时，会传递一个filterChain对象进来，filterChain对象是filter接口中最重要的一个对象，它也提供了一个doFilter方法，开发人员可以根据需求决定是否调用此方法，调用该方法，则web服务器就会调用web资源的service方法，即web资源就会被访问(根据所要访问的网址去寻找资源)，否则web资源不会被访问(可能会跳转到其他的界面,然后return返回)。 三、Filter开发入门3.1、Filter开发步骤Filter开发分为二个步骤： 编写java类实现Filter接口，并实现其doFilter方法。 在 web.xml 文件中使用&lt;filter&gt;和&lt;filter-mapping&gt;元素对编写的filter类进行 注册和映射，并设置它所能拦截的资源。 过滤器范例1234567891011121314151617181920212223242526272829303132/*** @Description:filter的三种典型应用：* 1.可以在filter中根据条件决定是否调用chain.doFilter(request, response)方法，即是否让目标资源执行* 2.在让目标资源执行之前，可以对request\response作预处理，再让目标资源执行* 3.在目标资源执行之后，可以捕获目标资源的执行结果，从而实现一些特殊的功能*/ public class FilterDemo01 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println("----过滤器初始化----"); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // 对request和response进行一些预处理 request.setCharacterEncoding("UTF-8"); response.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); System.out.println("FilterDemo01执行前！！！"); chain.doFilter(request, response); //让目标资源执行，放行 System.out.println("FilterDemo01执行后！！！"); &#125; @Override public void destroy() &#123; System.out.println("----过滤器销毁----"); &#125;&#125; 在web. xml中配置过滤器(详细内容见五)12345678910111213&lt;!--配置过滤器--&gt;&lt;!--注册过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;FilterDemo01&lt;/filter-name&gt; &lt;filter-class&gt;me.gacl.web.filter.FilterDemo01&lt;/filter-class&gt;&lt;/filter&gt;&lt;!--映射过滤器--&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;FilterDemo01&lt;/filter-name&gt; &lt;!--“/*”表示拦截所有的请求 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 四. Filter的生命周期4.1、Filter的创建 Filter的创建和销毁由WEB服务器负责。 web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其 init 方法 ，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作，filter对象只会创建一次，init方法也只会执行一次。通过 init 方法的参数，可获得代表当前filter配置信息的FilterConfig对象。 4.2、Filter的销毁 Web容器调用destroy方法销毁Filter。destroy方法在Filter的生命周期中仅执行一次。在destroy方法中，可以释放过滤器使用的资源。 4.3、FilterConfig接口 用户在配置filter时，可以使用 &lt;init-param&gt; 为filter配置一些初始化参数，当web容器实例化Filter对象，调用其 init 方法时 ，会把封装了filter初始化参数的filterConfig对象传递进来。因此开发人员在编写filter时，通过filterConfig对象的方法，就可获得： String getFilterName()：得到filter的名称。 String getInitParameter(String name)： 返回在部署描述中指定名称的初始化参数的值。如果不存在返回null. Enumeration getInitParameterNames()：返回过滤器的所有初始化参数的名字的枚举集合。 public ServletContext getServletContext()：返回Servlet上下文对象的引用。 五、Filter的部署 Filter的部署分为两个步骤： 注册Filter 映射Filter 5.1 注册Filter 开发好Filter之后，需要在web.xml文件中进行注册，这样才能够被web服务器调用 在web.xml文件中注册Filter范例： 123456789101112131415161718&lt;filter&gt; &lt;!--&lt;description&gt;用于添加描述信息，该元素的内容可为空，&lt;description&gt;可以不配置。--&gt; &lt;description&gt;FilterDemo02过滤器&lt;/description&gt; &lt;!--&lt;filter-name&gt;用于为过滤器指定一个名字，该元素的内容不能为空--&gt; &lt;filter-name&gt;FilterDemo02&lt;/filter-name&gt; &lt;!--&lt;filter-class&gt;元素用于指定过滤器的完整的限定类名--&gt; &lt;filter-class&gt;me.gacl.web.filter.FilterDemo02&lt;/filter-class&gt; &lt;!--配置FilterDemo02过滤器的初始化参数--&gt; &lt;!--&lt;init-param&gt;元素用于为过滤器指定初始化参数，它的子元素&lt;param-name&gt;指定参数的名字，&lt;param-value&gt;指定参数的值。在过滤器中，可以使用FilterConfig接口对象来访问初始化参数。如果过滤器不需要指定初始化参数，那么&lt;init-param&gt;元素可以不配置--&gt; &lt;init-param&gt; &lt;description&gt;配置FilterDemo02过滤器的初始化参数&lt;/description&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;gacl&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt; 5.2 映射Filter 在web.xml文件中注册了Filter之后，还要在web.xml文件中映射Filter 12345678910111213141516&lt;!--映射过滤器--&gt;&lt;!--&lt;filter-mapping&gt;元素用于设置一个 Filter 所负责拦截的资源。一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径--&gt; &lt;filter-mapping&gt; &lt;!--&lt;filter-name&gt;子元素用于设置filter的注册名称。该值必须是在&lt;filter&gt;元素中声明过的过滤器的名字--&gt; &lt;filter-name&gt;testFilter&lt;/filter-name&gt; &lt;!--&lt;url-pattern&gt;设置 filter 所拦截的请求路径(过滤器关联的URL样式)--&gt; &lt;!--“/*”表示拦截所有的请求 --&gt; &lt;url-pattern&gt;/index.jsp&lt;/url-pattern&gt; &lt;!--&lt;dispatcher&gt;指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是REQUEST,INCLUDE,FORWARD和ERROR之一，默认REQUEST。用户可以设置多个&lt;dispatcher&gt; 子元素用来指定 Filter 对资源的多种调用方式进行拦截。--&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;&lt;/filter-mapping&gt; &lt;dispatcher&gt; 子元素可以设置的值及其意义： REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。 INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。 FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。 ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。 参考博文​ javaweb学习总结(四十二)——Filter(过滤器)学习]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---面向对象(2)]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(2)%2F</url>
    <content type="text"><![CDATA[一. Java类的定义1.1 关键字​ 使用 class 关键字定义一个类 12345678910class Person &#123; // 成员变量(属性)定义 private int id; private int age = 10; //方法定义 public int getAge() &#123; return age; &#125; public void setAge(int i) &#123; age = i; &#125;&#125; 二. 成员变量2.1 注意 成员变量的作用范围为 整个类体 定义成员变量可以对其初始化, 如果 不对其初始化 , Java 使用默认的值 对其初始化(若不记得Java对成员变量默认的初始化是多少的话，定义一个成员变量，不给它初始化，然后直接打印这个成员变量,进行查看) 在 Java 里面的任何变量首先应该要声明，然后再赋值，然后再使用 2.2 成员变量和局部变量的区别: 成员变量 局部变量 不进行初始化 默认给初始化 不默认给初始化, 在方法里面声明一个局部变量如果不给它初始化时就会出错 实例12345678910111213package test;public class TestChushihua &#123; private static int aa; public static void main(String[] args) &#123; int bb; // aa 必须是 static, 因为要不然需要 new 对象 System.out.println(aa); // 报错,要求要赋值 // System.out.println(bb); &#125;&#125;// 打印结果: aa的值为:0 三. 基本概念 — 引用​ Java语言中 除基本类型之外 的变量类型都称之为引用类型, Java中的对象是通过引用对其操作的 3.1 基本类型与引用类型的区别 基本类型 引用类型 实现 当声明一个int i=0时，系统会马上给这个i分配一个内存空间（在 栈内存 里面分配一小块区域用来装数字0），里面装着一个值为0，以后使用i这个名字马上就可以访问这个内存空间里面的值 定义好这个类之后，需要使用new关键字把这个类的对象实例化出来，也就是真真正正造出一个对象出来才能使用这个对象 内存 占 一块 内存 占 两块 内存 存放位置 栈内存 栈内存: 引用对象 堆内存: 真正的内容(new出来的东西) 不论是基本数据类型还是引用类型，都会先在栈中分配一块内存 ，对于基本类型来说，这块区域包含的是 基本类型的内容；而对于引用类型来说，这块区域包含的是 指向真正内容的指针(存放真正内容的地址) ，真正的内容被手动的分配在堆上。 实例123456789101112131415161718public class Hero &#123; String name; float hp; public static void main(String[] args) &#123; //代表创建了一个Hero对象 //但是也仅仅是创建了一个对象，没有办法访问它 //为了访问这个对象，会使用引用来代表这个对象 new Hero(); //"h"这个变量是Hero类型，叫做引用(也叫 引用对象,对象的引用) //"="的意思指的h这个引用代表右侧创建的对象 //“代表” 在面向对象里，又叫做“指向” //引用h指向了新建的Hero对象 Hero h = new Hero(); &#125; &#125; 3.2 多个引用，一个对象，一个引用，多个对象区别答: 多个引用指向一个对象，操作的都是同一个对象 一个引用多个对象，之前的对象就没有办法访问了, 这个引用就指向了另一个对象 四. 类和对象的关系4,1 如何在内存中区分类和对象 类是 静态 的概念, 在代码区 对象是new出来的, 位于 堆内存 , 类的每个成员变量在不同的对象中都有不同的值 (除了静态变量,static),而方法只有一分,执行的时候才占用内存 . 五. 构造方法(函数) 主要作用 :完成对象的初始化工作，(如果写的类里面没有构造函数,那么编译器会默认加上一个无参数且方法体为空的构造函数) 5.1 特点 使用 new + 构造方法创建一个新的对象 构造函数是定义在 Java类中的一个用来 初始化对象 的函数,(new一个东西的时候，实际上你调用的是一个构造方法，构造方法就是把自己构造成一个新的对象，所以叫构造方法，构造一个新对象用的方法叫构造方法) 构造函数与类同名, 且没有返回值(构造方法的名字必须和类的名字完全一模一样，包括大小写,这个方法的名字和类名完全相同，并且没有返回值，也就是在这个方法前面不能写任何的方法的返回类型修饰符，连void都不可以写) 范例12345678910111213141516public class Person &#123; int id; //在person这类里面定义两个成员变量id和age, int age=20; //给成员变量age赋了初值为20 /**这里就是person这个类的一个构造方法 * 构造方法的规则很简单，和类名要完全一样，一点都不能错，包括大小写。 * 并且没有返回值，不能写void在它前面修饰 * @param _id * @param _age */ public Person(int _id,int _age ) &#123; id = _id; age = _age; &#125;&#125;//内存分析见 孤傲苍狼博客 注意 如果类已经有了一个有参数有方法体的构造函数,这时编译器就不会再给它默认加上一个无参且方法体为空的构造函数.可以理解为无参的构造函数被覆盖了.这种情况称为没有默认构造函数 ### 补:数据区、代码区、栈区、堆区 区别: 栈区(stack)：由系统的编译器自动的释放， 主要用来存放方法中的参数，一些临时的局部变量等 ，并且方法中的参数一般在操作完后，会由编译器自动的释放掉。 堆区(heap):由程序员决定，在Java中，如果程序员不释放的话，一般会由垃圾回收机制自动的清理掉。此区域主要用来 存放我们经常创建的对象、动态的申请的临时空间等 。 数据区(data seg):也称全局区或者静态区，根据名称我们就应该知道用来存放一些全局的东西，比如我们经常用到的 静态变量、全局变量等 都会存放到数据区，此区域上的东西都被全局所共享。比如我们可以采取类名.的方式就可以访问到方法，这就是所谓的静态方法，存放到数据区的。 代码区：存放 程序编译后可以执行代码的地方 。比如执行代码时写的While语句、if条件语句等，都会存放到此 理解了内存，就理解了一切，就理解了各种各样的语言。所有的语言无非都是这样：局部变量分配内存永远在栈里面，new出来的东西分配内存永远是在堆里，静态的东西分配内存永远是在数据区。剩下的代码肯定是在代码区 参考博文:how2J 类和对象 孤傲苍狼 Java基础学习总结——面向对象2 Java基本数据类型与引用数据类型 及在堆栈中内存的存储原理 数据区、代码区、栈区、堆区]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---static关键字]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---static%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Static 关键字 static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途 基本作用: 方便在 没有创建对象 的情况下来进行调用(方法/变量),被static修饰的变量和方法其随着类的加载而被加载 . 只要类被加载了，就可以通过类名去进行访问. 1. 静态变量 在类中用static声明的成员变量为 静态成员变量 (也叫类变量), 其为该类的公共变量, 在第一次使用时被初始化, 这个成员变量 只有一份 ，而且这一份是这个类 所有的对象 共享, 属于整个类的，它不属于专门的某个对象 非静态成员专属于某一个对象，想访问非静态成员必须new一个对象出来才能访问 static成员变量的初始化顺序按照定义的顺序进行初始化 注意: 注意不能把 任何方法体内的变量声明为静态 2. 静态方法 用static 声明的方法为静态方法(也叫类方法) 在静态方法里只能直接调用同类中其他的静态成员（包括变量和方法），而不能直接访问类中的非静态成员 。这是因为，对于非静态的方法和变量，需要先创建类的实例对象后才可使用，而静态方法在使用前不用创建任何对象。 对于非静态成员方法，它访问静态成员方法/变量显然是毫无限制的 静态方法不能以任何方式引用this和super关键字 因为静态方法在使用前不用创建任何实例对象，当静态方法调用时，this所引用的对象根本没有产生。 由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了 范例​ 想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。 ​ 最常见的static方法就是main方法。因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。 3. 静态代码块 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。 为什么说static块可以用来优化程序性能​ 是因为它的特性:只会在类加载的时候执行一次。 初始化的顺序 对象属性的初始化有三种方式 声明时初始化 静态代码块初始化 构造函数初始化 故意把初始化块，放在构造方法下面， 问题：这三种方式，谁先执行？谁后执行？ 代码演示12345678910111213141516171819202122232425public class StaticOrder &#123; // 声明时初始化 public String name = StaticOrder.getName("属性声明"); // 构造函数初始化 public StaticOrder() &#123; name = StaticOrder.getName("构造方法"); &#125; // 静态代码块初始化 &#123; name = StaticOrder.getName("初始化块"); &#125; // 被调用的 getName() 方法 public static String getName(String name) &#123; System.out.println("初始化: " + name); return name; &#125; public static void main(String[] args) &#123; new StaticOrder(); &#125;&#125;// 打印结果:// 初始化: 属性声明// 初始化: 初始化块// 初始化: 构造方法 所以顺序为: 声明时初始化 静态代码块初始化 构造函数初始化 杂:​ static可以修饰内部类，但是不能修饰普通类。静态内部类的话可以直接调用静态构造器（不用对象）。 参考博文:​ java基础学习总结——static关键字 ​ 优质答案 ​ java中静态代码块的用法 static用法详解 ​ Java中的static关键字解析]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---HttpServletRequest对象]]></title>
    <url>%2F2019%2F03%2F08%2FJavaWeb---HttpServletRequest%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[一. HttpServletRequest介绍 HttpServletRequest对象代表 客户端的请求 ，当 客户端通过HTTP协议访问服务器 时，HTTP请求头中的 所有信息都封装在这个对象中 ，通过这个对象提供的方法，可以获得客户端请求的所有信息 。 二. Request常用方法2.1. 获得客户机信息 getRequestURL方法返回客户端发出请求时的完整URL。 getRequestURI方法返回请求行中的资源名部分。 getQueryString 方法返回请求行中的参数部分。 getPathInfo方法返回请求URL中的额外路径信息。额外路径信息是请求URL中的位于Servlet的路径之后和查询参数之前的内容，它以“/”开头。 getRemoteAddr方法返回发出请求的客户机的IP地址。等 2.2 获得客户机请求头略 2.3 获得客户机请求参数(客户端提交的数据) getParameter(String)方法(常用) getParameterValues(String name)方法(常用) getParameterNames()方法(不常用) getParameterMap()方法(编写框架时常用) 详细代码见参考博客 在服务器端使用getParameter方法和getParameterValues方法接收表单参数，代码如下: 1234567891011121314151617181920212223/** * 获取客户端通过Form表单提交上来的参数 */public class RequestDemo03 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 客户端是以 UTF-8 编码提交表单数据的，所以需要设置服务器端以UTF-8 的编码进行接收，否则对于中文数据就会产生乱码 request.setCharacterEncoding("UTF-8"); /** * 用户名(文本框)：&lt;input type="text" name="username" value="请输入用户名"&gt; * 获取填写的用户名 */ String username = request.getParameter("username"); // 获取选中的性别 String sex = request.getParameter("sex"); // 获取选中的兴趣，因为可以选中多个值，所以获取到的值是一个字符串数组，因此需要使用 getParameterValues 方法来获取 // &lt;input type="checkbox" name="inst" value="唱歌"&gt;唱歌 String[] insts = request.getParameterValues("inst"); String hiddenField = request.getParameter("hiddenField");//获取隐藏域的内容 &#125;&#125; 2.4 获取路径方法与作用 getServletPath() : 获取能够与“url-pattern”中匹配的路径，注意是完全匹配的部分，* 的部分不包括。 getPageInfo() : 与getServletPath()获取的路径互补，能够得到的是“url-pattern”中 * 的路径部分 getContextPath() : 获取项目的根路径 getContextPath() 与 req.getServletContext().getContextPath()获取到内容的是相同的,都是项目的根路径 getRequestURI() : 获取根路径到地址结尾 getRequestURL() :获取请求的地址链接（浏览器中输入的地址） getServletContext().getRealPath(“/”) :获取“/”在机器中的实际地址 getScheme() : 获取的是使用的协议(http 或https) getProtocol() : 获取的是协议的名称(HTTP/1.11) getServerName() : 获取的是域名(xxx.com) getLocalName : 获取到的是IP 范例请求 http://localhost:8080/testweb/abc/def/ghi/test.html (url-pattern=/abc/def/*)打印的值为： 1234561. servletPath: /abc/def 2. pageInfo: /ghi/test.html3. contextPath: /testweb4. uri: /testweb/abc/def/ghi/test.html5. url: http://localhost:8080/testweb/abc/def/ghi/test.html6. realPath:G:\java\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\testweb\ 2.5 传参setAttribute和getAttribute可以用来在进行服务端跳转的时候，在不同的Servlet之间进行数据共享 三. request接收表单提交中文参数乱码问题3.1 以POST方式提交表单中文参数的乱码问题例如有如下的form表单页面1234567&lt;body&gt; &lt;!--提交方式为 POST--&gt; &lt;form action="&lt;%=request.getContextPath()%&gt;/servlet/RequestDemo04" method="post"&gt; 用户名：&lt;input type="text" name="userName"/&gt; &lt;input type="submit" value="post方式提交表单"&gt; &lt;/form&gt;&lt;/body&gt; servlet 中的代码12345678public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String username = request.getParameter("username"); System.out.println("userName:" + userName);&#125;// 打印结果: userName: 佷粈涔?灏辨暣// 是乱码 3.2. post方式提交中文数据乱码产生的原因和解决办法 之所以会产生乱码，就是因为服务器和客户端沟通的编码不一致造成的，因此解决的办法是：在客户端和服务器之间设置一个统一的编码，之后就按照此编码进行数据的传输和接收。 由于客户端是以UTF-8字符编码 将表单数据传输到服务器端的，因此服务器也需要设置以UTF-8字符编码进行接收，要想完成此操作，服务器可以直接使用从ServletRequest接口继承而来的setCharacterEncoding(charset) 方法进行统一的编码设置。修改后的代码如下： 12345678public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 客户端是以 UTF-8 编码传输数据到服务器端的，所以需要设置服务器端以UTF-8的编码进行接收，否则对于中文数据就会产生乱码 request.setCharacterEncoding("UTF-8"); String userName = request.getParameter("userName"); System.out.println("userName："+userName);&#125; 3.3 以GET方式提交表单中文参数的乱码问题例如有如下的form表单页面1234567&lt;body&gt; &lt;!--提交方式为 GET--&gt; &lt;form action="$&#123;pageContext.request.contextPath&#125;/servlet/RequestDemo04" method="get"&gt; 姓名：&lt;input type="text" name="name"/&gt; &lt;input type="submit" value="get方式提交表单"&gt; &lt;/form&gt;&lt;/body&gt; 此时在服务器端接收中文参数时就会出现中文乱码3.4. get方式提交中文数据乱码产生的原因和解决办法 ​ 默认的还是 使用ISO8859-1 这个字符编码来接收数据，客户端以UTF-8的编码传输数据到服务器端，而服务器端的request对象使用的是ISO8859-1这个字符编码来接收数据，服务器和客户端沟通的编码不一致因此才会产生中文乱码的。 解决办法： 在接收到数据后 获取request对象以ISO8859-1字符编码接收到的原始数据的字节数组 通过字节数组以指定的编码构建字符串，解决乱码问题。代码如下： 123456789public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String name = request.getParameter("name"); // 获取request对象以ISO8859-1字符编码接收到的原始数据的字节数组，然后通过字节数组以指定的编码构建字符串，解决乱码问题 name = new String(name.getBytes("ISO8859-1"), "UTF-8") ; System.out.println("name：" + name); &#125; 3.5 以超链接形式传递中文参数的乱码问题通过超链接后面加参数的形式，例如： 1&lt;a href="$&#123; pageContext.request.contextPath &#125;/servlet/RequestDemo05?userName=gacl&amp;name=徐达沛"&gt;点击&lt;/a&gt; 点击超链接，数据是以 get的方式 传输到服务器的，所以接收中文数据时也会产生中文乱码问题 解决中文乱码问题的方式与 上述的以get方式提交表单中文数据乱码处理问题的方式一致 , 如下所示： 12String name = request.getParameter("name");name =new String(name.getBytes("ISO8859-1"), "UTF-8"); 另外，需要提的一点就是 URL地址后面如果跟了中文数据，那么中文参数最好使用URL编码进行处理 , 如下所示： 1&lt;a href="$&#123;pageContext.request.contextPath&#125;/servlet/RequestDemo05?userName=gacl&amp;name=&lt;%=URLEncoder.encode("徐达沛", "UTF-8")%&gt;"&gt;点击&lt;/a&gt; 3.6 提交中文数据乱码问题总结提交方式为 POST​ 只需要在服务器端设置request对象的编码即可，客户端以哪种编码提交的，服务器端的request对象就以对应的编码接收，比如客户端是以UTF-8编码提交的 提交方式为GET​ 设置request对象的编码是无效的，request对象还是以默认的ISO8859-1编码接收数据，因此要想不乱码，只能在接收到数据后再 手工转换, 步骤如下： 123456// 1.获取获取客户端提交上来的数据，得到的是乱码字符串,data="???è?????"String data = request.getParameter("paramName"); // 2.查找ISO8859-1码表，得到客户机提交的原始数据的字节数组byte[] source = data.getBytes("ISO8859-1"); // 3.通过字节数组以指定的编码构建字符串，解决乱码data = new String(source, "UTF-8"); 通过字节数组以 指定的编码 构建字符串，这里 指定的编码 -是根据客户端那边提交数据时使用的字符编码来定的，如果是GB2312，那么就设置成data = new String(source, “GB2312”) 四.Request对象实现请求转发4.1 请求转发的基本概念​ 请求转发: 指一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理。 请求转发的应用场景: MVC设计模式 在Servlet中实现请求转发的两种方式： 通过 ServletContext 的 getRequestDispatcher(String path) 方法，该方法返回一个 RequestDispatcher 对象，调用这个对象的 forward 方法可以实现请求转发。 例如：将请求转发的test.jsp页面 123RequestDispatcher reqDispatcher = this.getServletContext().getRequestDispatcher("/test.jsp");reqDispatcher.forward(request, response); 通过 request对象 提供的 getRequestDispatche(String path) 方法，该方法返回一个RequestDispatcher对象，调用这个对象的 forward 方法可以实现请求转发。 例如：将请求转发的test.jsp页面 1request.getRequestDispatcher("/test.jsp").forward(request, response); request对象同时也是一个域对象(Map容器)，开发人员通过request对象在实现转发时，把数据通过request对象带给其它web资源处理。 request对象作为一个域对象(Map容器)使用时，主要是通过以下的四个方法来操作,如下: 123456789101112131415// 方法: setAttribute(String name,Object o);// 将数据作为request对象的一个属性存放到request对象中request.setAttribute("data", data);// 方法: getAttribute(String name);// 获取request对象的name属性的属性值，request.getAttribute("data");// 方法: removeAttribute(String name);// 移除request对象的name属性request.removeAttribute("data")// 方法: getAttributeNames()// 获取request对象的所有属性名，返回的是一个Enumeration&lt;String&gt; attrNames = request.getAttributeNames(); 4.2 请求重定向和请求转发的区别一个web资源收到客户端请求后 通知服务器去调用另外一个web资源进行处理，称之为请求转发/307 通知浏览器去访问另外一个web资源进行处理，称之为请求重定向/302 五. request设置参数存储代码1234567891011public class HeroEditServlet extends HttpServlet &#123; protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; int id = Integer.parseInt(request.getParameter("id")); Hero hero = new HeroDAO().get(id); // 存进来 request.setAttribute("hero", hero); request.getRequestDispatcher("editHero.jsp").forward(request, response); &#125;&#125; 拿出来1234567891011&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" import="java.util.*,bean.*,java.sql.*"%&gt; &lt;form action='updateHero' method='post'&gt; &lt;!-- 将信息提取出来 --&gt; 名字 ： &lt;input type='text' name='name' value='$&#123;hero.name&#125;'&gt; &lt;br&gt; 血量 ：&lt;input type='text' name='hp' value='$&#123;hero.hp&#125;'&gt; &lt;br&gt; 伤害： &lt;input type='text' name='damage' value='$&#123;hero.damage&#125;'&gt; &lt;br&gt; &lt;input type='hidden' name='id' value='$&#123;hero.id&#125;'&gt; &lt;input type='submit' value='更新'&gt;&lt;/form&gt; 可以在拂去端跳转后的.jsp文件取出来 参考博文​ javaweb学习总结(十)——HttpServletRequest对象(一)]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb---HttpResponse对象]]></title>
    <url>%2F2019%2F03%2F08%2FJavaWeb---HttpServletResponse%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[一. HttpServletResponse 对象介绍​ HttpServletResponse对象 代表服务器的响应。这个对象中封装了向客户端发送数据、发送响应头，发送响应状态码的方法。查看 HttpServletResponse 的API，可以看到这些相关的方法。 1.1 响应状态码的常量 HttpServletResponse 定义了很多状态码的常量(具体可以查看Servlet的API)，当需要向客户端发送响应状态码时，可以使用这些常量，避免了直接写数字，常见的状态码对应的常量： 状态码404对应的常量 状态码200对应的常量 状态码500对应的常量 二. HttpServletResponse常见应用——设置响应头控制浏览器的行为通过response实现请求重定向 请求重定向指：一个web资源收到客户端请求后，通知客户端去访问另外一个web资源，这称之为请求重定向。 应用场景：用户登陆，用户首先访问登录页面，登录成功后，就会跳转到某个页面，这个过程就是一个请求重定向的过程 实现方式： ==response.sendRedirect(String location)==，即调用response对象的sendRedirect方法实现请求重定向 sendRedirect内部的实现原理：使用response设置 302状态码和设置location响应头实现重定向 范例1234567891011121314151617181920212223242526public class ResponseDemo04 extends HttpServlet &#123; // 方法: doGet public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;/*** 1. 调用sendRedirect方法实现请求重定向, sendRedirect方法内部调用了* ① response.setHeader("Location",* "/JavaWeb_HttpServletResponse_Study_20140615/index.jsp");* ② response.setStatus(HttpServletResponse.SC_FOUND);//设置302状态码，等同于response.setStatus(302);*/ response.sendRedirect("/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"); /*** 2.使用response设置302状态码和设置location响应头实现重定向实现请求重定向* response.setHeader("Location", "/JavaWeb_HttpServletResponse_Study_20140615/index.jsp");* response.setStatus(HttpServletResponse.SC_FOUND);* 设置302状态码，等同于response.setStatus(302);*/ &#125; // 方法: doPost public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 3.2 /代表 webapps目录 的常见应用场景使用sendRedirect实现请求重定向1response.sendRedirect("/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"); 服务器发送一个URL地址给浏览器，浏览器拿到URL地址之后，再去请求服务器，所以这个”/“是给浏览器使用的，此时 /代表的就是webapps目录 ​ /JavaWeb_HttpServletResponse_Study_20140615/index.jsp这个地址指的就是 webapps\JavaWeb_HttpServletResponse_Study_20140615\index.jsp response.sendRedirect(“/项目名称/文件夹目录/页面”);这种写法是将项目名称 写死在程序中 的做法，不灵活，万一哪天项目名称变了，此时就得改程序，所以推荐使用下面的灵活写法： 将 1response.sendRedirect("/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"); 这种写法改成 1response.sendRedirect(request.getContextPath()+"/index.jsp"); request.getContextPath() 获取到的内容就是 /JavaWeb_HttpServletResponse_Study_20140615，这样就比较灵活了，使用request.getContextPath()代替”/项目名称”，推荐使用这种方式，灵活方便！ 使用超链接跳转1&lt;a href="/JavaWeb_HttpServletResponse_Study_20140615/index.jsp"&gt;跳转到首页&lt;/a&gt; 这是客户端浏览器使用的超链接跳转，这个 / 是给浏览器使用的 ，此时 / 代表的就是webapps目录。 使用超链接访问web资源，绝对路径的写法推荐使用下面的写法改进 1&lt;a href="$&#123;pageContext.request.contextPath&#125;/index.jsp"&gt;跳转到首页&lt;/a&gt; 这样就可以避免在路径中出现项目的名称，使用 ${pageContext.request.contextPath} 取代 /JavaWeb_HttpServletResponse_Study_20140615 Form表单提交123&lt;form action="/JavaWeb_HttpServletResponse_Study_20140615/servlet/CheckServlet" method="post"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 这是客户端浏览器将form表单提交到服务器，所以这个 / 是给浏览器使用的，此时 / 代表的就是webapps目录。 对于form表单提交中action属性绝对路径的写法，也推荐使用如下的方式改进： 123&lt;form action="$&#123;pageContext.request.contextPath&#125;/servlet/CheckServlet" method="post"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; ${pageContext.request.contextPath} 得到的就是 /JavaWeb_HttpServletResponse_Study_20140615 ${pageContext.request.contextPath}的效果等同于request.getContextPath()，两者获取到的都是“/项目名称” js脚本和css样式文件的引用123456&lt;%--使用绝对路径的方式引用js脚本--%&gt; &lt;script type="text/javascript" src="$&#123;pageContext.request.contextPath&#125;/js/index.js"&gt;&lt;/script&gt; &lt;%--$&#123;pageContext.request.contextPath&#125;与request.getContextPath()写法是得到的效果是一样的--%&gt; &lt;script type="text/javascript" src="&lt;%=request.getContextPath()%&gt;/js/login.js"&gt;&lt;/script&gt; &lt;%--使用绝对路径的方式引用css样式--%&gt; &lt;link rel="stylesheet" href="$&#123;pageContext.request.contextPath&#125;/css/index.css" type="text/css"/&gt; 总结​ ==只要是浏览器向服务器提交的, / 给浏览器使用, 都可以修改成推荐的方式== 参考博文​ javaweb学习总结(八)——HttpServletResponse对象(二)]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---面向对象(1)]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(1)%2F</url>
    <content type="text"><![CDATA[一. 面向过程的思想和面向对象的思想面向过程 自顶向下,逐步细化 ​ 面向解决问题的过程进行编程​ 按照步骤化解决问题.(一个问题,分析这个问题如何去解决,第一步做什么, 第二步什么…), 当我们用面向过程的思想去编程或解决问题时，首先一定要把详细的实现过程弄清楚。一旦过程设计清楚，代码的实现简直轻而易举。 面向对象 Java 中万物皆对象，模拟真实的现实世界 ​ 在编程的时候尽可能的去模拟真实的现实世界，按照现实世界中的逻辑去处理一个问题，分析问题中参与其中的有哪些实体，这些实体应该有什么属性和方法，我们如何通过调用这些实体的属性和方法去解决问题。拿到一个问题,应该分析: 这个问题里面有哪些类和对象 在分析这些类和对象应该具有哪些属性和方法 分析类和类之间具有什么关系 设计思维: 合适的方法应该出现在合适的类里面 二. 类和对象类一类事物的抽象包括属性(静态)和方法(动态) 属性: 用来描述这一个对象（类）的特征 ,比如一个人的属性有身高，肤色，体重等等， 方法: 可以完成一个特定的功能，方法就像是动作, 比如人可以吃饭，跑步，学习，都可以是方法 Java中属性就是成员变量,方法就是函数, 不同的叫法 对象一类事物的具体的某一个东西(符合这类事物的具体特征) 在Java中, 对象就是类的实例化 随笔: 对象和类是分不开的，必须首先定义类才能有对象类和对象的关系，类就是模板，里面定义着属性和方法，而对象就是实例，通过类来创建（new）对象，叫类的实例化 三. 面向过程与面向对象的比较 都可以实现代码重用和模块化编程，但是面对对象的模块化更深，数据更封闭，也更安全！因为面向对象的封装性更强！ 面对对象的思维方式更加贴近于现实生活，更容易解决大型的复杂的业务逻辑 从前期开发角度上来看，面对对象远比面向过程要复杂，但是从维护和扩展功能的角度上来看，面对对象远比面向过程要简单！ 当我们的业务逻辑比较简单时，使用面向过程能更快的实现当我们的业务逻辑比较复杂时，为了将来的维护和扩展，还是面向对象更为靠谱 参考博文​ 编程思想：面向对象和面向过程]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言---指针]]></title>
    <url>%2F2019%2F03%2F08%2FC%E8%AF%AD%E8%A8%80---%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[指针一. 简单理解指针变量: 专门用来存放地址的特殊变量 指针 ( = 变量的值) 指针变量 ( = 变量) 含义 地址 存放另一个变量地址的变量 指针与指针变量的关系类似于变量的值与变量的区别. 指针变量习惯上简称为 指针 1234567891011int main()&#123; int a, * p; p = &amp;a; // "&amp;a" 代表a的地址的值 a = 3; printf("p的值为 %d\n", p); // p中存放的是 a 的地址 printf("*p的值为 %d", *p); // * 号在 引用时表示"指向"操作, *p 代表 a, // "*"仅起到标志的作用, 表示该变量为指针变量, 不是变量名的一部分, 及指针变量名不包括 * return 0 ;&#125; 二. 复杂类型说明123456789int p; //这是一个普通的整型变量 int *p; //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针 int p[3]; //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组 int *p[3]; //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组 int (*p)[3]; //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与"()"这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针 int **p; //首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针. int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据 Int (*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针 int *(*p(int))[3]; //可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数. 三. 细说指针指针是一个 特殊的变量 ，它里面 存储的数值 被解释成为 内存里的一个地址 。要搞清一个指针需要搞清指针的四方面的内容： 指针的类型 指针所指向的类型 指针的值或者叫指针所指向的内存区 指针本身所占据的内存区。 3.1 指针的类型从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。例如: 12345int * ptr; //指针的类型是int*char * ptr; //指针的类型是char*int ** ptr; //指针的类型是int**int (* ptr)[3]; //指针的类型是int(*)[3]int * (* ptr)[4]; //指针的类型是int*(*)[4] 3.2 指针所指向的类型当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符去掉，剩下的就是指针所指向的类型。例如： 12345int * ptr; //指针所指向的类型是intchar * ptr; //指针所指向的的类型是charint ** ptr; //指针所指向的的类型是intint (*ptr)[3]; //指针所指向的的类型是int()[3]int (ptr)[4]; //指针所指向的的类型是int*()[4] 指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C 越来越熟悉时，你会发现，把与指针搅和在一起的”类型”这个概念分成”指针的类型”和”指针所指向的类型”两个概念，是精通指针的关键点之一。 3.3 指针的值—-或者叫指针所指向的内存区或地址 指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。 在32 位程序里，所有类型的指针的值都是一个32 位整数，因为32 位程序里内存地址全都是32 位长。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区 我们说一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在3.2例子中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。 以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？ 3.4 指针本身所占据的内存区指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32 位平台里，指针本身占据了4 个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式（后面会解释）是否是左值时很有用 四. 指针的算术运算五. 运算符 &amp; 和 *这里 &amp; 是取地址运算符，* 是间接运算符。&amp;a 的运算结果是一个指针，指针的类型是a 的类型加个* ，指针所指向的类型是a 的类型，指针所指向的地址嘛，那就是a 的地址。 *p 的运算结果就五花八门了。总之*p 的结果是 p 所指向的东西，这个东西有这些特点：它的类型是p 指向的类型，它所占用的地址是p所指向的地址。 123456789101112int a=12; int b; int *p; int **ptr; p=&amp;a; //&amp;a 的结果是一个指针，类型是int*，指向的类型是int，指向的地址是a的地址。 *p=24; //*p 的结果，在这里它的类型是int，它所占用的地址是p所指向的地址，*p就是变量a。 // 下面的还有有看懂ptr=&amp;p; //&amp;p 的结果是个指针，该指针的类型是p 的类型加个*, 在这里是int **。该指针所指向的类 //型是p的类型，这里是int*。该指针所指向的地址就是指针p 自己的地址。 *ptr=&amp;b; //*ptr 是个指针，&amp;b 的结果也是个指针，且这两个指针 //的类型和所指向的类型是一样的，所以用&amp;b 来给*ptr 赋 //值就是毫无问题的了。 **ptr=34; //*ptr 的结果是ptr 所指向的东西，在这里是一个指针， //对这个指针再做一次*运算，结果是一个int 类型的变量。 六. 指针表达式一个表达式的结果如果是一个指针，那么这个表达式就叫指针表式。 七. 数组和指针的关系八. 指针和结构类型的关系12345678910111213struct MyStruct &#123; int a; int b; int c; &#125;; // 声明了结构对象ss，并把ss 的成员初始化为20，30 和40。struct MyStruct ss = &#123;20,30,40&#125;; // 声明了一个指向结构对象 ss 的指针。它的类型是MyStruct *,它指向的类型是MyStruct。struct MyStruct *ptr = &amp;ss; // 声明了一个指向结构对象ss 的指针。但是pstr 和它被指向的类型ptr 是不同的。int *pstr = (int*)&amp;ss; 请问怎样通过指针ptr 来访问ss 的三个成员变量？答案： 123ptr-&gt;a; //指向运算符，或者可以这们(*ptr).a,建议使用前者ptr-&gt;b;ptr-&gt;c; 九. 指针和函数的关系可以把一个指针声明成为一个指向函数的指针。 1234int fun1(char *,int);int (*pfun1)(char ,int);pfun1 = fun1;int a = (*pfun1)("abcdefg",7); //通过函数指针调用函数。 可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。 12345678910111213int fun(char *); int a; char str[] = "abcdefghijklmn"; a = fun(str); int fun(char *s) &#123; int num=0; for(int i=0;;) &#123; num+=*s;s++; &#125; return num; &#125; 这个例子中的函数fun 统计一个字符串中各个字符的ASCII 码值之和。前面说了，数组的名字也是一个指针。在函数调用中，当把str作为实参传递给形参s 后，实际是把str 的值传递给了s，s 所指向的地址就和str 所指向的地址一致，但是str 和s 各自占用各自的存储空间。在函数体内对s 进行自加1 运算，并不意味着同时对str 进行了自加1 运算。 参考博文​ C语言指针详解(经典,非常详细) ​ 指针与函数]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言基础知识]]></title>
    <url>%2F2019%2F03%2F08%2FC%E8%AF%AD%E8%A8%80---%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[C语言基础知识:结构体:定义: 将一些已知的数据类型放在一起来定义的一种数据类型 结构体并没有创造出新的数据类型，这点要搞清楚。C语言的结构体和其他高级语言的类有点相似的概念，可以完成对一种事物的抽象。 代码中的定义: 1234567891011121314151617struct 结构名 // 结构名是结构的标识符不是变量名&#123; 类型 变量名; 类型 变量名;&#125; 结构变量;// 例子:struct student &#123; char name[8]; int age; char sex[2]; char depart[20]; float wage1, wage2, wage3, wage4, wage5; &#125; Mike, Marry;struct student John; // struct student:类型说明符, John 变量名// 定义了两个 struct student 类型的变量 Mike, Marry typedef: 使用 typedef 关键字来定义自己习惯的数据类型名称，来替代系统默认的基本类型名称、数组类型名称、指针类型名称与用户自定义的结构型名称、共用型名称、枚举型名称等。 基本用法 1. 为基本类型数据定义新的类型名1234567typedef int COUNT; // 为基本类型数据定义新的类型名int main() &#123; COUNT a = 88; printf("结果为: %d", a); return 0;&#125;// 打印结果: 结果为: 88 2. 为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称12345678910111213141516// 以结构体为例，下面我们定义一个名为 Point 的结构体struct Point&#123; double x; double y; double z;&#125;;// 在调用这个结构体时，我们必须像下面的代码这样来调用这个结构体int main() &#123; struct Point oPoint2; oPoint2.x = 3.3; printf("%f", oPoint2.x); return 0;&#125;// 打印结果: 3.300000 解析123456789typedef struct tagPoint&#123; double x; double y; double z;&#125; Point;// 1.相当于把 x = struct tagPoint &#123; …&#125;// 2.typedef x Point;// 可以看做是简写 参考文章: ​ typedef的用法，C语言typedef详解]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---基础语法(2)]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95(2)%2F</url>
    <content type="text"><![CDATA[一. 语句1.1 条件语句 if 语句 switch 语句 1.2 循环语句 for 循环语句 while 循环与do while 循环 1.3 break 和 continue 语句 二. 方法​ 一段用来完成特定功能的代码片段 1234[修饰符1 修饰符2 ...] 返回值类型 方法名(形式参数列表) &#123; java 语句; ...&#125; 方法可以有返回值，但可以不用这个返回值。方法首先要定义，然后才能调用 三、变量的作用域​ 变量的作用域只在“{ }”有效，出了这个“{ }”就没有作用了 四、递归调用 递归：在一个方法内部对自身的调用就称为递归 具体的参考 孤傲苍狼 博客 五、程序的执行过程 参考博文:​ java基础学习总结——基础语法2]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构---链表的概念及实现]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[链表线性表的链接存储结构成为链表 常见的链表: 单链表(每个节点有一个指针域的链表) 循环链表 双链表(每个节点有两个指针域的链表) 特点: 用一组任意的存储单元存储线性表的数据结构(存储单元可以是连续的,也可以是不连续的 数据元素的逻辑次序和物理次序 ==不一定一致== 相关概念 结点: 基本单元,由两部分组成 数据域: 用来存放节点本身的信息 指针域:用来存放本节点的直接后继节点的地址 空指针: 链表中最后一个节点的指针域不指向任何节点(通常用”∧”或者”NULL”表示 头指针: 指向单链表第一个节点的指针(head) 空表: 之神 head 为空指针,即 head=NULL 表头结点: 第一个节点之前再增加一个类型相同的结点(为了便于实现链表的各种运算, 其他节点成为表结点) 表结点: 除了表头结点其他的结点 在表结点中,第一个节点称为首结点 ,最后一个节点称为 尾节点]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构---线性表]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[线性表：定义:​ 由 n(n≥0) 个数据特性相同的元素构成的 有限序列 特点: 存在唯一的一个被称为”第一个”的数据元素 存在唯一的一个被称为”最后一个”的数据元素 除第一个之外, 结构中的每个数据元素均只有一个前驱元素 除最后一个之外, 结构中的每个数据元素均只有一个后继元素 存储结构及运算: 存储结构方式: 顺序存储方式(顺序表), 链接存储方式(链表) 运算: 线性表的初始化 求表的长度 取出表的元素 查找运算 相关概念 空表: 线性表的长度 n=0 前驱元素: 如果 a~i~ 和a~i+1~ 是相邻的具有前后关系的两个元素, 则 a~i~ 称为 a~i+1~ 的前驱元素 后继元素: 如果 a~i~ 和a~i+1~ 是相邻的具有前后关系的两个元素, 则 a~i+1~ 称为 a~i~ 的前驱元素 随笔: 线性表中的数据元素之间的逻辑关系就是其相互位置上的 邻接关系 ,该关系是线性的,因此,线性表是一种线性结构 常见例子: 学生成绩表, 列车时刻表, 英文字母表 ​]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[陈果老师语录]]></title>
    <url>%2F2019%2F03%2F07%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E6%88%91%E6%88%90%E9%95%BF---%E9%99%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[只有心灵才能洞察一切，世界上真正重要的东西要用心去看 你使用什么样的双眼观世界，就印证了你有怎样的心眼，如果心眼大，你所见的世界宽广无边，如果你心眼小，充满羡慕嫉妒恨，所见的世界也是偏狭丑陋 选择之所以称之为选择，一定是痛苦的，因为选项是不相上下的，能轻松做决定的，都不叫选择，选择意味着舍弃一种美好，承受一种痛苦，不安 回忆是一种重逢, 忘记是一份自由.]]></content>
      <categories>
        <category>人间词话</category>
      </categories>
      <tags>
        <tag>人间词话</tag>
        <tag>人生</tag>
        <tag>智慧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[涂磊老师语录]]></title>
    <url>%2F2019%2F03%2F07%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E6%88%91%E6%88%90%E9%95%BF---%E6%B6%82%E7%A3%8A%2F</url>
    <content type="text"><![CDATA[我们总是善于去伤害那些爱我们的人， 因为我们根本伤害不了那些不爱我们的人;我们总是甘愿被那些我们爱的人伤害，那是因为我爱他们 喜欢可以心动，而爱一定会心痛；喜欢可以舍得，但爱一定舍不得；喜欢一个人，冬天不过是冬天，不过是漂亮一点而已；但是爱一个人，冬天可以变成春天；爱一个人，她落泪你就会跟着她一起落泪；而喜欢一个人，她落泪你只不过是安慰；喜欢是可以变成爱的，但如果爱了就说不出喜欢；喜欢是不排她的，而爱一定是排她的，唯一的；喜欢与责任无关，而爱一定要负责任，这就是喜欢和爱的区别 春风得意的浪子回头最珍贵，穷途末路的认错悔改最虚伪 你曾经买了一件很喜欢的衣裳却舍不得穿，郑重地供奉在衣柜里；许久之后，当你再看见它的时候，却发现它已经过时了。所以，你就这样与它错过了。你也曾经买了一块漂亮的蛋糕却舍不得吃，郑重地供奉在冰箱里；许久之后，当你再看见它的时候，却发现它已经过期了。所以，你也这样与它错过了。没有在最喜欢的时候上身的衣裳，没有在最可口的时候品尝的蛋糕，就像没有在最想做的时候去做的事情，都是遗憾。生命也有保存期限，想做的事该趁早去做。如果你只是把你的心愿郑重地供奉在心里，却未曾去实行，那么唯一的结果，就是与它错过，一如那件过时的衣裳，一如那块过期的蛋糕 有些人注定是你生命中的过客，却总是成为你记忆中的常客，但永远也仅止于做客 你以为责任是什么？你以为责任就是终身相守，扔几个钱在家里。真正的责任是要在乎你所爱的人的每一分每一秒的感受 男人无事献殷勤非奸即盗，女人对爱来者不拒不是欺就是爱 人最伟大的力量不是创造，而是自省！如果不能自我反省，不能看到自身的错误和不足，即使有非凡的力量，创造出的一切都只是埋没自己的坟墓！ 越是嘴上说自己有原则的人，越是圆滑，因为他们的原则便是永远不说负责任的话，永远模棱两可！狡猾的眼神中永远透露的是欺骗，向下的嘴角代表的永远是严肃。 在我看来，绝大多数现代人的虚荣来自于虚伪，虚伪来自于自卑！在日常生活中衣着光鲜、牛逼哄哄的家伙其实内心很恐慌！]]></content>
      <categories>
        <category>人间词话</category>
      </categories>
      <tags>
        <tag>人间词话</tag>
        <tag>人生</tag>
        <tag>智慧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---基础语法(1)]]></title>
    <url>%2F2019%2F03%2F07%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95(1)%2F</url>
    <content type="text"><![CDATA[一.标识符​ 对于各种变量, 方法和类等要素 命名时使用的字符序列 称为标识符 凡是自己可以命名的地方都叫标识符, 都遵循标识符的规则 二.关键字​ 一些赋以特定的含义, 用作专门用途的字符串 成为关键字 大部分编辑会将关键字用特殊方式标出所有Java关键字都是小写英文 三. java基础数据类型3.1 Java常量​ eg: 整型常量: 123, 字符常量: ‘a’ 注意: 区分字符常量和字符串常量注意: “常量”这个名词还会用在另外其它语境中表示 值不可变的变量 3.2 Java变量1234// 变量i(变量的名字)中存放常量100(变量的值)int i = 100; float f = 3.14;String s = "hello"; 变量是 内存 中的一小块区域, 使用 变量名 来访问这块区域因此,每一个变量使用前必须要先 声明, 然后必须进行 赋值 (填充内容), 才能使用 补充(本质上理解): 一个程序在运行的时候，实际上这个程序是位于内存里面，然后才开始运行。一个.exe文件 存放在硬盘上是无法运行的 ，在硬盘上看到的.exe文件无非就是一个文件而已，当我们双击这个.exe文件时，运行起来的时候实际上是 整个.exe文件被放在了在内存里面 ，然后操作系统找到main方法，也就是程序的入口，然后就开始执行了。执行的过程之中，会不断地在内存里面分配一些区域 变量在内存里面就是一小块区域，变量有两个概念，一个是变量的名字，另一个是变量的值即这一小块区域是有名字的，里面装着一个值，因此以后要想访问这小块区域里面的内容就可以根据这小块区域的名字来访问了。因此，变量的本质就是一小块内存区域 。变量在内存里面分配多大的存储空间呢？ 答: 不同的变量类型分配不同大小的存储空间，每一个变量都是属于特定的数据类型的，声明成不同的数据类型，它就在内存里面分配不同的存储空间。 Java变量的分类:按被声明的 位置 划分: 局部变量: 方法或语句块内部定义的变量 成员变量: 方法外部, 类的内部定义的变量 类外面不能有变量的声明 按所属数据的 数据类型 划分: 基本数据类型变量 引用数据类型变量 3.3 Java数据类型3.3.1 基本数据类型 整数型: byte, short, int, long, 浮动型: float, double 布尔型: bool 字符型: char 3.3.2 基本数据类型的转换 boolean 类型不可以转换为其他的数据类型 容量小的类型自动转换为容量大的数据类型 容量大的类型转换为容量小的数据类型时, 要加上强制转换符,可能造成精度降低或溢出 有多种类型的数据混合运算时,系统首先自动的将所有数据类型转换成 容量最大 的那一种数据类型,然后在进行计算 范例1234567891011121314151617181920public class TestConvert &#123; public static void main(String arg[]) &#123; int i1 = 123; int i2 = 456; double d1 = (i1+i2)*1.2;//系统将转换为double型运算 float f1 = (float)((i1+i2)*1.2);//需要加强制转换符 byte b1 = 67; byte b2 = 89; byte b3 = (byte)(b1+b2);//系统将转换为int型运算，需要强制转换符 System.out.println(b3); double d2 = 1e200; float f2 = (float)d2;//会产生溢出 System.out.println(f2); float f3 = 1.23f;//必须加f long l1 = 123; long l2 = 30000000000L;//必须加l float f = l1+l2+f3;//系统将转换为float型计算 long l = (long)f;//强制转换会舍去小数部分（不是四舍五入） &#125;&#125; 3.3.3 引用数据类型 类(class) 接口(interface) 数组 四. 表达式以 ; 结尾的一段代码，即为一个表达式 范例123// 下面是两个表达式int a = 6;int b = a; 三目运算符条件运算符由两个符号组成”?“和”:“, 要求有3个操作对象,所以也叫它三目运算符 一般形式为 : 表达式1?表达式2:表达式3; 范例1234567if(a&lt;b) min = a;else mi n= b;// 可以用下面的条件运算符来处理// 执行过程: 如果 a&lt;b 为真,则表达式取a值, 否则取b值.min = (a&lt;b)?a:b; 参考博文:​ java基础学习总结——基础语法1 ​ Java中的三目运算符 详解]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo---常用命令]]></title>
    <url>%2F2019%2F03%2F07%2FHexo---%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. 写文章 写文章 你可以执行下列命令来创建一篇新文章。 hexo new #新建文章，可以改成中文的，如“新文章”，如果标题包含空格的话，请使用引号括起来。 删除文章 先删除目标文章，然后重新运行 hexo clean # 清除缓存文件 (db.json) 和已生成的静态文件 (public) hexo g -d # 文件生成后立即部署网站 写完文章后，你可以使用 hexo g # 全称hexo generate , 生成静态文件（generate：产生） hexo s # 全称hexo server , 启动服务器，默认情况下，访问网址为http://localhost:4000/在本地预览效果 hexo d # 全称hexo deploy, 部署网站，同步到github上（deploy：部署） 2. 分类和标签 Front-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说： 12title: Hello Worlddate: 2013/7/13 20:46:25 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 分类和标签 只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 123456categories:- Diarytags:- PS3- Games# 会使分类Games成为PS3的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试经典题目（1-5题）]]></title>
    <url>%2F2019%2F03%2F07%2FJava%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE(1-5%E9%A2%98)%2F</url>
    <content type="text"><![CDATA[1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？答案： 运行原理：Java源程序经过javac 编译器编译成二进制的xx.class 字节码文件, xx.class 在jvm（各平台装有不同的jvm）上运行，Java解释器（jvm的一部分）会将相同的字节码解释成对应平台的机器码，进而执行。 知识： 一份 xx.class 文件(不会变化）被 不同的jvm 解释成 相对应的机器码 机器码: 依附于硬件，根本不存在跨平台行，不同型号的CPU给相同的指令（eg：10011110）,解析成不同的结果 题外知识： JDK (Java Development Kit): Java开发工具包，针对于Java开发员的产品，JDK是整个Java的核心，包括了JRE, Java工具（Javac【编译Java源码的编译器】，Java程序调试和分析的工具）和Java基础的类库（即Java API) JRE (Java runtime environment)：Java运行环境 ,针对于使用Java程序的用户，Java程序运行做需要的软件环境，不是一个开发环境, 包含jvm，Java基础类库, 不包含任何开发工具（如编译器和调试器）。 JVM (Java Virtual Machine): Java虚拟机，实现Java跨平台的最核心的部分，JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行 2. JDK和JRE的区别是什么？答案： 详细区别见第一题 如果需要运行Java程序，只需要安装JRE（JRE根据不同操作系统有很多不同的版本） 如果需要编写Java程序，需要安装JDK 补充知识： JRE和JVM的区别是什么？ JRE包括JVM和lib（Jvm所需要的类库），JRE里有运行xx.class 的Java.exe 只有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库 时间：2019.3.7 3. ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？答案: static 表示静态的意思, 可用于修饰 成员变量和 方法 , 静态是随着类的加载而加载, 因此可以直接用类进行访问 private私有的方法不能被继承，子类就没有访问权限 覆盖 覆盖基于运动时动态绑定的 指覆盖了一个方法并且对其重写，以求达到不同的作用,，但是子类中的访问权限要不低于父类中的访问权限,重写的前提是必须要继承. Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。 私有的方法不能被继承，子类就没有访问权限，肯定也是不能别覆盖的。 12345678910111213141516171819202122232425262728class Super&#123; // 静态方法 static String greeting()&#123; return "Good night"; &#125; String name()&#123; return "Richard"; &#125; &#125; class Sub extends Super&#123; //子方法,继承Super //重写(覆盖)父类当中的静态方法 static String greeting()&#123; return "Hello"; &#125; String name()&#123; return "Dick"; &#125; &#125;class Test&#123; public static void main(String[] args)&#123; Super s = new Sub(); System.out.println(s.greeting()+","+s.name()); &#125; &#125;//运行结果：Good night,Dick (静态方法打印的是父类中的)//这个例子说明“实例方法被覆盖，静态方法被隐藏” 4. 是否可以在static环境中访问非static变量？答案: 不可以 因为静态的成员属于类，随着类的加载而加载到静态方法区内存，当类加载时，此时不一定有实例创建，没有实例，就不可以访问非静态的成员。 静态变量属于类变量，随着类的加载而加载，当调用类变量时Java虚拟机会对类的静态变量，静态方法进行初始化，此时如果静态方法中有非静态变量，由于非静态变量是随着实例的创建而创建，此时还没有实例创建，所以非静态变量还没有创建，所以会出现编译错误。 参考博文:​ 牛客网优质答案 时间: 2019.3.11 5. Java支持的数据类型有哪些？什么是自动拆装箱？答案: 基本数据类型 整数型: byte, short, int, long, 浮动型: float, double 布尔型: bool 字符型: char 整数默认int型，小数默认是double型。Float和long类型的必须加后缀。 引用类型 引用类型也就是我们常说的对象，在Java中每个基础类型的数据都有其包装类，对应上面分别是：Byte, Short, Int, Long, Float, Double, Char, Boolean 引用类型包括类、数组、接口, String等 自动装箱和拆箱就是基本类型和引用类型之间的转换 装箱：将基本类型转换成引用类型，如 Integer i = 10; 拆箱：将引用类型转换成基础类型，如 Integer i = 10; int j = i; 转化为引用类型之后，就可以new一个对象，从而就可以调用包装类型中的封装好的方法，方便使用 参考博客​ 牛客网优质答案 时间: 2019.3.12]]></content>
      <categories>
        <category>java面试常考题目</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java面试常考题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间词话---惊艳的文字]]></title>
    <url>%2F2019%2F03%2F06%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E6%83%8A%E8%89%B3%E7%9A%84%E6%96%87%E5%AD%97%2F</url>
    <content type="text"><![CDATA[现代诗 酒入豪肠，七分酿成了月光，余下的三分啸成剑气，绣口一吐，就半个盛唐。 —余光中《寻李白》 古诗 少年不知愁滋味,爱上层楼,爱上层楼.为赋新词强说愁.而今识尽愁滋味,欲说还休,欲说还休,却道天凉好个秋. —辛弃疾《丑奴儿》 十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。料得年年肠断处，明月夜，短松冈。 —苏轼 古文 斯是陋室,惟吾德馨. —刘禹锡《陋室铭》 夏虫不可语冰 —孔子 文章摘要 我知道我很大胆冒昧, 听说你朋友很多, 我不配高攀, 可是很想在你的朋友里凑个数目. —钱钟书《围城》 别客气,我求你明天来.我想去吃,对自己没有好借口,借你的名义,自己享受一下,你就体贴下情,答应了吧. —钱钟书《围城》]]></content>
      <categories>
        <category>人间词话</category>
      </categories>
      <tags>
        <tag>人间词话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间词话---文章]]></title>
    <url>%2F2019%2F03%2F06%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[感谢困难​ 林清玄​ 我做了一个梦。 梦见我在街上问人：“请问您可不可以给我一些困难、一些挫折，一些痛苦?” 所有的人都拒绝我，我着急地恳求别人：“那么，我雇用您，每小时五百元，请您给我一些折磨!” 那些陌生人摇摇头，沉默地离开，我因找不到愿意折磨我的人而惊醒。 我坐在床上发呆，是呀!困难，折磨，痛苦是多么珍贵!如果一切平顺，谁会静下来沉思，谁会生起智慧，谁又能在平凡安逸的日子中超越自我、登上高峰呢? 如果没有困难，谁又会谦卑地跪下来祈祷?谁又能相信有无边的宇宙?谁又能寄情于来生呢? 我深深地感谢着困难、挫折与痛苦。 也深深地感恩那些曾经折磨过我的人，他们是多么慈悲呀!我并未花钱聘雇他们，他们却以宝贵的时间来考验我、提升我，为了增长我的智慧。 真正的高贵​ 海明威 ​ 在风平浪静的大海，每个人都是领航员。 ​ 但是，只有阳光而无阴影，只有欢乐而无痛苦，那就不是人生。以最幸福的人的生活为例.他的生活也是一团缠结在一起的乱麻。痛苦与幸福交替出现,使得我们一会悲伤，一会高兴，甚至死亡本身也会使生命更加可爱。在人生的清醒的时刻，在悲伤与失落的阴影之下，人们与真实的自我最接近。 ​ 在生活和事业的种种事物中，性格比才智更能指导我们, 心灵比头脑更能引导我们,而由判断获得的克制, 耐心和教养比天分更能让我们受益。 ​ 我始终相信，内心生活开始更为严谨的人，他的外在生活也会变得更为简朴。在一个物欲横流的年代，但愿我能向世人表明，人类真正需求少得多么可怜。 ​ 反思自己的过错不至于重蹈覆辙才是真正的悔悟, 高人一等并没有什么值得夸耀的。真正的高贵是优于过去的自己。]]></content>
      <categories>
        <category>人间词话</category>
      </categories>
      <tags>
        <tag>人间词话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常见简写]]></title>
    <url>%2F2019%2F02%2F28%2FJava%E5%B8%B8%E8%A7%81%E7%AE%80%E5%86%99%2F</url>
    <content type="text"><![CDATA[ORM Object Relational Mapping 对象关系映射 对象和关系数据库的映射简单说，一个对象，对应数据库里的一条记录 DAOData Access Object的缩写，这些类专门用于进行数据库访问的操作]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曾仕强教授语录]]></title>
    <url>%2F2019%2F01%2F10%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E6%88%91%E6%88%90%E9%95%BF---%E6%9B%BE%E4%BB%95%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[很多事情，从不同的角度看，才能体会到其中的奥妙 做一个领导者，一定要充分了解下属的特性是什么，及时的下达合理的命令，而且效果要非常的良好，此为将才 事事都透露着一个人的能力 顾全大局，大局的前提底下，很多细小的事情，不用太过于考虑 一件事，从不同的角度看，都有道理，怎么讲都对，不是对不对的事，是价值观的体现 得意勿忘形，人在得意时，千万不能忘形，做事情随他爱怎样怎样，变为得意忘形，当一个人处于逆境的时候，他还会谨慎一点，当一个人处顺境的时候，他就开始沉不住气 形势比人强 人生的理想在于不断提升自己的层次 有智慧没知识容易陷入空想，一事无成。有知识没智慧，就不要埋怨被人当做工具使用，用毕即弃。要善用智慧来运用知识，以求合理的表现 处逆境容易，正因留意，处顺境很难，正因大意 你要很谨慎地去保留你独特的地方，这个独特之处就是你之所以为人的地方。能够自我成全，才是人最伟大的地方]]></content>
      <categories>
        <category>人间词话</category>
      </categories>
      <tags>
        <tag>人间词话</tag>
        <tag>人生</tag>
        <tag>智慧</tag>
      </tags>
  </entry>
</search>
