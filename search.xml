<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java基础知识---方法的重载和覆盖]]></title>
    <url>%2F2019%2F03%2F11%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[一. 方法的重载(overload)指一个类中可以定义有 相同的名字 ,但 参数不同 的多个方法. 调用时, 会根据 不同的参数表 选择对应的方法 范例 构造方法 注意 方法名一样, 但参数不一样,就是重载(overload) 参数不一样 (1.参数的个数不一样 2. 参数的类型不一样, 只要有一个就可以) 方法名一样，参数类型一样，只有返回值不一样，这个不构成重载 理解: 多重加载，不同样式的加载 二. 方法的覆盖(override)指覆盖了一个方法并且对其重写，以求达到不同的作用,也可以叫做 重写 范例 对 接口方法 的实现 在 继承 中也可能会在 子类覆盖父类 中的方法 注意 覆盖的方法的标志必须要和被覆盖的方法的 标志 (相同的名字和相同的参数)完全匹配，才能达到覆盖的效果； 覆盖的方法的返回值必须和被覆盖的方法的返回一致； 覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类； 被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖 参考博文 java中的方法覆盖（Overriding）和方法重载（Overloading）是什么意思？重写跟重载的区别？ 对比Java语言中的覆盖和重载]]></content>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---Java基础知识---访问修饰符]]></title>
    <url>%2F2019%2F03%2F11%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[区别 public：public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用 private：private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可以使用。 protected：protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private 不写时默认为friendly ，也即是“包访问权限” 详细 作用域 自身 同包子类 不同包子类 同包类 其他类 private 访问(√) 继承(×) 继承(×) 访问(×) 访问(×) package 访问(√) 继承(√) 继承(×) 访问(√) 访问(×) protected 访问(√) 继承(√) 继承(√) 访问(√) 访问(×) public 访问(√) 继承(√) 继承(√) 访问(√) 访问(√) 如何使用 属性 通常使用private封装起来 方法 一般使用public用于被调用 会 被子类继承 的方法，通常使用protected package用的不多，一般新手会用package,因为还不知道有修饰符这个东西 总结 如果一个成员需要被外部包所访问，则必须使用public修饰符；如果一个成员需要被定义在不同包下的子类所访问，则可以使用public或protected修饰符；如果一个成员需要被本包下的其他类所访问，则可以不用写任何的修饰符，使用public或者protected也行 若一个成员想使用同类中其他成员，则使用任意一个修饰符即可；若一个成员不想被任何一个外部的类所访问，则使用private关键字比较恰当。 参考博客: Java中private、public、default、protected的区别]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间词话---ZJ]]></title>
    <url>%2F2019%2F03%2F09%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---ZJ%2F</url>
    <content type="text"><![CDATA[没有人会拒绝微笑, 也没有人会拒绝真诚. 逢山开路, 遇水架桥.]]></content>
      <tags>
        <tag>人间词话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间词话---送给自己]]></title>
    <url>%2F2019%2F03%2F09%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[勇者愤怒, 抽刃向更强者.怯者愤怒, 却抽刀向更弱者 扬在脸上的微笑, 长在心里的善良,融进血液的骨气, 刻在生命里的坚强. 礼仪最重要的是在昭告自我,真正的宣誓是对自己说的话. —陈果 对一切人,一切西乡都保持一种开放二友善的胸襟和气度的时候,才真正成为名副其实的大学生. —陈果 挫折能使强者更强,弱者更弱,强者在面对中锻炼了自己,弱者在逃避中越发脆弱 最善言谈者就是最善于倾听的人]]></content>
      <tags>
        <tag>人间词话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间词话---网易云评论]]></title>
    <url>%2F2019%2F03%2F09%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%84%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[卿卿我我 写歌的人假正经, 听歌的人最无情.人要是桥请起来,听什么都像在唱自己. 校服是我和她唯一穿过的情侣装, 毕业照是我和她唯一的合影. 情怀 愿走出半生, 归来仍是少年.]]></content>
      <tags>
        <tag>人间词话</tag>
        <tag>网易云评论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---面向对象(1)]]></title>
    <url>%2F2019%2F03%2F09%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(1)%2F</url>
    <content type="text"><![CDATA[一. 面向过程的思想和面向对象的思想面向过程 自顶向下,逐步细化 ​ 面向解决问题的过程进行编程 ​ 按照步骤化解决问题.(一个问题,分析这个问题如何去解决,第一步做什么, 第二步什么…), 当我们用面向过程的思想去编程或解决问题时，首先一定要把详细的实现过程弄清楚。一旦过程设计清楚，代码的实现简直轻而易举。 面向对象 万物皆对象, 人在思考的时候，首先眼睛里看到的是一个一个的对象。，实体(对象)就是动作的支配者，没有实体，就肯定没有动作发生！ ​ 在编程的时候尽可能的去模拟真实的现实世界，按照现实世界中的逻辑去处理一个问题，分析问题中参与其中的有哪些实体，这些实体应该有什么属性和方法，我们如何通过调用这些实体的属性和方法去解决问题。 拿到一个问题,应该分析 : 这个问题里面有哪些类和对象 在分析这些类和对象应该具有哪些属性和方法 分析类和类之间具有什么关系 设计思维: 合适的方法应该出现在合适的类里面 二. 类和对象类一类事物的抽象包括属性(静态)和方法(动态) Java中属性或者成员变量是一回事,方法就是函数, 不同的叫法 对象一类事物的具体的某一个东西(符合这类事物的具体特征) 在Java中, 对象就是类的实例化 随笔: 对象和类是分不开的，必须首先定义类才能有对象 三. 面向过程与面向对象的特点总结: 都可以实现代码重用和模块化编程，但是面对对象的模块化更深，数据更封闭，也更安全！因为面向对象的封装性更强！ 面对对象的思维方式更加贴近于现实生活，更容易解决大型的复杂的业务逻辑 从前期开发角度上来看，面对对象远比面向过程要复杂，但是从维护和扩展功能的角度上来看，面对对象远比面向过程要简单！ 当我们的业务逻辑比较简单时，使用面向过程能更快的实现 当我们的业务逻辑比较简单时，使用面向过程能更快的实现]]></content>
      <categories>
        <category>java基础知识</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---基础语法(2)]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95(2)%2F</url>
    <content type="text"><![CDATA[一. 语句1.1 条件语句 if 语句 switch 语句 循环语句 for 循环语句 while 循环与do while 循环 break 和 continue 语句 二. 方法 一段用来完成特定功能的代码片段 1234[修饰符1 修饰符2 ...] 返回值类型 方法名(形式参数列表) &#123; java 语句; ...&#125; 方法可以有返回值，但可以不用这个返回值。方法首先要定义，然后才能调用 三、变量的作用域 变量的作用域只在“{ }”有效，出了这个“{ }”就没有作用了 四、递归调用 递归：在一个方法内部对自身的调用就称为递归 具体的参考 孤傲苍狼 博客 五、程序的执行过程 参考博文: 孤傲苍狼 java基础学习总结——基础语法2]]></content>
      <categories>
        <category>java基础知识</category>
        <category>基础语法</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---基础语法(1)]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95(1)%2F</url>
    <content type="text"><![CDATA[一.标识符​ 对于各种变量, 方法和类等要素 命名时使用的字符序列 成为标识符 凡事自己可以命名的地方都叫标识符,都遵循标识符的规则 二.关键字​ 一些赋以特定的含义, 用作专门用途的字符串 成为关键字 大部分编辑会将关键字用特殊方式标出 所有Java关键字都是小写英文 三. java基础数据类型Java常量​ eg: 整型常量: 123, 字符常量: ‘a’ 注意: 区分字符常量和字符串常量 注意: “常量”这个名词还会用在另外其它语境中表示 值不可变的变量 Java变量1234//变量i(变量的名字)中存放常量100(变量的值)int i = 100; float f = 3.14;String s = "hello"; 变量是 内存 中的一小块区域, 使用 变量名 来访问这块区域 因此,每一个变量使用前必须要先 声明, 然后必须进行 赋值 (填充内容), 才能使用 补充(本质上理解): 一个程序在运行的时候，实际上这个程序是位于内存里面，然后才开始运行。一个.exe文件 存放在硬盘上是无法运行的 ，在硬盘上看到的.exe文件无非就是一个文件而已，当我们双击这个.exe文件时，运行起来的时候实际上是 整个.exe文件被放在了在内存里面 ，然后操作系统找到main方法，也就是程序的入口，然后就开始执行了。执行的过程之中，会不断地在内存里面分配一些区域 变量在内存里面就是一小块区域，变量有两个概念，一个是变量的名字，另一个是变量的值 即这一小块区域是有名字的，里面装着一个值，因此以后要想访问这小块区域里面的内容就可以根据这小块区域的名字来访问了。因此，变量的本质就是一小块内存区域 。就变量来说，该在内存里面分配多大的存储空间呢？不同的变量类型分配不同大小的存储空间，每一个变量都是属于特定的数据类型的，声明成不同的数据类型，它就在内存里面分配不同的存储空间。 Java变量的分类:按被声明的 位置 划分: 局部变量: 方法或语句块内部定义的变量 成员变量: 方法外部, 累的内部定义的变量 类外面不能有变量的声明 按所属数据的 数据类型 划分: 基本数据类型变量 引用数据类型变量 Java数据类型基本数据类型 整数型: byte, short, int, long, 浮动型: float, double 布尔型: bool 字符型: char 引用数据类型 类(class) 接口(interface) 数组 基本数据类型的转换 boolean 类型不可以转换为其他的数据类型 容量小的类型自动转换为容量大的数据类型 容量大的类型转换为容量小的数据类型时, 要加上强制转换符,可能造成精度降低或溢出 有多种类型的数据混合运算时,系统首先自动的将所有数据类型转换成 容量最大 的那一种数据类型,然后在进行计算 1234567891011121314151617181920public class TestConvert &#123; public static void main(String arg[]) &#123; int i1 = 123; int i2 = 456; double d1 = (i1+i2)*1.2;//系统将转换为double型运算 float f1 = (float)((i1+i2)*1.2);//需要加强制转换符 byte b1 = 67; byte b2 = 89; byte b3 = (byte)(b1+b2);//系统将转换为int型运算，需要强制转换符 System.out.println(b3); double d2 = 1e200; float f2 = (float)d2;//会产生溢出 System.out.println(f2); float f3 = 1.23f;//必须加f long l1 = 123; long l2 = 30000000000L;//必须加l float f = l1+l2+f3;//系统将转换为float型计算 long l = (long)f;//强制转换会舍去小数部分（不是四舍五入） &#125;&#125; 参考博文: java基础学习总结——基础语法1 孤傲苍狼]]></content>
      <categories>
        <category>java基础知识</category>
        <category>基础语法</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---面向对象(2)]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(2)%2F</url>
    <content type="text"><![CDATA[一. Java类的定义 使用 class 关键字定义一个类 12345678910class Person &#123; // 成员变量(属性)定义 private int id; private int age = 10; //方法定义 public int getAge() &#123; return age; &#125; public void setAge(int i) &#123; age = i; &#125;&#125; 二. 成员变量 成员变量的作用范围为 整个类体 定义成员变量可以对其初始化, 如果 不对其初始化 , Java 使用默认的值 对其初始化(若不记得JAVA对成员变量默认的初始化是多少的话，定义一个成员变量，不给它初始化，然后直接打印这个成员变量,进行查看) 在 JAVA 里面的任何变量首先应该要声明，然后再赋值，然后再使用 成员变量和局部变量的区别: 成员变量 局部变量 不进行初始化 默认给初始化 不默认给初始化, 在方法里面声明一个局部变量如果不给它初始化时就会出错 三. 基本概念 — 引用​ Java语言中 除基本类型之外 的变量类型都称之为引用类型 Java中的对象是通过引用对其操作的 基本类型与引用类型的区别: 基本类型 引用类型 实现 当声明一个int i=0时，系统会马上给这个i分配一个内存空间（在 栈内存 里面分配一小块区域用来装数字0），里面装着一个值为0，以后使用i这个名字马上就可以访问这个内存空间里面的值 定义好这个类之后，需要使用new关键字把这个类的对象实例化出来，也就是真真正正造出一个对象出来才能使用这个对象 内存 占 一块 内存 占 两块 内存 存放位置 栈内存 栈内存: 引用对象 堆内存: 真正的内容(new出来的东西) 不论是基本数据类型还是引用类型，都会先在栈中分配一块内存 ，对于基本类型来说，这块区域包含的是 基本类型的内容；而对于引用类型来说，这块区域包含的是 指向真正内容的指针(存放真正内容的地址) ，真正的内容被手动的分配在堆上。 代码实例:123456789101112131415161718public class Hero &#123; String name; //姓名 float hp; //血量 public static void main(String[] args) &#123; //代表创建了一个Hero对象 //但是也仅仅是创建了一个对象，没有办法访问它 //为了访问这个对象，会使用引用来代表这个对象 new Hero(); //"h"这个变量是Hero类型，叫做引用(也叫 引用对象,对象的引用) //"="的意思指的h这个引用代表右侧创建的对象 //“代表” 在面向对象里，又叫做“指向” //引用h指向了新建的Hero对象 Hero h = new Hero(); &#125; &#125; 多个引用，一个对象，一个引用，多个对象区别： 多个引用指向一个对象，操作的都是同一个对象 一个引用多个对象，之前的对象就没有办法访问了, 这个引用就指向了另一个对象 四. 类和对象的关系如何在内存中区分类和对象 类是 静态 的概念, 在代码区 对象是new出来的, 位于 堆内存 , 类的每个成员变量在不同的对象中都有不同的值 (除了静态变量,static),而方法只有一分,执行的时候才占用内存 . 五. 构造方法(函数) 主要作用 :完成对象的初始化工作，(如果写的类里面没有构造函数,那么编译器会默认加上一个无参数且方法体为空的构造函数) 特点 使用 new + 构造方法创建一个新的对象 构造函数是定义在 Java类中的一个用来 初始化对象 的函数,(new一个东西的时候，实际上你调用的是一个构造方法，构造方法就是把自己构造成一个新的对象，所以叫构造方法，构造一个新对象用的方法叫构造方法) 构造函数与类同名且没有返回值(构造方法的名字必须和类的名字完全一模一样，包括大小写,这个方法的名字和类名完全相同，并且没有返回值，也就是在这个方法前面不能写任何的方法的返回类型修饰符，连void都不可以写) 范例12345678910111213141516public class Person &#123; int id; //在person这类里面定义两个成员变量id和age, int age=20; //给成员变量age赋了初值为20 /**这里就是person这个类的一个构造方法 * 构造方法的规则很简单，和类名要完全一样，一点都不能错，包括大小写。 * 并且没有返回值，不能写void在它前面修饰 * @param _id * @param _age */ public Person(int _id,int _age ) &#123; id = _id; age = _age; &#125;&#125;//内存分析见 孤傲苍狼博客 注意 如果类已经有了一个有参数有方法体的构造函数,这时编译器就不会再给它默认加上一个无参且方法体为空的构造函数.可以理解为无参的构造函数被覆盖了.这种情况称为没有默认构造函数 随笔数据区、代码区、栈区、堆区 区别: 栈区(stack)：由系统的编译器自动的释放， 主要用来存放方法中的参数，一些临时的局部变量等 ，并且方法中的参数一般在操作完后，会由编译器自动的释放掉。 堆区(heap):由程序员决定，在Java中，如果程序员不释放的话，一般会由垃圾回收机制自动的清理掉。此区域主要用来 存放我们经常创建的对象、动态的申请的临时空间等 。 数据区(data seg):也称全局区或者静态区，根据名称我们就应该知道用来存放一些全局的东西，比如我们经常用到的 静态变量、全局变量等 都会存放到数据区，此区域上的东西都被全局所共享。比如我们可以采取类名.的方式就可以访问到方法，这就是所谓的静态方法，存放到数据区的。 代码区：存放 程序编译后可以执行代码的地方 。比如执行代码时写的While语句、if条件语句等，都会存放到此 理解了内存，就理解了一切，就理解了各种各样的语言。所有的语言无非都是这样：局部变量分配内存永远在栈里面，new出来的东西分配内存永远是在堆里，静态的东西分配内存永远是在数据区。剩下的代码肯定是在代码区 参考博文:how2J 类和对象 孤傲苍狼 java基础学习总结——面向对象2 Java基本数据类型与引用数据类型 及在堆栈中内存的存储原理 数据区、代码区、栈区、堆区]]></content>
      <categories>
        <category>java基础知识</category>
        <category>java面向对象</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识---static关键字]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86---static%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Static 关键字理解: 在类中用static声明的成员变量为 静态成员变量 (也叫类变量), 为该类的公共变量, 在第一次使用时被初始化, 这个成员变量 只有一份 ，而且这一份是这个类 所有的对象 共享。 在static声明的方法为静态方法(也叫类方法),在调用该方法时, 不会将对象的引用传递给他, 所以在static方法中 不可以访问非static的成员 (静态方法不再是针对某一个对象来调用，所以不能访问非静态的成员) 可以通过对象引用或 类名 (不需要实例化)访问静态成员 (静态的变量可以通过对象名去访问，也可以通过类名去访问，两者访问的都是同一块内存) 被static修饰的变量被称为类变量，被其修饰的方法成为类方法，其随着类的加载而被加载 字符串常量是分配在数据区里面的 静态成员变量是属于整个类的，它不属于专门的某个对象 非静态成员专属于某一个对象，想访问非静态成员必须new一个对象出来才能访问 ①static可以修饰内部类，但是不能修饰普通类。静态内部类的话可以直接调用静态构造器（不用对象）。 ②static修饰方法， static 方法就是没有 this 的方法。在 static 方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用 static 方法。这实际上正是 static 方法的主要用途。 方便在没有创建对象的情况下来进行调用（方法/变量）。 最常见的static方法就是main,因为所有对象都是在该方法里面实例化的，而main是程序入口，所以要通过类名来调用。还有就是main中需要经常访问随类加载的成员变量。 ③static修饰变量，就变成了静态变量，随类加载一次，可以被多个对象共享。 ④static修饰代码块，形成静态代码块，用来优化程序性能，将需要加载一次的代码设置成随类加载，静态代码块可以有多个。 参考博文:java基础学习总结——static关键字优质答案]]></content>
      <categories>
        <category>java基础知识</category>
        <category>Static关键字</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言基础知识]]></title>
    <url>%2F2019%2F03%2F08%2FC%E8%AF%AD%E8%A8%80---%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[C语言基础知识:指针:指针变量: 专门用来存放地址的特殊变量 指针 ( = 变量的值) 指针变量 ( = 变量) 含义 地址 存放另一个变量地址的变量 指针与指针变量的关系类似于变量的值与变量的区别. 指针变量习惯上简称为 指针 1234567891011int main()&#123; int a, * p; p = &amp;a; // "&amp;a" 代表a的地址的值 a = 3; printf("p的值为 %d\n", p); // p中存放的是 a 的地址 printf("*p的值为 %d", *p); // * 号在 引用时表示"指向"操作, *p 代表 a, // "*"仅起到标志的作用, 表示该变量为指针变量, 不是变量名的一部分, 及指针变量名不包括 * return 0 ;&#125; 结构体:定义: 将一些已知的数据类型放在一起来定义的一种数据类型 结构体并没有创造出新的数据类型，这点要搞清楚。C语言的结构体和其他高级语言的类有点相似的概念，可以完成对一种事物的抽象。 代码中的定义: 1234567891011121314151617struct 结构名 // 结构名是结构的标识符不是变量名&#123; 类型 变量名; 类型 变量名;&#125; 结构变量;// 例子:struct student &#123; char name[8]; int age; char sex[2]; char depart[20]; float wage1, wage2, wage3, wage4, wage5; &#125; Mike, Marry;struct student John; // struct student:类型说明符, John 变量名// 定义了两个 struct student 类型的变量 Mike, Marry typedef: 使用 typedef 关键字来定义自己习惯的数据类型名称，来替代系统默认的基本类型名称、数组类型名称、指针类型名称与用户自定义的结构型名称、共用型名称、枚举型名称等。 eg: 结构体12345678910// 以结构体为例，下面我们定义一个名为 Point 的结构体struct Point&#123; double x; double y; double z;&#125;;// 在调用这个结构体时，我们必须像下面的代码这样来调用这个结构体struct Point oPoint1 = &#123;100，100，0&#125;;struct Point oPoint2; 现在，我们利用 typedef 定义这个结构体123456typedef struct tagPoint&#123; double x; double y; double z;&#125; Point; 上面的代码中，实际上完成了两个操作123456789101112131415// 1.定义了一个新的结构类型struct tagPoint&#123; double x; double y; double z; //struct 关键字和 tagPoint 一起构成了这个结构类型，无论是否存在 typedef 关键字，这个结构 都存在&#125;;// 2.使用 typedef 为这个新的结构起了一个别名，叫 Pointtypedef struct tagPoint Point//现在你就可以像 int 和 double 那样直接使用 Point 定义变量Point oPoint1 = &#123;100，100，0&#125;;Point oPoint2; 参考文章: typedef的用法，C语言typedef详解]]></content>
      <categories>
        <category>C语言</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构---线性表]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[线性表：定义:​ 由 n(n≥0) 个数据特性相同的元素构成的 有限序列 特点: 存在唯一的一个被称为”第一个”的数据元素 存在唯一的一个被称为”最后一个”的数据元素 除第一个之外, 结构中的每个数据元素均只有一个前驱元素 除最后一个之外, 结构中的每个数据元素均只有一个后继元素 存储结构及运算: 存储结构方式: 顺序存储方式(顺序表), 链接存储方式(链表) 运算: 线性表的初始化 求表的长度 取出表的元素 查找运算 随笔: 线性表中的数据元素之间的逻辑关系就是其相互位置上的 邻接关系 ,该关系是线性的,因此,线性表是一种线性结构 常见例子: 学生成绩表, 列车时刻表, 英文字母表 顺序表特点:​ 逻辑关系相邻的两个结点在 物理位置 上也相邻, 结点的逻辑次序和物理次序一致 实现方式:​ 数组 基本操作的实现: 初始化 1234Status InitList(SqList &amp;L)&#123; L.elem = new&#125; ​]]></content>
      <categories>
        <category>数据结构</category>
        <category>线性表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[涂磊老师语录]]></title>
    <url>%2F2019%2F03%2F07%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E6%88%91%E6%88%90%E9%95%BF---%E6%B6%82%E7%A3%8A%2F</url>
    <content type="text"><![CDATA[我们总是善于去伤害那些爱我们的人， 因为我们根本伤害不了那些不爱我们的人;我们总是甘愿被那些我们爱的人伤害，那是因为我爱他们 喜欢可以心动，而爱一定会心痛；喜欢可以舍得，但爱一定舍不得；喜欢一个人，冬天不过是冬天，不过是漂亮一点而已；但是爱一个人，冬天可以变成春天；爱一个人，她落泪你就会跟着她一起落泪；而喜欢一个人，她落泪你只不过是安慰；喜欢是可以变成爱的，但如果爱了就说不出喜欢；喜欢是不排她的，而爱一定是排她的，唯一的；喜欢与责任无关，而爱一定要负责任，这就是喜欢和爱的区别 春风得意的浪子回头最珍贵，穷途末路的认错悔改最虚伪 你曾经买了一件很喜欢的衣裳却舍不得穿，郑重地供奉在衣柜里；许久之后，当你再看见它的时候，却发现它已经过时了。所以，你就这样与它错过了。你也曾经买了一块漂亮的蛋糕却舍不得吃，郑重地供奉在冰箱里；许久之后，当你再看见它的时候，却发现它已经过期了。所以，你也这样与它错过了。没有在最喜欢的时候上身的衣裳，没有在最可口的时候品尝的蛋糕，就像没有在最想做的时候去做的事情，都是遗憾。生命也有保存期限，想做的事该趁早去做。如果你只是把你的心愿郑重地供奉在心里，却未曾去实行，那么唯一的结果，就是与它错过，一如那件过时的衣裳，一如那块过期的蛋糕 有些人注定是你生命中的过客，却总是成为你记忆中的常客，但永远也仅止于做客 你以为责任是什么？你以为责任就是终身相守，扔几个钱在家里。真正的责任是要在乎你所爱的人的每一分每一秒的感受 男人无事献殷勤非奸即盗，女人对爱来者不拒不是欺就是爱 人最伟大的力量不是创造，而是自省！如果不能自我反省，不能看到自身的错误和不足，即使有非凡的力量，创造出的一切都只是埋没自己的坟墓！ 越是嘴上说自己有原则的人，越是圆滑，因为他们的原则便是永远不说负责任的话，永远模棱两可！狡猾的眼神中永远透露的是欺骗，向下的嘴角代表的永远是严肃。 在我看来，绝大多数现代人的虚荣来自于虚伪，虚伪来自于自卑！在日常生活中衣着光鲜、牛逼哄哄的家伙其实内心很恐慌！]]></content>
      <categories>
        <category>感悟</category>
        <category>涂磊老师</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>人生方向</tag>
        <tag>智慧</tag>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[陈果老师语录]]></title>
    <url>%2F2019%2F03%2F07%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E6%88%91%E6%88%90%E9%95%BF---%E9%99%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[只有心灵才能洞察一切，世界上真正重要的东西要用心去看 你使用什么样的双眼观世界，就印证了你有怎样的心眼，如果心眼大，你所见的世界宽广无边，如果你心眼小，充满羡慕嫉妒恨，所见的世界也是偏狭丑陋 选择之所以称之为选择，一定是痛苦的，因为选项是不相上下的，能轻松做决定的，都不叫选择，选择意味着舍弃一种美好，承受一种痛苦，不安 回忆是一种重逢, 忘记是一份自由.]]></content>
      <categories>
        <category>感悟</category>
        <category>陈果老师</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>人生方向</tag>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 常用命令]]></title>
    <url>%2F2019%2F03%2F07%2FHexo---%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. 写文章 写文章 你可以执行下列命令来创建一篇新文章。 hexo new #新建文章，可以改成中文的，如“新文章”，如果标题包含空格的话，请使用引号括起来。 删除文章 先删除目标文章，然后重新运行 hexo clean # 清除缓存文件 (db.json) 和已生成的静态文件 (public) hexo g -d # 文件生成后立即部署网站 写完文章后，你可以使用 hexo g # 全称hexo generate , 生成静态文件（generate：产生） hexo s # 全称hexo server , 启动服务器，默认情况下，访问网址为http://localhost:4000/在本地预览效果 hexo d # 全称hexo deploy, 部署网站，同步到github上（deploy：部署） 2. 分类和标签 Front-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说： 12title: Hello Worlddate: 2013/7/13 20:46:25 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 分类和标签 只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 123456categories:- Diarytags:- PS3- Games# 会使分类Games成为PS3的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类]]></content>
      <categories>
        <category>hexo</category>
        <category>基本操作</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>写作常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试经典题目（1-6题）]]></title>
    <url>%2F2019%2F03%2F07%2Fjava%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%EF%BC%881-6%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？答案： 运行原理：java源程序经过javac 编译器编译成二进制的xx.class 字节码文件, xx.class 在jvm（各平台装有不同的jvm）上运行，java解释器（jvm的一部分）会将相同的字节码解释成对应平台的机器码，进而执行。 知识： 一份 xx.class 文件(不会变化）被 不同的jvm 解释成 相对应的机器码 机器码: 依附于硬件，根本不存在跨平台行，不同型号的CPU给相同的指令（eg：10011110）,解析成不同的结果 题外知识： JDK (Java Development Kit): Java开发工具包，针对于Java开发员的产品，JDK是整个Java的核心，包括了JRE, Java工具（javac【编译java源码的编译器】，java程序调试和分析的工具）和Java基础的类库（即Java API) JRE (Java runtime environment)：Java运行环境 ,针对于使用Java程序的用户，java程序运行做需要的软件环境，不是一个开发环境, 包含jvm，java基础类库, 不包含任何开发工具（如编译器和调试器）。 JVM (Java Virtual Machine): Java虚拟机，实现java跨平台的最核心的部分，JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行 2. JDK和JRE的区别是什么？答案： 详细区别见第一题 如果需要运行Java程序，只需要安装JRE（JRE根据不同操作系统有很多不同的版本） 如果需要编写Java程序，需要安装JDK 补充知识： JRE和JVM的区别是什么？ JRE包括JVM和lib（Jvm所需要的类库），JRE里有运行xx.class 的java.exe 只有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库 时间：2019.3.7 3. ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？答案: static 表示静态的意思, 可用于修饰 成员变量和 方法 , 静态是随着类的加载而加载, 因此可以直接用类进行访问 private私有的方法不能被继承，子类就没有访问权限 覆盖 覆盖基于运动时动态绑定的 指覆盖了一个方法并且对其重写，以求达到不同的作用,，但是子类中的访问权限要不低于父类中的访问权限,重写的前提是必须要继承. Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。 私有的方法不能被继承，子类就没有访问权限，肯定也是不能别覆盖的。 12345678910111213141516171819202122232425262728class Super&#123; // 静态方法 static String greeting()&#123; return "Good night"; &#125; String name()&#123; return "Richard"; &#125; &#125; class Sub extends Super&#123; //子方法,继承Super //重写(覆盖)父类当中的静态方法 static String greeting()&#123; return "Hello"; &#125; String name()&#123; return "Dick"; &#125; &#125;class Test&#123; public static void main(String[] args)&#123; Super s = new Sub(); System.out.println(s.greeting()+","+s.name()); &#125; &#125;//运行结果：Good night,Dick (静态方法打印的是父类中的)//这个例子说明“实例方法被覆盖，静态方法被隐藏” 4. 是否可以在static环境中访问非static变量？答案: 不可以 因为静态的成员属于类，随着类的加载而加载到静态方法区内存，当类加载时，此时不一定有实例创建，没有实例，就不可以访问非静态的成员。 静态变量属于类变量，随着类的加载而加载，当调用类变量时java虚拟机会对类的静态变量，静态方法进行初始化，此时如果静态方法中有非静态变量，由于非静态变量是随着实例的创建而创建，此时还没有实例创建，所以非静态变量还没有创建，所以会出现编译错误。 参考博文: 牛客网优质答案 时间: 2019.3.11]]></content>
      <categories>
        <category>java</category>
        <category>java面试经典题目</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
        <tag>java</tag>
        <tag>java面试经典题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间词话---惊艳的文字]]></title>
    <url>%2F2019%2F03%2F06%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E6%83%8A%E8%89%B3%E7%9A%84%E6%96%87%E5%AD%97%2F</url>
    <content type="text"><![CDATA[现代诗 酒入豪肠，七分酿成了月光，余下的三分啸成剑气，绣口一吐，就半个盛唐。 —余光中《寻李白》 古诗 少年不知愁滋味,爱上层楼,爱上层楼.为赋新词强说愁.而今识尽愁滋味,欲说还休,欲说还休,却道天凉好个秋. —辛弃疾《丑奴儿》 十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。料得年年肠断处，明月夜，短松冈。 —苏轼 古文 斯是陋室,惟吾德馨. —刘禹锡《陋室铭》 夏虫不可语冰 —孔子 文章摘要 我知道我很大胆冒昧, 听说你朋友很多, 我不配高攀, 可是很想在你的朋友里凑个数目. —钱钟书《围城》 别客气,我求你明天来.我想去吃,对自己没有好借口,借你的名义,自己享受一下,你就体贴下情,答应了吧. —钱钟书《围城》]]></content>
      <tags>
        <tag>人间词话</tag>
        <tag>现代诗</tag>
        <tag>古诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人间词话---文章]]></title>
    <url>%2F2019%2F03%2F06%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[感谢困难​ 林清玄​ 我做了一个梦。 梦见我在街上问人：“请问您可不可以给我一些困难、一些挫折，一些痛苦?” 所有的人都拒绝我，我着急地恳求别人：“那么，我雇用您，每小时五百元，请您给我一些折磨!” 那些陌生人摇摇头，沉默地离开，我因找不到愿意折磨我的人而惊醒。 我坐在床上发呆，是呀!困难，折磨，痛苦是多么珍贵!如果一切平顺，谁会静下来沉思，谁会生起智慧，谁又能在平凡安逸的日子中超越自我、登上高峰呢? 如果没有困难，谁又会谦卑地跪下来祈祷?谁又能相信有无边的宇宙?谁又能寄情于来生呢? 我深深地感谢着困难、挫折与痛苦。 也深深地感恩那些曾经折磨过我的人，他们是多么慈悲呀!我并未花钱聘雇他们，他们却以宝贵的时间来考验我、提升我，为了增长我的智慧。 真正的高贵​ 海明威 ​ 在风平浪静的大海，每个人都是领航员。 ​ 但是，只有阳光而无阴影，只有欢乐而无痛苦，那就不是人生。以最幸福的人的生活为例.他的生活也是一团缠结在一起的乱麻。痛苦与幸福交替出现,使得我们一会悲伤，一会高兴，甚至死亡本身也会使生命更加可爱。在人生的清醒的时刻，在悲伤与失落的阴影之下，人们与真实的自我最接近。 ​ 在生活和事业的种种事物中，性格比才智更能指导我们, 心灵比头脑更能引导我们,而由判断获得的克制, 耐心和教养比天分更能让我们受益。 ​ 我始终相信，内心生活开始更为严谨的人，他的外在生活也会变得更为简朴。在一个物欲横流的年代，但愿我能向世人表明，人类真正需求少得多么可怜。 ​ 反思自己的过错不至于重蹈覆辙才是真正的悔悟, 高人一等并没有什么值得夸耀的。真正的高贵是优于过去的自己。]]></content>
      <tags>
        <tag>人间词话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曾仕强教授语录]]></title>
    <url>%2F2019%2F01%2F10%2F%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D---%E8%87%AA%E6%88%91%E6%88%90%E9%95%BF---%E6%9B%BE%E4%BB%95%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[很多事情，从不同的角度看，才能体会到其中的奥妙 做一个领导者，一定要充分了解下属的特性是什么，及时的下达合理的命令，而且效果要非常的良好，此为将才 事事都透露着一个人的能力 顾全大局，大局的前提底下，很多细小的事情，不用太过于考虑 一件事，从不同的角度看，都有道理，怎么讲都对，不是对不对的事，是价值观的体现 得意勿忘形，人在得意时，千万不能忘形，做事情随他爱怎样怎样，变为得意忘形，当一个人处于逆境的时候，他还会谨慎一点，当一个人处顺境的时候，他就开始沉不住气 形势比人强 人生的理想在于不断提升自己的层次 有智慧没知识容易陷入空想，一事无成。有知识没智慧，就不要埋怨被人当做工具使用，用毕即弃。要善用智慧来运用知识，以求合理的表现 处逆境容易，正因留意，处顺境很难，正因大意 你要很谨慎地去保留你独特的地方，这个独特之处就是你之所以为人的地方。能够自我成全，才是人最伟大的地方]]></content>
      <categories>
        <category>感悟</category>
        <category>曾仕强教授</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>人生方向</tag>
        <tag>智慧</tag>
        <tag>成长</tag>
      </tags>
  </entry>
</search>
